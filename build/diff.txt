diff --git a/include/iora/core/config_loader.hpp b/include/iora/core/config_loader.hpp
index 1278ace..fc74882 100644
--- a/include/iora/core/config_loader.hpp
+++ b/include/iora/core/config_loader.hpp
@@ -7,126 +7,116 @@
 
 #pragma once
 
-#include <string>
-#include <stdexcept>
+#include <iora/parsers/minimal_toml.hpp>
 #include <optional>
+#include <stdexcept>
+#include <string>
 #include <vector>
-#include <iora/parsers/minimal_toml.hpp>
 
 namespace iora
 {
 namespace core
 {
-  /// \brief Loads and parses TOML configuration files for the application.
-  class ConfigLoader
-  {
-  public:
-    /// \brief Constructs and loads a TOML configuration file.
-    explicit ConfigLoader(const std::string& filename) : _filename(filename) {}
+/// \brief Loads and parses TOML configuration files for the application.
+class ConfigLoader
+{
+public:
+  /// \brief Constructs and loads a TOML configuration file.
+  explicit ConfigLoader(const std::string &filename) : _filename(filename) {}
 
-    /// \brief Reloads the configuration from disk.
-    bool reload()
+  /// \brief Reloads the configuration from disk.
+  bool reload()
+  {
+    try
     {
-      try
-      {
-        _table = parsers::toml::parse_file(_filename);
-        return true;
-      }
-      catch (...)
-      {
-        _table = parsers::toml::table{};
-        return false;
-      }
+      _table = parsers::toml::parse_file(_filename);
+      return true;
+    }
+    catch (...)
+    {
+      _table = parsers::toml::table{};
+      return false;
     }
+  }
 
-    const parsers::toml::table& load()
+  const parsers::toml::table &load()
+  {
+    if (_table.empty())
     {
-      if (_table.empty())
+      if (!reload())
       {
-        if (!reload())
-        {
-          throw std::runtime_error("Failed to load configuration file: " +
-                                   _filename);
-        }
+        throw std::runtime_error("Failed to load configuration file: " + _filename);
       }
-      return _table;
     }
+    return _table;
+  }
 
-    /// \brief Gets the full configuration table.
-    const parsers::toml::table& table() const { return _table; }
+  /// \brief Gets the full configuration table.
+  const parsers::toml::table &table() const { return _table; }
 
-    /// \brief Gets a typed value from the configuration.
-    /// \tparam T Must be a TOML native type (int64_t, double, bool,
-    /// std::string, etc.)
-    template <typename T>
-    std::optional<T> get(const std::string& dottedKey) const
+  /// \brief Gets a typed value from the configuration.
+  /// \tparam T Must be a TOML native type (int64_t, double, bool,
+  /// std::string, etc.)
+  template <typename T> std::optional<T> get(const std::string &dottedKey) const
+  {
+    auto node = _table.at_path(dottedKey);
+    if (node && node.is_value())
     {
-      auto node = _table.at_path(dottedKey);
-      if (node && node.is_value())
+      if (auto val = node.as<T>())
       {
-        if (auto val = node.as<T>())
-        {
-          return val;
-        }
+        return val;
       }
-      return std::nullopt;
     }
+    return std::nullopt;
+  }
 
-    /// \brief Gets an int value from the configuration.
-    std::optional<int64_t> getInt(const std::string& key) const
-    {
-      return get<int64_t>(key);
-    }
+  /// \brief Gets an int value from the configuration.
+  std::optional<int64_t> getInt(const std::string &key) const { return get<int64_t>(key); }
+
+  /// \brief Gets a bool value from the configuration.
+  std::optional<bool> getBool(const std::string &key) const { return get<bool>(key); }
+
+  /// \brief Gets a string value from the configuration.
+  std::optional<std::string> getString(const std::string &key) const
+  {
+    return get<std::string>(key);
+  }
 
-    /// \brief Gets a bool value from the configuration.
-    std::optional<bool> getBool(const std::string& key) const
+  /// \brief Gets an array of strings from the configuration.
+  /// \param key Dotted key path to the array in the TOML config.
+  /// \return std::optional<std::vector<std::string>> containing all string
+  /// elements, or std::nullopt if not found. \throws std::runtime_error if
+  /// the key is an array but any element is not a string.
+  std::optional<std::vector<std::string>> getStringArray(const std::string &key) const
+  {
+    auto node = _table.at_path(key);
+    if (!node)
     {
-      return get<bool>(key);
+      return std::nullopt;
     }
-
-    /// \brief Gets a string value from the configuration.
-    std::optional<std::string> getString(const std::string& key) const
+    if (!node.is_array())
     {
-      return get<std::string>(key);
+      return std::nullopt;
     }
-
-    /// \brief Gets an array of strings from the configuration.
-    /// \param key Dotted key path to the array in the TOML config.
-    /// \return std::optional<std::vector<std::string>> containing all string
-    /// elements, or std::nullopt if not found. \throws std::runtime_error if
-    /// the key is an array but any element is not a string.
-    std::optional<std::vector<std::string>>
-    getStringArray(const std::string& key) const
+    std::vector<std::string> result;
+    for (const auto &elem : *node.as_array())
     {
-      auto node = _table.at_path(key);
-      if (!node)
-      {
-        return std::nullopt;
-      }
-      if (!node.is_array())
+      if (auto *strVal = std::get_if<std::string>(&elem))
       {
-        return std::nullopt;
+        result.push_back(*strVal);
       }
-      std::vector<std::string> result;
-      for (const auto& elem : *node.as_array())
+      else
       {
-        if (auto* strVal = std::get_if<std::string>(&elem))
-        {
-          result.push_back(*strVal);
-        }
-        else
-        {
-          throw std::runtime_error("ConfigLoader: Array element at '" + key +
-                                   "' is not a string");
-        }
+        throw std::runtime_error("ConfigLoader: Array element at '" + key + "' is not a string");
       }
-      return result;
     }
+    return result;
+  }
 
-  private:
-    std::string _filename;
-    parsers::toml::table _table;
-  };
+private:
+  std::string _filename;
+  parsers::toml::table _table;
+};
 
 } // namespace core
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/core/event_queue.hpp b/include/iora/core/event_queue.hpp
index a4d19e2..b849fd2 100644
--- a/include/iora/core/event_queue.hpp
+++ b/include/iora/core/event_queue.hpp
@@ -8,298 +8,282 @@
 
 #pragma once
 
+#include <condition_variable>
+#include <functional>
 #include <iostream>
-#include <string>
-#include <queue>
 #include <map>
-#include <vector>
-#include <thread>
 #include <mutex>
-#include <condition_variable>
-#include <functional>
+#include <queue>
 #include <regex>
+#include <string>
+#include <thread>
+#include <vector>
 
-#include "iora/parsers/json.hpp"
 #include "iora/core/logger.hpp"
+#include "iora/parsers/json.hpp"
 
 namespace iora
 {
 namespace core
 {
 
-  /// \brief Thread-safe event queue for dispatching JSON events to registered
-  /// handlers using worker threads.
-  class EventQueue
-  {
-  public:
-    using Handler = std::function<void(const parsers::Json&)>;
+/// \brief Thread-safe event queue for dispatching JSON events to registered
+/// handlers using worker threads.
+class EventQueue
+{
+public:
+  using Handler = std::function<void(const parsers::Json &)>;
 
-    /// \brief Construct the event queue and spin up worker threads
-    EventQueue(std::size_t threadCount = std::thread::hardware_concurrency())
+  /// \brief Construct the event queue and spin up worker threads
+  EventQueue(std::size_t threadCount = std::thread::hardware_concurrency())
+  {
+    iora::core::Logger::info("EventQueue: Initializing with " + std::to_string(threadCount) +
+                             " worker threads");
+    for (std::size_t i = 0; i < threadCount; ++i)
     {
-      iora::core::Logger::info("EventQueue: Initializing with " +
-                               std::to_string(threadCount) + " worker threads");
-      for (std::size_t i = 0; i < threadCount; ++i)
-      {
-        _threads.emplace_back([this, i]() { this->workerLoop(i); });
-      }
-      iora::core::Logger::info(
-          "EventQueue: All worker threads started successfully");
+      _threads.emplace_back([this, i]() { this->workerLoop(i); });
     }
+    iora::core::Logger::info("EventQueue: All worker threads started successfully");
+  }
 
-    /// \brief Destructor gracefully shuts down the worker threads
-    ~EventQueue()
+  /// \brief Destructor gracefully shuts down the worker threads
+  ~EventQueue()
+  {
+    iora::core::Logger::debug("EventQueue: Starting shutdown process");
     {
-      iora::core::Logger::debug("EventQueue: Starting shutdown process");
-      {
-        std::unique_lock<std::mutex> lock(_mutex);
-        _shutdown = true;
-      }
-
-      _cv.notify_all();
-
-      for (auto& thread : _threads)
-      {
-        if (thread.joinable())
-        {
-          thread.join();
-        }
-      }
-      iora::core::Logger::debug(
-          "EventQueue: All worker threads shut down successfully");
+      std::unique_lock<std::mutex> lock(_mutex);
+      _shutdown = true;
     }
 
-    /// \brief Enqueue an event for processing
-    void push(const parsers::Json& event)
-    {
-      if (!isValidEvent(event))
-      {
-        iora::core::Logger::error("EventQueue: Dropping invalid event - "
-                                  "missing eventId or eventName fields");
-        return; // drop invalid event
-      }
-
-      std::string eventId = event["eventId"].get<std::string>();
-      std::string eventName = event["eventName"].get<std::string>();
+    _cv.notify_all();
 
+    for (auto &thread : _threads)
+    {
+      if (thread.joinable())
       {
-        std::unique_lock<std::mutex> lock(_mutex);
-        _queue.push(event);
-        iora::core::Logger::debug("EventQueue: Enqueued event (id=" + eventId +
-                                  ", name=" + eventName + ") - queue size: " +
-                                  std::to_string(_queue.size()));
+        thread.join();
       }
-
-      _cv.notify_one();
     }
+    iora::core::Logger::debug("EventQueue: All worker threads shut down successfully");
+  }
 
-    /// \brief Register a handler for an exact eventId
-    void onEventId(const std::string& eventId, Handler handler)
+  /// \brief Enqueue an event for processing
+  void push(const parsers::Json &event)
+  {
+    if (!isValidEvent(event))
     {
-      std::unique_lock<std::mutex> lock(_mutex);
-      _handlersById[eventId].emplace_back(std::move(handler));
-      iora::core::Logger::info(
-          "EventQueue: Registered handler for event ID: " + eventId +
-          " (total handlers for this ID: " +
-          std::to_string(_handlersById[eventId].size()) + ")");
+      iora::core::Logger::error("EventQueue: Dropping invalid event - "
+                                "missing eventId or eventName fields");
+      return; // drop invalid event
     }
 
-    /// \brief Register a handler for an exact eventName
-    void onEventName(const std::string& eventName, Handler handler)
+    std::string eventId = event["eventId"].get<std::string>();
+    std::string eventName = event["eventName"].get<std::string>();
+
     {
       std::unique_lock<std::mutex> lock(_mutex);
-      _handlersByName[eventName].emplace_back(std::move(handler));
-      iora::core::Logger::info(
-          "EventQueue: Registered handler for event name: " + eventName +
-          " (total handlers for this name: " +
-          std::to_string(_handlersByName[eventName].size()) + ")");
+      _queue.push(event);
+      iora::core::Logger::debug("EventQueue: Enqueued event (id=" + eventId + ", name=" +
+                                eventName + ") - queue size: " + std::to_string(_queue.size()));
     }
 
-    /// \brief Register a handler for an eventName using regex matching
-    void onEventNameMatches(const std::string& eventNamePattern,
-                            Handler handler)
+    _cv.notify_one();
+  }
+
+  /// \brief Register a handler for an exact eventId
+  void onEventId(const std::string &eventId, Handler handler)
+  {
+    std::unique_lock<std::mutex> lock(_mutex);
+    _handlersById[eventId].emplace_back(std::move(handler));
+    iora::core::Logger::info(
+      "EventQueue: Registered handler for event ID: " + eventId +
+      " (total handlers for this ID: " + std::to_string(_handlersById[eventId].size()) + ")");
+  }
+
+  /// \brief Register a handler for an exact eventName
+  void onEventName(const std::string &eventName, Handler handler)
+  {
+    std::unique_lock<std::mutex> lock(_mutex);
+    _handlersByName[eventName].emplace_back(std::move(handler));
+    iora::core::Logger::info(
+      "EventQueue: Registered handler for event name: " + eventName +
+      " (total handlers for this name: " + std::to_string(_handlersByName[eventName].size()) + ")");
+  }
+
+  /// \brief Register a handler for an eventName using regex matching
+  void onEventNameMatches(const std::string &eventNamePattern, Handler handler)
+  {
+    std::unique_lock<std::mutex> lock(_mutex);
+    try
     {
-      std::unique_lock<std::mutex> lock(_mutex);
-      try
-      {
-        _compiledHandlersByName[eventNamePattern] =
-            std::make_pair(std::regex(eventNamePattern), std::move(handler));
-        iora::core::Logger::info(
-            "EventQueue: Registered pattern handler for event name pattern: " +
-            eventNamePattern);
-      }
-      catch (const std::exception& e)
-      {
-        iora::core::Logger::error("EventQueue: Failed to register pattern "
-                                  "handler for invalid regex: " +
-                                  eventNamePattern + " - " + e.what());
-        throw;
-      }
+      _compiledHandlersByName[eventNamePattern] =
+        std::make_pair(std::regex(eventNamePattern), std::move(handler));
+      iora::core::Logger::info("EventQueue: Registered pattern handler for event name pattern: " +
+                               eventNamePattern);
     }
-
-  private:
-    bool isValidEvent(const parsers::Json& event) const
+    catch (const std::exception &e)
     {
-      return event.contains("eventId") && event.contains("eventName");
+      iora::core::Logger::error("EventQueue: Failed to register pattern "
+                                "handler for invalid regex: " +
+                                eventNamePattern + " - " + e.what());
+      throw;
     }
+  }
 
-    std::mutex _mutex;
-    std::condition_variable _cv;
-    std::queue<parsers::Json> _queue;
-    std::map<std::string, std::vector<Handler>> _handlersById;
-    std::map<std::string, std::vector<Handler>> _handlersByName;
-    std::map<std::string, std::pair<std::regex, Handler>>
-        _compiledHandlersByName;
-    std::vector<std::thread> _threads;
-    bool _shutdown = false;
-
-    void workerLoop(std::size_t workerId)
+private:
+  bool isValidEvent(const parsers::Json &event) const
+  {
+    return event.contains("eventId") && event.contains("eventName");
+  }
+
+  std::mutex _mutex;
+  std::condition_variable _cv;
+  std::queue<parsers::Json> _queue;
+  std::map<std::string, std::vector<Handler>> _handlersById;
+  std::map<std::string, std::vector<Handler>> _handlersByName;
+  std::map<std::string, std::pair<std::regex, Handler>> _compiledHandlersByName;
+  std::vector<std::thread> _threads;
+  bool _shutdown = false;
+
+  void workerLoop(std::size_t workerId)
+  {
+    iora::core::Logger::debug("EventQueue: Worker thread " + std::to_string(workerId) + " started");
+    while (true)
     {
-      iora::core::Logger::debug("EventQueue: Worker thread " +
-                                std::to_string(workerId) + " started");
-      while (true)
+      parsers::Json event;
+
       {
-        parsers::Json event;
+        std::unique_lock<std::mutex> lock(_mutex);
+        _cv.wait(lock, [this]() { return !_queue.empty() || _shutdown; });
 
+        if (_shutdown && _queue.empty())
         {
-          std::unique_lock<std::mutex> lock(_mutex);
-          _cv.wait(lock, [this]() { return !_queue.empty() || _shutdown; });
-
-          if (_shutdown && _queue.empty())
-          {
-            iora::core::Logger::debug("EventQueue: Worker thread " +
-                                      std::to_string(workerId) +
-                                      " shutting down");
-            return;
-          }
-
-          event = _queue.front();
-          _queue.pop();
+          iora::core::Logger::debug("EventQueue: Worker thread " + std::to_string(workerId) +
+                                    " shutting down");
+          return;
         }
 
-        dispatch(event, workerId);
+        event = _queue.front();
+        _queue.pop();
       }
-    }
-
-    void dispatch(const parsers::Json& event, std::size_t workerId)
-    {
-      const std::string eventId = event["eventId"];
-      const std::string eventName = event["eventName"];
 
-      bool handled = false;
-      std::size_t totalHandlers = 0;
+      dispatch(event, workerId);
+    }
+  }
 
-      std::vector<Handler> idHandlers;
-      std::vector<Handler> nameHandlers;
+  void dispatch(const parsers::Json &event, std::size_t workerId)
+  {
+    const std::string eventId = event["eventId"];
+    const std::string eventName = event["eventName"];
 
-      {
-        std::unique_lock<std::mutex> lock(_mutex);
+    bool handled = false;
+    std::size_t totalHandlers = 0;
 
-        auto idHandlersIt = _handlersById.find(eventId);
-        if (idHandlersIt != _handlersById.end())
-        {
-          idHandlers = idHandlersIt->second;
-        }
+    std::vector<Handler> idHandlers;
+    std::vector<Handler> nameHandlers;
 
-        auto nameHandlersIt = _handlersByName.find(eventName);
-        if (nameHandlersIt != _handlersByName.end())
-        {
-          nameHandlers = nameHandlersIt->second;
-        }
+    {
+      std::unique_lock<std::mutex> lock(_mutex);
 
-        for (const auto& [pattern, compiledHandler] : _compiledHandlersByName)
-        {
-          if (std::regex_match(eventName, compiledHandler.first))
-          {
-            nameHandlers.emplace_back(compiledHandler.second);
-          }
-        }
+      auto idHandlersIt = _handlersById.find(eventId);
+      if (idHandlersIt != _handlersById.end())
+      {
+        idHandlers = idHandlersIt->second;
       }
 
-      totalHandlers = idHandlers.size() + nameHandlers.size();
-      if (totalHandlers > 0)
+      auto nameHandlersIt = _handlersByName.find(eventName);
+      if (nameHandlersIt != _handlersByName.end())
       {
-        iora::core::Logger::debug(
-            "EventQueue: Worker " + std::to_string(workerId) +
-            " dispatching event (id=" + eventId + ", name=" + eventName +
-            ") to " + std::to_string(totalHandlers) + " handlers");
+        nameHandlers = nameHandlersIt->second;
       }
 
-      for (const auto& handler : idHandlers)
+      for (const auto &[pattern, compiledHandler] : _compiledHandlersByName)
       {
-        try
-        {
-          handler(event);
-          handled = true;
-        }
-        catch (const std::exception& e)
+        if (std::regex_match(eventName, compiledHandler.first))
         {
-          iora::core::Logger::error(
-              "EventQueue: Handler exception for event ID " + eventId + ": " +
-              e.what());
+          nameHandlers.emplace_back(compiledHandler.second);
         }
       }
+    }
 
-      for (const auto& handler : nameHandlers)
+    totalHandlers = idHandlers.size() + nameHandlers.size();
+    if (totalHandlers > 0)
+    {
+      iora::core::Logger::debug("EventQueue: Worker " + std::to_string(workerId) +
+                                " dispatching event (id=" + eventId + ", name=" + eventName +
+                                ") to " + std::to_string(totalHandlers) + " handlers");
+    }
+
+    for (const auto &handler : idHandlers)
+    {
+      try
       {
-        try
-        {
-          handler(event);
-          handled = true;
-        }
-        catch (const std::exception& e)
-        {
-          iora::core::Logger::error(
-              "EventQueue: Handler exception for event name " + eventName +
-              ": " + e.what());
-        }
+        handler(event);
+        handled = true;
       }
-
-      if (!handled)
+      catch (const std::exception &e)
       {
-        iora::core::Logger::debug(
-            "EventQueue: No handlers found for event (id=" + eventId +
-            ", name=" + eventName + ") - discarding");
+        iora::core::Logger::error("EventQueue: Handler exception for event ID " + eventId + ": " +
+                                  e.what());
       }
     }
 
-    bool eventNameMatches(const std::string& pattern,
-                          const std::string& name) const
+    for (const auto &handler : nameHandlers)
     {
-      if (pattern.find('*') == std::string::npos)
+      try
       {
-        return pattern == name;
+        handler(event);
+        handled = true;
       }
-
-      std::string regexPattern;
-      regexPattern.reserve(pattern.size() * 2);
-      for (char ch : pattern)
+      catch (const std::exception &e)
       {
-        if (ch == '*')
-        {
-          regexPattern += ".*";
-        }
-        else if (std::isalnum(static_cast<unsigned char>(ch)) || ch == ':' ||
-                 ch == '_')
-        {
-          regexPattern += ch;
-        }
-        else
-        {
-          regexPattern += '\\';
-          regexPattern += ch;
-        }
+        iora::core::Logger::error("EventQueue: Handler exception for event name " + eventName +
+                                  ": " + e.what());
       }
+    }
 
-      try
+    if (!handled)
+    {
+      iora::core::Logger::debug("EventQueue: No handlers found for event (id=" + eventId +
+                                ", name=" + eventName + ") - discarding");
+    }
+  }
+
+  bool eventNameMatches(const std::string &pattern, const std::string &name) const
+  {
+    if (pattern.find('*') == std::string::npos)
+    {
+      return pattern == name;
+    }
+
+    std::string regexPattern;
+    regexPattern.reserve(pattern.size() * 2);
+    for (char ch : pattern)
+    {
+      if (ch == '*')
       {
-        return std::regex_match(name, std::regex(regexPattern));
+        regexPattern += ".*";
       }
-      catch (...)
+      else if (std::isalnum(static_cast<unsigned char>(ch)) || ch == ':' || ch == '_')
       {
-        return false;
+        regexPattern += ch;
       }
+      else
+      {
+        regexPattern += '\\';
+        regexPattern += ch;
+      }
+    }
+
+    try
+    {
+      return std::regex_match(name, std::regex(regexPattern));
+    }
+    catch (...)
+    {
+      return false;
     }
-  };
+  }
+};
 } // namespace core
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/core/logger.hpp b/include/iora/core/logger.hpp
index 4ddbd0d..9faa873 100644
--- a/include/iora/core/logger.hpp
+++ b/include/iora/core/logger.hpp
@@ -7,20 +7,20 @@
 
 #pragma once
 
-#include <iostream>
-#include <string>
-#include <mutex>
-#include <sstream>
+#include <atomic>
 #include <chrono>
-#include <iomanip>
-#include <fstream>
+#include <condition_variable>
 #include <filesystem>
+#include <fstream>
+#include <functional>
+#include <iomanip>
+#include <iostream>
+#include <memory>
+#include <mutex>
 #include <queue>
+#include <sstream>
+#include <string>
 #include <thread>
-#include <condition_variable>
-#include <atomic>
-#include <memory>
-#include <functional>
 
 namespace iora
 {
@@ -28,580 +28,548 @@ namespace iora
 namespace core
 {
 
-  // Forward declaration
-  class LoggerStream;
+// Forward declaration
+class LoggerStream;
 
-  /// \brief Thread-safe logger supporting log levels, async mode, file
-  /// rotation, and retention.
-  class Logger
+/// \brief Thread-safe logger supporting log levels, async mode, file
+/// rotation, and retention.
+class Logger
+{
+public:
+  enum class Level
   {
-  public:
-    enum class Level
+    Trace,
+    Debug,
+    Info,
+    Warning,
+    Error,
+    Fatal
+  };
+
+  /// \brief External log handler function type
+  /// Takes log level, formatted message, and original message without timestamp/level prefix
+  using ExternalHandler = std::function<void(Level level, const std::string &formattedMessage,
+                                             const std::string &rawMessage)>;
+
+  struct Endl
+  {
+  };
+  static inline constexpr Endl endl{};
+
+  static void init(Level level = Level::Info, const std::string &filePath = "", bool async = false,
+                   int retentionDays = 7, const std::string &timeFormat = "%Y-%m-%d %H:%M:%S")
+  {
+    auto &data = getData();
+    std::lock_guard<std::mutex> lock(data.mutex);
+
+    data.minLevel = level;
+    data.asyncMode = async;
+    data.exit = false;
+    // If no filePath provided, use default in current directory
+    if (filePath.empty())
     {
-      Trace,
-      Debug,
-      Info,
-      Warning,
-      Error,
-      Fatal
-    };
-
-    /// \brief External log handler function type
-    /// Takes log level, formatted message, and original message without timestamp/level prefix
-    using ExternalHandler = std::function<void(Level level, const std::string& formattedMessage, const std::string& rawMessage)>;
-
-    struct Endl
+      data.logBasePath = "iora.log";
+    }
+    else
     {
-    };
-    static inline constexpr Endl endl{};
+      data.logBasePath = filePath;
+    }
+    data.retentionDays = retentionDays;
+    data.timestampFormat = timeFormat;
+    // Reset current log date so rotateLogFileIfNeeded always opens a new file
+    data.currentLogDate.clear();
+    rotateLogFileIfNeeded();
 
-    static void init(Level level = Level::Info,
-                     const std::string& filePath = "", bool async = false,
-                     int retentionDays = 7,
-                     const std::string& timeFormat = "%Y-%m-%d %H:%M:%S")
+    if (data.asyncMode && !data.workerThread.joinable())
     {
-      auto& data = getData();
-      std::lock_guard<std::mutex> lock(data.mutex);
+      data.workerThread = std::thread(runWorker);
+    }
+  }
 
-      data.minLevel = level;
-      data.asyncMode = async;
-      data.exit = false;
-      // If no filePath provided, use default in current directory
-      if (filePath.empty())
-      {
-        data.logBasePath = "iora.log";
-      }
-      else
-      {
-        data.logBasePath = filePath;
-      }
-      data.retentionDays = retentionDays;
-      data.timestampFormat = timeFormat;
-      // Reset current log date so rotateLogFileIfNeeded always opens a new file
-      data.currentLogDate.clear();
-      rotateLogFileIfNeeded();
+  static void flush()
+  {
+    auto &data = getData();
+    std::unique_lock<std::mutex> lock(data.mutex);
 
-      if (data.asyncMode && !data.workerThread.joinable())
-      {
-        data.workerThread = std::thread(runWorker);
-      }
+    // Flush external handler queue first
+    while (!data.rawQueue.empty() && data.useExternalHandler && data.externalHandler)
+    {
+      auto [level, rawMessage] = data.rawQueue.front();
+      data.rawQueue.pop();
+
+      // Format the message for external handler
+      std::ostringstream oss;
+      oss << "[" << timestamp() << "] "
+          << "[" << levelToString(level) << "] " << rawMessage << std::endl;
+      std::string formattedMessage = oss.str();
+
+      // Temporarily unlock to call external handler
+      lock.unlock();
+      data.externalHandler(level, formattedMessage, rawMessage);
+      lock.lock();
     }
 
-    static void flush()
+    // Always flush queue for both sync and async modes
+    while (!data.queue.empty())
     {
-      auto& data = getData();
-      std::unique_lock<std::mutex> lock(data.mutex);
-      
-      // Flush external handler queue first
-      while (!data.rawQueue.empty() && data.useExternalHandler && data.externalHandler)
-      {
-        auto [level, rawMessage] = data.rawQueue.front();
-        data.rawQueue.pop();
-        
-        // Format the message for external handler
-        std::ostringstream oss;
-        oss << "[" << timestamp() << "] "
-            << "[" << levelToString(level) << "] " << rawMessage << std::endl;
-        std::string formattedMessage = oss.str();
-        
-        // Temporarily unlock to call external handler
-        lock.unlock();
-        data.externalHandler(level, formattedMessage, rawMessage);
-        lock.lock();
-      }
-      
-      // Always flush queue for both sync and async modes
-      while (!data.queue.empty())
-      {
-        rotateLogFileIfNeeded();
-        const std::string& entry = data.queue.front();
+      rotateLogFileIfNeeded();
+      const std::string &entry = data.queue.front();
 
-        if (data.fileStream)
-        {
-          (*data.fileStream) << entry;
-          data.fileStream->flush();
-        }
-        else
-        {
-          std::cout << entry;
-        }
-        data.queue.pop();
-      }
-      // Also flush file stream if open
       if (data.fileStream)
       {
+        (*data.fileStream) << entry;
         data.fileStream->flush();
       }
-    }
-
-    static void shutdown()
-    {
-      flush();
-      auto& data = getData();
-      {
-        std::lock_guard<std::mutex> lock(data.mutex);
-        data.exit = true;
-      }
-      data.cv.notify_one();
-
-      if (data.workerThread.joinable())
+      else
       {
-        data.workerThread.join();
+        std::cout << entry;
       }
+      data.queue.pop();
     }
-
-    static void setLevel(Level level)
+    // Also flush file stream if open
+    if (data.fileStream)
     {
-      auto& data = getData();
-      std::lock_guard<std::mutex> lock(data.mutex);
-      data.minLevel = level;
+      data.fileStream->flush();
     }
+  }
 
-    /// \brief Register an external log handler
-    /// When an external handler is registered, file logging and console output are disabled
-    /// \param handler The external handler function to register
-    static void setExternalHandler(ExternalHandler handler)
+  static void shutdown()
+  {
+    flush();
+    auto &data = getData();
     {
-      auto& data = getData();
       std::lock_guard<std::mutex> lock(data.mutex);
-      data.externalHandler = std::move(handler);
-      data.useExternalHandler = true;
-      
-      // Close file stream when external handler is active
-      if (data.fileStream && data.fileStream->is_open())
-      {
-        data.fileStream->close();
-        data.fileStream.reset();
-      }
+      data.exit = true;
     }
+    data.cv.notify_one();
 
-    /// \brief Remove external log handler and restore normal logging
-    static void clearExternalHandler()
+    if (data.workerThread.joinable())
     {
-      auto& data = getData();
-      std::lock_guard<std::mutex> lock(data.mutex);
-      data.externalHandler = nullptr;
-      data.useExternalHandler = false;
-      // File logging will be restored on next log call via rotateLogFileIfNeeded
+      data.workerThread.join();
     }
+  }
 
-    static void trace(const std::string& message)
-    {
-      log(Level::Trace, message);
-    }
-    static void debug(const std::string& message)
-    {
-      log(Level::Debug, message);
-    }
-    static void info(const std::string& message) { log(Level::Info, message); }
-    static void warning(const std::string& message)
-    {
-      log(Level::Warning, message);
-    }
-    static void error(const std::string& message)
-    {
-      log(Level::Error, message);
-    }
-    static void fatal(const std::string& message)
+  static void setLevel(Level level)
+  {
+    auto &data = getData();
+    std::lock_guard<std::mutex> lock(data.mutex);
+    data.minLevel = level;
+  }
+
+  /// \brief Register an external log handler
+  /// When an external handler is registered, file logging and console output are disabled
+  /// \param handler The external handler function to register
+  static void setExternalHandler(ExternalHandler handler)
+  {
+    auto &data = getData();
+    std::lock_guard<std::mutex> lock(data.mutex);
+    data.externalHandler = std::move(handler);
+    data.useExternalHandler = true;
+
+    // Close file stream when external handler is active
+    if (data.fileStream && data.fileStream->is_open())
     {
-      log(Level::Fatal, message);
+      data.fileStream->close();
+      data.fileStream.reset();
     }
+  }
+
+  /// \brief Remove external log handler and restore normal logging
+  static void clearExternalHandler()
+  {
+    auto &data = getData();
+    std::lock_guard<std::mutex> lock(data.mutex);
+    data.externalHandler = nullptr;
+    data.useExternalHandler = false;
+    // File logging will be restored on next log call via rotateLogFileIfNeeded
+  }
 
-    static LoggerStream stream(Level level);
+  static void trace(const std::string &message) { log(Level::Trace, message); }
+  static void debug(const std::string &message) { log(Level::Debug, message); }
+  static void info(const std::string &message) { log(Level::Info, message); }
+  static void warning(const std::string &message) { log(Level::Warning, message); }
+  static void error(const std::string &message) { log(Level::Error, message); }
+  static void fatal(const std::string &message) { log(Level::Fatal, message); }
 
-    static void log(Level level, const std::string& message)
+  static LoggerStream stream(Level level);
+
+  static void log(Level level, const std::string &message)
+  {
+    auto &data = getData();
+    if (level < data.minLevel)
     {
-      auto& data = getData();
-      if (level < data.minLevel)
-      {
-        return;
-      }
+      return;
+    }
 
-      std::ostringstream oss;
-      oss << "[" << timestamp() << "] "
-          << "[" << levelToString(level) << "] " << message << std::endl;
+    std::ostringstream oss;
+    oss << "[" << timestamp() << "] "
+        << "[" << levelToString(level) << "] " << message << std::endl;
 
-      std::string output = oss.str();
+    std::string output = oss.str();
 
-      if (data.asyncMode)
+    if (data.asyncMode)
+    {
       {
+        std::lock_guard<std::mutex> lock(data.mutex);
+        if (data.useExternalHandler)
+        {
+          data.rawQueue.push({level, message});
+        }
+        else
         {
-          std::lock_guard<std::mutex> lock(data.mutex);
-          if (data.useExternalHandler)
-          {
-            data.rawQueue.push({level, message});
-          }
-          else
-          {
-            data.queue.push(std::move(output));
-          }
+          data.queue.push(std::move(output));
         }
-        data.cv.notify_one();
+      }
+      data.cv.notify_one();
+    }
+    else
+    {
+      std::lock_guard<std::mutex> lock(data.mutex);
+
+      if (data.useExternalHandler && data.externalHandler)
+      {
+        data.externalHandler(level, output, message);
       }
       else
       {
-        std::lock_guard<std::mutex> lock(data.mutex);
-        
-        if (data.useExternalHandler && data.externalHandler)
+        rotateLogFileIfNeeded();
+
+        if (data.fileStream)
         {
-          data.externalHandler(level, output, message);
+          (*data.fileStream) << output;
+          data.fileStream->flush();
         }
         else
         {
-          rotateLogFileIfNeeded();
-
-          if (data.fileStream)
-          {
-            (*data.fileStream) << output;
-            data.fileStream->flush();
-          }
-          else
-          {
-            std::cout << output;
-          }
+          std::cout << output;
         }
       }
     }
+  }
 
-  public:
-    friend class LoggerStream;
+public:
+  friend class LoggerStream;
 
-    struct LoggerData
+  struct LoggerData
+  {
+    std::mutex mutex;
+    std::condition_variable cv;
+    std::queue<std::string> queue;
+    std::queue<std::pair<Level, std::string>> rawQueue; // For external handlers
+    std::thread workerThread;
+    std::atomic<bool> exit{false};
+    bool asyncMode = false;
+    Level minLevel = Level::Info;
+    std::unique_ptr<std::ofstream> fileStream;
+    std::string logBasePath;
+    std::string currentLogDate;
+    int retentionDays = 7;
+    std::string timestampFormat = "%Y-%m-%d %H:%M:%S";
+    ExternalHandler externalHandler;
+    bool useExternalHandler = false;
+
+    ~LoggerData()
     {
-      std::mutex mutex;
-      std::condition_variable cv;
-      std::queue<std::string> queue;
-      std::queue<std::pair<Level, std::string>> rawQueue; // For external handlers
-      std::thread workerThread;
-      std::atomic<bool> exit{false};
-      bool asyncMode = false;
-      Level minLevel = Level::Info;
-      std::unique_ptr<std::ofstream> fileStream;
-      std::string logBasePath;
-      std::string currentLogDate;
-      int retentionDays = 7;
-      std::string timestampFormat = "%Y-%m-%d %H:%M:%S";
-      ExternalHandler externalHandler;
-      bool useExternalHandler = false;
-
-      ~LoggerData()
+      // Ensure clean shutdown during static destruction
+      try
       {
-        // Ensure clean shutdown during static destruction
-        try
-        {
-          exit = true;
-          cv.notify_all();
-          if (workerThread.joinable())
-          {
-            workerThread.join();
-          }
-        }
-        catch (...)
+        exit = true;
+        cv.notify_all();
+        if (workerThread.joinable())
         {
-          // Ignore exceptions during static destruction
+          workerThread.join();
         }
       }
-    };
-
-    static LoggerData& getData()
-    {
-      static LoggerData data;
-      return data;
+      catch (...)
+      {
+        // Ignore exceptions during static destruction
+      }
     }
+  };
+
+  static LoggerData &getData()
+  {
+    static LoggerData data;
+    return data;
+  }
 
-    static void runWorker()
+  static void runWorker()
+  {
+    auto &data = getData();
+    while (true)
     {
-      auto& data = getData();
-      while (true)
+      std::unique_lock<std::mutex> lock(data.mutex);
+      data.cv.wait(lock,
+                   [&data] { return !data.queue.empty() || !data.rawQueue.empty() || data.exit; });
+
+      // Process external handler queue
+      while (!data.rawQueue.empty() && data.useExternalHandler && data.externalHandler)
       {
-        std::unique_lock<std::mutex> lock(data.mutex);
-        data.cv.wait(lock,
-                     [&data] { return !data.queue.empty() || !data.rawQueue.empty() || data.exit; });
+        auto [level, rawMessage] = data.rawQueue.front();
+        data.rawQueue.pop();
 
-        // Process external handler queue
-        while (!data.rawQueue.empty() && data.useExternalHandler && data.externalHandler)
-        {
-          auto [level, rawMessage] = data.rawQueue.front();
-          data.rawQueue.pop();
-          
-          // Format the message for external handler
-          std::ostringstream oss;
-          oss << "[" << timestamp() << "] "
-              << "[" << levelToString(level) << "] " << rawMessage << std::endl;
-          std::string formattedMessage = oss.str();
-          
-          // Temporarily unlock to call external handler
-          lock.unlock();
-          data.externalHandler(level, formattedMessage, rawMessage);
-          lock.lock();
-        }
+        // Format the message for external handler
+        std::ostringstream oss;
+        oss << "[" << timestamp() << "] "
+            << "[" << levelToString(level) << "] " << rawMessage << std::endl;
+        std::string formattedMessage = oss.str();
+
+        // Temporarily unlock to call external handler
+        lock.unlock();
+        data.externalHandler(level, formattedMessage, rawMessage);
+        lock.lock();
+      }
+
+      // Process normal logging queue
+      while (!data.queue.empty())
+      {
+        rotateLogFileIfNeeded();
+        const std::string &entry = data.queue.front();
 
-        // Process normal logging queue
-        while (!data.queue.empty())
+        if (data.fileStream)
         {
-          rotateLogFileIfNeeded();
-          const std::string& entry = data.queue.front();
-
-          if (data.fileStream)
-          {
-            (*data.fileStream) << entry;
-            data.fileStream->flush();
-          }
-          else
-          {
-            std::cout << entry;
-          }
-          data.queue.pop();
+          (*data.fileStream) << entry;
+          data.fileStream->flush();
         }
-
-        if (data.exit)
+        else
         {
-          break;
+          std::cout << entry;
         }
+        data.queue.pop();
       }
-    }
-
-    static std::string timestamp()
-    {
-      auto now = std::chrono::system_clock::now();
-      auto t = std::chrono::system_clock::to_time_t(now);
-      auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
-                    now.time_since_epoch()) %
-                1000;
 
-      std::ostringstream oss;
-      auto& data = getData();
-      oss << std::put_time(std::localtime(&t), data.timestampFormat.c_str());
-      if (data.timestampFormat.find("%S") != std::string::npos)
+      if (data.exit)
       {
-        oss << '.' << std::setfill('0') << std::setw(3) << ms.count();
+        break;
       }
-      return oss.str();
     }
+  }
 
-    static std::string currentDate()
+  static std::string timestamp()
+  {
+    auto now = std::chrono::system_clock::now();
+    auto t = std::chrono::system_clock::to_time_t(now);
+    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;
+
+    std::ostringstream oss;
+    auto &data = getData();
+    oss << std::put_time(std::localtime(&t), data.timestampFormat.c_str());
+    if (data.timestampFormat.find("%S") != std::string::npos)
     {
-      auto now = std::chrono::system_clock::now();
-      auto t = std::chrono::system_clock::to_time_t(now);
-      std::ostringstream oss;
-      oss << std::put_time(std::localtime(&t), "%Y-%m-%d");
-      return oss.str();
+      oss << '.' << std::setfill('0') << std::setw(3) << ms.count();
     }
+    return oss.str();
+  }
 
-    static void rotateLogFileIfNeeded()
+  static std::string currentDate()
+  {
+    auto now = std::chrono::system_clock::now();
+    auto t = std::chrono::system_clock::to_time_t(now);
+    std::ostringstream oss;
+    oss << std::put_time(std::localtime(&t), "%Y-%m-%d");
+    return oss.str();
+  }
+
+  static void rotateLogFileIfNeeded()
+  {
+    auto &data = getData();
+    if (data.logBasePath.empty() || data.useExternalHandler)
     {
-      auto& data = getData();
-      if (data.logBasePath.empty() || data.useExternalHandler)
+      // No log file path specified or external handler is active, skip file logging
+      return;
+    }
+
+    namespace fs = std::filesystem;
+    auto logPath = fs::path(data.logBasePath);
+    auto logDir = logPath.parent_path();
+    // If logDir is empty, use current directory
+    if (logDir.empty())
+    {
+      logDir = fs::current_path();
+    }
+    if (!fs::exists(logDir))
+    {
+      std::error_code ec;
+      fs::create_directories(logDir, ec);
+      if (ec)
       {
-        // No log file path specified or external handler is active, skip file logging
+        std::cerr << "[Logger] Failed to create log directory: " << logDir << " - " << ec.message()
+                  << std::endl;
         return;
       }
+    }
 
-      namespace fs = std::filesystem;
-      auto logPath = fs::path(data.logBasePath);
-      auto logDir = logPath.parent_path();
-      // If logDir is empty, use current directory
-      if (logDir.empty())
-      {
-        logDir = fs::current_path();
-      }
-      if (!fs::exists(logDir))
+    std::string today = currentDate();
+    if (today != data.currentLogDate)
+    {
+      data.currentLogDate = today;
+      std::string rotatedPath =
+        (logDir / (logPath.filename().string() + "." + data.currentLogDate + ".log")).string();
+
+      data.fileStream = std::make_unique<std::ofstream>(rotatedPath, std::ios::app);
+      if (!data.fileStream->is_open())
       {
-        std::error_code ec;
-        fs::create_directories(logDir, ec);
-        if (ec)
-        {
-          std::cerr << "[Logger] Failed to create log directory: " << logDir
-                    << " - " << ec.message() << std::endl;
-          return;
-        }
+        std::cerr << "[Logger] Failed to open rotated log file: " << rotatedPath << std::endl;
+        data.fileStream.reset();
       }
 
-      std::string today = currentDate();
-      if (today != data.currentLogDate)
-      {
-        data.currentLogDate = today;
-        std::string rotatedPath = (logDir / (logPath.filename().string() + "." +
-                                             data.currentLogDate + ".log"))
-                                      .string();
-
-        data.fileStream =
-            std::make_unique<std::ofstream>(rotatedPath, std::ios::app);
-        if (!data.fileStream->is_open())
-        {
-          std::cerr << "[Logger] Failed to open rotated log file: "
-                    << rotatedPath << std::endl;
-          data.fileStream.reset();
-        }
+      deleteOldLogFiles();
+    }
+  }
 
-        deleteOldLogFiles();
-      }
+  static void deleteOldLogFiles()
+  {
+    auto &data = getData();
+    if (data.logBasePath.empty() || data.retentionDays <= 0)
+    {
+      return;
+    }
+
+    namespace fs = std::filesystem;
+    auto now = std::chrono::system_clock::now();
+    auto logPath = fs::path(data.logBasePath);
+    auto logDir = logPath.parent_path();
+    if (logDir.empty())
+    {
+      logDir = fs::current_path();
+    }
+    std::string baseName = logPath.filename().string();
+    std::string prefix = baseName + ".";
+
+    std::error_code dir_ec;
+    if (!fs::exists(logDir, dir_ec))
+    {
+      // Directory does not exist, nothing to delete
+      return;
     }
 
-    static void deleteOldLogFiles()
+    for (const auto &entry : fs::directory_iterator(logDir, dir_ec))
     {
-      auto& data = getData();
-      if (data.logBasePath.empty() || data.retentionDays <= 0)
+      if (dir_ec)
       {
-        return;
+        std::cerr << "[Logger] Failed to iterate log directory: " << logDir << " - "
+                  << dir_ec.message() << std::endl;
+        break;
       }
-
-      namespace fs = std::filesystem;
-      auto now = std::chrono::system_clock::now();
-      auto logPath = fs::path(data.logBasePath);
-      auto logDir = logPath.parent_path();
-      if (logDir.empty())
+      const auto &path = entry.path();
+      std::string fname = path.filename().string();
+      if (fname.find(prefix) != 0 || fname.size() <= prefix.size())
       {
-        logDir = fs::current_path();
+        continue;
       }
-      std::string baseName = logPath.filename().string();
-      std::string prefix = baseName + ".";
 
-      std::error_code dir_ec;
-      if (!fs::exists(logDir, dir_ec))
+      // Extract date from filename: baseName.YYYY-MM-DD.log
+      std::string datePart = fname.substr(prefix.size(), 10); // YYYY-MM-DD
+      std::tm tm = {};
+      std::istringstream ss(datePart);
+      ss >> std::get_time(&tm, "%Y-%m-%d");
+      if (ss.fail())
       {
-        // Directory does not exist, nothing to delete
-        return;
+        continue;
       }
-
-      for (const auto& entry : fs::directory_iterator(logDir, dir_ec))
+      auto fileTime = std::chrono::system_clock::from_time_t(std::mktime(&tm));
+      // Only compare date, not time-of-day
+      auto fileDays = std::chrono::duration_cast<std::chrono::hours>(now - fileTime).count() / 24;
+      if (fileDays >= data.retentionDays)
       {
-        if (dir_ec)
-        {
-          std::cerr << "[Logger] Failed to iterate log directory: " << logDir
-                    << " - " << dir_ec.message() << std::endl;
-          break;
-        }
-        const auto& path = entry.path();
-        std::string fname = path.filename().string();
-        if (fname.find(prefix) != 0 || fname.size() <= prefix.size())
-        {
-          continue;
-        }
-
-        // Extract date from filename: baseName.YYYY-MM-DD.log
-        std::string datePart = fname.substr(prefix.size(), 10); // YYYY-MM-DD
-        std::tm tm = {};
-        std::istringstream ss(datePart);
-        ss >> std::get_time(&tm, "%Y-%m-%d");
-        if (ss.fail())
-        {
-          continue;
-        }
-        auto fileTime =
-            std::chrono::system_clock::from_time_t(std::mktime(&tm));
-        // Only compare date, not time-of-day
-        auto fileDays =
-            std::chrono::duration_cast<std::chrono::hours>(now - fileTime)
-                .count() /
-            24;
-        if (fileDays >= data.retentionDays)
+        std::error_code ec;
+        fs::remove(path, ec);
+        if (ec)
         {
-          std::error_code ec;
-          fs::remove(path, ec);
-          if (ec)
-          {
-            std::cerr << "[Logger] Failed to delete old log file: " << path
-                      << " - " << ec.message() << std::endl;
-          }
+          std::cerr << "[Logger] Failed to delete old log file: " << path << " - " << ec.message()
+                    << std::endl;
         }
       }
     }
+  }
 
-    static const char* levelToString(Level level)
-    {
-      switch (level)
-      {
-      case Level::Trace:
-        return "TRACE";
-      case Level::Debug:
-        return "DEBUG";
-      case Level::Info:
-        return "INFO";
-      case Level::Warning:
-        return "WARN";
-      case Level::Error:
-        return "ERROR";
-      case Level::Fatal:
-        return "FATAL";
-      default:
-        return "UNKNOWN";
-      }
-    }
-  };
-
-  /// \brief Stream interface for composing and emitting log messages with
-  /// levels.
-  class LoggerStream
+  static const char *levelToString(Level level)
   {
-  public:
-    explicit LoggerStream(Logger::Level level) : _level(level), _flushed(false)
+    switch (level)
     {
+    case Level::Trace:
+      return "TRACE";
+    case Level::Debug:
+      return "DEBUG";
+    case Level::Info:
+      return "INFO";
+    case Level::Warning:
+      return "WARN";
+    case Level::Error:
+      return "ERROR";
+    case Level::Fatal:
+      return "FATAL";
+    default:
+      return "UNKNOWN";
     }
+  }
+};
 
-    template <typename T> LoggerStream& operator<<(const T& value)
-    {
-      _stream << value;
-      return *this;
-    }
+/// \brief Stream interface for composing and emitting log messages with
+/// levels.
+class LoggerStream
+{
+public:
+  explicit LoggerStream(Logger::Level level) : _level(level), _flushed(false) {}
 
-    LoggerStream& operator<<(Logger::Endl)
-    {
-      flush();
-      return *this;
-    }
+  template <typename T> LoggerStream &operator<<(const T &value)
+  {
+    _stream << value;
+    return *this;
+  }
+
+  LoggerStream &operator<<(Logger::Endl)
+  {
+    flush();
+    return *this;
+  }
 
-    ~LoggerStream()
+  ~LoggerStream()
+  {
+    try
     {
-      try
-      {
-        if (!_flushed && !_stream.str().empty())
-        {
-          flush();
-        }
-      }
-      catch (...)
+      if (!_flushed && !_stream.str().empty())
       {
-        // Ignore all exceptions in destructor to prevent double-exception
-        // issues
+        flush();
       }
     }
-
-  private:
-    Logger::Level _level;
-    std::ostringstream _stream;
-    bool _flushed;
-
-    void flush()
+    catch (...)
     {
-      Logger::log(_level, _stream.str());
-      _flushed = true;
-      // Ensure log content is flushed to disk for tests
-      iora::core::Logger::flush();
+      // Ignore all exceptions in destructor to prevent double-exception
+      // issues
     }
-  };
+  }
+
+private:
+  Logger::Level _level;
+  std::ostringstream _stream;
+  bool _flushed;
 
-  /// \brief Proxy for streaming log messages at specific log levels.
-  class LoggerProxy
+  void flush()
   {
-  public:
-    LoggerStream operator<<(Logger::Level level)
-    {
-      return Logger::stream(level);
-    }
-  };
+    Logger::log(_level, _stream.str());
+    _flushed = true;
+    // Ensure log content is flushed to disk for tests
+    iora::core::Logger::flush();
+  }
+};
 
-  inline LoggerProxy Logger;
+/// \brief Proxy for streaming log messages at specific log levels.
+class LoggerProxy
+{
+public:
+  LoggerStream operator<<(Logger::Level level) { return Logger::stream(level); }
+};
+
+inline LoggerProxy Logger;
 
-#define IORA_LOG_CONTEXT_PREFIX                                                     \
-  "[" << __FILE__ << ":" << __LINE__ << " " << __func__ << "] "
+#define IORA_LOG_CONTEXT_PREFIX "[" << __FILE__ << ":" << __LINE__ << " " << __func__ << "] "
 
-#define IORA_LOG_WITH_LEVEL(level, msg)                                             \
-  do                                                                           \
-  {                                                                            \
-    iora::core::Logger << iora::core::Logger::Level::level                     \
-                       << IORA_LOG_CONTEXT_PREFIX << msg                            \
-                       << iora::core::Logger::endl;                            \
+#define IORA_LOG_WITH_LEVEL(level, msg)                                                            \
+  do                                                                                               \
+  {                                                                                                \
+    iora::core::Logger << iora::core::Logger::Level::level << IORA_LOG_CONTEXT_PREFIX << msg       \
+                       << iora::core::Logger::endl;                                                \
   } while (0)
 
 #define IORA_LOG_TRACE(msg) IORA_LOG_WITH_LEVEL(Trace, msg)
@@ -611,9 +579,6 @@ namespace core
 #define IORA_LOG_ERROR(msg) IORA_LOG_WITH_LEVEL(Error, msg)
 #define IORA_LOG_FATAL(msg) IORA_LOG_WITH_LEVEL(Fatal, msg)
 
-  inline LoggerStream Logger::stream(Logger::Level level)
-  {
-    return LoggerStream(level);
-  }
+inline LoggerStream Logger::stream(Logger::Level level) { return LoggerStream(level); }
 } // namespace core
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/core/plugin_loader.hpp b/include/iora/core/plugin_loader.hpp
index 35cd5c4..ec47276 100644
--- a/include/iora/core/plugin_loader.hpp
+++ b/include/iora/core/plugin_loader.hpp
@@ -7,12 +7,12 @@
 
 #pragma once
 #include <iostream>
+#include <map>
+#include <memory>
+#include <mutex>
 #include <stdexcept>
 #include <string>
-#include <mutex>
 #include <unordered_map>
-#include <memory>
-#include <map>
 
 #ifdef _WIN32
 #include <windows.h>
@@ -25,146 +25,140 @@ namespace iora
 namespace core
 {
 
-  /// \brief Cross-platform dynamic library loader for plugins.
-  class PluginLoader
+/// \brief Cross-platform dynamic library loader for plugins.
+class PluginLoader
+{
+public:
+  /// \brief Constructor loads the dynamic library from the given path
+  PluginLoader(const std::string &path)
   {
-  public:
-    /// \brief Constructor loads the dynamic library from the given path
-    PluginLoader(const std::string& path)
-    {
 #ifdef _WIN32
-      _handle = LoadLibraryA(path.c_str());
-      if (!_handle)
-      {
-        throw std::runtime_error("Failed to load library: " + path +
-                                 ", error: " + std::to_string(GetLastError()));
-      }
+    _handle = LoadLibraryA(path.c_str());
+    if (!_handle)
+    {
+      throw std::runtime_error("Failed to load library: " + path +
+                               ", error: " + std::to_string(GetLastError()));
+    }
 #else
-      _handle = dlopen(path.c_str(), RTLD_NOW);
-      if (!_handle)
-      {
-        throw std::runtime_error("Failed to load library: " + path +
-                                 ", error: " + dlerror());
-      }
+    _handle = dlopen(path.c_str(), RTLD_NOW);
+    if (!_handle)
+    {
+      throw std::runtime_error("Failed to load library: " + path + ", error: " + dlerror());
+    }
 #endif
-      if (!_handle)
-      {
-        throw std::runtime_error("Failed to load library: " + path);
-      }
+    if (!_handle)
+    {
+      throw std::runtime_error("Failed to load library: " + path);
     }
+  }
 
-    /// \brief Destructor closes the dynamic library
-    ~PluginLoader()
+  /// \brief Destructor closes the dynamic library
+  ~PluginLoader()
+  {
+    if (_handle)
     {
-      if (_handle)
-      {
 #ifdef _WIN32
-        FreeLibrary((HMODULE) _handle);
+      FreeLibrary((HMODULE)_handle);
 #else
-        dlclose(_handle);
+      dlclose(_handle);
 #endif
-      }
     }
+  }
 
-    /// \brief Resolve a symbol from the loaded library
-    /// \tparam T Function or object pointer type
-    /// \param name Symbol name to resolve
-    /// \return Resolved symbol cast to type T
-    template <typename T> T resolve(const std::string& name)
+  /// \brief Resolve a symbol from the loaded library
+  /// \tparam T Function or object pointer type
+  /// \param name Symbol name to resolve
+  /// \return Resolved symbol cast to type T
+  template <typename T> T resolve(const std::string &name)
+  {
+    if (!isValid())
     {
-      if (!isValid())
-      {
-        throw std::runtime_error(
-            "Cannot resolve symbol from an invalid library: " + name);
-      }
+      throw std::runtime_error("Cannot resolve symbol from an invalid library: " + name);
+    }
 
 #ifdef _WIN32
-      FARPROC symbol = GetProcAddress((HMODULE) _handle, name.c_str());
+    FARPROC symbol = GetProcAddress((HMODULE)_handle, name.c_str());
 #else
-      void* symbol = dlsym(_handle, name.c_str());
+    void *symbol = dlsym(_handle, name.c_str());
 #endif
-      if (!symbol)
-      {
-        throw std::runtime_error("Failed to resolve symbol: " + name);
-      }
-
-      _symbolCache[name] = symbol;
-      return reinterpret_cast<T>(symbol);
-    }
-
-    /// \brief Check whether the library loaded successfully
-    bool isValid() const
+    if (!symbol)
     {
-      return _handle != nullptr;
+      throw std::runtime_error("Failed to resolve symbol: " + name);
     }
 
-  private:
-    void* _handle = nullptr;
-    std::unordered_map<std::string, void*> _symbolCache;
-  };
+    _symbolCache[name] = symbol;
+    return reinterpret_cast<T>(symbol);
+  }
 
-  /// \brief Manages the lifecycle and symbol resolution of multiple dynamically
-  /// loaded plugins.
-  class PluginManager
-  {
-  public:
-    /// \brief Load a plugin from the given path
-    void loadPlugin(const std::string& name, const std::string& path)
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      if (_plugins.find(name) != _plugins.end())
-      {
-        throw std::runtime_error("Plugin already loaded: " + name);
-      }
+  /// \brief Check whether the library loaded successfully
+  bool isValid() const { return _handle != nullptr; }
 
-      _plugins[name] = std::make_unique<PluginLoader>(path);
-    }
+private:
+  void *_handle = nullptr;
+  std::unordered_map<std::string, void *> _symbolCache;
+};
 
-    /// \brief Unload a previously loaded plugin
-    void unloadPlugin(const std::string& name)
+/// \brief Manages the lifecycle and symbol resolution of multiple dynamically
+/// loaded plugins.
+class PluginManager
+{
+public:
+  /// \brief Load a plugin from the given path
+  void loadPlugin(const std::string &name, const std::string &path)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    if (_plugins.find(name) != _plugins.end())
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      auto it = _plugins.find(name);
-      if (it != _plugins.end())
-      {
-        _plugins.erase(it);
-      }
+      throw std::runtime_error("Plugin already loaded: " + name);
     }
 
-    /// \brief Resolve a symbol from a loaded plugin
-    /// \tparam T Function or object pointer type
-    /// \param name Name of the loaded plugin
-    /// \param symbol Symbol name to resolve
-    /// \return Resolved symbol cast to type T
-    template <typename T>
-    T resolve(const std::string& name, const std::string& symbol)
-    {
-      auto it = _plugins.find(name);
-      if (it == _plugins.end())
-      {
-        throw std::runtime_error("Plugin not loaded: " + name);
-      }
-      return it->second->resolve<T>(symbol);
-    }
+    _plugins[name] = std::make_unique<PluginLoader>(path);
+  }
 
-    /// \brief Check if a plugin is loaded
-    bool isLoaded(const std::string& name) const
+  /// \brief Unload a previously loaded plugin
+  void unloadPlugin(const std::string &name)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    auto it = _plugins.find(name);
+    if (it != _plugins.end())
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      return _plugins.find(name) != _plugins.end();
+      _plugins.erase(it);
     }
-
-    /// \brief Unload all loaded plugins
-    void unloadAll()
+  }
+
+  /// \brief Resolve a symbol from a loaded plugin
+  /// \tparam T Function or object pointer type
+  /// \param name Name of the loaded plugin
+  /// \param symbol Symbol name to resolve
+  /// \return Resolved symbol cast to type T
+  template <typename T> T resolve(const std::string &name, const std::string &symbol)
+  {
+    auto it = _plugins.find(name);
+    if (it == _plugins.end())
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      _plugins.clear();
+      throw std::runtime_error("Plugin not loaded: " + name);
     }
+    return it->second->resolve<T>(symbol);
+  }
+
+  /// \brief Check if a plugin is loaded
+  bool isLoaded(const std::string &name) const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _plugins.find(name) != _plugins.end();
+  }
 
-  private:
-    std::map<std::string, std::unique_ptr<PluginLoader>> _plugins;
-    mutable std::mutex _mutex; // Protects access to _plugins
-  };
+  /// \brief Unload all loaded plugins
+  void unloadAll()
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    _plugins.clear();
+  }
+
+private:
+  std::map<std::string, std::unique_ptr<PluginLoader>> _plugins;
+  mutable std::mutex _mutex; // Protects access to _plugins
+};
 
 } // namespace core
 } // namespace iora
diff --git a/include/iora/core/thread_pool.hpp b/include/iora/core/thread_pool.hpp
index ca7f9d4..7adeafe 100644
--- a/include/iora/core/thread_pool.hpp
+++ b/include/iora/core/thread_pool.hpp
@@ -7,380 +7,360 @@
 
 #pragma once
 
-#include <thread>
-#include <mutex>
+#include <atomic>
+#include <chrono>
 #include <condition_variable>
-#include <queue>
-#include <unordered_map>
-#include <unordered_set>
-#include <vector>
-#include <list>
+#include <exception>
 #include <functional>
 #include <future>
-#include <chrono>
-#include <atomic>
-#include <stdexcept>
-#include <memory>
-#include <exception>
 #include <iostream>
+#include <list>
+#include <memory>
+#include <mutex>
+#include <queue>
 #include <sstream>
+#include <stdexcept>
+#include <thread>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
 
 namespace iora
 {
 namespace core
 {
 
-  /// A dynamic thread pool that accepts void or result-returning lambdas with
-  /// arbitrary arguments. Threads grow and shrink based on load and idle
-  /// timeout. Exceptions in tasks can be reported.
-  class ThreadPool
-  {
-  public:
-    /// Constructs the thread pool.
-    ///
-    /// @param initialSize       Minimum number of threads (always maintained).
-    /// @param maxSize           Maximum number of threads (hard limit).
-    /// @param idleTimeout       Duration after which idle threads beyond
-    /// initial count will exit.
-    /// @param maxQueueSize      Maximum number of queued tasks before enqueue
-    /// throws.
-    /// @param onTaskError       Optional handler for uncaught exceptions in
-    /// tasks.
-    ThreadPool(std::size_t initialSize = std::thread::hardware_concurrency(),
-               std::size_t maxSize = std::thread::hardware_concurrency() * 4,
-               std::chrono::milliseconds idleTimeout = std::chrono::seconds(30),
-               std::size_t maxQueueSize = 1024,
-               std::function<void(std::exception_ptr)> onTaskError = nullptr)
-      : _initialSize(initialSize),
-        _maxSize(maxSize),
-        _idleTimeout(idleTimeout),
-        _maxQueueSize(maxQueueSize),
-        _shutdown(false),
-        _activeThreads(0),
-        _busyThreads(0),
+/// A dynamic thread pool that accepts void or result-returning lambdas with
+/// arbitrary arguments. Threads grow and shrink based on load and idle
+/// timeout. Exceptions in tasks can be reported.
+class ThreadPool
+{
+public:
+  /// Constructs the thread pool.
+  ///
+  /// @param initialSize       Minimum number of threads (always maintained).
+  /// @param maxSize           Maximum number of threads (hard limit).
+  /// @param idleTimeout       Duration after which idle threads beyond
+  /// initial count will exit.
+  /// @param maxQueueSize      Maximum number of queued tasks before enqueue
+  /// throws.
+  /// @param onTaskError       Optional handler for uncaught exceptions in
+  /// tasks.
+  ThreadPool(std::size_t initialSize = std::thread::hardware_concurrency(),
+             std::size_t maxSize = std::thread::hardware_concurrency() * 4,
+             std::chrono::milliseconds idleTimeout = std::chrono::seconds(30),
+             std::size_t maxQueueSize = 1024,
+             std::function<void(std::exception_ptr)> onTaskError = nullptr)
+      : _initialSize(initialSize), _maxSize(maxSize), _idleTimeout(idleTimeout),
+        _maxQueueSize(maxQueueSize), _shutdown(false), _activeThreads(0), _busyThreads(0),
         _onTaskError(std::move(onTaskError))
+  {
+    for (std::size_t i = 0; i < _initialSize; ++i)
     {
-      for (std::size_t i = 0; i < _initialSize; ++i)
-      {
-        spawnWorker();
-      }
+      spawnWorker();
     }
+  }
 
-    ~ThreadPool()
+  ~ThreadPool()
+  {
+    iora::core::Logger::debug("ThreadPool::~ThreadPool() - Starting shutdown");
     {
-      iora::core::Logger::debug(
-          "ThreadPool::~ThreadPool() - Starting shutdown");
-      {
-        std::unique_lock<std::mutex> lock(_mutex);
-        _shutdown = true;
-      }
-      _condition.notify_all();
-      iora::core::Logger::debug("ThreadPool::~ThreadPool() - Joining " +
-                                std::to_string(_threads.size()) + " threads");
-      for (auto& [id, thread] : _threads)
+      std::unique_lock<std::mutex> lock(_mutex);
+      _shutdown = true;
+    }
+    _condition.notify_all();
+    iora::core::Logger::debug("ThreadPool::~ThreadPool() - Joining " +
+                              std::to_string(_threads.size()) + " threads");
+    for (auto &[id, thread] : _threads)
+    {
+      if (thread.joinable())
       {
-        if (thread.joinable())
-        {
-          std::ostringstream oss;
-          oss << id;
-          iora::core::Logger::debug(
-              "ThreadPool::~ThreadPool() - Joining thread " + oss.str());
-          thread.join();
-          iora::core::Logger::debug("ThreadPool::~ThreadPool() - Thread " +
-                                    oss.str() + " joined");
-        }
+        std::ostringstream oss;
+        oss << id;
+        iora::core::Logger::debug("ThreadPool::~ThreadPool() - Joining thread " + oss.str());
+        thread.join();
+        iora::core::Logger::debug("ThreadPool::~ThreadPool() - Thread " + oss.str() + " joined");
       }
-      iora::core::Logger::debug(
-          "ThreadPool::~ThreadPool() - All threads joined, shutdown complete");
     }
+    iora::core::Logger::debug("ThreadPool::~ThreadPool() - All threads joined, shutdown complete");
+  }
 
-    ThreadPool(const ThreadPool&) = delete;
-    ThreadPool& operator=(const ThreadPool&) = delete;
-    ThreadPool(ThreadPool&&) = delete;
-    ThreadPool& operator=(ThreadPool&&) = delete;
+  ThreadPool(const ThreadPool &) = delete;
+  ThreadPool &operator=(const ThreadPool &) = delete;
+  ThreadPool(ThreadPool &&) = delete;
+  ThreadPool &operator=(ThreadPool &&) = delete;
 
-    /// Enqueue a fire-and-forget task (void-returning) with arguments.
-    template <typename F, typename... Args>
-    void enqueue(F&& func, Args&&... args)
-    {
-      // Avoid std::packaged_task<void()>
-      auto bound =
-          std::bind(std::forward<F>(func), std::forward<Args>(args)...);
-      enqueueImpl(
-          [bound = std::move(bound), this]()
+  /// Enqueue a fire-and-forget task (void-returning) with arguments.
+  template <typename F, typename... Args> void enqueue(F &&func, Args &&...args)
+  {
+    // Avoid std::packaged_task<void()>
+    auto bound = std::bind(std::forward<F>(func), std::forward<Args>(args)...);
+    enqueueImpl(
+      [bound = std::move(bound), this]()
+      {
+        try
+        {
+          bound(); // if this throws, catch below
+        }
+        catch (...)
+        {
+          // Always forward to exception handler if present
+          std::function<void(std::exception_ptr)> handlerCopy;
           {
-            try
-            {
-              bound(); // if this throws, catch below
-            }
-            catch (...)
-            {
-              // Always forward to exception handler if present
-              std::function<void(std::exception_ptr)> handlerCopy;
-              {
-                std::lock_guard<std::mutex> lock(_configMutex);
-                handlerCopy = _onTaskError;
-              }
-
-              if (handlerCopy)
-              {
-                handlerCopy(std::current_exception());
-              }
-              else
-              {
-                std::cerr << "[ThreadPool] Unhandled exception in void task"
-                          << std::endl;
-              }
-            }
-          });
-    }
-
-    /// Enqueue a task that returns a value and get a future for it.
-    template <typename F, typename... Args>
-    auto enqueueWithResult(F&& func, Args&&... args)
-        -> std::future<std::invoke_result_t<F, Args...>>
-    {
-      using ResultType = std::invoke_result_t<F, Args...>;
-      auto task = std::make_shared<std::packaged_task<ResultType()>>(
-          std::bind(std::forward<F>(func), std::forward<Args>(args)...));
-      auto future = task->get_future();
-      enqueueImpl([task]() { (*task)(); });
-      return future;
-    }
-
-    /// Get the number of pending tasks in the queue.
-    std::size_t getPendingTaskCount() const
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      return _tasks.size();
-    }
+            std::lock_guard<std::mutex> lock(_configMutex);
+            handlerCopy = _onTaskError;
+          }
 
-    /// Get queue utilization as a percentage (0-100).
-    double getQueueUtilization() const
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      return _maxQueueSize > 0
-                 ? (static_cast<double>(_tasks.size()) / _maxQueueSize) * 100.0
-                 : 0.0;
-    }
+          if (handlerCopy)
+          {
+            handlerCopy(std::current_exception());
+          }
+          else
+          {
+            std::cerr << "[ThreadPool] Unhandled exception in void task" << std::endl;
+          }
+        }
+      });
+  }
 
-    /// Get the number of active worker threads.
-    std::size_t getActiveThreadCount() const { return _activeThreads.load(); }
+  /// Enqueue a task that returns a value and get a future for it.
+  template <typename F, typename... Args>
+  auto enqueueWithResult(F &&func, Args &&...args) -> std::future<std::invoke_result_t<F, Args...>>
+  {
+    using ResultType = std::invoke_result_t<F, Args...>;
+    auto task = std::make_shared<std::packaged_task<ResultType()>>(
+      std::bind(std::forward<F>(func), std::forward<Args>(args)...));
+    auto future = task->get_future();
+    enqueueImpl([task]() { (*task)(); });
+    return future;
+  }
+
+  /// Get the number of pending tasks in the queue.
+  std::size_t getPendingTaskCount() const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _tasks.size();
+  }
 
-    /// Get the total number of worker threads.
-    std::size_t getTotalThreadCount() const
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      return _threads.size();
-    }
+  /// Get queue utilization as a percentage (0-100).
+  double getQueueUtilization() const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _maxQueueSize > 0 ? (static_cast<double>(_tasks.size()) / _maxQueueSize) * 100.0 : 0.0;
+  }
 
-    /// Check if the thread pool is under high load (queue > 80% capacity).
-    bool isUnderHighLoad() const { return getQueueUtilization() > 80.0; }
+  /// Get the number of active worker threads.
+  std::size_t getActiveThreadCount() const { return _activeThreads.load(); }
 
-    /// Try to enqueue a task, returning false if queue is full instead of
-    /// throwing.
-    template <typename F, typename... Args>
-    bool tryEnqueue(F&& func, Args&&... args)
-    {
-      auto bound =
-          std::bind(std::forward<F>(func), std::forward<Args>(args)...);
-      return tryEnqueueImpl(
-          [bound = std::move(bound), this]()
-          {
-            try
-            {
-              bound();
-            }
-            catch (...)
-            {
-              std::function<void(std::exception_ptr)> handlerCopy;
-              {
-                std::lock_guard<std::mutex> lock(_configMutex);
-                handlerCopy = _onTaskError;
-              }
+  /// Get the total number of worker threads.
+  std::size_t getTotalThreadCount() const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _threads.size();
+  }
 
-              if (handlerCopy)
-              {
-                handlerCopy(std::current_exception());
-              }
-              else
-              {
-                std::cerr << "[ThreadPool] Unhandled exception in void task"
-                          << std::endl;
-              }
-            }
-          });
-    }
+  /// Check if the thread pool is under high load (queue > 80% capacity).
+  bool isUnderHighLoad() const { return getQueueUtilization() > 80.0; }
 
-  private:
-    void enqueueImpl(std::function<void()> f)
-    {
-      bool shouldSpawn = false;
+  /// Try to enqueue a task, returning false if queue is full instead of
+  /// throwing.
+  template <typename F, typename... Args> bool tryEnqueue(F &&func, Args &&...args)
+  {
+    auto bound = std::bind(std::forward<F>(func), std::forward<Args>(args)...);
+    return tryEnqueueImpl(
+      [bound = std::move(bound), this]()
       {
-        std::unique_lock<std::mutex> lock(_mutex);
-        if (_shutdown)
+        try
         {
-          throw std::runtime_error("ThreadPool is shutting down");
+          bound();
         }
-
-        if (_tasks.size() >= _maxQueueSize)
+        catch (...)
         {
-          throw std::runtime_error("ThreadPool task queue is full");
+          std::function<void(std::exception_ptr)> handlerCopy;
+          {
+            std::lock_guard<std::mutex> lock(_configMutex);
+            handlerCopy = _onTaskError;
+          }
+
+          if (handlerCopy)
+          {
+            handlerCopy(std::current_exception());
+          }
+          else
+          {
+            std::cerr << "[ThreadPool] Unhandled exception in void task" << std::endl;
+          }
         }
+      });
+  }
+
+private:
+  void enqueueImpl(std::function<void()> f)
+  {
+    bool shouldSpawn = false;
+    {
+      std::unique_lock<std::mutex> lock(_mutex);
+      if (_shutdown)
+      {
+        throw std::runtime_error("ThreadPool is shutting down");
+      }
 
-        _tasks.emplace(std::move(f));
+      if (_tasks.size() >= _maxQueueSize)
+      {
+        throw std::runtime_error("ThreadPool task queue is full");
+      }
 
-        // Check if we should spawn a new thread
-        if (_threads.size() < _maxSize)
-        {
-          shouldSpawn = true;
-        }
-      } // Release mutex here
+      _tasks.emplace(std::move(f));
 
-      // Spawn outside of the lock to avoid deadlock
-      if (shouldSpawn)
+      // Check if we should spawn a new thread
+      if (_threads.size() < _maxSize)
       {
-        spawnWorker();
+        shouldSpawn = true;
       }
+    } // Release mutex here
 
-      _condition.notify_one();
+    // Spawn outside of the lock to avoid deadlock
+    if (shouldSpawn)
+    {
+      spawnWorker();
     }
 
-    bool tryEnqueueImpl(std::function<void()> f)
+    _condition.notify_one();
+  }
+
+  bool tryEnqueueImpl(std::function<void()> f)
+  {
+    bool shouldSpawn = false;
     {
-      bool shouldSpawn = false;
+      std::unique_lock<std::mutex> lock(_mutex);
+      if (_shutdown)
       {
-        std::unique_lock<std::mutex> lock(_mutex);
-        if (_shutdown)
-        {
-          return false; // Shutting down, reject task
-        }
+        return false; // Shutting down, reject task
+      }
 
-        if (_tasks.size() >= _maxQueueSize)
-        {
-          return false; // Queue full, reject task
-        }
+      if (_tasks.size() >= _maxQueueSize)
+      {
+        return false; // Queue full, reject task
+      }
 
-        _tasks.emplace(std::move(f));
+      _tasks.emplace(std::move(f));
 
-        // Check if we should spawn a new thread
-        if (_threads.size() < _maxSize)
-        {
-          shouldSpawn = true;
-        }
-      } // Release mutex here
-
-      // Spawn outside of the lock to avoid deadlock
-      if (shouldSpawn)
+      // Check if we should spawn a new thread
+      if (_threads.size() < _maxSize)
       {
-        spawnWorker();
+        shouldSpawn = true;
       }
+    } // Release mutex here
 
-      _condition.notify_one();
-      return true;
-    }
-
-    void spawnWorker()
+    // Spawn outside of the lock to avoid deadlock
+    if (shouldSpawn)
     {
-      std::thread t(
-          [this]()
-          {
-            const std::thread::id tid = std::this_thread::get_id();
-
-            while (true)
-            {
-              std::function<void()> task;
+      spawnWorker();
+    }
 
-              {
-                std::unique_lock<std::mutex> lock(_mutex);
+    _condition.notify_one();
+    return true;
+  }
 
-                if (!_condition.wait_for(
-                        lock, _idleTimeout,
-                        [this]() { return _shutdown || !_tasks.empty(); }))
-                {
-                  // Idle timeout  remove and exit if over minimum size
-                  if (_threads.size() > _initialSize)
-                  {
-                    auto it = _threads.find(tid);
-                    if (it != _threads.end())
-                    {
-                      // thread has exited
-                      it->second.detach(); // ensure no join needed
-                      _threads.erase(it);
-                    }
-                    return;
-                  }
-                  continue;
-                }
+  void spawnWorker()
+  {
+    std::thread t(
+      [this]()
+      {
+        const std::thread::id tid = std::this_thread::get_id();
 
-                if (_shutdown && _tasks.empty())
-                {
-                  return;
-                }
+        while (true)
+        {
+          std::function<void()> task;
 
-                if (!_tasks.empty())
-                {
-                  task = std::move(_tasks.front());
-                  _tasks.pop();
-                  ++_busyThreads; // Thread has picked up work (for spawning
-                                  // decisions)
-                }
-              }
+          {
+            std::unique_lock<std::mutex> lock(_mutex);
 
-              if (task)
+            if (!_condition.wait_for(lock, _idleTimeout,
+                                     [this]() { return _shutdown || !_tasks.empty(); }))
+            {
+              // Idle timeout  remove and exit if over minimum size
+              if (_threads.size() > _initialSize)
               {
-                ++_activeThreads; // Thread is now executing (for monitoring)
-                try
+                auto it = _threads.find(tid);
+                if (it != _threads.end())
                 {
-                  task();
+                  // thread has exited
+                  it->second.detach(); // ensure no join needed
+                  _threads.erase(it);
                 }
-                catch (...)
-                {
-                  std::function<void(std::exception_ptr)> handlerCopy;
-                  {
-                    std::lock_guard<std::mutex> lock(_configMutex);
-                    handlerCopy = _onTaskError;
-                  }
-
-                  if (handlerCopy)
-                  {
-                    handlerCopy(std::current_exception());
-                  }
-                  else
-                  {
-                    std::cerr << "[ThreadPool] Unhandled exception in task"
-                              << std::endl;
-                  }
-                }
-
-                --_activeThreads; // Thread finished executing
-                --_busyThreads;   // Thread no longer busy
+                return;
               }
+              continue;
             }
-          });
 
-      std::lock_guard<std::mutex> lock(_mutex);
-      _threads.emplace(t.get_id(), std::move(t));
-    }
+            if (_shutdown && _tasks.empty())
+            {
+              return;
+            }
 
-  private:
-    std::unordered_map<std::thread::id, std::thread> _threads;
-    std::queue<std::function<void()>> _tasks;
-    mutable std::mutex _mutex;
-    std::condition_variable _condition;
+            if (!_tasks.empty())
+            {
+              task = std::move(_tasks.front());
+              _tasks.pop();
+              ++_busyThreads; // Thread has picked up work (for spawning
+                              // decisions)
+            }
+          }
 
-    const std::size_t _initialSize;
-    const std::size_t _maxSize;
-    const std::chrono::milliseconds _idleTimeout;
-    const std::size_t _maxQueueSize;
+          if (task)
+          {
+            ++_activeThreads; // Thread is now executing (for monitoring)
+            try
+            {
+              task();
+            }
+            catch (...)
+            {
+              std::function<void(std::exception_ptr)> handlerCopy;
+              {
+                std::lock_guard<std::mutex> lock(_configMutex);
+                handlerCopy = _onTaskError;
+              }
 
-    std::atomic<bool> _shutdown;
-    std::atomic<std::size_t> _activeThreads; // Threads actively executing tasks
-    std::atomic<std::size_t> _busyThreads;   // Threads that have picked up work
+              if (handlerCopy)
+              {
+                handlerCopy(std::current_exception());
+              }
+              else
+              {
+                std::cerr << "[ThreadPool] Unhandled exception in task" << std::endl;
+              }
+            }
 
-    std::mutex _configMutex;
-    std::function<void(std::exception_ptr)> _onTaskError;
-  };
+            --_activeThreads; // Thread finished executing
+            --_busyThreads;   // Thread no longer busy
+          }
+        }
+      });
+
+    std::lock_guard<std::mutex> lock(_mutex);
+    _threads.emplace(t.get_id(), std::move(t));
+  }
+
+private:
+  std::unordered_map<std::thread::id, std::thread> _threads;
+  std::queue<std::function<void()>> _tasks;
+  mutable std::mutex _mutex;
+  std::condition_variable _condition;
+
+  const std::size_t _initialSize;
+  const std::size_t _maxSize;
+  const std::chrono::milliseconds _idleTimeout;
+  const std::size_t _maxQueueSize;
+
+  std::atomic<bool> _shutdown;
+  std::atomic<std::size_t> _activeThreads; // Threads actively executing tasks
+  std::atomic<std::size_t> _busyThreads;   // Threads that have picked up work
+
+  std::mutex _configMutex;
+  std::function<void(std::exception_ptr)> _onTaskError;
+};
 
 } // namespace core
 } // namespace iora
diff --git a/include/iora/core/timer.hpp b/include/iora/core/timer.hpp
index 65cdc8f..2b71ff7 100644
--- a/include/iora/core/timer.hpp
+++ b/include/iora/core/timer.hpp
@@ -9,1323 +9,1266 @@
 #include <chrono>
 #include <cstdint>
 #include <functional>
+#include <future>
+#include <memory>
 #include <mutex>
 #include <optional>
+#include <queue>
 #include <stdexcept>
+#include <string>
 #include <thread>
+#include <type_traits>
 #include <unordered_map>
 #include <utility>
 #include <vector>
-#include <queue>
-#include <memory>
-#include <string>
-#include <future>
-#include <type_traits>
 
+#include <errno.h>
+#include <string.h>
 #include <sys/epoll.h>
-#include <sys/timerfd.h>
 #include <sys/eventfd.h>
+#include <sys/timerfd.h>
 #include <unistd.h>
-#include <errno.h>
-#include <string.h>
 
 namespace iora
 {
 namespace core
 {
 
-  // Forward declarations
-  class TimerService;
-  class TimerServicePool;
+// Forward declarations
+class TimerService;
+class TimerServicePool;
 
-  /// \brief Timer error codes for enhanced error handling.
-  enum class TimerError
-  {
-    None,
-    SystemError,
-    InvalidTimeout,
-    ServiceStopped,
-    HandlerException,
-    ResourceExhausted,
-    ConfigurationError
-  };
-
-  /// \brief Timer exception with error codes.
-  class TimerException : public std::exception
-  {
-  public:
-    TimerException(TimerError code, const std::string& msg, int errno_val = 0)
+/// \brief Timer error codes for enhanced error handling.
+enum class TimerError
+{
+  None,
+  SystemError,
+  InvalidTimeout,
+  ServiceStopped,
+  HandlerException,
+  ResourceExhausted,
+  ConfigurationError
+};
+
+/// \brief Timer exception with error codes.
+class TimerException : public std::exception
+{
+public:
+  TimerException(TimerError code, const std::string &msg, int errno_val = 0)
       : _code(code), _message(msg), _errno(errno_val)
+  {
+    if (errno_val != 0)
     {
-      if (errno_val != 0)
-      {
-        _message += " (errno: " + std::to_string(errno_val) + " - " +
-                    std::string(strerror(errno_val)) + ")";
-      }
+      _message +=
+        " (errno: " + std::to_string(errno_val) + " - " + std::string(strerror(errno_val)) + ")";
     }
+  }
 
-    TimerError code() const { return _code; }
-    int getErrno() const { return _errno; }
-    const char* what() const noexcept override { return _message.c_str(); }
+  TimerError code() const { return _code; }
+  int getErrno() const { return _errno; }
+  const char *what() const noexcept override { return _message.c_str(); }
 
-  private:
-    TimerError _code;
-    std::string _message;
-    int _errno;
-  };
+private:
+  TimerError _code;
+  std::string _message;
+  int _errno;
+};
 
-  /// \brief Statistics for timer service monitoring and debugging.
-  struct TimerStats
+/// \brief Statistics for timer service monitoring and debugging.
+struct TimerStats
+{
+  std::atomic<std::uint64_t> timersScheduled{0};
+  std::atomic<std::uint64_t> timersCanceled{0};
+  std::atomic<std::uint64_t> timersExecuted{0};
+  std::atomic<std::uint64_t> timersExpired{0};
+  std::atomic<std::uint64_t> periodicTimersActive{0};
+  std::atomic<std::uint64_t> exceptionsSwallowed{0};
+  std::atomic<std::uint64_t> systemErrors{0};
+  std::atomic<std::uint64_t> heapOperations{0};
+  std::atomic<std::uint64_t> epollWaits{0};
+  std::atomic<std::uint64_t> eventfdWakeups{0};
+  std::atomic<std::uint64_t> timerfdTriggers{0};
+
+  // Performance metrics
+  std::atomic<std::uint64_t> totalHandlerExecutionTimeNs{0};
+  std::atomic<std::uint64_t> maxHandlerExecutionTimeNs{0};
+  std::atomic<std::uint64_t> avgHandlerExecutionTimeNs{0};
+
+  std::chrono::steady_clock::time_point startTime{std::chrono::steady_clock::now()};
+
+  void reset()
   {
-    std::atomic<std::uint64_t> timersScheduled{0};
-    std::atomic<std::uint64_t> timersCanceled{0};
-    std::atomic<std::uint64_t> timersExecuted{0};
-    std::atomic<std::uint64_t> timersExpired{0};
-    std::atomic<std::uint64_t> periodicTimersActive{0};
-    std::atomic<std::uint64_t> exceptionsSwallowed{0};
-    std::atomic<std::uint64_t> systemErrors{0};
-    std::atomic<std::uint64_t> heapOperations{0};
-    std::atomic<std::uint64_t> epollWaits{0};
-    std::atomic<std::uint64_t> eventfdWakeups{0};
-    std::atomic<std::uint64_t> timerfdTriggers{0};
-
-    // Performance metrics
-    std::atomic<std::uint64_t> totalHandlerExecutionTimeNs{0};
-    std::atomic<std::uint64_t> maxHandlerExecutionTimeNs{0};
-    std::atomic<std::uint64_t> avgHandlerExecutionTimeNs{0};
-
-    std::chrono::steady_clock::time_point startTime{
-        std::chrono::steady_clock::now()};
-
-    void reset()
-    {
-      timersScheduled.store(0);
-      timersCanceled.store(0);
-      timersExecuted.store(0);
-      timersExpired.store(0);
-      periodicTimersActive.store(0);
-      exceptionsSwallowed.store(0);
-      systemErrors.store(0);
-      heapOperations.store(0);
-      epollWaits.store(0);
-      eventfdWakeups.store(0);
-      timerfdTriggers.store(0);
-      totalHandlerExecutionTimeNs.store(0);
-      maxHandlerExecutionTimeNs.store(0);
-      avgHandlerExecutionTimeNs.store(0);
-      startTime = std::chrono::steady_clock::now();
-    }
-
-    double getUptimeSeconds() const
-    {
-      auto now = std::chrono::steady_clock::now();
-      auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
-          now - startTime);
-      return duration.count() / 1000.0;
-    }
-  };
-
-  /// \brief Resource limits to prevent exhaustion.
-  struct TimerLimits
+    timersScheduled.store(0);
+    timersCanceled.store(0);
+    timersExecuted.store(0);
+    timersExpired.store(0);
+    periodicTimersActive.store(0);
+    exceptionsSwallowed.store(0);
+    systemErrors.store(0);
+    heapOperations.store(0);
+    epollWaits.store(0);
+    eventfdWakeups.store(0);
+    timerfdTriggers.store(0);
+    totalHandlerExecutionTimeNs.store(0);
+    maxHandlerExecutionTimeNs.store(0);
+    avgHandlerExecutionTimeNs.store(0);
+    startTime = std::chrono::steady_clock::now();
+  }
+
+  double getUptimeSeconds() const
+  {
+    auto now = std::chrono::steady_clock::now();
+    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime);
+    return duration.count() / 1000.0;
+  }
+};
+
+/// \brief Resource limits to prevent exhaustion.
+struct TimerLimits
+{
+  std::size_t maxConcurrentTimers{10000};
+  std::chrono::milliseconds maxTimeout{std::chrono::hours(24)};
+  std::chrono::milliseconds maxHandlerExecutionTime{std::chrono::seconds(30)};
+  std::size_t maxHeapSize{50000};
+  std::size_t maxPeriodicTimers{1000};
+};
+
+/// \brief Configuration for enhanced timer service.
+struct TimerServiceConfig
+{
+  int maxEpollEvents{16};                     ///< Maximum events per epoll_wait
+  bool throwOnSystemError{false};             ///< Throw vs. log system errors
+  std::chrono::milliseconds epollTimeout{-1}; ///< epoll_wait timeout (-1 = infinite)
+  std::size_t initialHeapCapacity{256};       ///< Pre-allocate heap capacity
+  bool enableStatistics{true};                ///< Enable performance statistics
+  bool enableDetailedLogging{false};          ///< Enable verbose logging
+  TimerLimits limits;                         ///< Resource limits
+
+  // Thread configuration
+  bool setThreadPriority{false};          ///< Set real-time thread priority
+  int threadPriority{0};                  ///< Thread priority (if enabled)
+  std::string threadName{"TimerService"}; ///< Thread name for debugging
+};
+
+/// \brief Enhanced error and event logging interface.
+class TimerLogger
+{
+public:
+  enum class Level
   {
-    std::size_t maxConcurrentTimers{10000};
-    std::chrono::milliseconds maxTimeout{std::chrono::hours(24)};
-    std::chrono::milliseconds maxHandlerExecutionTime{std::chrono::seconds(30)};
-    std::size_t maxHeapSize{50000};
-    std::size_t maxPeriodicTimers{1000};
+    Debug = 0,
+    Info = 1,
+    Warning = 2,
+    Error = 3,
+    Critical = 4
   };
 
-  /// \brief Configuration for enhanced timer service.
-  struct TimerServiceConfig
+  virtual ~TimerLogger() = default;
+  virtual void log(Level level, const std::string &message, TimerError error = TimerError::None,
+                   int errno_val = 0) = 0;
+
+  // Convenience methods
+  void debug(const std::string &msg) { log(Level::Debug, msg); }
+  void info(const std::string &msg) { log(Level::Info, msg); }
+  void warning(const std::string &msg) { log(Level::Warning, msg); }
+  void error(const std::string &msg, TimerError err = TimerError::None, int errno_val = 0)
   {
-    int maxEpollEvents{16};         ///< Maximum events per epoll_wait
-    bool throwOnSystemError{false}; ///< Throw vs. log system errors
-    std::chrono::milliseconds epollTimeout{
-        -1}; ///< epoll_wait timeout (-1 = infinite)
-    std::size_t initialHeapCapacity{256}; ///< Pre-allocate heap capacity
-    bool enableStatistics{true};          ///< Enable performance statistics
-    bool enableDetailedLogging{false};    ///< Enable verbose logging
-    TimerLimits limits;                   ///< Resource limits
-
-    // Thread configuration
-    bool setThreadPriority{false};          ///< Set real-time thread priority
-    int threadPriority{0};                  ///< Thread priority (if enabled)
-    std::string threadName{"TimerService"}; ///< Thread name for debugging
-  };
+    log(Level::Error, msg, err, errno_val);
+  }
+  void critical(const std::string &msg, TimerError err = TimerError::None, int errno_val = 0)
+  {
+    log(Level::Critical, msg, err, errno_val);
+  }
+};
 
-  /// \brief Enhanced error and event logging interface.
-  class TimerLogger
+/// \brief Default console logger implementation.
+class ConsoleTimerLogger : public TimerLogger
+{
+public:
+  explicit ConsoleTimerLogger(Level minLevel = Level::Info) : _minLevel(minLevel) {}
+
+  void log(Level level, const std::string &message, TimerError error = TimerError::None,
+           int errno_val = 0) override
   {
-  public:
-    enum class Level
+    if (level < _minLevel)
+      return;
+
+    std::string levelStr;
+    switch (level)
     {
-      Debug = 0,
-      Info = 1,
-      Warning = 2,
-      Error = 3,
-      Critical = 4
-    };
+    case Level::Debug:
+      levelStr = "DEBUG";
+      break;
+    case Level::Info:
+      levelStr = "INFO";
+      break;
+    case Level::Warning:
+      levelStr = "WARN";
+      break;
+    case Level::Error:
+      levelStr = "ERROR";
+      break;
+    case Level::Critical:
+      levelStr = "CRITICAL";
+      break;
+    }
+
+    auto now = std::chrono::system_clock::now();
+    auto time_t = std::chrono::system_clock::to_time_t(now);
+    auto tm = *std::localtime(&time_t);
+
+    std::printf("[%04d-%02d-%02d %02d:%02d:%02d] [%s] %s", tm.tm_year + 1900, tm.tm_mon + 1,
+                tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, levelStr.c_str(), message.c_str());
 
-    virtual ~TimerLogger() = default;
-    virtual void log(Level level, const std::string& message,
-                     TimerError error = TimerError::None,
-                     int errno_val = 0) = 0;
-
-    // Convenience methods
-    void debug(const std::string& msg) { log(Level::Debug, msg); }
-    void info(const std::string& msg) { log(Level::Info, msg); }
-    void warning(const std::string& msg) { log(Level::Warning, msg); }
-    void error(const std::string& msg, TimerError err = TimerError::None,
-               int errno_val = 0)
+    if (error != TimerError::None)
     {
-      log(Level::Error, msg, err, errno_val);
+      std::printf(" (error: %d)", static_cast<int>(error));
     }
-    void critical(const std::string& msg, TimerError err = TimerError::None,
-                  int errno_val = 0)
+
+    if (errno_val != 0)
     {
-      log(Level::Critical, msg, err, errno_val);
+      std::printf(" (errno: %d - %s)", errno_val, strerror(errno_val));
     }
-  };
 
-  /// \brief Default console logger implementation.
-  class ConsoleTimerLogger : public TimerLogger
+    std::printf("\n");
+    std::fflush(stdout);
+  }
+
+private:
+  Level _minLevel;
+};
+
+/// \brief Linux epoll-based timer service.
+class TimerService
+{
+public:
+  using Clock = std::chrono::steady_clock;
+  using TimePoint = Clock::time_point;
+  using Duration = Clock::duration;
+  /// \brief Type-erased handler that supports move-only types.
+  class Handler
   {
   public:
-    explicit ConsoleTimerLogger(Level minLevel = Level::Info)
-      : _minLevel(minLevel)
+    template <typename F>
+    Handler(F &&f) : _impl(std::make_unique<Model<std::decay_t<F>>>(std::forward<F>(f)))
     {
     }
 
-    void log(Level level, const std::string& message,
-             TimerError error = TimerError::None, int errno_val = 0) override
-    {
-      if (level < _minLevel)
-        return;
+    Handler(const Handler &) = delete;
+    Handler &operator=(const Handler &) = delete;
 
-      std::string levelStr;
-      switch (level)
-      {
-      case Level::Debug:
-        levelStr = "DEBUG";
-        break;
-      case Level::Info:
-        levelStr = "INFO";
-        break;
-      case Level::Warning:
-        levelStr = "WARN";
-        break;
-      case Level::Error:
-        levelStr = "ERROR";
-        break;
-      case Level::Critical:
-        levelStr = "CRITICAL";
-        break;
-      }
-
-      auto now = std::chrono::system_clock::now();
-      auto time_t = std::chrono::system_clock::to_time_t(now);
-      auto tm = *std::localtime(&time_t);
+    Handler(Handler &&) = default;
+    Handler &operator=(Handler &&) = default;
 
-      std::printf("[%04d-%02d-%02d %02d:%02d:%02d] [%s] %s", tm.tm_year + 1900,
-                  tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec,
-                  levelStr.c_str(), message.c_str());
+    void operator()() const
+    {
+      if (_impl)
+        _impl->call();
+    }
 
-      if (error != TimerError::None)
-      {
-        std::printf(" (error: %d)", static_cast<int>(error));
-      }
+    explicit operator bool() const { return static_cast<bool>(_impl); }
 
-      if (errno_val != 0)
-      {
-        std::printf(" (errno: %d - %s)", errno_val, strerror(errno_val));
-      }
+  private:
+    struct Concept
+    {
+      virtual ~Concept() = default;
+      virtual void call() = 0;
+    };
 
-      std::printf("\n");
-      std::fflush(stdout);
-    }
+    template <typename F> struct Model : Concept
+    {
+      F _f;
+      explicit Model(F f) : _f(std::move(f)) {}
+      void call() override { _f(); }
+    };
 
-  private:
-    Level _minLevel;
+    std::unique_ptr<Concept> _impl;
   };
 
-  /// \brief Linux epoll-based timer service.
-  class TimerService
+  /// \brief Enhanced error handler with context.
+  using ErrorHandler =
+    std::function<void(TimerError error, const std::string &message, int errno_val)>;
+
+  /// \brief Start the service with configuration.
+  explicit TimerService(const TimerServiceConfig &config = {})
+      : _config(config), _logger(std::make_shared<ConsoleTimerLogger>())
   {
-  public:
-    using Clock = std::chrono::steady_clock;
-    using TimePoint = Clock::time_point;
-    using Duration = Clock::duration;
-    /// \brief Type-erased handler that supports move-only types.
-    class Handler
-    {
-    public:
-      template <typename F>
-      Handler(F&& f)
-        : _impl(std::make_unique<Model<std::decay_t<F>>>(std::forward<F>(f)))
-      {
-      }
+    _heap.reserve(_config.initialHeapCapacity);
+    initialize();
+  }
 
-      Handler(const Handler&) = delete;
-      Handler& operator=(const Handler&) = delete;
+  /// \brief Start the service with custom logger.
+  TimerService(const TimerServiceConfig &config, std::shared_ptr<TimerLogger> logger)
+      : _config(config), _logger(std::move(logger))
+  {
+    _heap.reserve(_config.initialHeapCapacity);
+    initialize();
+  }
 
-      Handler(Handler&&) = default;
-      Handler& operator=(Handler&&) = default;
+  /// \brief Stop the service and join the thread.
+  ~TimerService() { stop(); }
 
-      void operator()() const
-      {
-        if (_impl)
-          _impl->call();
-      }
+  TimerService(const TimerService &) = delete;
+  TimerService &operator=(const TimerService &) = delete;
 
-      explicit operator bool() const { return static_cast<bool>(_impl); }
+  /// \brief Schedule handler at absolute time with perfect forwarding.
+  template <typename Handler> std::uint64_t scheduleAt(TimePoint tp, Handler &&handler)
+  {
+    static_assert(std::is_invocable_v<Handler>, "Handler must be callable with no arguments");
 
-    private:
-      struct Concept
-      {
-        virtual ~Concept() = default;
-        virtual void call() = 0;
-      };
+    if (!isValidTimeout(tp))
+    {
+      handleError(TimerError::InvalidTimeout, "Timeout exceeds maximum allowed", 0);
+      return 0;
+    }
 
-      template <typename F> struct Model : Concept
-      {
-        F _f;
-        explicit Model(F f) : _f(std::move(f)) {}
-        void call() override { _f(); }
-      };
+    std::lock_guard<std::mutex> lock(_mutex);
 
-      std::unique_ptr<Concept> _impl;
-    };
+    if (_records.size() >= _config.limits.maxConcurrentTimers)
+    {
+      handleError(TimerError::ResourceExhausted, "Maximum concurrent timers exceeded", 0);
+      return 0;
+    }
 
-    /// \brief Enhanced error handler with context.
-    using ErrorHandler = std::function<void(
-        TimerError error, const std::string& message, int errno_val)>;
+    std::uint64_t id = ++_nextId;
+    _records.emplace(id, Record{tp, std::forward<Handler>(handler), false, false});
+    _heap.emplace_back(HeapItem{tp, id});
+    siftUp(_heap.size() - 1);
 
-    /// \brief Start the service with configuration.
-    explicit TimerService(const TimerServiceConfig& config = {})
-      : _config(config), _logger(std::make_shared<ConsoleTimerLogger>())
+    if (_config.enableStatistics)
     {
-      _heap.reserve(_config.initialHeapCapacity);
-      initialize();
+      _stats.timersScheduled.fetch_add(1, std::memory_order_relaxed);
+      _stats.heapOperations.fetch_add(1, std::memory_order_relaxed);
     }
 
-    /// \brief Start the service with custom logger.
-    TimerService(const TimerServiceConfig& config,
-                 std::shared_ptr<TimerLogger> logger)
-      : _config(config), _logger(std::move(logger))
+    poke();
+
+    if (_config.enableDetailedLogging)
     {
-      _heap.reserve(_config.initialHeapCapacity);
-      initialize();
+      _logger->debug("Timer " + std::to_string(id) + " scheduled");
     }
 
-    /// \brief Stop the service and join the thread.
-    ~TimerService() { stop(); }
+    return id;
+  }
 
-    TimerService(const TimerService&) = delete;
-    TimerService& operator=(const TimerService&) = delete;
+  /// \brief Schedule handler after duration with perfect forwarding.
+  template <typename Handler> std::uint64_t scheduleAfter(Duration d, Handler &&handler)
+  {
+    return scheduleAt(Clock::now() + d, std::forward<Handler>(handler));
+  }
 
-    /// \brief Schedule handler at absolute time with perfect forwarding.
-    template <typename Handler>
-    std::uint64_t scheduleAt(TimePoint tp, Handler&& handler)
+  /// \brief Schedule periodic timer (simplified implementation).
+  template <typename F> std::uint64_t schedulePeriodic(Duration interval, F &&handler)
+  {
+    if (_periodicTimers.size() >= _config.limits.maxPeriodicTimers)
     {
-      static_assert(std::is_invocable_v<Handler>,
-                    "Handler must be callable with no arguments");
+      handleError(TimerError::ResourceExhausted, "Maximum periodic timers exceeded", 0);
+      return 0;
+    }
 
-      if (!isValidTimeout(tp))
-      {
-        handleError(TimerError::InvalidTimeout,
-                    "Timeout exceeds maximum allowed", 0);
-        return 0;
-      }
+    std::uint64_t id = ++_nextId;
 
+    {
       std::lock_guard<std::mutex> lock(_mutex);
+      _periodicTimers.emplace(id, PeriodicTimer{id, interval, Clock::now() + interval, false});
+    }
 
-      if (_records.size() >= _config.limits.maxConcurrentTimers)
-      {
-        handleError(TimerError::ResourceExhausted,
-                    "Maximum concurrent timers exceeded", 0);
-        return 0;
-      }
+    if (_config.enableStatistics)
+    {
+      _stats.periodicTimersActive.fetch_add(1, std::memory_order_relaxed);
+    }
+
+    // Simple implementation: just schedule once for now
+    // For a full implementation, you'd want a proper periodic scheduling
+    // mechanism
+    return scheduleAt(Clock::now() + interval, std::forward<F>(handler));
+  }
 
-      std::uint64_t id = ++_nextId;
-      _records.emplace(
-          id, Record{tp, std::forward<Handler>(handler), false, false});
-      _heap.emplace_back(HeapItem{tp, id});
-      siftUp(_heap.size() - 1);
+  /// \brief Cancel a scheduled timer; returns true if existed.
+  bool cancel(std::uint64_t id)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+
+    // Check regular timers
+    auto it = _records.find(id);
+    if (it != _records.end())
+    {
+      it->second.canceled = true;
+      poke();
 
       if (_config.enableStatistics)
       {
-        _stats.timersScheduled.fetch_add(1, std::memory_order_relaxed);
-        _stats.heapOperations.fetch_add(1, std::memory_order_relaxed);
+        _stats.timersCanceled.fetch_add(1, std::memory_order_relaxed);
       }
 
-      poke();
-
       if (_config.enableDetailedLogging)
       {
-        _logger->debug("Timer " + std::to_string(id) + " scheduled");
+        _logger->debug("Timer " + std::to_string(id) + " canceled");
       }
 
-      return id;
+      return true;
     }
 
-    /// \brief Schedule handler after duration with perfect forwarding.
-    template <typename Handler>
-    std::uint64_t scheduleAfter(Duration d, Handler&& handler)
+    // Check periodic timers
+    auto periodicIt = _periodicTimers.find(id);
+    if (periodicIt != _periodicTimers.end())
     {
-      return scheduleAt(Clock::now() + d, std::forward<Handler>(handler));
-    }
+      periodicIt->second.canceled = true;
 
-    /// \brief Schedule periodic timer (simplified implementation).
-    template <typename F>
-    std::uint64_t schedulePeriodic(Duration interval, F&& handler)
-    {
-      if (_periodicTimers.size() >= _config.limits.maxPeriodicTimers)
+      if (_config.enableStatistics)
       {
-        handleError(TimerError::ResourceExhausted,
-                    "Maximum periodic timers exceeded", 0);
-        return 0;
+        _stats.periodicTimersActive.fetch_sub(1, std::memory_order_relaxed);
       }
 
-      std::uint64_t id = ++_nextId;
+      return true;
+    }
+
+    return false;
+  }
 
-      {
-        std::lock_guard<std::mutex> lock(_mutex);
-        _periodicTimers.emplace(
-            id, PeriodicTimer{id, interval, Clock::now() + interval, false});
-      }
+  /// \brief Stop the service and join the thread.
+  void stop()
+  {
+    bool expected = true;
+    if (_running.compare_exchange_strong(expected, false, std::memory_order_acq_rel))
+    {
+      _logger->info("Stopping timer service");
+      poke();
 
-      if (_config.enableStatistics)
+      if (_thread.joinable())
       {
-        _stats.periodicTimersActive.fetch_add(1, std::memory_order_relaxed);
+        _thread.join();
       }
 
-      // Simple implementation: just schedule once for now
-      // For a full implementation, you'd want a proper periodic scheduling
-      // mechanism
-      return scheduleAt(Clock::now() + interval, std::forward<F>(handler));
+      cleanup();
+      _logger->info("Timer service stopped");
     }
+  }
 
-    /// \brief Cancel a scheduled timer; returns true if existed.
-    bool cancel(std::uint64_t id)
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
+  /// \brief Get current statistics.
+  const TimerStats &getStats() const { return _stats; }
 
-      // Check regular timers
-      auto it = _records.find(id);
-      if (it != _records.end())
-      {
-        it->second.canceled = true;
-        poke();
+  /// \brief Reset statistics.
+  void resetStats()
+  {
+    _stats.reset();
+    _logger->info("Timer statistics reset");
+  }
 
-        if (_config.enableStatistics)
-        {
-          _stats.timersCanceled.fetch_add(1, std::memory_order_relaxed);
-        }
+  /// \brief Get current configuration.
+  const TimerServiceConfig &getConfig() const { return _config; }
 
-        if (_config.enableDetailedLogging)
-        {
-          _logger->debug("Timer " + std::to_string(id) + " canceled");
-        }
+  /// \brief Set error handler.
+  void setErrorHandler(ErrorHandler handler)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    _errorHandler = std::move(handler);
+  }
 
-        return true;
-      }
+  /// \brief Set logger.
+  void setLogger(std::shared_ptr<TimerLogger> logger)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    _logger = std::move(logger);
+  }
 
-      // Check periodic timers
-      auto periodicIt = _periodicTimers.find(id);
-      if (periodicIt != _periodicTimers.end())
-      {
-        periodicIt->second.canceled = true;
+private:
+  struct Record
+  {
+    TimePoint tp;
+    Handler handler;
+    bool canceled{false};
+    bool periodic{false};
+  };
 
-        if (_config.enableStatistics)
-        {
-          _stats.periodicTimersActive.fetch_sub(1, std::memory_order_relaxed);
-        }
+  struct HeapItem
+  {
+    TimePoint tp;
+    std::uint64_t id;
+  };
 
-        return true;
-      }
+  struct PeriodicTimer
+  {
+    std::uint64_t id;
+    Duration interval;
+    TimePoint nextExecution;
+    bool canceled{false};
+  };
 
-      return false;
-    }
+  static bool less(const HeapItem &a, const HeapItem &b)
+  {
+    return a.tp < b.tp || (a.tp == b.tp && a.id < b.id);
+  }
 
-    /// \brief Stop the service and join the thread.
-    void stop()
+  void initialize()
+  {
+    try
     {
-      bool expected = true;
-      if (_running.compare_exchange_strong(expected, false,
-                                           std::memory_order_acq_rel))
+      _epollFd = ::epoll_create1(EPOLL_CLOEXEC);
+      if (_epollFd < 0)
       {
-        _logger->info("Stopping timer service");
-        poke();
+        throw TimerException(TimerError::SystemError, "epoll_create1 failed", errno);
+      }
 
-        if (_thread.joinable())
-        {
-          _thread.join();
-        }
+      _timerFd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
+      if (_timerFd < 0)
+      {
+        ::close(_epollFd);
+        throw TimerException(TimerError::SystemError, "timerfd_create failed", errno);
+      }
 
-        cleanup();
-        _logger->info("Timer service stopped");
+      _eventFd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
+      if (_eventFd < 0)
+      {
+        ::close(_timerFd);
+        ::close(_epollFd);
+        throw TimerException(TimerError::SystemError, "eventfd create failed", errno);
       }
-    }
 
-    /// \brief Get current statistics.
-    const TimerStats& getStats() const { return _stats; }
+      addEpollFd(_timerFd, EPOLLIN);
+      addEpollFd(_eventFd, EPOLLIN);
 
-    /// \brief Reset statistics.
-    void resetStats()
-    {
-      _stats.reset();
-      _logger->info("Timer statistics reset");
-    }
+      _running.store(true, std::memory_order_release);
+      _thread = std::thread([this]() { this->runLoop(); });
 
-    /// \brief Get current configuration.
-    const TimerServiceConfig& getConfig() const { return _config; }
+      // Set thread name and priority if configured
+      configureThread();
 
-    /// \brief Set error handler.
-    void setErrorHandler(ErrorHandler handler)
+      _logger->info("Timer service started successfully");
+    }
+    catch (const TimerException &e)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      _errorHandler = std::move(handler);
+      handleError(e.code(), e.what(), e.getErrno());
+      if (_config.throwOnSystemError)
+      {
+        throw;
+      }
     }
+  }
 
-    /// \brief Set logger.
-    void setLogger(std::shared_ptr<TimerLogger> logger)
+  void configureThread()
+  {
+#ifdef __linux__
+    if (_config.setThreadPriority)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      _logger = std::move(logger);
+      struct sched_param param;
+      param.sched_priority = _config.threadPriority;
+      if (pthread_setschedparam(_thread.native_handle(), SCHED_FIFO, &param) != 0)
+      {
+        _logger->warning("Failed to set thread priority");
+      }
     }
 
-  private:
-    struct Record
+    if (!_config.threadName.empty())
     {
-      TimePoint tp;
-      Handler handler;
-      bool canceled{false};
-      bool periodic{false};
-    };
+      pthread_setname_np(_thread.native_handle(), _config.threadName.c_str());
+    }
+#endif
+  }
 
-    struct HeapItem
+  void cleanup()
+  {
+    if (_eventFd >= 0)
     {
-      TimePoint tp;
-      std::uint64_t id;
-    };
-
-    struct PeriodicTimer
+      ::close(_eventFd);
+      _eventFd = -1;
+    }
+    if (_timerFd >= 0)
     {
-      std::uint64_t id;
-      Duration interval;
-      TimePoint nextExecution;
-      bool canceled{false};
-    };
+      ::close(_timerFd);
+      _timerFd = -1;
+    }
+    if (_epollFd >= 0)
+    {
+      ::close(_epollFd);
+      _epollFd = -1;
+    }
+  }
+
+  bool isValidTimeout(TimePoint tp) const
+  {
+    auto now = Clock::now();
+    auto duration = tp - now;
+    return duration <= _config.limits.maxTimeout;
+  }
 
-    static bool less(const HeapItem& a, const HeapItem& b)
+  void handleError(TimerError error, const std::string &message, int errno_val)
+  {
+    if (_config.enableStatistics && error == TimerError::SystemError)
     {
-      return a.tp < b.tp || (a.tp == b.tp && a.id < b.id);
+      _stats.systemErrors.fetch_add(1, std::memory_order_relaxed);
     }
 
-    void initialize()
+    _logger->error(message, error, errno_val);
+
+    if (_errorHandler)
     {
       try
       {
-        _epollFd = ::epoll_create1(EPOLL_CLOEXEC);
-        if (_epollFd < 0)
-        {
-          throw TimerException(TimerError::SystemError, "epoll_create1 failed",
-                               errno);
-        }
-
-        _timerFd =
-            ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
-        if (_timerFd < 0)
-        {
-          ::close(_epollFd);
-          throw TimerException(TimerError::SystemError, "timerfd_create failed",
-                               errno);
-        }
-
-        _eventFd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
-        if (_eventFd < 0)
-        {
-          ::close(_timerFd);
-          ::close(_epollFd);
-          throw TimerException(TimerError::SystemError, "eventfd create failed",
-                               errno);
-        }
-
-        addEpollFd(_timerFd, EPOLLIN);
-        addEpollFd(_eventFd, EPOLLIN);
-
-        _running.store(true, std::memory_order_release);
-        _thread = std::thread([this]() { this->runLoop(); });
-
-        // Set thread name and priority if configured
-        configureThread();
-
-        _logger->info("Timer service started successfully");
+        _errorHandler(error, message, errno_val);
       }
-      catch (const TimerException& e)
+      catch (...)
       {
-        handleError(e.code(), e.what(), e.getErrno());
-        if (_config.throwOnSystemError)
-        {
-          throw;
-        }
+        _logger->critical("Error handler threw exception");
       }
     }
+  }
 
-    void configureThread()
+  void siftUp(std::size_t idx)
+  {
+    while (idx > 0)
     {
-#ifdef __linux__
-      if (_config.setThreadPriority)
+      std::size_t parent = (idx - 1) / 2;
+      if (!less(_heap[idx], _heap[parent]))
       {
-        struct sched_param param;
-        param.sched_priority = _config.threadPriority;
-        if (pthread_setschedparam(_thread.native_handle(), SCHED_FIFO,
-                                  &param) != 0)
-        {
-          _logger->warning("Failed to set thread priority");
-        }
-      }
-
-      if (!_config.threadName.empty())
-      {
-        pthread_setname_np(_thread.native_handle(), _config.threadName.c_str());
+        break;
       }
-#endif
+      std::swap(_heap[idx], _heap[parent]);
+      idx = parent;
     }
+  }
 
-    void cleanup()
+  void siftDown(std::size_t idx)
+  {
+    for (;;)
     {
-      if (_eventFd >= 0)
+      std::size_t left = idx * 2 + 1;
+      std::size_t right = left + 1;
+      std::size_t smallest = idx;
+      if (left < _heap.size() && less(_heap[left], _heap[smallest]))
       {
-        ::close(_eventFd);
-        _eventFd = -1;
+        smallest = left;
       }
-      if (_timerFd >= 0)
+      if (right < _heap.size() && less(_heap[right], _heap[smallest]))
       {
-        ::close(_timerFd);
-        _timerFd = -1;
+        smallest = right;
       }
-      if (_epollFd >= 0)
+      if (smallest == idx)
       {
-        ::close(_epollFd);
-        _epollFd = -1;
+        break;
       }
+      std::swap(_heap[idx], _heap[smallest]);
+      idx = smallest;
     }
+  }
 
-    bool isValidTimeout(TimePoint tp) const
+  std::optional<HeapItem> heapTop() const
+  {
+    if (_heap.empty())
     {
-      auto now = Clock::now();
-      auto duration = tp - now;
-      return duration <= _config.limits.maxTimeout;
+      return std::nullopt;
     }
+    return _heap.front();
+  }
 
-    void handleError(TimerError error, const std::string& message,
-                     int errno_val)
+  void heapPop()
+  {
+    if (_heap.empty())
     {
-      if (_config.enableStatistics && error == TimerError::SystemError)
-      {
-        _stats.systemErrors.fetch_add(1, std::memory_order_relaxed);
-      }
-
-      _logger->error(message, error, errno_val);
-
-      if (_errorHandler)
-      {
-        try
-        {
-          _errorHandler(error, message, errno_val);
-        }
-        catch (...)
-        {
-          _logger->critical("Error handler threw exception");
-        }
-      }
+      return;
     }
-
-    void siftUp(std::size_t idx)
+    std::swap(_heap.front(), _heap.back());
+    _heap.pop_back();
+    if (!_heap.empty())
     {
-      while (idx > 0)
-      {
-        std::size_t parent = (idx - 1) / 2;
-        if (!less(_heap[idx], _heap[parent]))
-        {
-          break;
-        }
-        std::swap(_heap[idx], _heap[parent]);
-        idx = parent;
-      }
+      siftDown(0);
     }
 
-    void siftDown(std::size_t idx)
+    if (_config.enableStatistics)
     {
-      for (;;)
-      {
-        std::size_t left = idx * 2 + 1;
-        std::size_t right = left + 1;
-        std::size_t smallest = idx;
-        if (left < _heap.size() && less(_heap[left], _heap[smallest]))
-        {
-          smallest = left;
-        }
-        if (right < _heap.size() && less(_heap[right], _heap[smallest]))
-        {
-          smallest = right;
-        }
-        if (smallest == idx)
-        {
-          break;
-        }
-        std::swap(_heap[idx], _heap[smallest]);
-        idx = smallest;
-      }
+      _stats.heapOperations.fetch_add(1, std::memory_order_relaxed);
     }
+  }
 
-    std::optional<HeapItem> heapTop() const
+  void programTimerfd(std::optional<TimePoint> nextDue)
+  {
+    itimerspec its{};
+    if (nextDue.has_value())
     {
-      if (_heap.empty())
-      {
-        return std::nullopt;
-      }
-      return _heap.front();
-    }
+      TimePoint now = Clock::now();
+      auto delta = (nextDue.value() > now) ? (nextDue.value() - now) : Duration::zero();
+      auto ns = std::chrono::duration_cast<std::chrono::nanoseconds>(delta).count();
 
-    void heapPop()
-    {
-      if (_heap.empty())
-      {
-        return;
-      }
-      std::swap(_heap.front(), _heap.back());
-      _heap.pop_back();
-      if (!_heap.empty())
-      {
-        siftDown(0);
-      }
+      its.it_value.tv_sec = static_cast<time_t>(ns / 1000000000LL);
+      its.it_value.tv_nsec = static_cast<long>(ns % 1000000000LL);
 
-      if (_config.enableStatistics)
+      if (its.it_value.tv_sec == 0 && its.it_value.tv_nsec == 0)
       {
-        _stats.heapOperations.fetch_add(1, std::memory_order_relaxed);
+        its.it_value.tv_nsec = 1;
       }
     }
 
-    void programTimerfd(std::optional<TimePoint> nextDue)
+    if (::timerfd_settime(_timerFd, 0, &its, nullptr) != 0)
     {
-      itimerspec its{};
-      if (nextDue.has_value())
+      handleError(TimerError::SystemError, "timerfd_settime failed", errno);
+      if (_config.throwOnSystemError)
       {
-        TimePoint now = Clock::now();
-        auto delta = (nextDue.value() > now) ? (nextDue.value() - now)
-                                             : Duration::zero();
-        auto ns =
-            std::chrono::duration_cast<std::chrono::nanoseconds>(delta).count();
-
-        its.it_value.tv_sec = static_cast<time_t>(ns / 1000000000LL);
-        its.it_value.tv_nsec = static_cast<long>(ns % 1000000000LL);
-
-        if (its.it_value.tv_sec == 0 && its.it_value.tv_nsec == 0)
-        {
-          its.it_value.tv_nsec = 1;
-        }
-      }
-
-      if (::timerfd_settime(_timerFd, 0, &its, nullptr) != 0)
-      {
-        handleError(TimerError::SystemError, "timerfd_settime failed", errno);
-        if (_config.throwOnSystemError)
-        {
-          throw TimerException(TimerError::SystemError,
-                               "timerfd_settime failed", errno);
-        }
+        throw TimerException(TimerError::SystemError, "timerfd_settime failed", errno);
       }
     }
+  }
 
-    void poke()
+  void poke()
+  {
+    std::uint64_t one = 1;
+    ssize_t n = ::write(_eventFd, &one, sizeof(one));
+    if (n < 0 && errno != EAGAIN)
     {
-      std::uint64_t one = 1;
-      ssize_t n = ::write(_eventFd, &one, sizeof(one));
-      if (n < 0 && errno != EAGAIN)
-      {
-        handleError(TimerError::SystemError, "eventfd write failed", errno);
-      }
+      handleError(TimerError::SystemError, "eventfd write failed", errno);
     }
+  }
 
-    void drainEventfd()
+  void drainEventfd()
+  {
+    std::uint64_t val = 0;
+    while (true)
     {
-      std::uint64_t val = 0;
-      while (true)
+      ssize_t n = ::read(_eventFd, &val, sizeof(val));
+      if (n < 0)
       {
-        ssize_t n = ::read(_eventFd, &val, sizeof(val));
-        if (n < 0)
-        {
-          if (errno == EAGAIN)
-          {
-            break;
-          }
-          break;
-        }
-        if (n < static_cast<ssize_t>(sizeof(val)))
+        if (errno == EAGAIN)
         {
           break;
         }
+        break;
       }
-
-      if (_config.enableStatistics)
+      if (n < static_cast<ssize_t>(sizeof(val)))
       {
-        _stats.eventfdWakeups.fetch_add(1, std::memory_order_relaxed);
+        break;
       }
     }
 
-    void drainTimerfd()
+    if (_config.enableStatistics)
     {
-      std::uint64_t expirations = 0;
-      (void) ::read(_timerFd, &expirations, sizeof(expirations));
+      _stats.eventfdWakeups.fetch_add(1, std::memory_order_relaxed);
+    }
+  }
 
-      if (_config.enableStatistics)
-      {
-        _stats.timerfdTriggers.fetch_add(1, std::memory_order_relaxed);
-      }
+  void drainTimerfd()
+  {
+    std::uint64_t expirations = 0;
+    (void)::read(_timerFd, &expirations, sizeof(expirations));
+
+    if (_config.enableStatistics)
+    {
+      _stats.timerfdTriggers.fetch_add(1, std::memory_order_relaxed);
     }
+  }
 
-    void addEpollFd(int fd, std::uint32_t events)
+  void addEpollFd(int fd, std::uint32_t events)
+  {
+    epoll_event ev{};
+    ev.events = events;
+    ev.data.fd = fd;
+    if (::epoll_ctl(_epollFd, EPOLL_CTL_ADD, fd, &ev) != 0)
     {
-      epoll_event ev{};
-      ev.events = events;
-      ev.data.fd = fd;
-      if (::epoll_ctl(_epollFd, EPOLL_CTL_ADD, fd, &ev) != 0)
-      {
-        throw TimerException(TimerError::SystemError, "epoll_ctl(ADD) failed",
-                             errno);
-      }
+      throw TimerException(TimerError::SystemError, "epoll_ctl(ADD) failed", errno);
     }
+  }
 
-    void collectDueLocked(TimePoint now, std::vector<Handler>& out)
+  void collectDueLocked(TimePoint now, std::vector<Handler> &out)
+  {
+    while (!_heap.empty())
     {
-      while (!_heap.empty())
+      const HeapItem &top = _heap.front();
+      if (top.tp > now)
       {
-        const HeapItem& top = _heap.front();
-        if (top.tp > now)
-        {
-          break;
-        }
+        break;
+      }
 
-        auto it = _records.find(top.id);
-        heapPop();
+      auto it = _records.find(top.id);
+      heapPop();
 
-        if (it == _records.end())
-        {
-          continue;
-        }
+      if (it == _records.end())
+      {
+        continue;
+      }
 
-        Record rec = std::move(it->second);
-        _records.erase(it);
+      Record rec = std::move(it->second);
+      _records.erase(it);
 
-        if (!rec.canceled)
-        {
-          out.push_back(std::move(rec.handler));
+      if (!rec.canceled)
+      {
+        out.push_back(std::move(rec.handler));
 
-          if (_config.enableStatistics)
-          {
-            _stats.timersExpired.fetch_add(1, std::memory_order_relaxed);
-          }
+        if (_config.enableStatistics)
+        {
+          _stats.timersExpired.fetch_add(1, std::memory_order_relaxed);
         }
       }
     }
+  }
 
-    void safeRun(const Handler& h)
-    {
-      if (!static_cast<bool>(h))
-        return;
+  void safeRun(const Handler &h)
+  {
+    if (!static_cast<bool>(h))
+      return;
 
-      auto start = std::chrono::steady_clock::now();
+    auto start = std::chrono::steady_clock::now();
 
-      try
+    try
+    {
+      h();
+
+      if (_config.enableStatistics)
       {
-        h();
+        _stats.timersExecuted.fetch_add(1, std::memory_order_relaxed);
 
-        if (_config.enableStatistics)
-        {
-          _stats.timersExecuted.fetch_add(1, std::memory_order_relaxed);
-
-          auto end = std::chrono::steady_clock::now();
-          auto duration = static_cast<std::uint64_t>(
-              std::chrono::duration_cast<std::chrono::nanoseconds>(end - start)
-                  .count());
-
-          _stats.totalHandlerExecutionTimeNs.fetch_add(
-              duration, std::memory_order_relaxed);
-
-          // Update max execution time
-          auto currentMax =
-              _stats.maxHandlerExecutionTimeNs.load(std::memory_order_relaxed);
-          while (duration > currentMax &&
-                 !_stats.maxHandlerExecutionTimeNs.compare_exchange_weak(
-                     currentMax, duration, std::memory_order_relaxed))
-          {
-          }
+        auto end = std::chrono::steady_clock::now();
+        auto duration = static_cast<std::uint64_t>(
+          std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count());
+
+        _stats.totalHandlerExecutionTimeNs.fetch_add(duration, std::memory_order_relaxed);
 
-          // Update average (simple moving average)
-          auto totalExecuted =
-              _stats.timersExecuted.load(std::memory_order_relaxed);
-          auto totalTime = _stats.totalHandlerExecutionTimeNs.load(
-              std::memory_order_relaxed);
-          _stats.avgHandlerExecutionTimeNs.store(totalTime / totalExecuted,
-                                                 std::memory_order_relaxed);
+        // Update max execution time
+        auto currentMax = _stats.maxHandlerExecutionTimeNs.load(std::memory_order_relaxed);
+        while (duration > currentMax && !_stats.maxHandlerExecutionTimeNs.compare_exchange_weak(
+                                          currentMax, duration, std::memory_order_relaxed))
+        {
         }
+
+        // Update average (simple moving average)
+        auto totalExecuted = _stats.timersExecuted.load(std::memory_order_relaxed);
+        auto totalTime = _stats.totalHandlerExecutionTimeNs.load(std::memory_order_relaxed);
+        _stats.avgHandlerExecutionTimeNs.store(totalTime / totalExecuted,
+                                               std::memory_order_relaxed);
       }
-      catch (...)
+    }
+    catch (...)
+    {
+      if (_config.enableStatistics)
       {
-        if (_config.enableStatistics)
-        {
-          _stats.exceptionsSwallowed.fetch_add(1, std::memory_order_relaxed);
-        }
-        handleError(TimerError::HandlerException,
-                    "Timer handler threw exception", 0);
+        _stats.exceptionsSwallowed.fetch_add(1, std::memory_order_relaxed);
       }
+      handleError(TimerError::HandlerException, "Timer handler threw exception", 0);
     }
+  }
 
-    void runLoop()
-    {
-      _logger->info("Timer service loop started");
+  void runLoop()
+  {
+    _logger->info("Timer service loop started");
+
+    std::vector<epoll_event> events(_config.maxEpollEvents);
 
-      std::vector<epoll_event> events(_config.maxEpollEvents);
+    for (;;)
+    {
+      std::optional<TimePoint> nextDue;
+      std::vector<Handler> ready;
 
-      for (;;)
       {
-        std::optional<TimePoint> nextDue;
-        std::vector<Handler> ready;
+        std::lock_guard<std::mutex> lock(_mutex);
 
+        if (!_running.load(std::memory_order_acquire))
         {
-          std::lock_guard<std::mutex> lock(_mutex);
-
-          if (!_running.load(std::memory_order_acquire))
-          {
-            TimePoint now = Clock::now();
-            collectDueLocked(now, ready);
-            programTimerfd(std::nullopt);
-            for (auto& h : ready)
-            {
-              safeRun(h);
-            }
-            break;
-          }
-
-          if (auto top = heapTop())
+          TimePoint now = Clock::now();
+          collectDueLocked(now, ready);
+          programTimerfd(std::nullopt);
+          for (auto &h : ready)
           {
-            nextDue = top->tp;
+            safeRun(h);
           }
-
-          programTimerfd(nextDue);
+          break;
         }
 
-        for (auto& h : ready)
+        if (auto top = heapTop())
         {
-          safeRun(h);
+          nextDue = top->tp;
         }
-        ready.clear();
 
-        int timeout = _config.epollTimeout.count() >= 0
-                          ? static_cast<int>(_config.epollTimeout.count())
-                          : -1;
-        int rc = ::epoll_wait(_epollFd, events.data(), _config.maxEpollEvents,
-                              timeout);
+        programTimerfd(nextDue);
+      }
 
-        if (_config.enableStatistics)
-        {
-          _stats.epollWaits.fetch_add(1, std::memory_order_relaxed);
-        }
+      for (auto &h : ready)
+      {
+        safeRun(h);
+      }
+      ready.clear();
+
+      int timeout =
+        _config.epollTimeout.count() >= 0 ? static_cast<int>(_config.epollTimeout.count()) : -1;
+      int rc = ::epoll_wait(_epollFd, events.data(), _config.maxEpollEvents, timeout);
+
+      if (_config.enableStatistics)
+      {
+        _stats.epollWaits.fetch_add(1, std::memory_order_relaxed);
+      }
 
-        if (rc < 0)
+      if (rc < 0)
+      {
+        if (errno == EINTR)
         {
-          if (errno == EINTR)
-          {
-            continue;
-          }
-          handleError(TimerError::SystemError, "epoll_wait failed", errno);
-          if (_config.throwOnSystemError)
-          {
-            break;
-          }
           continue;
         }
-
-        bool timerTriggered = false;
-        bool woke = false;
-
-        for (int i = 0; i < rc; ++i)
+        handleError(TimerError::SystemError, "epoll_wait failed", errno);
+        if (_config.throwOnSystemError)
         {
-          int fd = events[i].data.fd;
-          std::uint32_t ev = events[i].events;
+          break;
+        }
+        continue;
+      }
 
-          if ((ev & (EPOLLERR | EPOLLHUP)) != 0)
-          {
-            _logger->warning("epoll error on fd " + std::to_string(fd));
-          }
+      bool timerTriggered = false;
+      bool woke = false;
 
-          if (fd == _timerFd && (ev & EPOLLIN))
-          {
-            timerTriggered = true;
-          }
-          else if (fd == _eventFd && (ev & EPOLLIN))
-          {
-            woke = true;
-          }
-        }
+      for (int i = 0; i < rc; ++i)
+      {
+        int fd = events[i].data.fd;
+        std::uint32_t ev = events[i].events;
 
-        if (woke)
-        {
-          drainEventfd();
-        }
-        if (timerTriggered)
+        if ((ev & (EPOLLERR | EPOLLHUP)) != 0)
         {
-          drainTimerfd();
+          _logger->warning("epoll error on fd " + std::to_string(fd));
         }
 
+        if (fd == _timerFd && (ev & EPOLLIN))
         {
-          std::lock_guard<std::mutex> lock(_mutex);
-          TimePoint now = Clock::now();
-          collectDueLocked(now, ready);
+          timerTriggered = true;
         }
-
-        for (auto& h : ready)
+        else if (fd == _eventFd && (ev & EPOLLIN))
         {
-          safeRun(h);
+          woke = true;
         }
       }
 
-      _logger->info("Timer service loop finished");
-    }
+      if (woke)
+      {
+        drainEventfd();
+      }
+      if (timerTriggered)
+      {
+        drainTimerfd();
+      }
 
-  private:
-    // Configuration and logging
-    TimerServiceConfig _config;
-    std::shared_ptr<TimerLogger> _logger;
-    ErrorHandler _errorHandler;
-
-    // Statistics
-    mutable TimerStats _stats;
-
-    // Timer bookkeeping
-    std::mutex _mutex;
-    std::unordered_map<std::uint64_t, Record> _records;
-    std::unordered_map<std::uint64_t, PeriodicTimer> _periodicTimers;
-    std::vector<HeapItem> _heap;
-    std::uint64_t _nextId{0};
-
-    // Threading and fds
-    std::atomic<bool> _running{false};
-    std::thread _thread;
-    int _epollFd{-1};
-    int _timerFd{-1};
-    int _eventFd{-1};
-  };
+      {
+        std::lock_guard<std::mutex> lock(_mutex);
+        TimePoint now = Clock::now();
+        collectDueLocked(now, ready);
+      }
 
-  /// \brief Enhanced ASIO-like timer bound to TimerService.
-  class SteadyTimer
-  {
-  public:
-    using Clock = TimerService::Clock;
-    using TimePoint = TimerService::TimePoint;
-    using Duration = TimerService::Duration;
-    using Handler = TimerService::Handler;
+      for (auto &h : ready)
+      {
+        safeRun(h);
+      }
+    }
 
-    explicit SteadyTimer(TimerService& svc) : _svc(svc) {}
+    _logger->info("Timer service loop finished");
+  }
+
+private:
+  // Configuration and logging
+  TimerServiceConfig _config;
+  std::shared_ptr<TimerLogger> _logger;
+  ErrorHandler _errorHandler;
+
+  // Statistics
+  mutable TimerStats _stats;
+
+  // Timer bookkeeping
+  std::mutex _mutex;
+  std::unordered_map<std::uint64_t, Record> _records;
+  std::unordered_map<std::uint64_t, PeriodicTimer> _periodicTimers;
+  std::vector<HeapItem> _heap;
+  std::uint64_t _nextId{0};
+
+  // Threading and fds
+  std::atomic<bool> _running{false};
+  std::thread _thread;
+  int _epollFd{-1};
+  int _timerFd{-1};
+  int _eventFd{-1};
+};
+
+/// \brief Enhanced ASIO-like timer bound to TimerService.
+class SteadyTimer
+{
+public:
+  using Clock = TimerService::Clock;
+  using TimePoint = TimerService::TimePoint;
+  using Duration = TimerService::Duration;
+  using Handler = TimerService::Handler;
 
-    ~SteadyTimer()
-    {
-      cancel();
-      _shared.reset();
-    }
+  explicit SteadyTimer(TimerService &svc) : _svc(svc) {}
+
+  ~SteadyTimer()
+  {
+    cancel();
+    _shared.reset();
+  }
 
-    void expiresAt(TimePoint tp) { _expiry = tp; }
+  void expiresAt(TimePoint tp) { _expiry = tp; }
 
-    void expiresAfter(Duration d) { _expiry = Clock::now() + d; }
+  void expiresAfter(Duration d) { _expiry = Clock::now() + d; }
 
-    /// \brief Arm the timer with perfect forwarding.
-    template <typename Handler> void asyncWait(Handler&& handler)
+  /// \brief Arm the timer with perfect forwarding.
+  template <typename Handler> void asyncWait(Handler &&handler)
+  {
+    cancel();
+    _shared = std::make_shared<Shared>();
+    TimePoint tp = _expiry.value_or(Clock::now());
+    std::weak_ptr<Shared> w = _shared;
+
+    _token = _svc.scheduleAt(tp,
+                             [w, h = std::forward<Handler>(handler)]() mutable
+                             {
+                               if (auto s = w.lock())
+                               {
+                                 if (!s->canceled.load(std::memory_order_acquire))
+                                 {
+                                   try
+                                   {
+                                     h();
+                                   }
+                                   catch (...)
+                                   {
+                                     // Exception handling is done in the service
+                                   }
+                                 }
+                               }
+                             });
+  }
+
+  bool cancel()
+  {
+    if (_shared)
     {
-      cancel();
-      _shared = std::make_shared<Shared>();
-      TimePoint tp = _expiry.value_or(Clock::now());
-      std::weak_ptr<Shared> w = _shared;
-
-      _token =
-          _svc.scheduleAt(tp,
-                          [w, h = std::forward<Handler>(handler)]() mutable
-                          {
-                            if (auto s = w.lock())
-                            {
-                              if (!s->canceled.load(std::memory_order_acquire))
-                              {
-                                try
-                                {
-                                  h();
-                                }
-                                catch (...)
-                                {
-                                  // Exception handling is done in the service
-                                }
-                              }
-                            }
-                          });
+      _shared->canceled.store(true, std::memory_order_release);
     }
-
-    bool cancel()
+    if (_token)
     {
-      if (_shared)
-      {
-        _shared->canceled.store(true, std::memory_order_release);
-      }
-      if (_token)
-      {
-        bool ok = _svc.cancel(*_token);
-        _token.reset();
-        return ok;
-      }
-      return false;
+      bool ok = _svc.cancel(*_token);
+      _token.reset();
+      return ok;
     }
+    return false;
+  }
 
-    /// \brief Get the underlying service.
-    TimerService& getService() { return _svc; }
-    const TimerService& getService() const { return _svc; }
+  /// \brief Get the underlying service.
+  TimerService &getService() { return _svc; }
+  const TimerService &getService() const { return _svc; }
 
-  private:
-    struct Shared
-    {
-      std::atomic<bool> canceled{false};
-    };
-
-    TimerService& _svc;
-    std::optional<TimePoint> _expiry;
-    std::optional<std::uint64_t> _token;
-    std::shared_ptr<Shared> _shared;
+private:
+  struct Shared
+  {
+    std::atomic<bool> canceled{false};
   };
 
-  /// \brief Timer service pool for high-load scenarios.
-  class TimerServicePool
-  {
-  public:
-    /// \brief Create pool with specified number of services.
-    explicit TimerServicePool(
-        std::size_t numServices = std::thread::hardware_concurrency(),
-        const TimerServiceConfig& config = {})
+  TimerService &_svc;
+  std::optional<TimePoint> _expiry;
+  std::optional<std::uint64_t> _token;
+  std::shared_ptr<Shared> _shared;
+};
+
+/// \brief Timer service pool for high-load scenarios.
+class TimerServicePool
+{
+public:
+  /// \brief Create pool with specified number of services.
+  explicit TimerServicePool(std::size_t numServices = std::thread::hardware_concurrency(),
+                            const TimerServiceConfig &config = {})
       : _config(config)
+  {
+    if (numServices == 0)
     {
-      if (numServices == 0)
-      {
-        numServices = 1;
-      }
-
-      _services.reserve(numServices);
-      for (std::size_t i = 0; i < numServices; ++i)
-      {
-        auto serviceConfig = _config;
-        serviceConfig.threadName = _config.threadName + "_" + std::to_string(i);
-        _services.emplace_back(std::make_unique<TimerService>(serviceConfig));
-      }
-
-      _logger = std::make_shared<ConsoleTimerLogger>();
-      _logger->info("Timer service pool created with " +
-                    std::to_string(numServices) + " services");
+      numServices = 1;
     }
 
-    /// \brief Create pool with custom logger.
-    TimerServicePool(std::size_t numServices, const TimerServiceConfig& config,
-                     std::shared_ptr<TimerLogger> logger)
-      : _config(config), _logger(std::move(logger))
+    _services.reserve(numServices);
+    for (std::size_t i = 0; i < numServices; ++i)
     {
-      if (numServices == 0)
-      {
-        numServices = 1;
-      }
-
-      _services.reserve(numServices);
-      for (std::size_t i = 0; i < numServices; ++i)
-      {
-        auto serviceConfig = _config;
-        serviceConfig.threadName = _config.threadName + "_" + std::to_string(i);
-        _services.emplace_back(
-            std::make_unique<TimerService>(serviceConfig, _logger));
-      }
-
-      _logger->info("Timer service pool created with " +
-                    std::to_string(numServices) + " services");
+      auto serviceConfig = _config;
+      serviceConfig.threadName = _config.threadName + "_" + std::to_string(i);
+      _services.emplace_back(std::make_unique<TimerService>(serviceConfig));
     }
 
-    ~TimerServicePool() { stop(); }
+    _logger = std::make_shared<ConsoleTimerLogger>();
+    _logger->info("Timer service pool created with " + std::to_string(numServices) + " services");
+  }
 
-    /// \brief Get next service using round-robin selection.
-    TimerService& getService()
+  /// \brief Create pool with custom logger.
+  TimerServicePool(std::size_t numServices, const TimerServiceConfig &config,
+                   std::shared_ptr<TimerLogger> logger)
+      : _config(config), _logger(std::move(logger))
+  {
+    if (numServices == 0)
     {
-      std::size_t index =
-          _nextIndex.fetch_add(1, std::memory_order_relaxed) % _services.size();
-      return *_services[index];
+      numServices = 1;
     }
 
-    /// \brief Get service with least load (based on active timers).
-    TimerService& getLeastLoadedService()
+    _services.reserve(numServices);
+    for (std::size_t i = 0; i < numServices; ++i)
     {
-      if (_services.empty())
-      {
-        throw TimerException(TimerError::ConfigurationError,
-                             "No services available in pool", 0);
-      }
+      auto serviceConfig = _config;
+      serviceConfig.threadName = _config.threadName + "_" + std::to_string(i);
+      _services.emplace_back(std::make_unique<TimerService>(serviceConfig, _logger));
+    }
 
-      auto* bestService = _services[0].get();
-      std::uint64_t minLoad = bestService->getStats().timersScheduled.load() -
-                              bestService->getStats().timersExecuted.load();
+    _logger->info("Timer service pool created with " + std::to_string(numServices) + " services");
+  }
 
-      for (std::size_t i = 1; i < _services.size(); ++i)
-      {
-        auto* service = _services[i].get();
-        std::uint64_t load = service->getStats().timersScheduled.load() -
-                             service->getStats().timersExecuted.load();
-        if (load < minLoad)
-        {
-          minLoad = load;
-          bestService = service;
-        }
-      }
+  ~TimerServicePool() { stop(); }
+
+  /// \brief Get next service using round-robin selection.
+  TimerService &getService()
+  {
+    std::size_t index = _nextIndex.fetch_add(1, std::memory_order_relaxed) % _services.size();
+    return *_services[index];
+  }
 
-      return *bestService;
+  /// \brief Get service with least load (based on active timers).
+  TimerService &getLeastLoadedService()
+  {
+    if (_services.empty())
+    {
+      throw TimerException(TimerError::ConfigurationError, "No services available in pool", 0);
     }
 
-    /// \brief Get number of services in pool.
-    std::size_t size() const { return _services.size(); }
+    auto *bestService = _services[0].get();
+    std::uint64_t minLoad = bestService->getStats().timersScheduled.load() -
+                            bestService->getStats().timersExecuted.load();
 
-    /// \brief Stop all services.
-    void stop()
+    for (std::size_t i = 1; i < _services.size(); ++i)
     {
-      _logger->info("Stopping timer service pool");
-      for (auto& service : _services)
+      auto *service = _services[i].get();
+      std::uint64_t load =
+        service->getStats().timersScheduled.load() - service->getStats().timersExecuted.load();
+      if (load < minLoad)
       {
-        service->stop();
+        minLoad = load;
+        bestService = service;
       }
-      _logger->info("Timer service pool stopped");
     }
 
-    /// \brief Get aggregated statistics from all services.
-    void getAggregatedStats(TimerStats& aggregated) const
+    return *bestService;
+  }
+
+  /// \brief Get number of services in pool.
+  std::size_t size() const { return _services.size(); }
+
+  /// \brief Stop all services.
+  void stop()
+  {
+    _logger->info("Stopping timer service pool");
+    for (auto &service : _services)
     {
-      aggregated.reset();
+      service->stop();
+    }
+    _logger->info("Timer service pool stopped");
+  }
 
-      for (const auto& service : _services)
-      {
-        const auto& stats = service->getStats();
-        aggregated.timersScheduled.store(aggregated.timersScheduled.load() +
-                                             stats.timersScheduled.load(),
-                                         std::memory_order_relaxed);
-        aggregated.timersCanceled.store(aggregated.timersCanceled.load() +
-                                            stats.timersCanceled.load(),
-                                        std::memory_order_relaxed);
-        aggregated.timersExecuted.store(aggregated.timersExecuted.load() +
-                                            stats.timersExecuted.load(),
-                                        std::memory_order_relaxed);
-        aggregated.timersExpired.store(aggregated.timersExpired.load() +
-                                           stats.timersExpired.load(),
+  /// \brief Get aggregated statistics from all services.
+  void getAggregatedStats(TimerStats &aggregated) const
+  {
+    aggregated.reset();
+
+    for (const auto &service : _services)
+    {
+      const auto &stats = service->getStats();
+      aggregated.timersScheduled.store(aggregated.timersScheduled.load() +
+                                         stats.timersScheduled.load(),
                                        std::memory_order_relaxed);
-        aggregated.periodicTimersActive.store(
-            aggregated.periodicTimersActive.load() +
-                stats.periodicTimersActive.load(),
-            std::memory_order_relaxed);
-        aggregated.exceptionsSwallowed.store(
-            aggregated.exceptionsSwallowed.load() +
-                stats.exceptionsSwallowed.load(),
-            std::memory_order_relaxed);
-        aggregated.systemErrors.store(aggregated.systemErrors.load() +
-                                          stats.systemErrors.load(),
-                                      std::memory_order_relaxed);
-        aggregated.heapOperations.store(aggregated.heapOperations.load() +
-                                            stats.heapOperations.load(),
-                                        std::memory_order_relaxed);
-        aggregated.epollWaits.store(aggregated.epollWaits.load() +
-                                        stats.epollWaits.load(),
+      aggregated.timersCanceled.store(
+        aggregated.timersCanceled.load() + stats.timersCanceled.load(), std::memory_order_relaxed);
+      aggregated.timersExecuted.store(
+        aggregated.timersExecuted.load() + stats.timersExecuted.load(), std::memory_order_relaxed);
+      aggregated.timersExpired.store(aggregated.timersExpired.load() + stats.timersExpired.load(),
+                                     std::memory_order_relaxed);
+      aggregated.periodicTimersActive.store(aggregated.periodicTimersActive.load() +
+                                              stats.periodicTimersActive.load(),
+                                            std::memory_order_relaxed);
+      aggregated.exceptionsSwallowed.store(aggregated.exceptionsSwallowed.load() +
+                                             stats.exceptionsSwallowed.load(),
+                                           std::memory_order_relaxed);
+      aggregated.systemErrors.store(aggregated.systemErrors.load() + stats.systemErrors.load(),
                                     std::memory_order_relaxed);
-        aggregated.eventfdWakeups.store(aggregated.eventfdWakeups.load() +
-                                            stats.eventfdWakeups.load(),
-                                        std::memory_order_relaxed);
-        aggregated.timerfdTriggers.store(aggregated.timerfdTriggers.load() +
-                                             stats.timerfdTriggers.load(),
-                                         std::memory_order_relaxed);
-      }
+      aggregated.heapOperations.store(
+        aggregated.heapOperations.load() + stats.heapOperations.load(), std::memory_order_relaxed);
+      aggregated.epollWaits.store(aggregated.epollWaits.load() + stats.epollWaits.load(),
+                                  std::memory_order_relaxed);
+      aggregated.eventfdWakeups.store(
+        aggregated.eventfdWakeups.load() + stats.eventfdWakeups.load(), std::memory_order_relaxed);
+      aggregated.timerfdTriggers.store(aggregated.timerfdTriggers.load() +
+                                         stats.timerfdTriggers.load(),
+                                       std::memory_order_relaxed);
     }
+  }
 
-    /// \brief Reset statistics for all services.
-    void resetStats()
+  /// \brief Reset statistics for all services.
+  void resetStats()
+  {
+    for (auto &service : _services)
     {
-      for (auto& service : _services)
-      {
-        service->resetStats();
-      }
+      service->resetStats();
     }
+  }
 
-  private:
-    TimerServiceConfig _config;
-    std::shared_ptr<TimerLogger> _logger;
-    std::vector<std::unique_ptr<TimerService>> _services;
-    std::atomic<std::size_t> _nextIndex{0};
-  };
+private:
+  TimerServiceConfig _config;
+  std::shared_ptr<TimerLogger> _logger;
+  std::vector<std::unique_ptr<TimerService>> _services;
+  std::atomic<std::size_t> _nextIndex{0};
+};
 
-  /// \brief Convenience builder for timer configuration.
-  class TimerConfigBuilder
+/// \brief Convenience builder for timer configuration.
+class TimerConfigBuilder
+{
+public:
+  TimerConfigBuilder &maxEpollEvents(int events)
   {
-  public:
-    TimerConfigBuilder& maxEpollEvents(int events)
-    {
-      _config.maxEpollEvents = events;
-      return *this;
-    }
-    TimerConfigBuilder& throwOnSystemError(bool enable)
-    {
-      _config.throwOnSystemError = enable;
-      return *this;
-    }
-    TimerConfigBuilder& epollTimeout(std::chrono::milliseconds timeout)
-    {
-      _config.epollTimeout = timeout;
-      return *this;
-    }
-    TimerConfigBuilder& initialHeapCapacity(std::size_t capacity)
-    {
-      _config.initialHeapCapacity = capacity;
-      return *this;
-    }
-    TimerConfigBuilder& enableStatistics(bool enable)
-    {
-      _config.enableStatistics = enable;
-      return *this;
-    }
-    TimerConfigBuilder& enableDetailedLogging(bool enable)
-    {
-      _config.enableDetailedLogging = enable;
-      return *this;
-    }
-    TimerConfigBuilder& maxConcurrentTimers(std::size_t max)
-    {
-      _config.limits.maxConcurrentTimers = max;
-      return *this;
-    }
-    TimerConfigBuilder& maxTimeout(std::chrono::milliseconds timeout)
-    {
-      _config.limits.maxTimeout = timeout;
-      return *this;
-    }
-    TimerConfigBuilder& threadPriority(bool enable, int priority = 0)
-    {
-      _config.setThreadPriority = enable;
-      _config.threadPriority = priority;
-      return *this;
-    }
-    TimerConfigBuilder& threadName(const std::string& name)
-    {
-      _config.threadName = name;
-      return *this;
-    }
+    _config.maxEpollEvents = events;
+    return *this;
+  }
+  TimerConfigBuilder &throwOnSystemError(bool enable)
+  {
+    _config.throwOnSystemError = enable;
+    return *this;
+  }
+  TimerConfigBuilder &epollTimeout(std::chrono::milliseconds timeout)
+  {
+    _config.epollTimeout = timeout;
+    return *this;
+  }
+  TimerConfigBuilder &initialHeapCapacity(std::size_t capacity)
+  {
+    _config.initialHeapCapacity = capacity;
+    return *this;
+  }
+  TimerConfigBuilder &enableStatistics(bool enable)
+  {
+    _config.enableStatistics = enable;
+    return *this;
+  }
+  TimerConfigBuilder &enableDetailedLogging(bool enable)
+  {
+    _config.enableDetailedLogging = enable;
+    return *this;
+  }
+  TimerConfigBuilder &maxConcurrentTimers(std::size_t max)
+  {
+    _config.limits.maxConcurrentTimers = max;
+    return *this;
+  }
+  TimerConfigBuilder &maxTimeout(std::chrono::milliseconds timeout)
+  {
+    _config.limits.maxTimeout = timeout;
+    return *this;
+  }
+  TimerConfigBuilder &threadPriority(bool enable, int priority = 0)
+  {
+    _config.setThreadPriority = enable;
+    _config.threadPriority = priority;
+    return *this;
+  }
+  TimerConfigBuilder &threadName(const std::string &name)
+  {
+    _config.threadName = name;
+    return *this;
+  }
 
-    TimerServiceConfig build() const { return _config; }
+  TimerServiceConfig build() const { return _config; }
 
-  private:
-    TimerServiceConfig _config;
-  };
+private:
+  TimerServiceConfig _config;
+};
 
 } // namespace core
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/crypto/secure_rng.hpp b/include/iora/crypto/secure_rng.hpp
index 3234b14..c62a01a 100644
--- a/include/iora/crypto/secure_rng.hpp
+++ b/include/iora/crypto/secure_rng.hpp
@@ -9,94 +9,93 @@
 
 #include <array>
 #include <cstdint>
+#include <stdexcept>
 #include <string>
 #include <vector>
-#include <stdexcept>
 
-#include <openssl/rand.h>
 #include <openssl/err.h>
 #include <openssl/evp.h>
+#include <openssl/rand.h>
 
 namespace iora
 {
 namespace crypto
 {
 
-  /// \brief Cryptographically Secure Pseudo-Random Number Generator using OpenSSL RAND_bytes().
-  /// 
-  /// This class provides secure random number generation suitable for cryptographic purposes,
-  /// including token generation, session IDs, and other security-sensitive applications.
-  class SecureRng
+/// \brief Cryptographically Secure Pseudo-Random Number Generator using OpenSSL RAND_bytes().
+///
+/// This class provides secure random number generation suitable for cryptographic purposes,
+/// including token generation, session IDs, and other security-sensitive applications.
+class SecureRng
+{
+public:
+  /// \brief Fill a buffer with cryptographically secure random bytes.
+  /// \param dst Destination buffer
+  /// \param len Number of bytes to generate
+  /// \throws std::runtime_error if RAND_bytes fails
+  static void fill(std::uint8_t *dst, std::size_t len)
   {
-  public:
-    /// \brief Fill a buffer with cryptographically secure random bytes.
-    /// \param dst Destination buffer
-    /// \param len Number of bytes to generate
-    /// \throws std::runtime_error if RAND_bytes fails
-    static void fill(std::uint8_t* dst, std::size_t len)
+    if (len == 0)
     {
-      if (len == 0)
-      {
-        return;
-      }
-      if (RAND_bytes(dst, static_cast<int>(len)) != 1)
-      {
-        auto error = lastError();
-        std::string msg;
-        msg.reserve(27 + error.size()); // "SecureRng: RAND_bytes failed: " = 27 chars
-        msg += "SecureRng: RAND_bytes failed: ";
-        msg += error;
-        throw std::runtime_error(std::move(msg));
-      }
+      return;
     }
-
-    /// \brief Fill a container with cryptographically secure random bytes.
-    /// \tparam Container Container type with byte-sized elements
-    /// \param c Container to fill (must have data() and size() methods)
-    /// \throws std::runtime_error if RAND_bytes fails
-    template <typename Container>
-    static void fill(Container& c)
+    if (RAND_bytes(dst, static_cast<int>(len)) != 1)
     {
-      static_assert(sizeof(typename Container::value_type) == 1, "byte container required");
-      fill(reinterpret_cast<std::uint8_t*>(c.data()), c.size());
+      auto error = lastError();
+      std::string msg;
+      msg.reserve(27 + error.size()); // "SecureRng: RAND_bytes failed: " = 27 chars
+      msg += "SecureRng: RAND_bytes failed: ";
+      msg += error;
+      throw std::runtime_error(std::move(msg));
     }
+  }
 
-    /// \brief Compute SHA-256 hash of input data.
-    /// \param data Input data to hash
-    /// \param out Output buffer (must be at least 32 bytes)
-    /// \throws std::runtime_error if hashing fails
-    static void sha256(const std::string& data, unsigned char out[32])
+  /// \brief Fill a container with cryptographically secure random bytes.
+  /// \tparam Container Container type with byte-sized elements
+  /// \param c Container to fill (must have data() and size() methods)
+  /// \throws std::runtime_error if RAND_bytes fails
+  template <typename Container> static void fill(Container &c)
+  {
+    static_assert(sizeof(typename Container::value_type) == 1, "byte container required");
+    fill(reinterpret_cast<std::uint8_t *>(c.data()), c.size());
+  }
+
+  /// \brief Compute SHA-256 hash of input data.
+  /// \param data Input data to hash
+  /// \param out Output buffer (must be at least 32 bytes)
+  /// \throws std::runtime_error if hashing fails
+  static void sha256(const std::string &data, unsigned char out[32])
+  {
+    EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+    if (!ctx)
     {
-      EVP_MD_CTX* ctx = EVP_MD_CTX_new();
-      if (!ctx)
-      {
-        throw std::runtime_error("SecureRng/sha256: EVP_MD_CTX_new failed");
-      }
-      int ok = EVP_DigestInit_ex(ctx, EVP_sha256(), nullptr);
-      ok &= EVP_DigestUpdate(ctx, data.data(), data.size());
-      unsigned int len = 0;
-      ok &= EVP_DigestFinal_ex(ctx, out, &len);
-      EVP_MD_CTX_free(ctx);
-      if (!ok || len != 32U)
-      {
-        throw std::runtime_error("SecureRng/sha256: EVP_Digest (SHA-256) failed");
-      }
+      throw std::runtime_error("SecureRng/sha256: EVP_MD_CTX_new failed");
     }
+    int ok = EVP_DigestInit_ex(ctx, EVP_sha256(), nullptr);
+    ok &= EVP_DigestUpdate(ctx, data.data(), data.size());
+    unsigned int len = 0;
+    ok &= EVP_DigestFinal_ex(ctx, out, &len);
+    EVP_MD_CTX_free(ctx);
+    if (!ok || len != 32U)
+    {
+      throw std::runtime_error("SecureRng/sha256: EVP_Digest (SHA-256) failed");
+    }
+  }
 
-  private:
-    /// \brief Get the last OpenSSL error as a string
-    static std::string lastError()
+private:
+  /// \brief Get the last OpenSSL error as a string
+  static std::string lastError()
+  {
+    unsigned long code = ERR_peek_last_error(); // NOLINT(google-runtime-int)
+    if (code == 0UL)
     {
-      unsigned long code = ERR_peek_last_error(); // NOLINT(google-runtime-int)
-      if (code == 0UL)
-      {
-        return "no OpenSSL error available";
-      }
-      char buf[256] = {0};
-      ERR_error_string_n(code, buf, sizeof(buf));
-      return std::string(buf);
+      return "no OpenSSL error available";
     }
-  };
+    char buf[256] = {0};
+    ERR_error_string_n(code, buf, sizeof(buf));
+    return std::string(buf);
+  }
+};
 
 } // namespace crypto
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/ids/uuid.hpp b/include/iora/ids/uuid.hpp
index 1a5665f..38ec554 100644
--- a/include/iora/ids/uuid.hpp
+++ b/include/iora/ids/uuid.hpp
@@ -8,9 +8,9 @@
 #pragma once
 
 #include <array>
+#include <chrono>
 #include <cstdint>
 #include <string>
-#include <chrono>
 
 #include "iora/crypto/secure_rng.hpp"
 
@@ -19,125 +19,129 @@ namespace iora
 namespace ids
 {
 
-  /// \brief UUID generator supporting v4 (random) and v7 (time-ordered) variants.
-  /// 
-  /// Generates RFC 4122 compliant UUIDs:
-  /// - v4: Fully random UUIDs for general use
-  /// - v7: Time-ordered UUIDs for sortable identifiers (draft RFC)
-  class Uuid
+/// \brief UUID generator supporting v4 (random) and v7 (time-ordered) variants.
+///
+/// Generates RFC 4122 compliant UUIDs:
+/// - v4: Fully random UUIDs for general use
+/// - v7: Time-ordered UUIDs for sortable identifiers (draft RFC)
+class Uuid
+{
+public:
+  /// \brief Generate a version 4 (random) UUID.
+  /// \return String representation of UUID (e.g., "550e8400-e29b-41d4-a716-446655440000")
+  static std::string v4()
   {
-  public:
-    /// \brief Generate a version 4 (random) UUID.
-    /// \return String representation of UUID (e.g., "550e8400-e29b-41d4-a716-446655440000")
-    static std::string v4()
-    {
-      std::array<std::uint8_t, 16> b{};
-      iora::crypto::SecureRng::fill(b);
-      
-      // Set version 4 (random)
-      b[6] = static_cast<std::uint8_t>((b[6] & 0x0F) | 0x40);
-      
-      // Set variant bits (10xx)
-      b[8] = static_cast<std::uint8_t>((b[8] & 0x3F) | 0x80);
-      
-      return toHexString(b);
-    }
+    std::array<std::uint8_t, 16> b{};
+    iora::crypto::SecureRng::fill(b);
 
-    /// \brief Generate a version 7 (time-ordered) UUID.
-    /// \return String representation of time-ordered UUID
-    /// 
-    /// Version 7 UUIDs contain a timestamp in the most significant bits,
-    /// making them naturally sortable by creation time while maintaining
-    /// sufficient randomness for uniqueness.
-    static std::string v7()
-    {
-      std::array<std::uint8_t, 16> b{};
-      
-      // Get current timestamp in milliseconds since Unix epoch
-      const auto now = std::chrono::time_point_cast<std::chrono::milliseconds>(
-        std::chrono::system_clock::now());
-      std::uint64_t ms = static_cast<std::uint64_t>(now.time_since_epoch().count());
-
-      // Pack timestamp into first 48 bits (6 bytes)
-      b[0] = static_cast<std::uint8_t>((ms >> 40) & 0xFF);
-      b[1] = static_cast<std::uint8_t>((ms >> 32) & 0xFF);
-      b[2] = static_cast<std::uint8_t>((ms >> 24) & 0xFF);
-      b[3] = static_cast<std::uint8_t>((ms >> 16) & 0xFF);
-      b[4] = static_cast<std::uint8_t>((ms >> 8) & 0xFF);
-      b[5] = static_cast<std::uint8_t>(ms & 0xFF);
-
-      // Fill remaining 10 bytes with random data directly
-      iora::crypto::SecureRng::fill(b.data() + 6, 10);
-
-      // Set version 7 (time-ordered)
-      b[6] = static_cast<std::uint8_t>((b[6] & 0x0F) | 0x70);
-      
-      // Set variant bits (10xx)
-      b[8] = static_cast<std::uint8_t>((b[8] & 0x3F) | 0x80);
-      
-      return toHexString(b);
-    }
+    // Set version 4 (random)
+    b[6] = static_cast<std::uint8_t>((b[6] & 0x0F) | 0x40);
+
+    // Set variant bits (10xx)
+    b[8] = static_cast<std::uint8_t>((b[8] & 0x3F) | 0x80);
+
+    return toHexString(b);
+  }
+
+  /// \brief Generate a version 7 (time-ordered) UUID.
+  /// \return String representation of time-ordered UUID
+  ///
+  /// Version 7 UUIDs contain a timestamp in the most significant bits,
+  /// making them naturally sortable by creation time while maintaining
+  /// sufficient randomness for uniqueness.
+  static std::string v7()
+  {
+    std::array<std::uint8_t, 16> b{};
+
+    // Get current timestamp in milliseconds since Unix epoch
+    const auto now =
+      std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::system_clock::now());
+    std::uint64_t ms = static_cast<std::uint64_t>(now.time_since_epoch().count());
+
+    // Pack timestamp into first 48 bits (6 bytes)
+    b[0] = static_cast<std::uint8_t>((ms >> 40) & 0xFF);
+    b[1] = static_cast<std::uint8_t>((ms >> 32) & 0xFF);
+    b[2] = static_cast<std::uint8_t>((ms >> 24) & 0xFF);
+    b[3] = static_cast<std::uint8_t>((ms >> 16) & 0xFF);
+    b[4] = static_cast<std::uint8_t>((ms >> 8) & 0xFF);
+    b[5] = static_cast<std::uint8_t>(ms & 0xFF);
+
+    // Fill remaining 10 bytes with random data directly
+    iora::crypto::SecureRng::fill(b.data() + 6, 10);
+
+    // Set version 7 (time-ordered)
+    b[6] = static_cast<std::uint8_t>((b[6] & 0x0F) | 0x70);
+
+    // Set variant bits (10xx)
+    b[8] = static_cast<std::uint8_t>((b[8] & 0x3F) | 0x80);
+
+    return toHexString(b);
+  }
+
+private:
+  /// \brief Convert 16-byte array to standard UUID string format.
+  /// \param b 16-byte UUID data
+  /// \return Formatted UUID string with hyphens
+  static std::string toHexString(const std::array<std::uint8_t, 16> &b)
+  {
+    // Pre-computed lookup table for byte-to-hex conversion (2 chars per byte)
+    static constexpr char kHexPairs[256][2] = {
+      {'0', '0'}, {'0', '1'}, {'0', '2'}, {'0', '3'}, {'0', '4'}, {'0', '5'}, {'0', '6'},
+      {'0', '7'}, {'0', '8'}, {'0', '9'}, {'0', 'a'}, {'0', 'b'}, {'0', 'c'}, {'0', 'd'},
+      {'0', 'e'}, {'0', 'f'}, {'1', '0'}, {'1', '1'}, {'1', '2'}, {'1', '3'}, {'1', '4'},
+      {'1', '5'}, {'1', '6'}, {'1', '7'}, {'1', '8'}, {'1', '9'}, {'1', 'a'}, {'1', 'b'},
+      {'1', 'c'}, {'1', 'd'}, {'1', 'e'}, {'1', 'f'}, {'2', '0'}, {'2', '1'}, {'2', '2'},
+      {'2', '3'}, {'2', '4'}, {'2', '5'}, {'2', '6'}, {'2', '7'}, {'2', '8'}, {'2', '9'},
+      {'2', 'a'}, {'2', 'b'}, {'2', 'c'}, {'2', 'd'}, {'2', 'e'}, {'2', 'f'}, {'3', '0'},
+      {'3', '1'}, {'3', '2'}, {'3', '3'}, {'3', '4'}, {'3', '5'}, {'3', '6'}, {'3', '7'},
+      {'3', '8'}, {'3', '9'}, {'3', 'a'}, {'3', 'b'}, {'3', 'c'}, {'3', 'd'}, {'3', 'e'},
+      {'3', 'f'}, {'4', '0'}, {'4', '1'}, {'4', '2'}, {'4', '3'}, {'4', '4'}, {'4', '5'},
+      {'4', '6'}, {'4', '7'}, {'4', '8'}, {'4', '9'}, {'4', 'a'}, {'4', 'b'}, {'4', 'c'},
+      {'4', 'd'}, {'4', 'e'}, {'4', 'f'}, {'5', '0'}, {'5', '1'}, {'5', '2'}, {'5', '3'},
+      {'5', '4'}, {'5', '5'}, {'5', '6'}, {'5', '7'}, {'5', '8'}, {'5', '9'}, {'5', 'a'},
+      {'5', 'b'}, {'5', 'c'}, {'5', 'd'}, {'5', 'e'}, {'5', 'f'}, {'6', '0'}, {'6', '1'},
+      {'6', '2'}, {'6', '3'}, {'6', '4'}, {'6', '5'}, {'6', '6'}, {'6', '7'}, {'6', '8'},
+      {'6', '9'}, {'6', 'a'}, {'6', 'b'}, {'6', 'c'}, {'6', 'd'}, {'6', 'e'}, {'6', 'f'},
+      {'7', '0'}, {'7', '1'}, {'7', '2'}, {'7', '3'}, {'7', '4'}, {'7', '5'}, {'7', '6'},
+      {'7', '7'}, {'7', '8'}, {'7', '9'}, {'7', 'a'}, {'7', 'b'}, {'7', 'c'}, {'7', 'd'},
+      {'7', 'e'}, {'7', 'f'}, {'8', '0'}, {'8', '1'}, {'8', '2'}, {'8', '3'}, {'8', '4'},
+      {'8', '5'}, {'8', '6'}, {'8', '7'}, {'8', '8'}, {'8', '9'}, {'8', 'a'}, {'8', 'b'},
+      {'8', 'c'}, {'8', 'd'}, {'8', 'e'}, {'8', 'f'}, {'9', '0'}, {'9', '1'}, {'9', '2'},
+      {'9', '3'}, {'9', '4'}, {'9', '5'}, {'9', '6'}, {'9', '7'}, {'9', '8'}, {'9', '9'},
+      {'9', 'a'}, {'9', 'b'}, {'9', 'c'}, {'9', 'd'}, {'9', 'e'}, {'9', 'f'}, {'a', '0'},
+      {'a', '1'}, {'a', '2'}, {'a', '3'}, {'a', '4'}, {'a', '5'}, {'a', '6'}, {'a', '7'},
+      {'a', '8'}, {'a', '9'}, {'a', 'a'}, {'a', 'b'}, {'a', 'c'}, {'a', 'd'}, {'a', 'e'},
+      {'a', 'f'}, {'b', '0'}, {'b', '1'}, {'b', '2'}, {'b', '3'}, {'b', '4'}, {'b', '5'},
+      {'b', '6'}, {'b', '7'}, {'b', '8'}, {'b', '9'}, {'b', 'a'}, {'b', 'b'}, {'b', 'c'},
+      {'b', 'd'}, {'b', 'e'}, {'b', 'f'}, {'c', '0'}, {'c', '1'}, {'c', '2'}, {'c', '3'},
+      {'c', '4'}, {'c', '5'}, {'c', '6'}, {'c', '7'}, {'c', '8'}, {'c', '9'}, {'c', 'a'},
+      {'c', 'b'}, {'c', 'c'}, {'c', 'd'}, {'c', 'e'}, {'c', 'f'}, {'d', '0'}, {'d', '1'},
+      {'d', '2'}, {'d', '3'}, {'d', '4'}, {'d', '5'}, {'d', '6'}, {'d', '7'}, {'d', '8'},
+      {'d', '9'}, {'d', 'a'}, {'d', 'b'}, {'d', 'c'}, {'d', 'd'}, {'d', 'e'}, {'d', 'f'},
+      {'e', '0'}, {'e', '1'}, {'e', '2'}, {'e', '3'}, {'e', '4'}, {'e', '5'}, {'e', '6'},
+      {'e', '7'}, {'e', '8'}, {'e', '9'}, {'e', 'a'}, {'e', 'b'}, {'e', 'c'}, {'e', 'd'},
+      {'e', 'e'}, {'e', 'f'}, {'f', '0'}, {'f', '1'}, {'f', '2'}, {'f', '3'}, {'f', '4'},
+      {'f', '5'}, {'f', '6'}, {'f', '7'}, {'f', '8'}, {'f', '9'}, {'f', 'a'}, {'f', 'b'},
+      {'f', 'c'}, {'f', 'd'}, {'f', 'e'}, {'f', 'f'}};
+
+    std::string s;
+    s.resize(36); // 32 hex chars + 4 hyphens
 
-  private:
-    /// \brief Convert 16-byte array to standard UUID string format.
-    /// \param b 16-byte UUID data
-    /// \return Formatted UUID string with hyphens
-    static std::string toHexString(const std::array<std::uint8_t, 16>& b)
+    int p = 0;
+    for (int i = 0; i < 16; ++i)
     {
-      // Pre-computed lookup table for byte-to-hex conversion (2 chars per byte)
-      static constexpr char kHexPairs[256][2] = {
-        {'0','0'}, {'0','1'}, {'0','2'}, {'0','3'}, {'0','4'}, {'0','5'}, {'0','6'}, {'0','7'},
-        {'0','8'}, {'0','9'}, {'0','a'}, {'0','b'}, {'0','c'}, {'0','d'}, {'0','e'}, {'0','f'},
-        {'1','0'}, {'1','1'}, {'1','2'}, {'1','3'}, {'1','4'}, {'1','5'}, {'1','6'}, {'1','7'},
-        {'1','8'}, {'1','9'}, {'1','a'}, {'1','b'}, {'1','c'}, {'1','d'}, {'1','e'}, {'1','f'},
-        {'2','0'}, {'2','1'}, {'2','2'}, {'2','3'}, {'2','4'}, {'2','5'}, {'2','6'}, {'2','7'},
-        {'2','8'}, {'2','9'}, {'2','a'}, {'2','b'}, {'2','c'}, {'2','d'}, {'2','e'}, {'2','f'},
-        {'3','0'}, {'3','1'}, {'3','2'}, {'3','3'}, {'3','4'}, {'3','5'}, {'3','6'}, {'3','7'},
-        {'3','8'}, {'3','9'}, {'3','a'}, {'3','b'}, {'3','c'}, {'3','d'}, {'3','e'}, {'3','f'},
-        {'4','0'}, {'4','1'}, {'4','2'}, {'4','3'}, {'4','4'}, {'4','5'}, {'4','6'}, {'4','7'},
-        {'4','8'}, {'4','9'}, {'4','a'}, {'4','b'}, {'4','c'}, {'4','d'}, {'4','e'}, {'4','f'},
-        {'5','0'}, {'5','1'}, {'5','2'}, {'5','3'}, {'5','4'}, {'5','5'}, {'5','6'}, {'5','7'},
-        {'5','8'}, {'5','9'}, {'5','a'}, {'5','b'}, {'5','c'}, {'5','d'}, {'5','e'}, {'5','f'},
-        {'6','0'}, {'6','1'}, {'6','2'}, {'6','3'}, {'6','4'}, {'6','5'}, {'6','6'}, {'6','7'},
-        {'6','8'}, {'6','9'}, {'6','a'}, {'6','b'}, {'6','c'}, {'6','d'}, {'6','e'}, {'6','f'},
-        {'7','0'}, {'7','1'}, {'7','2'}, {'7','3'}, {'7','4'}, {'7','5'}, {'7','6'}, {'7','7'},
-        {'7','8'}, {'7','9'}, {'7','a'}, {'7','b'}, {'7','c'}, {'7','d'}, {'7','e'}, {'7','f'},
-        {'8','0'}, {'8','1'}, {'8','2'}, {'8','3'}, {'8','4'}, {'8','5'}, {'8','6'}, {'8','7'},
-        {'8','8'}, {'8','9'}, {'8','a'}, {'8','b'}, {'8','c'}, {'8','d'}, {'8','e'}, {'8','f'},
-        {'9','0'}, {'9','1'}, {'9','2'}, {'9','3'}, {'9','4'}, {'9','5'}, {'9','6'}, {'9','7'},
-        {'9','8'}, {'9','9'}, {'9','a'}, {'9','b'}, {'9','c'}, {'9','d'}, {'9','e'}, {'9','f'},
-        {'a','0'}, {'a','1'}, {'a','2'}, {'a','3'}, {'a','4'}, {'a','5'}, {'a','6'}, {'a','7'},
-        {'a','8'}, {'a','9'}, {'a','a'}, {'a','b'}, {'a','c'}, {'a','d'}, {'a','e'}, {'a','f'},
-        {'b','0'}, {'b','1'}, {'b','2'}, {'b','3'}, {'b','4'}, {'b','5'}, {'b','6'}, {'b','7'},
-        {'b','8'}, {'b','9'}, {'b','a'}, {'b','b'}, {'b','c'}, {'b','d'}, {'b','e'}, {'b','f'},
-        {'c','0'}, {'c','1'}, {'c','2'}, {'c','3'}, {'c','4'}, {'c','5'}, {'c','6'}, {'c','7'},
-        {'c','8'}, {'c','9'}, {'c','a'}, {'c','b'}, {'c','c'}, {'c','d'}, {'c','e'}, {'c','f'},
-        {'d','0'}, {'d','1'}, {'d','2'}, {'d','3'}, {'d','4'}, {'d','5'}, {'d','6'}, {'d','7'},
-        {'d','8'}, {'d','9'}, {'d','a'}, {'d','b'}, {'d','c'}, {'d','d'}, {'d','e'}, {'d','f'},
-        {'e','0'}, {'e','1'}, {'e','2'}, {'e','3'}, {'e','4'}, {'e','5'}, {'e','6'}, {'e','7'},
-        {'e','8'}, {'e','9'}, {'e','a'}, {'e','b'}, {'e','c'}, {'e','d'}, {'e','e'}, {'e','f'},
-        {'f','0'}, {'f','1'}, {'f','2'}, {'f','3'}, {'f','4'}, {'f','5'}, {'f','6'}, {'f','7'},
-        {'f','8'}, {'f','9'}, {'f','a'}, {'f','b'}, {'f','c'}, {'f','d'}, {'f','e'}, {'f','f'}
-      };
-      
-      std::string s;
-      s.resize(36); // 32 hex chars + 4 hyphens
-      
-      int p = 0;
-      for (int i = 0; i < 16; ++i)
+      // Insert hyphens at standard positions
+      if (i == 4 || i == 6 || i == 8 || i == 10)
       {
-        // Insert hyphens at standard positions
-        if (i == 4 || i == 6 || i == 8 || i == 10)
-        {
-          s[p++] = '-';
-        }
-        const auto& hex = kHexPairs[b[i]];
-        s[p++] = hex[0];
-        s[p++] = hex[1];
+        s[p++] = '-';
       }
-      return s;
+      const auto &hex = kHexPairs[b[i]];
+      s[p++] = hex[0];
+      s[p++] = hex[1];
     }
-  };
+    return s;
+  }
+};
 
 } // namespace ids
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/iora.hpp b/include/iora/iora.hpp
index e7e4560..d12a928 100644
--- a/include/iora/iora.hpp
+++ b/include/iora/iora.hpp
@@ -1213,7 +1213,7 @@ protected:
   }
 
   /// \brief Registers a dependency relationship assuming the mutex is already held
-  /// \param dependent The module that depends on another module  
+  /// \param dependent The module that depends on another module
   /// \param dependency The module that the dependent module requires
   /// \note PRECONDITION: Caller must hold _loadModulesMutex
   void registerDependencyLocked(const std::string &dependent, const std::string &dependency)
@@ -1228,7 +1228,7 @@ protected:
       assert(false && "registerDependencyLocked called without holding _loadModulesMutex");
     }
 #endif
-    
+
     _dependents[dependency].push_back(dependent);
 
     // Don't use [] operator as it creates entries - use find instead
@@ -1649,7 +1649,7 @@ inline void IoraService::Plugin::require(const std::string &moduleName)
   }
 
   // Register this dependency relationship for tracking
-  // Use locked version since we're called from onLoad() which is called from loadSingleModule() 
+  // Use locked version since we're called from onLoad() which is called from loadSingleModule()
   // which already holds _loadModulesMutex
   _service->registerDependencyLocked(_name, moduleName);
 
diff --git a/include/iora/network/circuit_breaker.hpp b/include/iora/network/circuit_breaker.hpp
index 9ca2509..c88f8d5 100644
--- a/include/iora/network/circuit_breaker.hpp
+++ b/include/iora/network/circuit_breaker.hpp
@@ -6,298 +6,273 @@
 
 #pragma once
 
-#include <chrono>
 #include <atomic>
-#include <mutex>
+#include <chrono>
 #include <functional>
+#include <memory>
+#include <mutex>
 
 namespace iora
 {
 namespace network
 {
 
-  struct CircuitBreakerConfig
-  {
-    int failureThreshold{5};          // Failures to trigger open state
-    std::chrono::seconds timeout{60}; // Time to wait before trying again
-    int successThreshold{3};          // Successes needed to close circuit
-    std::chrono::seconds statisticsWindow{
-        300};                         // Window for calculating failure rate
-    double failureRateThreshold{0.5}; // Failure rate (0.0-1.0) to trigger open
-    int minimumRequests{10}; // Minimum requests before considering failure rate
-  };
+struct CircuitBreakerConfig
+{
+  int failureThreshold{5};                    // Failures to trigger open state
+  std::chrono::seconds timeout{60};           // Time to wait before trying again
+  int successThreshold{3};                    // Successes needed to close circuit
+  std::chrono::seconds statisticsWindow{300}; // Window for calculating failure rate
+  double failureRateThreshold{0.5};           // Failure rate (0.0-1.0) to trigger open
+  int minimumRequests{10};                    // Minimum requests before considering failure rate
+};
+
+enum class CircuitBreakerState
+{
+  Closed,  // Normal operation
+  Open,    // Failing fast, not allowing requests
+  HalfOpen // Testing if service has recovered
+};
 
-  enum class CircuitBreakerState
+class CircuitBreaker
+{
+public:
+  explicit CircuitBreaker(const CircuitBreakerConfig &config = {})
+      : config_(config), state_(CircuitBreakerState::Closed), failureCount_(0), successCount_(0),
+        lastFailureTime_(std::chrono::steady_clock::time_point{}), requestCount_(0)
   {
-    Closed,  // Normal operation
-    Open,    // Failing fast, not allowing requests
-    HalfOpen // Testing if service has recovered
-  };
+  }
 
-  class CircuitBreaker
+  // Check if request should be allowed
+  bool allowRequest()
   {
-  public:
-    explicit CircuitBreaker(const CircuitBreakerConfig& config = {})
-      : config_(config),
-        state_(CircuitBreakerState::Closed),
-        failureCount_(0),
-        successCount_(0),
-        lastFailureTime_(std::chrono::steady_clock::time_point{}),
-        requestCount_(0)
-    {
-    }
+    auto now = std::chrono::steady_clock::now();
 
-    // Check if request should be allowed
-    bool allowRequest()
+    switch (state_.load(std::memory_order_relaxed))
     {
-      auto now = std::chrono::steady_clock::now();
+    case CircuitBreakerState::Closed:
+      return true;
 
-      switch (state_.load(std::memory_order_relaxed))
-      {
-      case CircuitBreakerState::Closed:
-        return true;
-
-      case CircuitBreakerState::Open:
+    case CircuitBreakerState::Open:
+    {
+      auto lastFailure = lastFailureTime_.load(std::memory_order_relaxed);
+      if (now - lastFailure >= config_.timeout)
       {
-        auto lastFailure = lastFailureTime_.load(std::memory_order_relaxed);
-        if (now - lastFailure >= config_.timeout)
+        // Transition to half-open
+        auto expected = CircuitBreakerState::Open;
+        if (state_.compare_exchange_strong(expected, CircuitBreakerState::HalfOpen,
+                                           std::memory_order_relaxed))
         {
-          // Transition to half-open
-          auto expected = CircuitBreakerState::Open;
-          if (state_.compare_exchange_strong(expected,
-                                             CircuitBreakerState::HalfOpen,
-                                             std::memory_order_relaxed))
-          {
-            successCount_.store(0, std::memory_order_relaxed);
-          }
-          return true;
+          successCount_.store(0, std::memory_order_relaxed);
         }
-        return false;
+        return true;
       }
+      return false;
+    }
 
-      case CircuitBreakerState::HalfOpen:
-        // Allow limited requests to test recovery
-        return true;
+    case CircuitBreakerState::HalfOpen:
+      // Allow limited requests to test recovery
+      return true;
 
-      default:
-        return false;
-      }
+    default:
+      return false;
     }
+  }
 
-    void recordSuccess()
-    {
-      requestCount_.fetch_add(1, std::memory_order_relaxed);
+  void recordSuccess()
+  {
+    requestCount_.fetch_add(1, std::memory_order_relaxed);
 
-      auto currentState = state_.load(std::memory_order_relaxed);
+    auto currentState = state_.load(std::memory_order_relaxed);
 
-      if (currentState == CircuitBreakerState::HalfOpen)
-      {
-        int successes =
-            successCount_.fetch_add(1, std::memory_order_relaxed) + 1;
-        if (successes >= config_.successThreshold)
-        {
-          // Circuit recovered, close it
-          state_.store(CircuitBreakerState::Closed, std::memory_order_relaxed);
-          failureCount_.store(0, std::memory_order_relaxed);
-          successCount_.store(0, std::memory_order_relaxed);
-        }
-      }
-      else if (currentState == CircuitBreakerState::Closed)
+    if (currentState == CircuitBreakerState::HalfOpen)
+    {
+      int successes = successCount_.fetch_add(1, std::memory_order_relaxed) + 1;
+      if (successes >= config_.successThreshold)
       {
-        // Reset failure count on success
+        // Circuit recovered, close it
+        state_.store(CircuitBreakerState::Closed, std::memory_order_relaxed);
         failureCount_.store(0, std::memory_order_relaxed);
+        successCount_.store(0, std::memory_order_relaxed);
       }
     }
-
-    void recordFailure()
+    else if (currentState == CircuitBreakerState::Closed)
     {
-      requestCount_.fetch_add(1, std::memory_order_relaxed);
+      // Reset failure count on success
+      failureCount_.store(0, std::memory_order_relaxed);
+    }
+  }
+
+  void recordFailure()
+  {
+    requestCount_.fetch_add(1, std::memory_order_relaxed);
 
-      auto now = std::chrono::steady_clock::now();
-      lastFailureTime_.store(now, std::memory_order_relaxed);
+    auto now = std::chrono::steady_clock::now();
+    lastFailureTime_.store(now, std::memory_order_relaxed);
 
-      int failures = failureCount_.fetch_add(1, std::memory_order_relaxed) + 1;
+    int failures = failureCount_.fetch_add(1, std::memory_order_relaxed) + 1;
 
-      auto currentState = state_.load(std::memory_order_relaxed);
+    auto currentState = state_.load(std::memory_order_relaxed);
 
-      if (currentState == CircuitBreakerState::HalfOpen)
+    if (currentState == CircuitBreakerState::HalfOpen)
+    {
+      // Failed during testing, go back to open
+      state_.store(CircuitBreakerState::Open, std::memory_order_relaxed);
+      successCount_.store(0, std::memory_order_relaxed);
+    }
+    else if (currentState == CircuitBreakerState::Closed)
+    {
+      // Check if we should open the circuit
+      if (shouldOpenCircuit(failures))
       {
-        // Failed during testing, go back to open
         state_.store(CircuitBreakerState::Open, std::memory_order_relaxed);
-        successCount_.store(0, std::memory_order_relaxed);
-      }
-      else if (currentState == CircuitBreakerState::Closed)
-      {
-        // Check if we should open the circuit
-        if (shouldOpenCircuit(failures))
-        {
-          state_.store(CircuitBreakerState::Open, std::memory_order_relaxed);
-        }
       }
     }
+  }
 
-    CircuitBreakerState getState() const
-    {
-      return state_.load(std::memory_order_relaxed);
-    }
+  CircuitBreakerState getState() const { return state_.load(std::memory_order_relaxed); }
 
-    struct Stats
-    {
-      CircuitBreakerState state;
-      int failureCount;
-      int successCount;
-      std::uint64_t totalRequests;
-      std::chrono::milliseconds timeSinceLastFailure;
-      double failureRate;
-    };
-
-    Stats getStats() const
+  struct Stats
+  {
+    CircuitBreakerState state;
+    int failureCount;
+    int successCount;
+    std::uint64_t totalRequests;
+    std::chrono::milliseconds timeSinceLastFailure;
+    double failureRate;
+  };
+
+  Stats getStats() const
+  {
+    auto now = std::chrono::steady_clock::now();
+    auto lastFailure = lastFailureTime_.load(std::memory_order_relaxed);
+    auto failures = failureCount_.load(std::memory_order_relaxed);
+    auto requests = requestCount_.load(std::memory_order_relaxed);
+
+    return {state_.load(std::memory_order_relaxed),
+            failures,
+            successCount_.load(std::memory_order_relaxed),
+            requests,
+            std::chrono::duration_cast<std::chrono::milliseconds>(now - lastFailure),
+            requests > 0 ? static_cast<double>(failures) / requests : 0.0};
+  }
+
+  void updateConfig(const CircuitBreakerConfig &config) { config_ = config; }
+
+  void reset()
+  {
+    state_.store(CircuitBreakerState::Closed, std::memory_order_relaxed);
+    failureCount_.store(0, std::memory_order_relaxed);
+    successCount_.store(0, std::memory_order_relaxed);
+    requestCount_.store(0, std::memory_order_relaxed);
+    lastFailureTime_.store(std::chrono::steady_clock::time_point{}, std::memory_order_relaxed);
+  }
+
+private:
+  bool shouldOpenCircuit(int failures) const
+  {
+    // Simple threshold-based check
+    if (failures >= config_.failureThreshold)
     {
-      auto now = std::chrono::steady_clock::now();
-      auto lastFailure = lastFailureTime_.load(std::memory_order_relaxed);
-      auto failures = failureCount_.load(std::memory_order_relaxed);
-      auto requests = requestCount_.load(std::memory_order_relaxed);
-
-      return {state_.load(std::memory_order_relaxed),
-              failures,
-              successCount_.load(std::memory_order_relaxed),
-              requests,
-              std::chrono::duration_cast<std::chrono::milliseconds>(
-                  now - lastFailure),
-              requests > 0 ? static_cast<double>(failures) / requests : 0.0};
+      return true;
     }
 
-    void updateConfig(const CircuitBreakerConfig& config) { config_ = config; }
-
-    void reset()
+    // Failure rate based check
+    auto requests = requestCount_.load(std::memory_order_relaxed);
+    if (static_cast<int>(requests) >= config_.minimumRequests)
     {
-      state_.store(CircuitBreakerState::Closed, std::memory_order_relaxed);
-      failureCount_.store(0, std::memory_order_relaxed);
-      successCount_.store(0, std::memory_order_relaxed);
-      requestCount_.store(0, std::memory_order_relaxed);
-      lastFailureTime_.store(std::chrono::steady_clock::time_point{},
-                             std::memory_order_relaxed);
+      double failureRate = static_cast<double>(failures) / requests;
+      return failureRate >= config_.failureRateThreshold;
     }
 
-  private:
-    bool shouldOpenCircuit(int failures) const
-    {
-      // Simple threshold-based check
-      if (failures >= config_.failureThreshold)
-      {
-        return true;
-      }
+    return false;
+  }
 
-      // Failure rate based check
-      auto requests = requestCount_.load(std::memory_order_relaxed);
-      if (static_cast<int>(requests) >= config_.minimumRequests)
-      {
-        double failureRate = static_cast<double>(failures) / requests;
-        return failureRate >= config_.failureRateThreshold;
-      }
+private:
+  CircuitBreakerConfig config_;
+  std::atomic<CircuitBreakerState> state_;
+  std::atomic<int> failureCount_;
+  std::atomic<int> successCount_;
+  std::atomic<std::chrono::steady_clock::time_point> lastFailureTime_;
+  std::atomic<std::uint64_t> requestCount_;
+};
 
-      return false;
-    }
+// Circuit breaker manager for different operations/endpoints
+class CircuitBreakerManager
+{
+public:
+  using BreakerFactory = std::function<std::unique_ptr<CircuitBreaker>()>;
 
-  private:
-    CircuitBreakerConfig config_;
-    std::atomic<CircuitBreakerState> state_;
-    std::atomic<int> failureCount_;
-    std::atomic<int> successCount_;
-    std::atomic<std::chrono::steady_clock::time_point> lastFailureTime_;
-    std::atomic<std::uint64_t> requestCount_;
-  };
+  explicit CircuitBreakerManager(BreakerFactory factory = nullptr)
+      : factory_(factory ? std::move(factory) : []() { return std::make_unique<CircuitBreaker>(); })
+  {
+  }
 
-  // Circuit breaker manager for different operations/endpoints
-  class CircuitBreakerManager
+  CircuitBreaker &getBreaker(const std::string &name)
   {
-  public:
-    using BreakerFactory = std::function<std::unique_ptr<CircuitBreaker>()>;
+    std::lock_guard<std::mutex> lock(mutex_);
 
-    explicit CircuitBreakerManager(BreakerFactory factory = nullptr)
-      : factory_(factory ? std::move(factory)
-                         : []() { return std::make_unique<CircuitBreaker>(); })
+    auto it = breakers_.find(name);
+    if (it == breakers_.end())
     {
+      auto [inserted, success] = breakers_.emplace(name, factory_());
+      return *inserted->second;
     }
 
-    CircuitBreaker& getBreaker(const std::string& name)
-    {
-      std::lock_guard<std::mutex> lock(mutex_);
+    return *it->second;
+  }
 
-      auto it = breakers_.find(name);
-      if (it == breakers_.end())
-      {
-        auto [inserted, success] = breakers_.emplace(name, factory_());
-        return *inserted->second;
-      }
+  bool allowRequest(const std::string &name) { return getBreaker(name).allowRequest(); }
 
-      return *it->second;
-    }
+  void recordSuccess(const std::string &name) { getBreaker(name).recordSuccess(); }
 
-    bool allowRequest(const std::string& name)
-    {
-      return getBreaker(name).allowRequest();
-    }
+  void recordFailure(const std::string &name) { getBreaker(name).recordFailure(); }
 
-    void recordSuccess(const std::string& name)
-    {
-      getBreaker(name).recordSuccess();
-    }
+  CircuitBreakerState getState(const std::string &name) { return getBreaker(name).getState(); }
 
-    void recordFailure(const std::string& name)
-    {
-      getBreaker(name).recordFailure();
-    }
+  void updateConfig(const std::string &name, const CircuitBreakerConfig &config)
+  {
+    getBreaker(name).updateConfig(config);
+  }
 
-    CircuitBreakerState getState(const std::string& name)
+  void updateAllConfigs(const CircuitBreakerConfig &config)
+  {
+    std::lock_guard<std::mutex> lock(mutex_);
+    for (auto &[name, breaker] : breakers_)
     {
-      return getBreaker(name).getState();
+      breaker->updateConfig(config);
     }
+  }
 
-    void updateConfig(const std::string& name,
-                      const CircuitBreakerConfig& config)
-    {
-      getBreaker(name).updateConfig(config);
-    }
+  std::vector<std::string> getBreakerNames() const
+  {
+    std::vector<std::string> names;
+    std::lock_guard<std::mutex> lock(mutex_);
 
-    void updateAllConfigs(const CircuitBreakerConfig& config)
+    for (const auto &[name, breaker] : breakers_)
     {
-      std::lock_guard<std::mutex> lock(mutex_);
-      for (auto& [name, breaker] : breakers_)
-      {
-        breaker->updateConfig(config);
-      }
+      names.push_back(name);
     }
 
-    std::vector<std::string> getBreakerNames() const
-    {
-      std::vector<std::string> names;
-      std::lock_guard<std::mutex> lock(mutex_);
-
-      for (const auto& [name, breaker] : breakers_)
-      {
-        names.push_back(name);
-      }
-
-      return names;
-    }
+    return names;
+  }
 
-    void reset(const std::string& name) { getBreaker(name).reset(); }
+  void reset(const std::string &name) { getBreaker(name).reset(); }
 
-    void resetAll()
+  void resetAll()
+  {
+    std::lock_guard<std::mutex> lock(mutex_);
+    for (auto &[name, breaker] : breakers_)
     {
-      std::lock_guard<std::mutex> lock(mutex_);
-      for (auto& [name, breaker] : breakers_)
-      {
-        breaker->reset();
-      }
+      breaker->reset();
     }
+  }
 
-  private:
-    mutable std::mutex mutex_;
-    std::unordered_map<std::string, std::unique_ptr<CircuitBreaker>> breakers_;
-    BreakerFactory factory_;
-  };
+private:
+  mutable std::mutex mutex_;
+  std::unordered_map<std::string, std::unique_ptr<CircuitBreaker>> breakers_;
+  BreakerFactory factory_;
+};
 
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/connection_health.hpp b/include/iora/network/connection_health.hpp
index fe92fe8..cc2447b 100644
--- a/include/iora/network/connection_health.hpp
+++ b/include/iora/network/connection_health.hpp
@@ -7,325 +7,316 @@
 
 #pragma once
 
-#include <chrono>
+#include "transport_types.hpp"
 #include <atomic>
+#include <chrono>
 #include <mutex>
 #include <unordered_map>
-#include "transport_types.hpp"
 
 namespace iora
 {
 namespace network
 {
 
-  struct HealthConfig
-  {
-    std::chrono::seconds heartbeatInterval{30};
-    std::chrono::seconds timeoutThreshold{90};
-    int maxConsecutiveFailures{3};
-    bool enableHeartbeat{true};
-  };
+struct HealthConfig
+{
+  std::chrono::seconds heartbeatInterval{30};
+  std::chrono::seconds timeoutThreshold{90};
+  int maxConsecutiveFailures{3};
+  bool enableHeartbeat{true};
+};
 
-  enum class ConnectionState
+enum class ConnectionState
+{
+  Healthy,
+  Warning,  // Some issues detected
+  Degraded, // Consistent problems
+  Critical, // Frequent failures
+  Unhealthy // Should be closed
+};
+
+class ConnectionHealth
+{
+public:
+  explicit ConnectionHealth(const HealthConfig &config = {})
+      : config_(config), lastActivity_(std::chrono::steady_clock::now()), consecutiveFailures_(0),
+        state_(ConnectionState::Healthy)
   {
-    Healthy,
-    Warning,  // Some issues detected
-    Degraded, // Consistent problems
-    Critical, // Frequent failures
-    Unhealthy // Should be closed
-  };
+  }
 
-  class ConnectionHealth
+  void recordActivity()
   {
-  public:
-    explicit ConnectionHealth(const HealthConfig& config = {})
-      : config_(config),
-        lastActivity_(std::chrono::steady_clock::now()),
-        consecutiveFailures_(0),
-        state_(ConnectionState::Healthy)
-    {
-    }
+    lastActivity_.store(std::chrono::steady_clock::now(), std::memory_order_relaxed);
 
-    void recordActivity()
+    // Reset failure count on successful activity
+    if (consecutiveFailures_.load(std::memory_order_relaxed) > 0)
     {
-      lastActivity_.store(std::chrono::steady_clock::now(),
-                          std::memory_order_relaxed);
-
-      // Reset failure count on successful activity
-      if (consecutiveFailures_.load(std::memory_order_relaxed) > 0)
-      {
-        consecutiveFailures_.store(0, std::memory_order_relaxed);
-        updateState();
-      }
+      consecutiveFailures_.store(0, std::memory_order_relaxed);
+      updateState();
     }
+  }
 
-    void recordFailure()
+  void recordFailure()
+  {
+    consecutiveFailures_.fetch_add(1, std::memory_order_relaxed);
+    totalFailures_.fetch_add(1, std::memory_order_relaxed);
+    updateState();
+  }
+
+  void recordSuccess()
+  {
+    totalSuccesses_.fetch_add(1, std::memory_order_relaxed);
+    // Decrease consecutive failures on success
+    int current = consecutiveFailures_.load(std::memory_order_relaxed);
+    if (current > 0)
     {
-      consecutiveFailures_.fetch_add(1, std::memory_order_relaxed);
-      totalFailures_.fetch_add(1, std::memory_order_relaxed);
+      consecutiveFailures_.compare_exchange_weak(current, std::max(0, current - 1),
+                                                 std::memory_order_relaxed);
       updateState();
     }
+  }
 
-    void recordSuccess()
-    {
-      totalSuccesses_.fetch_add(1, std::memory_order_relaxed);
-      // Decrease consecutive failures on success
-      int current = consecutiveFailures_.load(std::memory_order_relaxed);
-      if (current > 0)
-      {
-        consecutiveFailures_.compare_exchange_weak(
-            current, std::max(0, current - 1), std::memory_order_relaxed);
-        updateState();
-      }
-    }
+  bool isHealthy() const
+  {
+    return state_.load(std::memory_order_relaxed) <= ConnectionState::Warning;
+  }
 
-    bool isHealthy() const
-    {
-      return state_.load(std::memory_order_relaxed) <= ConnectionState::Warning;
-    }
+  ConnectionState getState() const { return state_.load(std::memory_order_relaxed); }
 
-    ConnectionState getState() const
-    {
-      return state_.load(std::memory_order_relaxed);
-    }
+  bool needsHeartbeat() const
+  {
+    if (!config_.enableHeartbeat)
+      return false;
 
-    bool needsHeartbeat() const
-    {
-      if (!config_.enableHeartbeat)
-        return false;
+    auto now = std::chrono::steady_clock::now();
+    auto lastActivity = lastActivity_.load(std::memory_order_relaxed);
 
-      auto now = std::chrono::steady_clock::now();
-      auto lastActivity = lastActivity_.load(std::memory_order_relaxed);
+    return (now - lastActivity) >= config_.heartbeatInterval;
+  }
 
-      return (now - lastActivity) >= config_.heartbeatInterval;
-    }
+  bool isTimedOut() const
+  {
+    auto now = std::chrono::steady_clock::now();
+    auto lastActivity = lastActivity_.load(std::memory_order_relaxed);
 
-    bool isTimedOut() const
-    {
-      auto now = std::chrono::steady_clock::now();
-      auto lastActivity = lastActivity_.load(std::memory_order_relaxed);
+    return (now - lastActivity) >= config_.timeoutThreshold;
+  }
 
-      return (now - lastActivity) >= config_.timeoutThreshold;
-    }
+  struct Stats
+  {
+    ConnectionState state;
+    int consecutiveFailures;
+    std::uint64_t totalSuccesses;
+    std::uint64_t totalFailures;
+    std::chrono::milliseconds timeSinceLastActivity;
+    double successRate; // 0.0 to 1.0
+  };
+
+  Stats getStats() const
+  {
+    auto now = std::chrono::steady_clock::now();
+    auto lastActivity = lastActivity_.load(std::memory_order_relaxed);
+    auto successes = totalSuccesses_.load(std::memory_order_relaxed);
+    auto failures = totalFailures_.load(std::memory_order_relaxed);
+    auto total = successes + failures;
+
+    return {state_.load(std::memory_order_relaxed),
+            consecutiveFailures_.load(std::memory_order_relaxed),
+            successes,
+            failures,
+            std::chrono::duration_cast<std::chrono::milliseconds>(now - lastActivity),
+            total > 0 ? static_cast<double>(successes) / total : 1.0};
+  }
+
+  void updateConfig(const HealthConfig &config) { config_ = config; }
+
+private:
+  void updateState()
+  {
+    int failures = consecutiveFailures_.load(std::memory_order_relaxed);
+    ConnectionState newState;
 
-    struct Stats
+    if (failures == 0)
+    {
+      newState = ConnectionState::Healthy;
+    }
+    else if (failures == 1)
     {
-      ConnectionState state;
-      int consecutiveFailures;
-      std::uint64_t totalSuccesses;
-      std::uint64_t totalFailures;
-      std::chrono::milliseconds timeSinceLastActivity;
-      double successRate; // 0.0 to 1.0
-    };
-
-    Stats getStats() const
+      newState = ConnectionState::Warning;
+    }
+    else if (failures < config_.maxConsecutiveFailures)
     {
-      auto now = std::chrono::steady_clock::now();
-      auto lastActivity = lastActivity_.load(std::memory_order_relaxed);
-      auto successes = totalSuccesses_.load(std::memory_order_relaxed);
-      auto failures = totalFailures_.load(std::memory_order_relaxed);
-      auto total = successes + failures;
-
-      return {state_.load(std::memory_order_relaxed),
-              consecutiveFailures_.load(std::memory_order_relaxed),
-              successes,
-              failures,
-              std::chrono::duration_cast<std::chrono::milliseconds>(
-                  now - lastActivity),
-              total > 0 ? static_cast<double>(successes) / total : 1.0};
+      newState = ConnectionState::Degraded;
     }
-
-    void updateConfig(const HealthConfig& config) { config_ = config; }
-
-  private:
-    void updateState()
+    else if (failures == config_.maxConsecutiveFailures)
+    {
+      newState = ConnectionState::Critical;
+    }
+    else
     {
-      int failures = consecutiveFailures_.load(std::memory_order_relaxed);
-      ConnectionState newState;
+      newState = ConnectionState::Unhealthy;
+    }
 
-      if (failures == 0)
-      {
-        newState = ConnectionState::Healthy;
-      }
-      else if (failures == 1)
-      {
-        newState = ConnectionState::Warning;
-      }
-      else if (failures < config_.maxConsecutiveFailures)
-      {
-        newState = ConnectionState::Degraded;
-      }
-      else if (failures == config_.maxConsecutiveFailures)
-      {
-        newState = ConnectionState::Critical;
-      }
-      else
-      {
-        newState = ConnectionState::Unhealthy;
-      }
+    state_.store(newState, std::memory_order_relaxed);
+  }
 
-      state_.store(newState, std::memory_order_relaxed);
-    }
+private:
+  HealthConfig config_;
+  std::atomic<std::chrono::steady_clock::time_point> lastActivity_;
+  std::atomic<int> consecutiveFailures_;
+  std::atomic<std::uint64_t> totalSuccesses_{0};
+  std::atomic<std::uint64_t> totalFailures_{0};
+  std::atomic<ConnectionState> state_;
+};
 
-  private:
-    HealthConfig config_;
-    std::atomic<std::chrono::steady_clock::time_point> lastActivity_;
-    std::atomic<int> consecutiveFailures_;
-    std::atomic<std::uint64_t> totalSuccesses_{0};
-    std::atomic<std::uint64_t> totalFailures_{0};
-    std::atomic<ConnectionState> state_;
-  };
+// Health monitor for managing multiple connections
+class HealthMonitor
+{
+public:
+  explicit HealthMonitor(const HealthConfig &config = {}) : config_(config) {}
 
-  // Health monitor for managing multiple connections
-  class HealthMonitor
+  void addConnection(SessionId id)
   {
-  public:
-    explicit HealthMonitor(const HealthConfig& config = {}) : config_(config) {}
+    std::lock_guard<std::mutex> lock(mutex_);
+    connections_[id] = std::make_unique<ConnectionHealth>(config_);
+  }
 
-    void addConnection(SessionId id)
-    {
-      std::lock_guard<std::mutex> lock(mutex_);
-      connections_[id] = std::make_unique<ConnectionHealth>(config_);
-    }
+  void removeConnection(SessionId id)
+  {
+    std::lock_guard<std::mutex> lock(mutex_);
+    connections_.erase(id);
+  }
 
-    void removeConnection(SessionId id)
+  void recordActivity(SessionId id)
+  {
+    std::lock_guard<std::mutex> lock(mutex_);
+    auto it = connections_.find(id);
+    if (it != connections_.end())
     {
-      std::lock_guard<std::mutex> lock(mutex_);
-      connections_.erase(id);
+      it->second->recordActivity();
     }
+  }
 
-    void recordActivity(SessionId id)
+  void recordFailure(SessionId id)
+  {
+    std::lock_guard<std::mutex> lock(mutex_);
+    auto it = connections_.find(id);
+    if (it != connections_.end())
     {
-      std::lock_guard<std::mutex> lock(mutex_);
-      auto it = connections_.find(id);
-      if (it != connections_.end())
-      {
-        it->second->recordActivity();
-      }
+      it->second->recordFailure();
     }
+  }
 
-    void recordFailure(SessionId id)
+  void recordSuccess(SessionId id)
+  {
+    std::lock_guard<std::mutex> lock(mutex_);
+    auto it = connections_.find(id);
+    if (it != connections_.end())
     {
-      std::lock_guard<std::mutex> lock(mutex_);
-      auto it = connections_.find(id);
-      if (it != connections_.end())
-      {
-        it->second->recordFailure();
-      }
+      it->second->recordSuccess();
     }
+  }
 
-    void recordSuccess(SessionId id)
+  std::vector<SessionId> getUnhealthyConnections() const
+  {
+    std::vector<SessionId> unhealthy;
+    std::lock_guard<std::mutex> lock(mutex_);
+
+    for (const auto &[id, health] : connections_)
     {
-      std::lock_guard<std::mutex> lock(mutex_);
-      auto it = connections_.find(id);
-      if (it != connections_.end())
+      if (!health->isHealthy())
       {
-        it->second->recordSuccess();
+        unhealthy.push_back(id);
       }
     }
 
-    std::vector<SessionId> getUnhealthyConnections() const
-    {
-      std::vector<SessionId> unhealthy;
-      std::lock_guard<std::mutex> lock(mutex_);
+    return unhealthy;
+  }
 
-      for (const auto& [id, health] : connections_)
+  std::vector<SessionId> getConnectionsNeedingHeartbeat() const
+  {
+    std::vector<SessionId> needHeartbeat;
+    std::lock_guard<std::mutex> lock(mutex_);
+
+    for (const auto &[id, health] : connections_)
+    {
+      if (health->needsHeartbeat())
       {
-        if (!health->isHealthy())
-        {
-          unhealthy.push_back(id);
-        }
+        needHeartbeat.push_back(id);
       }
-
-      return unhealthy;
     }
 
-    std::vector<SessionId> getConnectionsNeedingHeartbeat() const
-    {
-      std::vector<SessionId> needHeartbeat;
-      std::lock_guard<std::mutex> lock(mutex_);
+    return needHeartbeat;
+  }
 
-      for (const auto& [id, health] : connections_)
-      {
-        if (health->needsHeartbeat())
-        {
-          needHeartbeat.push_back(id);
-        }
-      }
+  struct OverallStats
+  {
+    std::size_t totalConnections;
+    std::size_t healthyConnections;
+    std::size_t warningConnections;
+    std::size_t degradedConnections;
+    std::size_t criticalConnections;
+    std::size_t unhealthyConnections;
+    double overallSuccessRate;
+  };
 
-      return needHeartbeat;
-    }
+  OverallStats getOverallStats() const
+  {
+    std::lock_guard<std::mutex> lock(mutex_);
 
-    struct OverallStats
-    {
-      std::size_t totalConnections;
-      std::size_t healthyConnections;
-      std::size_t warningConnections;
-      std::size_t degradedConnections;
-      std::size_t criticalConnections;
-      std::size_t unhealthyConnections;
-      double overallSuccessRate;
-    };
-
-    OverallStats getOverallStats() const
-    {
-      std::lock_guard<std::mutex> lock(mutex_);
+    OverallStats stats{};
+    stats.totalConnections = connections_.size();
 
-      OverallStats stats{};
-      stats.totalConnections = connections_.size();
+    std::uint64_t totalSuccesses = 0;
+    std::uint64_t totalFailures = 0;
 
-      std::uint64_t totalSuccesses = 0;
-      std::uint64_t totalFailures = 0;
+    for (const auto &[id, health] : connections_)
+    {
+      auto connStats = health->getStats();
+      totalSuccesses += connStats.totalSuccesses;
+      totalFailures += connStats.totalFailures;
 
-      for (const auto& [id, health] : connections_)
+      switch (connStats.state)
       {
-        auto connStats = health->getStats();
-        totalSuccesses += connStats.totalSuccesses;
-        totalFailures += connStats.totalFailures;
-
-        switch (connStats.state)
-        {
-        case ConnectionState::Healthy:
-          stats.healthyConnections++;
-          break;
-        case ConnectionState::Warning:
-          stats.warningConnections++;
-          break;
-        case ConnectionState::Degraded:
-          stats.degradedConnections++;
-          break;
-        case ConnectionState::Critical:
-          stats.criticalConnections++;
-          break;
-        case ConnectionState::Unhealthy:
-          stats.unhealthyConnections++;
-          break;
-        }
+      case ConnectionState::Healthy:
+        stats.healthyConnections++;
+        break;
+      case ConnectionState::Warning:
+        stats.warningConnections++;
+        break;
+      case ConnectionState::Degraded:
+        stats.degradedConnections++;
+        break;
+      case ConnectionState::Critical:
+        stats.criticalConnections++;
+        break;
+      case ConnectionState::Unhealthy:
+        stats.unhealthyConnections++;
+        break;
       }
+    }
 
-      auto total = totalSuccesses + totalFailures;
-      stats.overallSuccessRate =
-          total > 0 ? static_cast<double>(totalSuccesses) / total : 1.0;
+    auto total = totalSuccesses + totalFailures;
+    stats.overallSuccessRate = total > 0 ? static_cast<double>(totalSuccesses) / total : 1.0;
 
-      return stats;
-    }
+    return stats;
+  }
 
-    void updateConfig(const HealthConfig& config)
+  void updateConfig(const HealthConfig &config)
+  {
+    config_ = config;
+    std::lock_guard<std::mutex> lock(mutex_);
+    for (auto &[id, health] : connections_)
     {
-      config_ = config;
-      std::lock_guard<std::mutex> lock(mutex_);
-      for (auto& [id, health] : connections_)
-      {
-        health->updateConfig(config);
-      }
+      health->updateConfig(config);
     }
+  }
 
-  private:
-    HealthConfig config_;
-    mutable std::mutex mutex_;
-    std::unordered_map<SessionId, std::unique_ptr<ConnectionHealth>>
-        connections_;
-  };
+private:
+  HealthConfig config_;
+  mutable std::mutex mutex_;
+  std::unordered_map<SessionId, std::unique_ptr<ConnectionHealth>> connections_;
+};
 
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/dns/dns_cache.hpp b/include/iora/network/dns/dns_cache.hpp
index ecb18e9..fadcd9d 100644
--- a/include/iora/network/dns/dns_cache.hpp
+++ b/include/iora/network/dns/dns_cache.hpp
@@ -8,10 +8,10 @@
 
 #include "dns_types.hpp"
 #include "iora/util/expiring_cache.hpp"
-#include <memory>
+#include <atomic>
 #include <chrono>
 #include <functional>
-#include <atomic>
+#include <memory>
 
 namespace iora
 {
@@ -23,15 +23,15 @@ namespace dns
 /// \brief Cache statistics for monitoring
 struct DnsCacheStats
 {
-  std::uint64_t hits{0};                        ///< Cache hits
-  std::uint64_t misses{0};                      ///< Cache misses
-  std::uint64_t negative_hits{0};               ///< Negative cache hits
-  std::uint64_t insertions{0};                  ///< New cache insertions (not replacements)
-  std::uint64_t replacements{0};                ///< Cache entry replacements
-  std::uint64_t negative_insertions{0};         ///< New negative cache insertions
-  std::uint64_t negative_replacements{0};       ///< Negative cache entry replacements
-  std::uint64_t current_entries{0};             ///< Accurate current entry count
-  std::uint64_t current_negative_entries{0};    ///< Accurate current negative entries
+  std::uint64_t hits{0};                              ///< Cache hits
+  std::uint64_t misses{0};                            ///< Cache misses
+  std::uint64_t negative_hits{0};                     ///< Negative cache hits
+  std::uint64_t insertions{0};                        ///< New cache insertions (not replacements)
+  std::uint64_t replacements{0};                      ///< Cache entry replacements
+  std::uint64_t negative_insertions{0};               ///< New negative cache insertions
+  std::uint64_t negative_replacements{0};             ///< Negative cache entry replacements
+  std::uint64_t current_entries{0};                   ///< Accurate current entry count
+  std::uint64_t current_negative_entries{0};          ///< Accurate current negative entries
   std::chrono::steady_clock::time_point last_cleanup; ///< Last cleanup time
 
   /// \brief Calculate hit ratio
@@ -48,40 +48,35 @@ struct CachedDnsResult
   DnsResult result;
   bool isNegative{false};
   std::string errorMessage;
-  
+
   CachedDnsResult() = default;
-  
+
   // Positive result constructor
-  explicit CachedDnsResult(const DnsResult& res) 
-    : result(res), isNegative(false) {}
-  
-  // Negative result constructor  
-  CachedDnsResult(const DnsResult& res, const std::string& error)
-    : result(res), isNegative(true), errorMessage(error) {}
+  explicit CachedDnsResult(const DnsResult &res) : result(res), isNegative(false) {}
+
+  // Negative result constructor
+  CachedDnsResult(const DnsResult &res, const std::string &error)
+      : result(res), isNegative(true), errorMessage(error)
+  {
+  }
 };
 
 /// \brief Thread-safe DNS cache with TTL-aware expiration
-/// 
+///
 /// This cache uses Iora's ExpiringCache for robust TTL handling and automatic cleanup.
 /// It supports both positive and negative response caching per RFC 2308.
 class DnsCache
 {
 public:
   /// \brief Constructor with default configuration
-  DnsCache() : defaultTtl_(std::chrono::seconds(300)) 
-  { 
-    initializeCache();
-  } // 5 minute default TTL
-  
+  DnsCache() : defaultTtl_(std::chrono::seconds(300)) { initializeCache(); } // 5 minute default TTL
+
   /// \brief Constructor with configurable TTL
   /// \param ttl Time-to-live for cache entries
-  explicit DnsCache(std::chrono::seconds ttl) : defaultTtl_(ttl) 
-  {
-    initializeCache();
-  }
-  
+  explicit DnsCache(std::chrono::seconds ttl) : defaultTtl_(ttl) { initializeCache(); }
+
   /// \brief Constructor with maximum cache size (ignored - ExpiringCache uses TTL only)
-  /// \param maxSize Ignored for compatibility with old API  
+  /// \param maxSize Ignored for compatibility with old API
   explicit DnsCache(std::size_t maxSize) : defaultTtl_(std::chrono::seconds(300))
   {
     // maxSize is ignored - ExpiringCache uses time-based expiration only
@@ -89,36 +84,36 @@ public:
   }
 
   /// \brief Store DNS query result in cache with minimum TTL
-  /// 
+  ///
   /// This implementation uses a single TTL for the entire DNS result, calculated as the
   /// minimum TTL across all resource records in the response. This follows the conservative
   /// approach from RFC 1035 and ensures correctness when records have different expiration times.
-  /// 
+  ///
   /// \note Future Enhancement: Per-record caching granularity could be implemented by
   ///       storing individual records with their respective TTLs. This would require:
   ///       - Separate cache keys per record type (e.g., "example.com:A", "example.com:AAAA")
   ///       - Modified cache lookup to merge available records into a response
   ///       - Handling of partial cache hits (some record types expired, others valid)
   ///       - More complex statistics tracking for per-record hit/miss ratios
-  /// 
+  ///
   /// \param question DNS question used as cache key
   /// \param result DNS query result to cache
-  void put(const DnsQuestion& question, const DnsResult& result)
+  void put(const DnsQuestion &question, const DnsResult &result)
   {
     DnsCacheKey key = DnsCacheKey::fromQuestion(question);
-    
+
     // Check what type of entry exists to handle counter correctly
     auto existingEntry = cache_->get(key);
     bool hadEntry = existingEntry.has_value();
     bool hadNegativeEntry = hadEntry && existingEntry->isNegative;
-    
+
     // Calculate TTL from DNS result
     std::uint32_t ttl = calculateResultTtl(result);
-    
+
     // Store positive result
     CachedDnsResult cachedResult(result);
     cache_->set(key, cachedResult, std::chrono::seconds(ttl));
-    
+
     // Update statistics - distinguish insertions from replacements
     if (!hadEntry)
     {
@@ -142,24 +137,24 @@ public:
   }
 
   /// \brief Store negative DNS response in cache (RFC 2308)
-  /// \param question DNS question used as cache key  
+  /// \param question DNS question used as cache key
   /// \param result DNS error result to cache
   /// \param negativeTtl TTL for negative caching (from SOA or default)
   /// \param errorMessage Error description
-  void putNegative(const DnsQuestion& question, const DnsResult& result, 
-                   std::uint32_t negativeTtl, const std::string& errorMessage)
+  void putNegative(const DnsQuestion &question, const DnsResult &result, std::uint32_t negativeTtl,
+                   const std::string &errorMessage)
   {
     DnsCacheKey key = DnsCacheKey::fromQuestion(question);
-    
+
     // Check what type of entry exists to handle counter correctly
     auto existingEntry = cache_->get(key);
     bool hadEntry = existingEntry.has_value();
     bool hadNegativeEntry = hadEntry && existingEntry->isNegative;
-    
+
     // Store negative result
     CachedDnsResult cachedResult(result, errorMessage);
     cache_->set(key, cachedResult, std::chrono::seconds(negativeTtl));
-    
+
     // Update statistics - distinguish insertions from replacements
     if (!hadEntry)
     {
@@ -183,11 +178,11 @@ public:
   }
 
   /// \brief Store negative DNS response with automatic SOA TTL calculation (RFC 2308)
-  /// \param question DNS question used as cache key  
+  /// \param question DNS question used as cache key
   /// \param result DNS error result to cache (should contain SOA in authority section)
   /// \param errorMessage Error description
-  void putNegative(const DnsQuestion& question, const DnsResult& result, 
-                   const std::string& errorMessage)
+  void putNegative(const DnsQuestion &question, const DnsResult &result,
+                   const std::string &errorMessage)
   {
     std::uint32_t negativeTtl = calculateNegativeTtl(result);
     putNegative(question, result, negativeTtl, errorMessage);
@@ -197,20 +192,20 @@ public:
   /// \param question DNS question to look up
   /// \param result Output parameter for cached result
   /// \return true if cache hit, false if miss or expired
-  bool get(const DnsQuestion& question, DnsResult& result)
+  bool get(const DnsQuestion &question, DnsResult &result)
   {
     DnsCacheKey key = DnsCacheKey::fromQuestion(question);
-    
+
     auto cachedResult = cache_->get(key);
     if (!cachedResult.has_value())
     {
       stats_.misses.fetch_add(1);
       return false;
     }
-    
+
     // Return the cached result
     result = cachedResult->result;
-    
+
     if (cachedResult->isNegative)
     {
       stats_.negative_hits.fetch_add(1);
@@ -219,36 +214,36 @@ public:
     {
       stats_.hits.fetch_add(1);
     }
-    
+
     return true;
   }
 
   /// \brief Remove specific entry from cache
   /// \param question DNS question to remove
-  void remove(const DnsQuestion& question)
+  void remove(const DnsQuestion &question)
   {
     DnsCacheKey key = DnsCacheKey::fromQuestion(question);
     cache_->remove(key);
   }
 
   /// \brief Clear entire cache (preserves historical statistics)
-  /// 
+  ///
   /// This method clears all cached entries and resets current entry counters,
   /// but preserves historical statistics (hits, misses, insertions) for monitoring.
   /// The cleanupCallback is preserved and will continue to function correctly.
-  /// 
+  ///
   /// \note For full statistics reset, use clear(true)
   void clear()
   {
     clear(false); // Default: preserve historical statistics
   }
-  
+
   /// \brief Clear entire cache with optional statistics reset
-  /// 
+  ///
   /// This method clears all cached entries and resets current entry counters.
   /// The cleanupCallback is preserved and will continue to function correctly
   /// after reinitializing the ExpiringCache with the same TTL and callback.
-  /// 
+  ///
   /// \param resetHistoricalStats If true, reset all statistics including historical counters
   ///                            If false, preserve hits/misses/insertions for monitoring
   void clear(bool resetHistoricalStats)
@@ -256,7 +251,7 @@ public:
     // Reset current entry counters (always)
     stats_.current_entries.store(0);
     stats_.current_negative_entries.store(0);
-    
+
     // Reset historical statistics if requested
     if (resetHistoricalStats)
     {
@@ -268,7 +263,7 @@ public:
       stats_.negative_insertions.store(0);
       stats_.negative_replacements.store(0);
     }
-    
+
     // ExpiringCache doesn't have a clear method, so we create a new instance
     // The cleanupCallback_ is preserved and passed to initializeCache()
     // The defaultTtl_ is also preserved from construction time
@@ -287,11 +282,11 @@ public:
     currentStats.replacements = stats_.replacements.load();
     currentStats.negative_insertions = stats_.negative_insertions.load();
     currentStats.negative_replacements = stats_.negative_replacements.load();
-    
+
     // Use accurate counters maintained via eviction callbacks
     currentStats.current_entries = stats_.current_entries.load();
     currentStats.current_negative_entries = stats_.current_negative_entries.load();
-    
+
     currentStats.last_cleanup = std::chrono::steady_clock::now();
     return currentStats;
   }
@@ -306,7 +301,7 @@ public:
 
   /// \brief Set cleanup callback (no-op for compatibility)
   /// \param callback Cleanup callback function
-  void setCleanupCallback(std::function<void(const DnsCacheStats&)> callback)
+  void setCleanupCallback(std::function<void(const DnsCacheStats &)> callback)
   {
     // Store callback for potential future use
     cleanupCallback_ = callback;
@@ -315,15 +310,15 @@ public:
 private:
   /// \brief Underlying expiring cache
   std::unique_ptr<util::ExpiringCache<DnsCacheKey, CachedDnsResult>> cache_;
-  
+
   /// \brief Default TTL for cache entries
   std::chrono::seconds defaultTtl_;
-  
+
   /// \brief Atomic statistics counters
   struct AtomicStats
   {
     std::atomic<std::uint64_t> hits{0};
-    std::atomic<std::uint64_t> misses{0}; 
+    std::atomic<std::uint64_t> misses{0};
     std::atomic<std::uint64_t> negative_hits{0};
     std::atomic<std::uint64_t> insertions{0};
     std::atomic<std::uint64_t> replacements{0};
@@ -332,14 +327,14 @@ private:
     std::atomic<std::uint64_t> current_entries{0};          ///< Accurate current positive entries
     std::atomic<std::uint64_t> current_negative_entries{0}; ///< Accurate current negative entries
   } stats_;
-  
+
   /// \brief Optional cleanup callback
-  std::function<void(const DnsCacheStats&)> cleanupCallback_;
+  std::function<void(const DnsCacheStats &)> cleanupCallback_;
 
   /// \brief Initialize cache with eviction callback
   void initializeCache()
   {
-    auto evictionCallback = [this](const DnsCacheKey& key, const CachedDnsResult& result)
+    auto evictionCallback = [this](const DnsCacheKey &key, const CachedDnsResult &result)
     {
       // Decrement appropriate counter when entries are evicted
       if (result.isNegative)
@@ -351,147 +346,151 @@ private:
         stats_.current_entries.fetch_sub(1);
       }
     };
-    
-    cache_ = std::make_unique<util::ExpiringCache<DnsCacheKey, CachedDnsResult>>(defaultTtl_, evictionCallback);
+
+    cache_ = std::make_unique<util::ExpiringCache<DnsCacheKey, CachedDnsResult>>(defaultTtl_,
+                                                                                 evictionCallback);
   }
 
   /// \brief Calculate negative TTL from SOA records (RFC 2308)
-  /// 
-  /// This method implements RFC 2308 negative caching TTL calculation with multiple fallback levels:
-  /// 
+  ///
+  /// This method implements RFC 2308 negative caching TTL calculation with multiple fallback
+  /// levels:
+  ///
   /// 1. **Preferred**: Uses parsed SOA records from result.soa_records
   ///    - Extracts the SOA MINIMUM field (proper RFC 2308 behavior)
   ///    - Returns min(SOA.minimum, SOA.ttl) to respect both limits
-  /// 
+  ///
   /// 2. **Fallback**: Scans result.authority for unparsed SOA records
   ///    - Uses SOA record TTL as approximation (less precise than MINIMUM field)
   ///    - This handles cases where SOA parsing might have been missed
   ///    - Note: This is less accurate as it doesn't extract MINIMUM from RDATA
-  /// 
+  ///
   /// 3. **Default**: Uses provided default when no SOA found
   ///    - Standard fallback per RFC 2308 recommendations
-  /// 
+  ///
   /// The authority section fallback exists because SOA records in NXDOMAIN responses
   /// typically appear in the authority section, and our SOA parsing should have moved
   /// them to soa_records. If this fallback is frequently used, it may indicate a parsing issue.
   ///
-  /// \param result DNS query result containing potential SOA records  
+  /// \param result DNS query result containing potential SOA records
   /// \param defaultNegativeTtl Fallback TTL if no SOA found (default: 5 minutes)
   /// \return Negative TTL in seconds (from SOA minimum or default)
-  std::uint32_t calculateNegativeTtl(const DnsResult& result, std::uint32_t defaultNegativeTtl = 300) const
+  std::uint32_t calculateNegativeTtl(const DnsResult &result,
+                                     std::uint32_t defaultNegativeTtl = 300) const
   {
     // RFC 2308: Use SOA MINIMUM field for negative caching (preferred path)
-    for (const auto& record : result.soa_records)
+    for (const auto &record : result.soa_records)
     {
       return std::min(record.minimum, record.ttl); // Use minimum of SOA minimum and TTL
     }
-    
+
     // Fallback: check authority section for SOA records that weren't parsed into soa_records
     // This should be rare if SOA parsing is working correctly
-    for (const auto& record : result.authority)
+    for (const auto &record : result.authority)
     {
       if (record.type == DnsType::SOA)
       {
         // Less precise: use record TTL as approximation instead of SOA MINIMUM field
         // This is acceptable but not ideal - log a warning for monitoring
-        iora::core::Logger::debug("DNS negative TTL using SOA record TTL approximation (SOA parsing may have failed)");
+        iora::core::Logger::debug(
+          "DNS negative TTL using SOA record TTL approximation (SOA parsing may have failed)");
         return record.ttl;
       }
     }
-    
+
     // RFC 2308 fallback: use default negative TTL when no SOA found
     return defaultNegativeTtl;
   }
 
   /// \brief Calculate appropriate TTL from DNS result using conservative minimum approach
-  /// 
+  ///
   /// This method implements the conservative caching strategy by returning the minimum TTL
   /// across all resource records in the DNS response. This ensures that the cached entry
   /// expires when the first record would become stale, maintaining DNS correctness.
-  /// 
+  ///
   /// Alternative approaches could include:
   /// - Per-record TTL caching: Store each record type separately with individual TTLs
   /// - Weighted TTL: Use TTL from the most "important" record type for the query
   /// - Configurable strategy: Allow applications to choose caching granularity
-  /// 
+  ///
   /// \param result DNS query result containing multiple resource records
   /// \return TTL in seconds (minimum across all records, default 300s if none found)
-  std::uint32_t calculateResultTtl(const DnsResult& result) const
+  std::uint32_t calculateResultTtl(const DnsResult &result) const
   {
     std::uint32_t min_ttl = std::numeric_limits<std::uint32_t>::max();
-    
+
     // Check all raw record sections (RFC 1035 sections)
-    for (const auto& record : result.answers)
+    for (const auto &record : result.answers)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
-    for (const auto& record : result.authority)
+
+    for (const auto &record : result.authority)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
-    for (const auto& record : result.additional)
+
+    for (const auto &record : result.additional)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
+
     // Check all typed record collections (comprehensive coverage)
-    for (const auto& record : result.a_records)
+    for (const auto &record : result.a_records)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
-    for (const auto& record : result.aaaa_records)
+
+    for (const auto &record : result.aaaa_records)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
-    for (const auto& record : result.srv_records)
+
+    for (const auto &record : result.srv_records)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
-    for (const auto& record : result.naptr_records)
+
+    for (const auto &record : result.naptr_records)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
-    for (const auto& record : result.cname_records)
+
+    for (const auto &record : result.cname_records)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
-    for (const auto& record : result.mx_records)
+
+    for (const auto &record : result.mx_records)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
-    for (const auto& record : result.txt_records)
+
+    for (const auto &record : result.txt_records)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
-    for (const auto& record : result.ptr_records)
+
+    for (const auto &record : result.ptr_records)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
-    for (const auto& record : result.soa_records)
+
+    for (const auto &record : result.soa_records)
     {
       min_ttl = std::min(min_ttl, record.ttl);
     }
-    
+
     // Default TTL if no records found (RFC 1035 suggests reasonable defaults)
     if (min_ttl == std::numeric_limits<std::uint32_t>::max())
     {
       min_ttl = 300; // 5 minutes default
     }
-    
+
     return min_ttl;
   }
 };
 
 } // namespace dns
-} // namespace network  
+} // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/dns/dns_message.hpp b/include/iora/network/dns/dns_message.hpp
index 878ee70..ef4c080 100644
--- a/include/iora/network/dns/dns_message.hpp
+++ b/include/iora/network/dns/dns_message.hpp
@@ -8,13 +8,13 @@
 
 #include "dns_types.hpp"
 #include "iora/core/logger.hpp"
-#include <stdexcept>
-#include <sstream>
+#include <arpa/inet.h>
+#include <cstring>
 #include <iomanip>
 #include <random>
+#include <sstream>
+#include <stdexcept>
 #include <unordered_set>
-#include <cstring>
-#include <arpa/inet.h>
 
 namespace iora
 {
@@ -27,8 +27,8 @@ namespace dns
 class DnsParseException : public std::runtime_error
 {
 public:
-  explicit DnsParseException(const std::string& message)
-    : std::runtime_error("DNS Parse Error: " + message)
+  explicit DnsParseException(const std::string &message)
+      : std::runtime_error("DNS Parse Error: " + message)
   {
   }
 };
@@ -42,13 +42,13 @@ public:
   /// \param size Size of the data
   /// \return Parsed DNS result structure
   /// \throws DnsParseException on parsing errors
-  static DnsResult parse(const std::uint8_t* data, std::size_t size);
+  static DnsResult parse(const std::uint8_t *data, std::size_t size);
 
   /// \brief Parse DNS message from vector
   /// \param data Binary DNS message data
   /// \return Parsed DNS result structure
   /// \throws DnsParseException on parsing errors
-  static DnsResult parse(const std::vector<std::uint8_t>& data)
+  static DnsResult parse(const std::vector<std::uint8_t> &data)
   {
     return parse(data.data(), data.size());
   }
@@ -57,23 +57,22 @@ public:
   /// \param question DNS question to query
   /// \param id Query identifier (0 = auto-generate)
   /// \return Binary DNS query message
-  static std::vector<std::uint8_t> buildQuery(const DnsQuestion& question, 
-                                               std::uint16_t id = 0);
+  static std::vector<std::uint8_t> buildQuery(const DnsQuestion &question, std::uint16_t id = 0);
 
   /// \brief Build DNS query for multiple questions
   /// \param questions DNS questions to query
   /// \param id Query identifier (0 = auto-generate)
   /// \return Binary DNS query message
-  static std::vector<std::uint8_t> buildQuery(const std::vector<DnsQuestion>& questions,
-                                               std::uint16_t id = 0);
+  static std::vector<std::uint8_t> buildQuery(const std::vector<DnsQuestion> &questions,
+                                              std::uint16_t id = 0);
 
   /// \brief Build DNS query with configurable recursion flag
   /// \param questions DNS questions to query
   /// \param recursionDesired Whether to set RD flag (recursion desired)
   /// \param id Query identifier (0 = auto-generate)
   /// \return Binary DNS query message
-  static std::vector<std::uint8_t> buildQuery(const std::vector<DnsQuestion>& questions,
-                                               bool recursionDesired, std::uint16_t id = 0);
+  static std::vector<std::uint8_t> buildQuery(const std::vector<DnsQuestion> &questions,
+                                              bool recursionDesired, std::uint16_t id = 0);
 
   /// \brief Generate random query ID
   static std::uint16_t generateQueryId();
@@ -81,7 +80,7 @@ public:
   /// \brief Convert domain name to DNS wire format
   /// \param name Domain name (e.g., "example.com")
   /// \return Wire format name with length prefixes
-  static std::vector<std::uint8_t> encodeName(const std::string& name);
+  static std::vector<std::uint8_t> encodeName(const std::string &name);
 
   /// \brief Parse domain name from DNS wire format
   /// \param data DNS message data
@@ -90,8 +89,8 @@ public:
   /// \param name Output parameter for parsed name
   /// \return New offset after parsing name
   /// \throws DnsParseException on parsing errors
-  static std::size_t decodeName(const std::uint8_t* data, std::size_t offset,
-                               std::size_t size, std::string& name);
+  static std::size_t decodeName(const std::uint8_t *data, std::size_t offset, std::size_t size,
+                                std::string &name);
 
   /// \brief Parse domain name with loop detection
   /// \param data DNS message data
@@ -100,92 +99,81 @@ public:
   /// \param name Output parameter for parsed name
   /// \param visitedPointers Set to track visited compression pointers
   /// \return New offset after parsing name
-  static std::size_t decodeNameWithLoopDetection(const std::uint8_t* data, std::size_t offset,
-                                                 std::size_t size, std::string& name,
-                                                 std::unordered_set<std::uint16_t>& visitedPointers);
+  static std::size_t
+  decodeNameWithLoopDetection(const std::uint8_t *data, std::size_t offset, std::size_t size,
+                              std::string &name,
+                              std::unordered_set<std::uint16_t> &visitedPointers);
 
 private:
   /// \brief Parse DNS header from binary data
-  static std::size_t parseHeader(const std::uint8_t* data, std::size_t offset,
-                                std::size_t size, DnsHeader& header);
+  static std::size_t parseHeader(const std::uint8_t *data, std::size_t offset, std::size_t size,
+                                 DnsHeader &header);
 
   /// \brief Parse DNS question from binary data
-  static std::size_t parseQuestion(const std::uint8_t* data, std::size_t offset,
-                                  std::size_t size, DnsQuestion& question);
+  static std::size_t parseQuestion(const std::uint8_t *data, std::size_t offset, std::size_t size,
+                                   DnsQuestion &question);
 
   /// \brief Parse DNS resource record from binary data
-  static std::size_t parseResourceRecord(const std::uint8_t* data, std::size_t offset,
-                                        std::size_t size, DnsResourceRecord& rr);
+  static std::size_t parseResourceRecord(const std::uint8_t *data, std::size_t offset,
+                                         std::size_t size, DnsResourceRecord &rr);
 
   /// \brief Parse DNS resource record with RDATA offset tracking
-  static std::size_t parseResourceRecord(const std::uint8_t* data, std::size_t offset,
-                                        std::size_t size, DnsResourceRecord& rr, 
-                                        std::size_t& rdataOffset);
+  static std::size_t parseResourceRecord(const std::uint8_t *data, std::size_t offset,
+                                         std::size_t size, DnsResourceRecord &rr,
+                                         std::size_t &rdataOffset);
 
   /// \brief Parse specific record types from resource record data
-  static void parseTypedRecord(const DnsResourceRecord& rr, DnsResult& result,
-                              const std::uint8_t* messageData, std::size_t messageSize,
-                              std::size_t rdataOffset);
+  static void parseTypedRecord(const DnsResourceRecord &rr, DnsResult &result,
+                               const std::uint8_t *messageData, std::size_t messageSize,
+                               std::size_t rdataOffset);
 
   /// \brief Security validation for RDATA to detect malicious compression pointers
   /// \param rr Resource record to validate
   /// \throws DnsParseException if malicious compression patterns are detected
-  static void validateRdataSecurity(const DnsResourceRecord& rr);
+  static void validateRdataSecurity(const DnsResourceRecord &rr);
 
   /// \brief Parse A record data
-  static ARecord parseARecord(const DnsResourceRecord& rr);
+  static ARecord parseARecord(const DnsResourceRecord &rr);
 
   /// \brief Parse AAAA record data
-  static AAAARecord parseAAAARecord(const DnsResourceRecord& rr);
+  static AAAARecord parseAAAARecord(const DnsResourceRecord &rr);
 
   /// \brief Parse SRV record data (critical for SIP)
-  static SrvRecord parseSrvRecord(const DnsResourceRecord& rr, 
-                                 const std::uint8_t* messageData, 
-                                 std::size_t messageSize,
-                                 std::size_t rdataOffset);
+  static SrvRecord parseSrvRecord(const DnsResourceRecord &rr, const std::uint8_t *messageData,
+                                  std::size_t messageSize, std::size_t rdataOffset);
 
   /// \brief Parse NAPTR record data (essential for SIP)
-  static NaptrRecord parseNaptrRecord(const DnsResourceRecord& rr,
-                                     const std::uint8_t* messageData,
-                                     std::size_t messageSize,
-                                     std::size_t rdataOffset);
+  static NaptrRecord parseNaptrRecord(const DnsResourceRecord &rr, const std::uint8_t *messageData,
+                                      std::size_t messageSize, std::size_t rdataOffset);
 
   /// \brief Parse CNAME record data
-  static CnameRecord parseCnameRecord(const DnsResourceRecord& rr,
-                                     const std::uint8_t* messageData,
-                                     std::size_t messageSize,
-                                     std::size_t rdataOffset);
+  static CnameRecord parseCnameRecord(const DnsResourceRecord &rr, const std::uint8_t *messageData,
+                                      std::size_t messageSize, std::size_t rdataOffset);
 
   /// \brief Parse MX record data
-  static MxRecord parseMxRecord(const DnsResourceRecord& rr,
-                               const std::uint8_t* messageData,
-                               std::size_t messageSize,
-                               std::size_t rdataOffset);
+  static MxRecord parseMxRecord(const DnsResourceRecord &rr, const std::uint8_t *messageData,
+                                std::size_t messageSize, std::size_t rdataOffset);
 
   /// \brief Parse TXT record data
-  static TxtRecord parseTxtRecord(const DnsResourceRecord& rr);
+  static TxtRecord parseTxtRecord(const DnsResourceRecord &rr);
 
   /// \brief Parse PTR record data
-  static PtrRecord parsePtrRecord(const DnsResourceRecord& rr,
-                                 const std::uint8_t* messageData,
-                                 std::size_t messageSize,
-                                 std::size_t rdataOffset);
+  static PtrRecord parsePtrRecord(const DnsResourceRecord &rr, const std::uint8_t *messageData,
+                                  std::size_t messageSize, std::size_t rdataOffset);
 
   /// \brief Parse SOA record data (Start of Authority, RFC 1035)
-  static SoaRecord parseSoaRecord(const DnsResourceRecord& rr,
-                                 const std::uint8_t* messageData,
-                                 std::size_t messageSize,
-                                 std::size_t rdataOffset);
+  static SoaRecord parseSoaRecord(const DnsResourceRecord &rr, const std::uint8_t *messageData,
+                                  std::size_t messageSize, std::size_t rdataOffset);
 
   /// \brief Parse domain name from RDATA with compression support
-  /// 
+  ///
   /// This is a complex function that handles various edge cases including:
   /// - Compression pointers within RDATA pointing back to message
   /// - Mixed compression/literal name segments
   /// - Pointer loops (prevented by visited set in decodeName)
   /// - Names that extend beyond RDATA bounds via compression
   /// - Invalid compression pointers beyond message bounds
-  /// 
+  ///
   /// Critical test cases needed:
   /// - Simple name in RDATA without compression
   /// - Name with compression pointer at start of RDATA
@@ -195,7 +183,7 @@ private:
   /// - Pointer beyond message bounds (should throw exception)
   /// - Empty RDATA (should handle gracefully)
   /// - RDATA smaller than pointer (2 bytes)
-  /// 
+  ///
   /// \param messageData Full DNS message data
   /// \param messageSize Size of full message
   /// \param rdataStart Absolute offset where RDATA starts in message
@@ -204,29 +192,29 @@ private:
   /// \param rdataSize Size of RDATA
   /// \param name Output parameter for parsed name
   /// \return New offset within RDATA after parsing name
-  static std::size_t decodeNameFromRdata(const std::uint8_t* messageData, std::size_t messageSize,
-                                         std::size_t rdataStart, std::size_t rdataOffset, 
-                                         const std::uint8_t* rdata, std::size_t rdataSize, 
-                                         std::string& name);
+  static std::size_t decodeNameFromRdata(const std::uint8_t *messageData, std::size_t messageSize,
+                                         std::size_t rdataStart, std::size_t rdataOffset,
+                                         const std::uint8_t *rdata, std::size_t rdataSize,
+                                         std::string &name);
 
   /// \brief Write 16-bit value to buffer in network byte order
-  static void writeUint16(std::vector<std::uint8_t>& buffer, std::uint16_t value);
+  static void writeUint16(std::vector<std::uint8_t> &buffer, std::uint16_t value);
 
   /// \brief Write 32-bit value to buffer in network byte order
-  static void writeUint32(std::vector<std::uint8_t>& buffer, std::uint32_t value);
+  static void writeUint32(std::vector<std::uint8_t> &buffer, std::uint32_t value);
 
   /// \brief Read 16-bit value from buffer in network byte order
-  static std::uint16_t readUint16(const std::uint8_t* data, std::size_t offset);
+  static std::uint16_t readUint16(const std::uint8_t *data, std::size_t offset);
 
   /// \brief Read 32-bit value from buffer in network byte order
-  static std::uint32_t readUint32(const std::uint8_t* data, std::size_t offset);
+  static std::uint32_t readUint32(const std::uint8_t *data, std::size_t offset);
 
   /// \brief Check if there's enough data at offset
   static void checkBounds(std::size_t offset, std::size_t needed, std::size_t total);
 
   /// \brief Static random number generator for query IDs
-  static std::random_device& getRandomDevice();
-  static std::mt19937& getRandomGenerator();
+  static std::random_device &getRandomDevice();
+  static std::mt19937 &getRandomGenerator();
 };
 
 // ==================== Implementation ====================
@@ -237,40 +225,40 @@ inline std::uint16_t DnsMessage::generateQueryId()
   return dist(getRandomGenerator());
 }
 
-inline std::random_device& DnsMessage::getRandomDevice()
+inline std::random_device &DnsMessage::getRandomDevice()
 {
   static std::random_device rd;
   return rd;
 }
 
-inline std::mt19937& DnsMessage::getRandomGenerator()
+inline std::mt19937 &DnsMessage::getRandomGenerator()
 {
   static std::mt19937 gen(getRandomDevice()());
   return gen;
 }
 
-inline void DnsMessage::writeUint16(std::vector<std::uint8_t>& buffer, std::uint16_t value)
+inline void DnsMessage::writeUint16(std::vector<std::uint8_t> &buffer, std::uint16_t value)
 {
   std::uint16_t netValue = htons(value);
-  const std::uint8_t* bytes = reinterpret_cast<const std::uint8_t*>(&netValue);
+  const std::uint8_t *bytes = reinterpret_cast<const std::uint8_t *>(&netValue);
   buffer.insert(buffer.end(), bytes, bytes + 2);
 }
 
-inline void DnsMessage::writeUint32(std::vector<std::uint8_t>& buffer, std::uint32_t value)
+inline void DnsMessage::writeUint32(std::vector<std::uint8_t> &buffer, std::uint32_t value)
 {
   std::uint32_t netValue = htonl(value);
-  const std::uint8_t* bytes = reinterpret_cast<const std::uint8_t*>(&netValue);
+  const std::uint8_t *bytes = reinterpret_cast<const std::uint8_t *>(&netValue);
   buffer.insert(buffer.end(), bytes, bytes + 4);
 }
 
-inline std::uint16_t DnsMessage::readUint16(const std::uint8_t* data, std::size_t offset)
+inline std::uint16_t DnsMessage::readUint16(const std::uint8_t *data, std::size_t offset)
 {
   std::uint16_t netValue;
   std::memcpy(&netValue, data + offset, 2);
   return ntohs(netValue);
 }
 
-inline std::uint32_t DnsMessage::readUint32(const std::uint8_t* data, std::size_t offset)
+inline std::uint32_t DnsMessage::readUint32(const std::uint8_t *data, std::size_t offset)
 {
   std::uint32_t netValue;
   std::memcpy(&netValue, data + offset, 4);
@@ -281,16 +269,15 @@ inline void DnsMessage::checkBounds(std::size_t offset, std::size_t needed, std:
 {
   if (offset + needed > total)
   {
-    throw DnsParseException("Insufficient data at offset " + std::to_string(offset) +
-                           ", needed " + std::to_string(needed) + 
-                           ", total " + std::to_string(total));
+    throw DnsParseException("Insufficient data at offset " + std::to_string(offset) + ", needed " +
+                            std::to_string(needed) + ", total " + std::to_string(total));
   }
 }
 
-inline std::vector<std::uint8_t> DnsMessage::encodeName(const std::string& name)
+inline std::vector<std::uint8_t> DnsMessage::encodeName(const std::string &name)
 {
   std::vector<std::uint8_t> encoded;
-  
+
   if (name.empty() || name == ".")
   {
     encoded.push_back(0); // Root domain
@@ -299,51 +286,51 @@ inline std::vector<std::uint8_t> DnsMessage::encodeName(const std::string& name)
 
   std::istringstream iss(name);
   std::string label;
-  
+
   while (std::getline(iss, label, '.'))
   {
     if (label.empty())
       continue;
-      
+
     if (label.length() > constants::DNS_MAX_LABEL_SIZE)
     {
-      throw DnsParseException("Label too long: " + label + 
-                             " (max " + std::to_string(constants::DNS_MAX_LABEL_SIZE) + ")");
+      throw DnsParseException("Label too long: " + label + " (max " +
+                              std::to_string(constants::DNS_MAX_LABEL_SIZE) + ")");
     }
-    
+
     encoded.push_back(static_cast<std::uint8_t>(label.length()));
     encoded.insert(encoded.end(), label.begin(), label.end());
   }
-  
+
   encoded.push_back(0); // Null terminator
-  
+
   if (encoded.size() > constants::DNS_MAX_NAME_SIZE)
   {
     throw DnsParseException("Domain name too long: " + name);
   }
-  
+
   return encoded;
 }
 
-inline std::vector<std::uint8_t> DnsMessage::buildQuery(const DnsQuestion& question, 
+inline std::vector<std::uint8_t> DnsMessage::buildQuery(const DnsQuestion &question,
                                                         std::uint16_t id)
 {
   return buildQuery(std::vector<DnsQuestion>{question}, id);
 }
 
-inline std::vector<std::uint8_t> DnsMessage::buildQuery(const std::vector<DnsQuestion>& questions,
+inline std::vector<std::uint8_t> DnsMessage::buildQuery(const std::vector<DnsQuestion> &questions,
                                                         std::uint16_t id)
 {
   // Default behavior: recursion desired = true (backward compatibility)
   return buildQuery(questions, true, id);
 }
 
-inline std::vector<std::uint8_t> DnsMessage::buildQuery(const std::vector<DnsQuestion>& questions,
+inline std::vector<std::uint8_t> DnsMessage::buildQuery(const std::vector<DnsQuestion> &questions,
                                                         bool recursionDesired, std::uint16_t id)
 {
   std::vector<std::uint8_t> message;
   message.reserve(512); // Typical UDP DNS message size
-  
+
   // Generate ID if not provided
   if (id == 0)
   {
@@ -351,24 +338,24 @@ inline std::vector<std::uint8_t> DnsMessage::buildQuery(const std::vector<DnsQue
   }
 
   // DNS Header with configurable recursion flag
-  writeUint16(message, id);                              // Query ID
-  std::uint16_t flags = recursionDesired ? 0x0100 : 0x0000;  // Standard query, RD configurable
+  writeUint16(message, id);                                 // Query ID
+  std::uint16_t flags = recursionDesired ? 0x0100 : 0x0000; // Standard query, RD configurable
   writeUint16(message, flags);
   writeUint16(message, static_cast<std::uint16_t>(questions.size())); // QDCOUNT
-  writeUint16(message, 0);                              // ANCOUNT
-  writeUint16(message, 0);                              // NSCOUNT  
-  writeUint16(message, 0);                              // ARCOUNT
+  writeUint16(message, 0);                                            // ANCOUNT
+  writeUint16(message, 0);                                            // NSCOUNT
+  writeUint16(message, 0);                                            // ARCOUNT
 
   // Questions section
-  for (const auto& question : questions)
+  for (const auto &question : questions)
   {
     // QNAME
     auto encodedName = encodeName(question.qname);
     message.insert(message.end(), encodedName.begin(), encodedName.end());
-    
+
     // QTYPE
     writeUint16(message, static_cast<std::uint16_t>(question.qtype));
-    
+
     // QCLASS
     writeUint16(message, static_cast<std::uint16_t>(question.qclass));
   }
@@ -376,13 +363,13 @@ inline std::vector<std::uint8_t> DnsMessage::buildQuery(const std::vector<DnsQue
   return message;
 }
 
-inline DnsResult DnsMessage::parse(const std::uint8_t* data, std::size_t size)
+inline DnsResult DnsMessage::parse(const std::uint8_t *data, std::size_t size)
 {
   if (size < constants::DNS_HEADER_SIZE)
   {
-    throw DnsParseException("Message too short for DNS header: " + 
-                           std::to_string(size) + " bytes, minimum " + 
-                           std::to_string(constants::DNS_HEADER_SIZE) + " required");
+    throw DnsParseException("Message too short for DNS header: " + std::to_string(size) +
+                            " bytes, minimum " + std::to_string(constants::DNS_HEADER_SIZE) +
+                            " required");
   }
 
   DnsResult result;
@@ -438,8 +425,8 @@ inline DnsResult DnsMessage::parse(const std::uint8_t* data, std::size_t size)
   return result;
 }
 
-inline std::size_t DnsMessage::parseHeader(const std::uint8_t* data, std::size_t offset,
-                                          std::size_t size, DnsHeader& header)
+inline std::size_t DnsMessage::parseHeader(const std::uint8_t *data, std::size_t offset,
+                                           std::size_t size, DnsHeader &header)
 {
   checkBounds(offset, constants::DNS_HEADER_SIZE, size);
 
@@ -469,8 +456,8 @@ inline std::size_t DnsMessage::parseHeader(const std::uint8_t* data, std::size_t
   return offset;
 }
 
-inline std::size_t DnsMessage::parseQuestion(const std::uint8_t* data, std::size_t offset,
-                                            std::size_t size, DnsQuestion& question)
+inline std::size_t DnsMessage::parseQuestion(const std::uint8_t *data, std::size_t offset,
+                                             std::size_t size, DnsQuestion &question)
 {
   // Parse QNAME
   offset = decodeName(data, offset, size, question.qname);
@@ -488,8 +475,8 @@ inline std::size_t DnsMessage::parseQuestion(const std::uint8_t* data, std::size
   return offset;
 }
 
-inline std::size_t DnsMessage::parseResourceRecord(const std::uint8_t* data, std::size_t offset,
-                                                  std::size_t size, DnsResourceRecord& rr)
+inline std::size_t DnsMessage::parseResourceRecord(const std::uint8_t *data, std::size_t offset,
+                                                   std::size_t size, DnsResourceRecord &rr)
 {
   // Parse NAME
   offset = decodeName(data, offset, size, rr.name);
@@ -517,18 +504,18 @@ inline std::size_t DnsMessage::parseResourceRecord(const std::uint8_t* data, std
   // Parse RDATA
   checkBounds(offset, rr.rdlength, size);
   rr.rdata.assign(data + offset, data + offset + rr.rdlength);
-  
+
   // Security validation: detect malicious compression pointers in RDATA where they shouldn't exist
   validateRdataSecurity(rr);
-  
+
   offset += rr.rdlength;
 
   return offset;
 }
 
-inline std::size_t DnsMessage::parseResourceRecord(const std::uint8_t* data, std::size_t offset,
-                                                   std::size_t size, DnsResourceRecord& rr, 
-                                                   std::size_t& rdataOffset)
+inline std::size_t DnsMessage::parseResourceRecord(const std::uint8_t *data, std::size_t offset,
+                                                   std::size_t size, DnsResourceRecord &rr,
+                                                   std::size_t &rdataOffset)
 {
   // Parse NAME
   offset = decodeName(data, offset, size, rr.name);
@@ -559,25 +546,26 @@ inline std::size_t DnsMessage::parseResourceRecord(const std::uint8_t* data, std
   // Parse RDATA
   checkBounds(offset, rr.rdlength, size);
   rr.rdata.assign(data + offset, data + offset + rr.rdlength);
-  
+
   // Security validation: detect malicious compression pointers in RDATA where they shouldn't exist
   validateRdataSecurity(rr);
-  
+
   offset += rr.rdlength;
 
   return offset;
 }
 
-inline std::size_t DnsMessage::decodeName(const std::uint8_t* data, std::size_t offset,
-                                         std::size_t size, std::string& name)
+inline std::size_t DnsMessage::decodeName(const std::uint8_t *data, std::size_t offset,
+                                          std::size_t size, std::string &name)
 {
   std::unordered_set<std::uint16_t> visitedPointers;
   return decodeNameWithLoopDetection(data, offset, size, name, visitedPointers);
 }
 
-inline std::size_t DnsMessage::decodeNameWithLoopDetection(const std::uint8_t* data, std::size_t offset,
-                                                          std::size_t size, std::string& name,
-                                                          std::unordered_set<std::uint16_t>& visitedPointers)
+inline std::size_t
+DnsMessage::decodeNameWithLoopDetection(const std::uint8_t *data, std::size_t offset,
+                                        std::size_t size, std::string &name,
+                                        std::unordered_set<std::uint16_t> &visitedPointers)
 {
   name.clear();
   std::size_t originalOffset = offset;
@@ -587,7 +575,7 @@ inline std::size_t DnsMessage::decodeNameWithLoopDetection(const std::uint8_t* d
   while (offset < size)
   {
     std::uint8_t length = data[offset];
-    
+
     // Check for compression
     if ((length & constants::DNS_COMPRESSION_MASK) == constants::DNS_COMPRESSION_MASK)
     {
@@ -596,67 +584,69 @@ inline std::size_t DnsMessage::decodeNameWithLoopDetection(const std::uint8_t* d
         originalOffset = offset + 2; // Continue from after the pointer
         jumped = true;
       }
-      
+
       checkBounds(offset, 2, size);
       std::uint16_t pointer = readUint16(data, offset) & constants::DNS_COMPRESSION_POINTER_MASK;
-      
+
       // Check for invalid pointer
       if (pointer >= size)
       {
-        throw DnsParseException("Invalid compression pointer: " + std::to_string(pointer) + 
-                               ", message size: " + std::to_string(size));
+        throw DnsParseException("Invalid compression pointer: " + std::to_string(pointer) +
+                                ", message size: " + std::to_string(size));
       }
-      
+
       // Check for compression loops
       if (visitedPointers.find(pointer) != visitedPointers.end())
       {
-        throw DnsParseException("Compression pointer loop detected at offset: " + std::to_string(pointer));
+        throw DnsParseException("Compression pointer loop detected at offset: " +
+                                std::to_string(pointer));
       }
       visitedPointers.insert(pointer);
-      
+
       offset = pointer;
       continue;
     }
-    
+
     // End of name
     if (length == 0)
     {
       offset++;
       break;
     }
-    
+
     // Regular label
     if (length > constants::DNS_MAX_LABEL_SIZE)
     {
-      throw DnsParseException("Label too long: " + std::to_string(length) + 
-                             " (max " + std::to_string(constants::DNS_MAX_LABEL_SIZE) + ")");
+      throw DnsParseException("Label too long: " + std::to_string(length) + " (max " +
+                              std::to_string(constants::DNS_MAX_LABEL_SIZE) + ")");
     }
-    
+
     checkBounds(offset + 1, length, size);
-    
+
     if (!name.empty())
     {
       name += ".";
     }
-    
-    name.append(reinterpret_cast<const char*>(data + offset + 1), length);
+
+    name.append(reinterpret_cast<const char *>(data + offset + 1), length);
     offset += length + 1;
-    
+
     totalLength += length + 1;
     if (totalLength > constants::DNS_MAX_NAME_SIZE)
     {
-      throw DnsParseException("Domain name too long: " + std::to_string(totalLength) + 
-                             " (max " + std::to_string(constants::DNS_MAX_NAME_SIZE) + ")");
+      throw DnsParseException("Domain name too long: " + std::to_string(totalLength) + " (max " +
+                              std::to_string(constants::DNS_MAX_NAME_SIZE) + ")");
     }
   }
 
   return jumped ? originalOffset : offset;
 }
 
-inline std::size_t DnsMessage::decodeNameFromRdata(const std::uint8_t* messageData, std::size_t messageSize,
-                                                   std::size_t rdataStart, std::size_t rdataOffset, 
-                                                   const std::uint8_t* rdata, std::size_t rdataSize, 
-                                                   std::string& name)
+inline std::size_t DnsMessage::decodeNameFromRdata(const std::uint8_t *messageData,
+                                                   std::size_t messageSize, std::size_t rdataStart,
+                                                   std::size_t rdataOffset,
+                                                   const std::uint8_t *rdata, std::size_t rdataSize,
+                                                   std::string &name)
 {
   // Handle edge case: empty RDATA or invalid offset
   if (rdataSize == 0 || rdataOffset >= rdataSize)
@@ -664,7 +654,7 @@ inline std::size_t DnsMessage::decodeNameFromRdata(const std::uint8_t* messageDa
     name.clear();
     return rdataOffset;
   }
-  
+
   // Check if we have a compression pointer at this offset in RDATA
   if (rdataOffset + 1 < rdataSize)
   {
@@ -674,24 +664,29 @@ inline std::size_t DnsMessage::decodeNameFromRdata(const std::uint8_t* messageDa
       // Edge case: ensure we have enough bytes for a compression pointer
       if (rdataOffset + 2 > rdataSize)
       {
-        throw DnsParseException("RDATA too short for compression pointer at offset " + std::to_string(rdataOffset));
+        throw DnsParseException("RDATA too short for compression pointer at offset " +
+                                std::to_string(rdataOffset));
       }
-      
+
       // This is a compression pointer - decode directly from message
-      // 
-      // CRITICAL: The pointer bytes in RDATA represent an absolute offset into the full DNS message,
-      // not relative to RDATA. The readUint16() call correctly handles network byte order (ntohs).
-      // This works correctly even if pointer bytes are split across TCP fragmentation boundaries
-      // because RDATA is already assembled as a contiguous buffer by parseResourceRecord().
+      //
+      // CRITICAL: The pointer bytes in RDATA represent an absolute offset into the full DNS
+      // message, not relative to RDATA. The readUint16() call correctly handles network byte order
+      // (ntohs). This works correctly even if pointer bytes are split across TCP fragmentation
+      // boundaries because RDATA is already assembled as a contiguous buffer by
+      // parseResourceRecord().
       //
       // Edge cases handled:
       // - Pointer near message-size boundary (checked below)
       // - Big-endian vs host byte order (readUint16 handles ntohs conversion)
       // - Pointer beyond message bounds (validation below)
-      std::uint16_t pointer = readUint16(rdata, rdataOffset) & constants::DNS_COMPRESSION_POINTER_MASK;
-      
+      std::uint16_t pointer =
+        readUint16(rdata, rdataOffset) & constants::DNS_COMPRESSION_POINTER_MASK;
+
       // Validate pointer is within message bounds with safety margin for name parsing
-      if (static_cast<std::size_t>(pointer) < messageSize && (static_cast<std::size_t>(pointer) + 1) < messageSize) // Need at least 1 byte for length field
+      if (static_cast<std::size_t>(pointer) < messageSize &&
+          (static_cast<std::size_t>(pointer) + 1) <
+            messageSize) // Need at least 1 byte for length field
       {
         decodeName(messageData, pointer, messageSize, name);
         return rdataOffset + 2; // Compression pointer is 2 bytes
@@ -699,26 +694,26 @@ inline std::size_t DnsMessage::decodeNameFromRdata(const std::uint8_t* messageDa
       else
       {
         throw DnsParseException("Invalid compression pointer in RDATA: " + std::to_string(pointer) +
-                               " (message size=" + std::to_string(messageSize) + 
-                               ", need at least 1 byte for name length)");
+                                " (message size=" + std::to_string(messageSize) +
+                                ", need at least 1 byte for name length)");
       }
     }
   }
-  
+
   // Not a compression pointer, parse name directly from RDATA
   // But we need to handle the case where the name itself contains compression pointers
   // by translating RDATA offsets to absolute message offsets
   std::size_t absoluteOffset = rdataStart + rdataOffset;
-  
+
   // Validate absolute offset is within message bounds
   if (absoluteOffset >= messageSize)
   {
-    throw DnsParseException("RDATA name offset beyond message bounds: " + 
-                           std::to_string(absoluteOffset) + " >= " + std::to_string(messageSize));
+    throw DnsParseException("RDATA name offset beyond message bounds: " +
+                            std::to_string(absoluteOffset) + " >= " + std::to_string(messageSize));
   }
-  
+
   std::size_t newOffset = decodeName(messageData, absoluteOffset, messageSize, name);
-  
+
   // Convert back to relative RDATA offset
   // If decodeName followed a compression pointer, it returns the original offset + pointer size
   // If it parsed a regular name, it returns the new absolute offset
@@ -731,8 +726,9 @@ inline std::size_t DnsMessage::decodeNameFromRdata(const std::uint8_t* messageDa
     // Name parsing went beyond RDATA bounds or followed compression pointer
     // Find how many bytes were consumed in the original RDATA
     std::size_t consumedInRdata = rdataOffset;
-    while (consumedInRdata < rdataSize && 
-           (rdata[consumedInRdata] & constants::DNS_COMPRESSION_MASK) != constants::DNS_COMPRESSION_MASK &&
+    while (consumedInRdata < rdataSize &&
+           (rdata[consumedInRdata] & constants::DNS_COMPRESSION_MASK) !=
+             constants::DNS_COMPRESSION_MASK &&
            rdata[consumedInRdata] != 0)
     {
       std::uint8_t labelLen = rdata[consumedInRdata];
@@ -746,11 +742,12 @@ inline std::size_t DnsMessage::decodeNameFromRdata(const std::uint8_t* messageDa
         throw DnsParseException("Name extends beyond RDATA bounds");
       }
     }
-    
+
     // Account for terminator or compression pointer
     if (consumedInRdata < rdataSize)
     {
-      if ((rdata[consumedInRdata] & constants::DNS_COMPRESSION_MASK) == constants::DNS_COMPRESSION_MASK)
+      if ((rdata[consumedInRdata] & constants::DNS_COMPRESSION_MASK) ==
+          constants::DNS_COMPRESSION_MASK)
       {
         consumedInRdata += 2; // Compression pointer
       }
@@ -759,93 +756,90 @@ inline std::size_t DnsMessage::decodeNameFromRdata(const std::uint8_t* messageDa
         consumedInRdata += 1; // Null terminator
       }
     }
-    
+
     return consumedInRdata;
   }
 }
 
-inline void DnsMessage::parseTypedRecord(const DnsResourceRecord& rr, DnsResult& result,
-                                         const std::uint8_t* messageData, std::size_t messageSize,
+inline void DnsMessage::parseTypedRecord(const DnsResourceRecord &rr, DnsResult &result,
+                                         const std::uint8_t *messageData, std::size_t messageSize,
                                          std::size_t rdataOffset)
 {
   try
   {
     switch (rr.type)
     {
-      case DnsType::A:
-        result.a_records.push_back(parseARecord(rr));
-        break;
-      case DnsType::AAAA:
-        result.aaaa_records.push_back(parseAAAARecord(rr));
-        break;
-      case DnsType::SRV:
-        result.srv_records.push_back(parseSrvRecord(rr, messageData, messageSize, rdataOffset));
-        break;
-      case DnsType::NAPTR:
-        result.naptr_records.push_back(parseNaptrRecord(rr, messageData, messageSize, rdataOffset));
-        break;
-      case DnsType::CNAME:
-        result.cname_records.push_back(parseCnameRecord(rr, messageData, messageSize, rdataOffset));
-        break;
-      case DnsType::MX:
-        result.mx_records.push_back(parseMxRecord(rr, messageData, messageSize, rdataOffset));
-        break;
-      case DnsType::TXT:
-        result.txt_records.push_back(parseTxtRecord(rr));
-        break;
-      case DnsType::PTR:
-        result.ptr_records.push_back(parsePtrRecord(rr, messageData, messageSize, rdataOffset));
-        break;
-      case DnsType::SOA:
-        result.soa_records.push_back(parseSoaRecord(rr, messageData, messageSize, rdataOffset));
-        break;
-      default:
-        // Unknown record type - keep in generic records
-        break;
+    case DnsType::A:
+      result.a_records.push_back(parseARecord(rr));
+      break;
+    case DnsType::AAAA:
+      result.aaaa_records.push_back(parseAAAARecord(rr));
+      break;
+    case DnsType::SRV:
+      result.srv_records.push_back(parseSrvRecord(rr, messageData, messageSize, rdataOffset));
+      break;
+    case DnsType::NAPTR:
+      result.naptr_records.push_back(parseNaptrRecord(rr, messageData, messageSize, rdataOffset));
+      break;
+    case DnsType::CNAME:
+      result.cname_records.push_back(parseCnameRecord(rr, messageData, messageSize, rdataOffset));
+      break;
+    case DnsType::MX:
+      result.mx_records.push_back(parseMxRecord(rr, messageData, messageSize, rdataOffset));
+      break;
+    case DnsType::TXT:
+      result.txt_records.push_back(parseTxtRecord(rr));
+      break;
+    case DnsType::PTR:
+      result.ptr_records.push_back(parsePtrRecord(rr, messageData, messageSize, rdataOffset));
+      break;
+    case DnsType::SOA:
+      result.soa_records.push_back(parseSoaRecord(rr, messageData, messageSize, rdataOffset));
+      break;
+    default:
+      // Unknown record type - keep in generic records
+      break;
     }
   }
-  catch (const std::exception& e)
+  catch (const std::exception &e)
   {
     // Log parsing error but don't fail entire message
-    iora::core::Logger::warning("DNS record parsing error for " + rr.name + 
-                            " type=" + std::to_string(static_cast<uint16_t>(rr.type)) +
-                            ": " + e.what());
+    iora::core::Logger::warning("DNS record parsing error for " + rr.name + " type=" +
+                                std::to_string(static_cast<uint16_t>(rr.type)) + ": " + e.what());
   }
 }
 
-inline ARecord DnsMessage::parseARecord(const DnsResourceRecord& rr)
+inline ARecord DnsMessage::parseARecord(const DnsResourceRecord &rr)
 {
   if (rr.rdata.size() != 4)
   {
     throw DnsParseException("Invalid A record data length");
   }
-  
+
   ARecord record(rr.name, "", rr.ttl);
-  
+
   std::ostringstream oss;
-  oss << static_cast<int>(rr.rdata[0]) << "."
-      << static_cast<int>(rr.rdata[1]) << "."
-      << static_cast<int>(rr.rdata[2]) << "."
-      << static_cast<int>(rr.rdata[3]);
-  
+  oss << static_cast<int>(rr.rdata[0]) << "." << static_cast<int>(rr.rdata[1]) << "."
+      << static_cast<int>(rr.rdata[2]) << "." << static_cast<int>(rr.rdata[3]);
+
   record.address = oss.str();
   return record;
 }
 
-inline AAAARecord DnsMessage::parseAAAARecord(const DnsResourceRecord& rr)
+inline AAAARecord DnsMessage::parseAAAARecord(const DnsResourceRecord &rr)
 {
   if (rr.rdata.size() != 16)
   {
     throw DnsParseException("Invalid AAAA record data length");
   }
-  
+
   AAAARecord record(rr.name, "", rr.ttl);
-  
+
   // Use proper IPv6 canonical formatting with zero-compression
   char ipv6Str[INET6_ADDRSTRLEN];
   struct in6_addr addr;
   std::memcpy(&addr, rr.rdata.data(), 16);
-  
+
   if (inet_ntop(AF_INET6, &addr, ipv6Str, INET6_ADDRSTRLEN) != nullptr)
   {
     record.address = std::string(ipv6Str);
@@ -856,204 +850,203 @@ inline AAAARecord DnsMessage::parseAAAARecord(const DnsResourceRecord& rr)
     std::ostringstream oss;
     for (int i = 0; i < 8; ++i)
     {
-      if (i > 0) oss << ":";
-      std::uint16_t segment = (rr.rdata[i*2] << 8) | rr.rdata[i*2+1];
+      if (i > 0)
+        oss << ":";
+      std::uint16_t segment = (rr.rdata[i * 2] << 8) | rr.rdata[i * 2 + 1];
       oss << std::hex << std::setw(4) << std::setfill('0') << segment;
     }
     record.address = oss.str();
   }
-  
+
   return record;
 }
 
-inline SrvRecord DnsMessage::parseSrvRecord(const DnsResourceRecord& rr, 
-                                           const std::uint8_t* messageData, 
-                                           std::size_t messageSize,
-                                           std::size_t rdataOffset)
+inline SrvRecord DnsMessage::parseSrvRecord(const DnsResourceRecord &rr,
+                                            const std::uint8_t *messageData,
+                                            std::size_t messageSize, std::size_t rdataOffset)
 {
   if (rr.rdata.size() < 6)
   {
     throw DnsParseException("Invalid SRV record data length");
   }
-  
+
   SrvRecord record(rr.name, 0, 0, 0, "", rr.ttl);
-  
+
   record.priority = readUint16(rr.rdata.data(), 0);
   record.weight = readUint16(rr.rdata.data(), 2);
   record.port = readUint16(rr.rdata.data(), 4);
-  
+
   // Parse target name with proper compression support
   if (messageData != nullptr && messageSize > 0)
   {
     std::size_t nameOffset = 6; // Target name starts after priority(2) + weight(2) + port(2)
     if (nameOffset < rr.rdata.size())
     {
-      decodeNameFromRdata(messageData, messageSize, rdataOffset, nameOffset, 
-                         rr.rdata.data(), rr.rdata.size(), record.target);
+      decodeNameFromRdata(messageData, messageSize, rdataOffset, nameOffset, rr.rdata.data(),
+                          rr.rdata.size(), record.target);
     }
   }
-  
+
   return record;
 }
 
-inline NaptrRecord DnsMessage::parseNaptrRecord(const DnsResourceRecord& rr,
-                                               const std::uint8_t* messageData,
-                                               std::size_t messageSize,
-                                               std::size_t rdataOffset)
+inline NaptrRecord DnsMessage::parseNaptrRecord(const DnsResourceRecord &rr,
+                                                const std::uint8_t *messageData,
+                                                std::size_t messageSize, std::size_t rdataOffset)
 {
   if (rr.rdata.size() < 4)
   {
     throw DnsParseException("Invalid NAPTR record data length");
   }
-  
+
   NaptrRecord record(rr.name, 0, 0, "", "", "", "", rr.ttl);
-  
+
   std::size_t offset = 0;
-  
+
   record.order = readUint16(rr.rdata.data(), offset);
   offset += 2;
   record.preference = readUint16(rr.rdata.data(), offset);
   offset += 2;
-  
+
   // Parse strings: flags, service, regexp, replacement
-  auto parseString = [&](std::string& str) {
-    if (offset >= rr.rdata.size()) return;
+  auto parseString = [&](std::string &str)
+  {
+    if (offset >= rr.rdata.size())
+      return;
     std::uint8_t len = rr.rdata[offset++];
-    if (offset + len > rr.rdata.size()) return;
-    str.assign(reinterpret_cast<const char*>(rr.rdata.data() + offset), len);
+    if (offset + len > rr.rdata.size())
+      return;
+    str.assign(reinterpret_cast<const char *>(rr.rdata.data() + offset), len);
     offset += len;
   };
-  
+
   parseString(record.flags);
   parseString(record.service);
   parseString(record.regexp);
-  
+
   // Parse replacement domain name with proper compression support
   if (offset < rr.rdata.size() && messageData != nullptr && messageSize > 0)
   {
-    decodeNameFromRdata(messageData, messageSize, rdataOffset, offset, 
-                       rr.rdata.data(), rr.rdata.size(), record.replacement);
+    decodeNameFromRdata(messageData, messageSize, rdataOffset, offset, rr.rdata.data(),
+                        rr.rdata.size(), record.replacement);
   }
-  
+
   return record;
 }
 
-inline CnameRecord DnsMessage::parseCnameRecord(const DnsResourceRecord& rr,
-                                               const std::uint8_t* messageData,
-                                               std::size_t messageSize,
-                                               std::size_t rdataOffset)
+inline CnameRecord DnsMessage::parseCnameRecord(const DnsResourceRecord &rr,
+                                                const std::uint8_t *messageData,
+                                                std::size_t messageSize, std::size_t rdataOffset)
 {
   CnameRecord record(rr.name, "", rr.ttl);
-  
+
   // Parse CNAME with proper compression support
   if (!rr.rdata.empty() && messageData != nullptr && messageSize > 0)
   {
-    decodeNameFromRdata(messageData, messageSize, rdataOffset, 0, 
-                       rr.rdata.data(), rr.rdata.size(), record.cname);
+    decodeNameFromRdata(messageData, messageSize, rdataOffset, 0, rr.rdata.data(), rr.rdata.size(),
+                        record.cname);
   }
-  
+
   return record;
 }
 
-inline MxRecord DnsMessage::parseMxRecord(const DnsResourceRecord& rr,
-                                         const std::uint8_t* messageData,
-                                         std::size_t messageSize,
-                                         std::size_t rdataOffset)
+inline MxRecord DnsMessage::parseMxRecord(const DnsResourceRecord &rr,
+                                          const std::uint8_t *messageData, std::size_t messageSize,
+                                          std::size_t rdataOffset)
 {
   if (rr.rdata.size() < 2)
   {
     throw DnsParseException("Invalid MX record data length");
   }
-  
+
   MxRecord record(rr.name, 0, "", rr.ttl);
-  
+
   record.preference = readUint16(rr.rdata.data(), 0);
-  
+
   // Parse exchange name with proper compression support
   if (rr.rdata.size() > 2 && messageData != nullptr && messageSize > 0)
   {
     std::size_t nameOffset = 2; // Exchange name starts after preference(2)
-    decodeNameFromRdata(messageData, messageSize, rdataOffset, nameOffset, 
-                       rr.rdata.data(), rr.rdata.size(), record.exchange);
+    decodeNameFromRdata(messageData, messageSize, rdataOffset, nameOffset, rr.rdata.data(),
+                        rr.rdata.size(), record.exchange);
   }
-  
+
   return record;
 }
 
-inline TxtRecord DnsMessage::parseTxtRecord(const DnsResourceRecord& rr)
+inline TxtRecord DnsMessage::parseTxtRecord(const DnsResourceRecord &rr)
 {
   TxtRecord record(rr.name, {}, rr.ttl);
-  
+
   std::size_t offset = 0;
   while (offset < rr.rdata.size())
   {
     std::uint8_t len = rr.rdata[offset++];
-    if (offset + len > rr.rdata.size()) break;
-    
-    std::string text(reinterpret_cast<const char*>(rr.rdata.data() + offset), len);
+    if (offset + len > rr.rdata.size())
+      break;
+
+    std::string text(reinterpret_cast<const char *>(rr.rdata.data() + offset), len);
     record.text.push_back(text);
     offset += len;
   }
-  
+
   return record;
 }
 
-inline PtrRecord DnsMessage::parsePtrRecord(const DnsResourceRecord& rr,
-                                           const std::uint8_t* messageData,
-                                           std::size_t messageSize,
-                                           std::size_t rdataOffset)
+inline PtrRecord DnsMessage::parsePtrRecord(const DnsResourceRecord &rr,
+                                            const std::uint8_t *messageData,
+                                            std::size_t messageSize, std::size_t rdataOffset)
 {
   PtrRecord record(rr.name, "", rr.ttl);
-  
+
   // Parse PTR domain name with proper compression support
   if (!rr.rdata.empty() && messageData != nullptr && messageSize > 0)
   {
-    decodeNameFromRdata(messageData, messageSize, rdataOffset, 0, 
-                       rr.rdata.data(), rr.rdata.size(), record.ptrdname);
+    decodeNameFromRdata(messageData, messageSize, rdataOffset, 0, rr.rdata.data(), rr.rdata.size(),
+                        record.ptrdname);
   }
-  
+
   return record;
 }
 
-inline SoaRecord DnsMessage::parseSoaRecord(const DnsResourceRecord& rr,
-                                           const std::uint8_t* messageData,
-                                           std::size_t messageSize,
-                                           std::size_t rdataOffset)
+inline SoaRecord DnsMessage::parseSoaRecord(const DnsResourceRecord &rr,
+                                            const std::uint8_t *messageData,
+                                            std::size_t messageSize, std::size_t rdataOffset)
 {
   // SOA records require at least 20 bytes (2 names minimum + 5 * 4-byte integers)
   if (rr.rdata.size() < 20)
   {
     throw DnsParseException("Invalid SOA record data length");
   }
-  
+
   SoaRecord record(rr.name, "", "", 0, 0, 0, 0, 0, rr.ttl);
-  
+
   std::size_t offset = 0;
-  
+
   // Parse MNAME (primary nameserver) with compression support
   if (messageData != nullptr && messageSize > 0)
   {
-    offset = decodeNameFromRdata(messageData, messageSize, rdataOffset, offset, 
-                                rr.rdata.data(), rr.rdata.size(), record.mname);
+    offset = decodeNameFromRdata(messageData, messageSize, rdataOffset, offset, rr.rdata.data(),
+                                 rr.rdata.size(), record.mname);
   }
   else
   {
     throw DnsParseException("SOA parsing requires full message context for compression");
   }
-  
+
   // Parse RNAME (responsible person email) with compression support
   if (offset < rr.rdata.size())
   {
-    offset = decodeNameFromRdata(messageData, messageSize, rdataOffset, offset, 
-                                rr.rdata.data(), rr.rdata.size(), record.rname);
+    offset = decodeNameFromRdata(messageData, messageSize, rdataOffset, offset, rr.rdata.data(),
+                                 rr.rdata.size(), record.rname);
   }
-  
+
   // Parse 5 32-bit integers: SERIAL, REFRESH, RETRY, EXPIRE, MINIMUM
   if (offset + 20 > rr.rdata.size())
   {
     throw DnsParseException("SOA record truncated: insufficient data for numeric fields");
   }
-  
+
   record.serial = readUint32(rr.rdata.data(), offset);
   offset += 4;
   record.refresh = readUint32(rr.rdata.data(), offset);
@@ -1063,11 +1056,11 @@ inline SoaRecord DnsMessage::parseSoaRecord(const DnsResourceRecord& rr,
   record.expire = readUint32(rr.rdata.data(), offset);
   offset += 4;
   record.minimum = readUint32(rr.rdata.data(), offset);
-  
+
   return record;
 }
 
-inline void DnsMessage::validateRdataSecurity(const DnsResourceRecord& rr)
+inline void DnsMessage::validateRdataSecurity(const DnsResourceRecord &rr)
 {
   // Validate A records for malicious compression pointers and wrong lengths
   if (rr.type == DnsType::A)
@@ -1077,10 +1070,11 @@ inline void DnsMessage::validateRdataSecurity(const DnsResourceRecord& rr)
     if (rr.rdata.size() != 4)
     {
       // Check if the wrong-length RDATA contains compression pointers (definitely malicious)
-      if (rr.rdata.size() >= 2 && 
+      if (rr.rdata.size() >= 2 &&
           (rr.rdata[0] & constants::DNS_COMPRESSION_MASK) == constants::DNS_COMPRESSION_MASK)
       {
-        throw DnsParseException("Malicious compression pointer in A record RDATA with invalid length");
+        throw DnsParseException(
+          "Malicious compression pointer in A record RDATA with invalid length");
       }
       // If no compression pointer pattern, let normal parsing handle the length error
     }
@@ -1090,8 +1084,9 @@ inline void DnsMessage::validateRdataSecurity(const DnsResourceRecord& rr)
       if ((rr.rdata[0] & constants::DNS_COMPRESSION_MASK) == constants::DNS_COMPRESSION_MASK)
       {
         std::uint16_t pointer = ((rr.rdata[0] & 0x3F) << 8) | rr.rdata[1];
-        
-        // Additional check: if the remaining bytes are 0x00, 0x00, it's likely padding for a pointer
+
+        // Additional check: if the remaining bytes are 0x00, 0x00, it's likely padding for a
+        // pointer
         if (pointer < 64 && rr.rdata[2] == 0x00 && rr.rdata[3] == 0x00)
         {
           throw DnsParseException("Malicious compression pointer detected in A record RDATA");
@@ -1099,7 +1094,7 @@ inline void DnsMessage::validateRdataSecurity(const DnsResourceRecord& rr)
       }
     }
   }
-  
+
   // Validate other record types that should never contain compression pointers in RDATA
   if (rr.type == DnsType::TXT || rr.type == DnsType::AAAA)
   {
@@ -1107,13 +1102,13 @@ inline void DnsMessage::validateRdataSecurity(const DnsResourceRecord& rr)
     {
       if ((rr.rdata[i] & constants::DNS_COMPRESSION_MASK) == constants::DNS_COMPRESSION_MASK)
       {
-        throw DnsParseException("Malicious compression pointer detected in " + 
-                               std::to_string(static_cast<std::uint16_t>(rr.type)) + 
-                               " record RDATA at offset " + std::to_string(i));
+        throw DnsParseException("Malicious compression pointer detected in " +
+                                std::to_string(static_cast<std::uint16_t>(rr.type)) +
+                                " record RDATA at offset " + std::to_string(i));
       }
     }
   }
-  
+
   // Additional validation for other record types that shouldn't have compression pointers
   // in specific parts of their RDATA could be added here in the future
 }
diff --git a/include/iora/network/dns/dns_resolver.hpp b/include/iora/network/dns/dns_resolver.hpp
index a166cd0..b2ef626 100644
--- a/include/iora/network/dns/dns_resolver.hpp
+++ b/include/iora/network/dns/dns_resolver.hpp
@@ -6,17 +6,17 @@
 
 #pragma once
 
-#include "dns_types.hpp"
-#include "dns_transport.hpp"
 #include "dns_cache.hpp"
-#include <string>
-#include <vector>
-#include <memory>
-#include <functional>
-#include <regex>
-#include <random>
+#include "dns_transport.hpp"
+#include "dns_types.hpp"
 #include <algorithm>
 #include <cctype>
+#include <functional>
+#include <memory>
+#include <random>
+#include <regex>
+#include <string>
+#include <vector>
 
 namespace iora
 {
@@ -29,46 +29,54 @@ namespace dns
 /// Supports SIP and other service discovery protocols following RFC 3263
 enum class ServiceType
 {
-  SIPS_TLS,        ///< SIPS over TLS (secure)
-  SIPS_SCTP,       ///< SIPS over SCTP (secure)
-  SIP_TCP,         ///< SIP over TCP 
-  SIP_UDP,         ///< SIP over UDP
-  SIP_SCTP,        ///< SIP over SCTP
-  HTTP_TCP,        ///< HTTP over TCP (for generic HTTP service discovery)
-  HTTPS_TCP,       ///< HTTPS over TCP (secure HTTP)
-  Unknown          ///< Unknown or unsupported service
+  SIPS_TLS,  ///< SIPS over TLS (secure)
+  SIPS_SCTP, ///< SIPS over SCTP (secure)
+  SIP_TCP,   ///< SIP over TCP
+  SIP_UDP,   ///< SIP over UDP
+  SIP_SCTP,  ///< SIP over SCTP
+  HTTP_TCP,  ///< HTTP over TCP (for generic HTTP service discovery)
+  HTTPS_TCP, ///< HTTPS over TCP (secure HTTP)
+  Unknown    ///< Unknown or unsupported service
 };
 
 /// \brief Resolved service target with all connection details
 struct ServiceTarget
 {
-  std::string hostname;                         ///< Target hostname
-  std::uint16_t port;                           ///< Target port
-  ServiceType transport;                        ///< Transport protocol
-  std::uint16_t priority;                       ///< SRV priority (lower = higher priority)
-  std::uint16_t weight;                         ///< SRV weight for load balancing
-  std::vector<std::string> addresses;           ///< Resolved IP addresses (A/AAAA)
-  
+  std::string hostname;               ///< Target hostname
+  std::uint16_t port;                 ///< Target port
+  ServiceType transport;              ///< Transport protocol
+  std::uint16_t priority;             ///< SRV priority (lower = higher priority)
+  std::uint16_t weight;               ///< SRV weight for load balancing
+  std::vector<std::string> addresses; ///< Resolved IP addresses (A/AAAA)
+
   /// \brief Get transport protocol as string
   std::string getTransportString() const
   {
     switch (transport)
     {
-      case ServiceType::SIPS_TLS: return "tls";
-      case ServiceType::SIP_TCP: return "tcp";
-      case ServiceType::SIP_UDP: return "udp";
-      case ServiceType::SIP_SCTP: return "sctp";
-      case ServiceType::SIPS_SCTP: return "sctp";
-      case ServiceType::HTTP_TCP: return "tcp";
-      case ServiceType::HTTPS_TCP: return "tls";
-      default: return "unknown";
+    case ServiceType::SIPS_TLS:
+      return "tls";
+    case ServiceType::SIP_TCP:
+      return "tcp";
+    case ServiceType::SIP_UDP:
+      return "udp";
+    case ServiceType::SIP_SCTP:
+      return "sctp";
+    case ServiceType::SIPS_SCTP:
+      return "sctp";
+    case ServiceType::HTTP_TCP:
+      return "tcp";
+    case ServiceType::HTTPS_TCP:
+      return "tls";
+    default:
+      return "unknown";
     }
   }
-  
+
   /// \brief Check if this is a secure transport
   bool isSecure() const
   {
-    return transport == ServiceType::SIPS_TLS || transport == ServiceType::SIPS_SCTP || 
+    return transport == ServiceType::SIPS_TLS || transport == ServiceType::SIPS_SCTP ||
            transport == ServiceType::HTTPS_TCP;
   }
 };
@@ -77,30 +85,27 @@ struct ServiceTarget
 /// Follows RFC 3263 NAPTRSRVA/AAAA resolution chain
 struct ServiceResolutionResult
 {
-  std::vector<ServiceTarget> targets;           ///< Resolved targets (priority sorted)
-  std::string domain;                           ///< Original domain queried
-  bool fromCache{false};                        ///< Whether result came from cache
+  std::vector<ServiceTarget> targets;              ///< Resolved targets (priority sorted)
+  std::string domain;                              ///< Original domain queried
+  bool fromCache{false};                           ///< Whether result came from cache
   std::chrono::steady_clock::time_point timestamp; ///< Resolution timestamp
-  
+
   /// \brief Constructor
-  explicit ServiceResolutionResult(const std::string& d = "")
-    : domain(d), timestamp(std::chrono::steady_clock::now())
+  explicit ServiceResolutionResult(const std::string &d = "")
+      : domain(d), timestamp(std::chrono::steady_clock::now())
   {
   }
-  
+
   /// \brief Check if resolution was successful
-  bool isSuccess() const
-  {
-    return !targets.empty();
-  }
-  
+  bool isSuccess() const { return !targets.empty(); }
+
   /// \brief Get targets for specific transport
   /// \param transport Desired transport type
   /// \return Filtered targets
   std::vector<ServiceTarget> getTargetsForTransport(ServiceType transport) const
   {
     std::vector<ServiceTarget> filtered;
-    for (const auto& target : targets)
+    for (const auto &target : targets)
     {
       if (target.transport == transport)
       {
@@ -109,18 +114,18 @@ struct ServiceResolutionResult
     }
     return filtered;
   }
-  
+
   /// \brief Get preferred target with DETERMINISTIC weighted selection
-  /// 
+  ///
   /// IMPORTANT: This const overload uses a deterministic RNG seeded from candidate targets.
   /// This provides consistent, reproducible selection for the same set of targets,
   /// which is useful for testing and debugging. However, it does NOT provide proper
   /// load distribution in production environments.
-  /// 
+  ///
   /// For production randomness with proper load balancing, use:
   /// - getPreferredTarget(RNG&) with your own RNG
   /// - getPreferredTargetWithDefaultRng() for thread-local randomness
-  /// 
+  ///
   /// \return Selected target using deterministic weighted selection
   ServiceTarget getPreferredTarget() const
   {
@@ -128,12 +133,12 @@ struct ServiceResolutionResult
     {
       return ServiceTarget{};
     }
-    
+
     // Find all targets with highest priority (lowest numeric value)
     std::uint16_t best_priority = targets[0].priority;
     std::vector<ServiceTarget> candidates;
-    
-    for (const auto& target : targets)
+
+    for (const auto &target : targets)
     {
       if (target.priority < best_priority)
       {
@@ -146,53 +151,54 @@ struct ServiceResolutionResult
         candidates.push_back(target);
       }
     }
-    
+
     // If only one candidate, return it
     if (candidates.size() == 1)
     {
       return candidates[0];
     }
-    
+
     // Weight-based selection among equal priority targets
     std::uint32_t total_weight = 0;
-    for (const auto& candidate : candidates)
+    for (const auto &candidate : candidates)
     {
       total_weight += candidate.weight;
     }
-    
+
     if (total_weight == 0)
     {
       // All weights are 0, use deterministic RNG seeded from targets for consistent selection
       std::mt19937 deterministicRng;
       std::size_t seed = std::hash<std::size_t>{}(candidates.size());
-      for (const auto& candidate : candidates)
+      for (const auto &candidate : candidates)
       {
-        seed ^= std::hash<std::string>{}(candidate.hostname) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
+        seed ^=
+          std::hash<std::string>{}(candidate.hostname) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
         seed ^= std::hash<std::uint16_t>{}(candidate.port) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
       }
       deterministicRng.seed(static_cast<std::uint32_t>(seed));
-      
+
       std::uniform_int_distribution<size_t> dist(0, candidates.size() - 1);
       return candidates[dist(deterministicRng)];
     }
-    
+
     // RFC 2782 weighted selection with deterministic RNG seeded from candidates
     std::mt19937 deterministicRng;
     std::size_t seed = std::hash<std::uint32_t>{}(total_weight);
-    for (const auto& candidate : candidates)
+    for (const auto &candidate : candidates)
     {
       seed ^= std::hash<std::string>{}(candidate.hostname) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
       seed ^= std::hash<std::uint16_t>{}(candidate.port) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
       seed ^= std::hash<std::uint16_t>{}(candidate.weight) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
     }
     deterministicRng.seed(static_cast<std::uint32_t>(seed));
-    
+
     // Use the same weighted random logic as the RNG overload
     std::uniform_int_distribution<std::uint32_t> dist(0, total_weight - 1);
     std::uint32_t random_weight = dist(deterministicRng);
-    
+
     std::uint32_t cumulative_weight = 0;
-    for (const auto& candidate : candidates)
+    for (const auto &candidate : candidates)
     {
       cumulative_weight += candidate.weight;
       if (random_weight < cumulative_weight)
@@ -200,17 +206,17 @@ struct ServiceResolutionResult
         return candidate;
       }
     }
-    
+
     // Fallback (should never reach here)
     return candidates.back();
   }
-  
+
   /// \brief Get preferred target with PRODUCTION-GRADE random weighted selection
-  /// 
+  ///
   /// This method uses thread-local random number generation for proper load balancing
   /// in production environments. Each thread maintains its own RNG state seeded from
   /// std::random_device, providing excellent distribution across multiple targets.
-  /// 
+  ///
   /// \return Selected target using thread-local randomness (production recommended)
   ServiceTarget getPreferredTargetWithDefaultRng() const
   {
@@ -218,23 +224,22 @@ struct ServiceResolutionResult
     thread_local std::mt19937 productionRng(std::random_device{}());
     return getPreferredTarget(productionRng);
   }
-  
+
   /// \brief Get preferred target with RFC 2782 compliant weighted random selection
   /// \param rng Random number generator for weighted selection
   /// \return Selected target based on priority and weighted randomness
-  template<typename RNG>
-  ServiceTarget getPreferredTarget(RNG& rng) const
+  template <typename RNG> ServiceTarget getPreferredTarget(RNG &rng) const
   {
     if (targets.empty())
     {
       return ServiceTarget{};
     }
-    
+
     // Find all targets with highest priority (lowest numeric value)
     std::uint16_t best_priority = targets[0].priority;
     std::vector<ServiceTarget> candidates;
-    
-    for (const auto& target : targets)
+
+    for (const auto &target : targets)
     {
       if (target.priority < best_priority)
       {
@@ -247,33 +252,33 @@ struct ServiceResolutionResult
         candidates.push_back(target);
       }
     }
-    
+
     // If only one candidate, return it
     if (candidates.size() == 1)
     {
       return candidates[0];
     }
-    
+
     // RFC 2782 weighted random selection among equal priority targets
     std::uint32_t total_weight = 0;
-    for (const auto& candidate : candidates)
+    for (const auto &candidate : candidates)
     {
       total_weight += candidate.weight;
     }
-    
+
     if (total_weight == 0)
     {
       // All weights are 0, choose randomly among candidates
       std::uniform_int_distribution<size_t> dist(0, candidates.size() - 1);
       return candidates[dist(rng)];
     }
-    
+
     // Weighted random selection (RFC 2782)
     std::uniform_int_distribution<std::uint32_t> dist(0, total_weight - 1);
     std::uint32_t random_weight = dist(rng);
-    
+
     std::uint32_t cumulative_weight = 0;
-    for (const auto& candidate : candidates)
+    for (const auto &candidate : candidates)
     {
       cumulative_weight += candidate.weight;
       if (random_weight < cumulative_weight)
@@ -281,7 +286,7 @@ struct ServiceResolutionResult
         return candidate;
       }
     }
-    
+
     // Should never reach here, but return last candidate as fallback
     return candidates.back();
   }
@@ -291,21 +296,16 @@ struct ServiceResolutionResult
 class DnsResolverException : public std::exception
 {
 public:
-  explicit DnsResolverException(const std::string& message, DnsResponseCode code = DnsResponseCode::SERVFAIL)
-    : message_(message), responseCode_(code)
-  {
-  }
-  
-  const char* what() const noexcept override
-  {
-    return message_.c_str();
-  }
-  
-  DnsResponseCode getResponseCode() const noexcept
+  explicit DnsResolverException(const std::string &message,
+                                DnsResponseCode code = DnsResponseCode::SERVFAIL)
+      : message_(message), responseCode_(code)
   {
-    return responseCode_;
   }
 
+  const char *what() const noexcept override { return message_.c_str(); }
+
+  DnsResponseCode getResponseCode() const noexcept { return responseCode_; }
+
 private:
   std::string message_;
   DnsResponseCode responseCode_;
@@ -314,8 +314,8 @@ private:
 class DnsResolutionFailedException : public DnsResolverException
 {
 public:
-  explicit DnsResolutionFailedException(const std::string& domain, DnsResponseCode code)
-    : DnsResolverException("Failed to resolve domain: " + domain, code)
+  explicit DnsResolutionFailedException(const std::string &domain, DnsResponseCode code)
+      : DnsResolverException("Failed to resolve domain: " + domain, code)
   {
   }
 };
@@ -323,8 +323,9 @@ public:
 class DnsNoRecordsException : public DnsResolverException
 {
 public:
-  explicit DnsNoRecordsException(const std::string& domain, DnsType type)
-    : DnsResolverException("No " + typeToString(type) + " records found for: " + domain, DnsResponseCode::NXDOMAIN)
+  explicit DnsNoRecordsException(const std::string &domain, DnsType type)
+      : DnsResolverException("No " + typeToString(type) + " records found for: " + domain,
+                             DnsResponseCode::NXDOMAIN)
   {
   }
 
@@ -333,15 +334,24 @@ private:
   {
     switch (type)
     {
-      case DnsType::A: return "A";
-      case DnsType::AAAA: return "AAAA";
-      case DnsType::SRV: return "SRV";
-      case DnsType::NAPTR: return "NAPTR";
-      case DnsType::CNAME: return "CNAME";
-      case DnsType::MX: return "MX";
-      case DnsType::TXT: return "TXT";
-      case DnsType::PTR: return "PTR";
-      default: return "Unknown";
+    case DnsType::A:
+      return "A";
+    case DnsType::AAAA:
+      return "AAAA";
+    case DnsType::SRV:
+      return "SRV";
+    case DnsType::NAPTR:
+      return "NAPTR";
+    case DnsType::CNAME:
+      return "CNAME";
+    case DnsType::MX:
+      return "MX";
+    case DnsType::TXT:
+      return "TXT";
+    case DnsType::PTR:
+      return "PTR";
+    default:
+      return "Unknown";
     }
   }
 };
@@ -354,12 +364,13 @@ private:
 /// 3. A/AAAA queries to resolve hostnames to IP addresses
 /// 4. Intelligent caching and fallback mechanisms
 /// Supports SIP, HTTP, and other service discovery protocols.
-class DnsResolver
+class DnsResolver : public std::enable_shared_from_this<DnsResolver>
 {
 public:
   /// \brief Service resolution callback for async operations
-  using ServiceResolutionCallback = std::function<void(const ServiceResolutionResult&, const std::exception_ptr&)>;
-  
+  using ServiceResolutionCallback =
+    std::function<void(const ServiceResolutionResult &, const std::exception_ptr &)>;
+
   /// \brief Simple DNS query callback (uses DnsTransport::QueryCallback)
   using QueryCallback = DnsTransport::QueryCallback;
 
@@ -369,8 +380,8 @@ public:
   /// \param config DNS configuration
   explicit DnsResolver(std::shared_ptr<DnsTransport> transport,
                        std::shared_ptr<DnsCache> cache = nullptr,
-                       const DnsConfig& config = DnsConfig{})
-    : transport_(transport), cache_(cache), config_(config)
+                       const DnsConfig &config = DnsConfig{})
+      : transport_(transport), cache_(cache), config_(config)
   {
     // Initialize RNG with random seed for production use
     std::random_device rd;
@@ -379,25 +390,23 @@ public:
 
   /// \brief Set RNG seed for deterministic testing
   /// \param seed Seed value for reproducible randomness
-  void setRngSeed(std::uint32_t seed)
-  {
-    rng_.seed(seed);
-  }
+  void setRngSeed(std::uint32_t seed) { rng_.seed(seed); }
 
-  /// \brief Resolve service domain using RFC 3263 NAPTRSRVA/AAAA procedure  
+  /// \brief Resolve service domain using RFC 3263 NAPTRSRVA/AAAA procedure
   /// \param domain Service domain to resolve (e.g., "example.com", "sip.example.com")
   /// \param preferredTransports Preferred transport types in order of preference
   /// \return Service resolution result with prioritized targets
   /// \throws DnsResolverException on resolution failure
-  ServiceResolutionResult resolveServiceDomain(const std::string& domain, 
-                                               const std::vector<ServiceType>& preferredTransports = {})
+  ServiceResolutionResult
+  resolveServiceDomain(const std::string &domain,
+                       const std::vector<ServiceType> &preferredTransports = {})
   {
     // Validate input domain
     if (!validateHostname(domain))
     {
       throw DnsResolverException("Invalid hostname: " + sanitizeInput(domain, 100));
     }
-    
+
     // Check cache first
     if (cache_)
     {
@@ -415,7 +424,8 @@ public:
         }
         else
         {
-          iora::core::Logger::debug("DNS cached service resolution incomplete for domain: " + domain);
+          iora::core::Logger::debug("DNS cached service resolution incomplete for domain: " +
+                                    domain);
         }
       }
       else
@@ -423,22 +433,22 @@ public:
         iora::core::Logger::debug("DNS service resolution cache miss for domain: " + domain);
       }
     }
-    
+
     // Perform fresh resolution
     iora::core::Logger::debug("DNS starting fresh service resolution for domain: " + domain);
     auto startTime = std::chrono::steady_clock::now();
-    
+
     auto result = performServiceResolution(domain, preferredTransports);
-    
+
     auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
-        std::chrono::steady_clock::now() - startTime
-    ).count();
-    
-    iora::core::Logger::info("DNS fresh service resolution completed for domain: " + domain + 
-                            " duration=" + std::to_string(duration) + "ms" +
-                            " targets=" + std::to_string(result.targets.size()) +
-                            " success=" + (result.isSuccess() ? "true" : "false"));
-    
+                      std::chrono::steady_clock::now() - startTime)
+                      .count();
+
+    iora::core::Logger::info("DNS fresh service resolution completed for domain: " + domain +
+                             " duration=" + std::to_string(duration) + "ms" +
+                             " targets=" + std::to_string(result.targets.size()) +
+                             " success=" + (result.isSuccess() ? "true" : "false"));
+
     return result;
   }
 
@@ -446,8 +456,8 @@ public:
   /// \param domain Service domain to resolve
   /// \param callback Callback function for result notification
   /// \param preferredTransports Preferred transport types in order of preference
-  void resolveServiceDomainAsync(const std::string& domain, ServiceResolutionCallback callback,
-                                const std::vector<ServiceType>& preferredTransports = {})
+  void resolveServiceDomainAsync(const std::string &domain, ServiceResolutionCallback callback,
+                                 const std::vector<ServiceType> &preferredTransports = {})
   {
     // Check cache first
     if (cache_)
@@ -469,12 +479,14 @@ public:
           }
           else
           {
-            iora::core::Logger::debug("DNS cached async service resolution incomplete for domain: " + domain);
+            iora::core::Logger::debug(
+              "DNS cached async service resolution incomplete for domain: " + domain);
           }
         }
         catch (...)
         {
-          iora::core::Logger::debug("DNS cached async service resolution error for domain: " + domain);
+          iora::core::Logger::debug("DNS cached async service resolution error for domain: " +
+                                    domain);
           // Fall through to fresh resolution
         }
       }
@@ -483,42 +495,43 @@ public:
         iora::core::Logger::debug("DNS async service resolution cache miss for domain: " + domain);
       }
     }
-    
+
     // Perform async fresh resolution
     iora::core::Logger::debug("DNS starting async fresh service resolution for domain: " + domain);
-    auto startTime = std::make_shared<std::chrono::steady_clock::time_point>(
-        std::chrono::steady_clock::now()
-    );
-    
-    performServiceResolutionAsync(domain, 
-        [domain, startTime, callback](const ServiceResolutionResult& result, std::exception_ptr error) {
-            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
-                std::chrono::steady_clock::now() - *startTime
-            ).count();
-            
-            if (error)
-            {
-                iora::core::Logger::info("DNS async fresh service resolution failed for domain: " + domain + 
-                                        " duration=" + std::to_string(duration) + "ms");
-            }
-            else
-            {
-                iora::core::Logger::info("DNS async fresh service resolution completed for domain: " + domain + 
-                                        " duration=" + std::to_string(duration) + "ms" +
-                                        " targets=" + std::to_string(result.targets.size()) +
-                                        " success=" + (result.isSuccess() ? "true" : "false"));
-            }
-            
-            callback(result, error);
-        }, 
-        preferredTransports);
+    auto startTime =
+      std::make_shared<std::chrono::steady_clock::time_point>(std::chrono::steady_clock::now());
+
+    performServiceResolutionAsync(
+      domain,
+      [domain, startTime, callback](const ServiceResolutionResult &result, std::exception_ptr error)
+      {
+        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
+                          std::chrono::steady_clock::now() - *startTime)
+                          .count();
+
+        if (error)
+        {
+          iora::core::Logger::info("DNS async fresh service resolution failed for domain: " +
+                                   domain + " duration=" + std::to_string(duration) + "ms");
+        }
+        else
+        {
+          iora::core::Logger::info("DNS async fresh service resolution completed for domain: " +
+                                   domain + " duration=" + std::to_string(duration) + "ms" +
+                                   " targets=" + std::to_string(result.targets.size()) +
+                                   " success=" + (result.isSuccess() ? "true" : "false"));
+        }
+
+        callback(result, error);
+      },
+      preferredTransports);
   }
 
   /// \brief Perform standard DNS query
   /// \param question DNS question to resolve
   /// \return DNS query result
   /// \throws DnsResolverException on query failure
-  DnsResult query(const DnsQuestion& question)
+  DnsResult query(const DnsQuestion &question)
   {
     // Check cache first
     if (cache_)
@@ -534,10 +547,10 @@ public:
         return result;
       }
     }
-    
+
     // Perform query via transport
     DnsResult result = transport_->query(question);
-    
+
     // Cache results (positive and negative)
     if (cache_)
     {
@@ -551,19 +564,19 @@ public:
         cache_->putNegative(question, result, "Domain not found (NXDOMAIN)");
       }
     }
-    
+
     if (!result.isSuccess())
     {
       throw DnsResolutionFailedException(question.qname, result.header.rcode);
     }
-    
+
     return result;
   }
 
   /// \brief Perform DNS query asynchronously
   /// \param question DNS question to resolve
   /// \param callback Callback function for result
-  void queryAsync(const DnsQuestion& question, QueryCallback callback)
+  void queryAsync(const DnsQuestion &question, QueryCallback callback)
   {
     // Check cache first
     if (cache_)
@@ -574,7 +587,8 @@ public:
         // For negative cache hits, still need to pass the appropriate exception
         if (!result.isSuccess())
         {
-          auto dns_ex = std::make_exception_ptr(DnsResolutionFailedException(question.qname, result.header.rcode));
+          auto dns_ex = std::make_exception_ptr(
+            DnsResolutionFailedException(question.qname, result.header.rcode));
           callback(result, dns_ex);
           return;
         }
@@ -582,39 +596,43 @@ public:
         return;
       }
     }
-    
+
     // Perform async query
-    transport_->queryAsync(question, [this, question, callback](const DnsResult& result, const std::exception_ptr& ex)
-    {
-      if (ex)
-      {
-        callback(result, ex);
-        return;
-      }
-      
-      // Cache results (positive and negative)
-      if (cache_)
+    auto self = shared_from_this();
+    transport_->queryAsync(
+      question,
+      [self, question, callback](const DnsResult &result, const std::exception_ptr &ex)
       {
-        if (result.isSuccess())
+        if (ex)
         {
-          cache_->put(question, result);
+          callback(result, ex);
+          return;
         }
-        else if (result.header.rcode == DnsResponseCode::NXDOMAIN)
+
+        // Cache results (positive and negative)
+        if (self->cache_)
         {
-          // Negative caching for NXDOMAIN responses per RFC 2308
-          cache_->putNegative(question, result, "Domain not found (NXDOMAIN)");
+          if (result.isSuccess())
+          {
+            self->cache_->put(question, result);
+          }
+          else if (result.header.rcode == DnsResponseCode::NXDOMAIN)
+          {
+            // Negative caching for NXDOMAIN responses per RFC 2308
+            self->cache_->putNegative(question, result, "Domain not found (NXDOMAIN)");
+          }
         }
-      }
-      
-      if (!result.isSuccess())
-      {
-        auto dns_ex = std::make_exception_ptr(DnsResolutionFailedException(question.qname, result.header.rcode));
-        callback(result, dns_ex);
-        return;
-      }
-      
-      callback(result, nullptr);
-    });
+
+        if (!result.isSuccess())
+        {
+          auto dns_ex = std::make_exception_ptr(
+            DnsResolutionFailedException(question.qname, result.header.rcode));
+          callback(result, dns_ex);
+          return;
+        }
+
+        callback(result, nullptr);
+      });
   }
 
   /// \brief Resolve hostname to IP addresses
@@ -622,97 +640,120 @@ public:
   /// \param prefer_ipv6 Prefer IPv6 addresses if available
   /// \return Vector of IP address strings
   /// \throws DnsResolverException on resolution failure
-  std::vector<std::string> resolveHostname(const std::string& hostname, bool prefer_ipv6 = false)
+  std::vector<std::string> resolveHostname(const std::string &hostname, bool prefer_ipv6 = false)
   {
     // Validate input hostname
     if (!validateHostname(hostname))
     {
       throw DnsResolverException("Invalid hostname: " + sanitizeInput(hostname, 100));
     }
-    
-    std::vector<std::string> addresses;
-    
+
+    // Determine address resolution policy
+    // If prefer_ipv6 is explicitly set, honor it for backward compatibility
+    AddressResolutionPolicy policy = config_.addressResolutionPolicy;
+    if (prefer_ipv6 && policy == AddressResolutionPolicy::IPv4First)
+    {
+      policy = AddressResolutionPolicy::IPv6First;
+    }
+
+    std::vector<std::string> ipv4Addresses;
+    std::vector<std::string> ipv6Addresses;
+
     try
     {
-      if (prefer_ipv6)
+      // Query A records (IPv4) if policy allows
+      if (policy == AddressResolutionPolicy::IPv4Only ||
+          policy == AddressResolutionPolicy::IPv4First ||
+          policy == AddressResolutionPolicy::IPv6First)
       {
-        // Try AAAA first
         try
         {
-          DnsResult result = query(DnsQuestion(hostname, DnsType::AAAA, DnsClass::IN));
-          for (const auto& record : result.aaaa_records)
+          DnsResult ipv4Result = query(DnsQuestion(hostname, DnsType::A, DnsClass::IN));
+          for (const auto &record : ipv4Result.a_records)
           {
-            addresses.push_back(record.address);
+            ipv4Addresses.push_back(record.address);
           }
         }
-        catch (const DnsResolverException&)
-        {
-          // IPv6 failed, will try IPv4
-        }
-      }
-      
-      // Try A records (or if IPv6 failed)
-      if (addresses.empty())
-      {
-        DnsResult result = query(DnsQuestion(hostname, DnsType::A, DnsClass::IN));
-        for (const auto& record : result.a_records)
+        catch (const DnsResolverException &)
         {
-          addresses.push_back(record.address);
+          // IPv4 query failed, continue
         }
       }
-    }
-    catch (const DnsResolverException&)
-    {
-      // If preferred type failed, try the other
-      if (prefer_ipv6)
+
+      // Query AAAA records (IPv6) if policy allows
+      if (policy == AddressResolutionPolicy::IPv6Only ||
+          policy == AddressResolutionPolicy::IPv4First ||
+          policy == AddressResolutionPolicy::IPv6First)
       {
         try
         {
-          DnsResult result = query(DnsQuestion(hostname, DnsType::A, DnsClass::IN));
-          for (const auto& record : result.a_records)
+          DnsResult ipv6Result = query(DnsQuestion(hostname, DnsType::AAAA, DnsClass::IN));
+          for (const auto &record : ipv6Result.aaaa_records)
           {
-            addresses.push_back(record.address);
+            ipv6Addresses.push_back(record.address);
           }
         }
-        catch (const DnsResolverException&)
+        catch (const DnsResolverException &)
         {
-          throw DnsNoRecordsException(hostname, prefer_ipv6 ? DnsType::AAAA : DnsType::A);
+          // IPv6 query failed, continue
         }
       }
-      else
+
+      // Combine results according to policy
+      std::vector<std::string> addresses;
+
+      switch (policy)
       {
-        try
-        {
-          DnsResult result = query(DnsQuestion(hostname, DnsType::AAAA, DnsClass::IN));
-          for (const auto& record : result.aaaa_records)
-          {
-            addresses.push_back(record.address);
-          }
-        }
-        catch (const DnsResolverException&)
-        {
-          throw DnsNoRecordsException(hostname, DnsType::A);
-        }
+      case AddressResolutionPolicy::IPv4Only:
+        addresses = std::move(ipv4Addresses);
+        break;
+
+      case AddressResolutionPolicy::IPv6Only:
+        addresses = std::move(ipv6Addresses);
+        break;
+
+      case AddressResolutionPolicy::IPv4First:
+        // IPv4 addresses first, then IPv6
+        addresses.reserve(ipv4Addresses.size() + ipv6Addresses.size());
+        addresses.insert(addresses.end(), ipv4Addresses.begin(), ipv4Addresses.end());
+        addresses.insert(addresses.end(), ipv6Addresses.begin(), ipv6Addresses.end());
+        break;
+
+      case AddressResolutionPolicy::IPv6First:
+        // IPv6 addresses first, then IPv4
+        addresses.reserve(ipv6Addresses.size() + ipv4Addresses.size());
+        addresses.insert(addresses.end(), ipv6Addresses.begin(), ipv6Addresses.end());
+        addresses.insert(addresses.end(), ipv4Addresses.begin(), ipv4Addresses.end());
+        break;
+      }
+
+      // If no addresses found, throw exception
+      if (addresses.empty())
+      {
+        throw DnsNoRecordsException(
+          hostname, policy == AddressResolutionPolicy::IPv6Only ? DnsType::AAAA : DnsType::A);
       }
+
+      return addresses;
     }
-    
-    if (addresses.empty())
+    catch (const DnsResolverException &)
     {
-      throw DnsNoRecordsException(hostname, prefer_ipv6 ? DnsType::AAAA : DnsType::A);
+      // If both queries failed, throw appropriate exception
+      DnsType failedType =
+        (policy == AddressResolutionPolicy::IPv6Only) ? DnsType::AAAA : DnsType::A;
+      throw DnsNoRecordsException(hostname, failedType);
     }
-    
-    return addresses;
   }
 
   /// \brief Get preferred target from resolution result using resolver's RNG
-  /// 
+  ///
   /// This method provides access to RFC-compliant weighted random target selection
   /// using the resolver's internal RNG, which is essential for deterministic testing
   /// when a seed has been set via setRngSeed().
-  /// 
+  ///
   /// \param result Service resolution result containing prioritized targets
   /// \return Selected target based on priority and weighted randomness
-  ServiceTarget getPreferredTarget(const ServiceResolutionResult& result) const
+  ServiceTarget getPreferredTarget(const ServiceResolutionResult &result) const
   {
     return result.getPreferredTarget(rng_);
   }
@@ -720,68 +761,73 @@ public:
   /// \brief Handle direct SRV resolution when no NAPTR records exist (generic version)
   /// \param domain Domain to resolve
   /// \param preferredTransports Preferred transport types
-  /// \param srvQueries Custom SRV queries to perform (defaults to SIP services for backward compatibility)
+  /// \param srvQueries Custom SRV queries to perform (defaults to SIP services for backward
+  /// compatibility)
   /// \return Service resolution result
-  ServiceResolutionResult performDirectSrvResolution(const std::string& domain,
-                                                const std::vector<ServiceType>& preferredTransports,
-                                                const std::optional<std::vector<std::pair<std::string, ServiceType>>>& srvQueries = std::nullopt)
+  ServiceResolutionResult performDirectSrvResolution(
+    const std::string &domain, const std::vector<ServiceType> &preferredTransports,
+    const std::optional<std::vector<std::pair<std::string, ServiceType>>> &srvQueries =
+      std::nullopt)
   {
     ServiceResolutionResult result(domain);
-    
+
     // Use provided SRV queries or default to common SIP services for backward compatibility
     std::vector<std::pair<std::string, ServiceType>> actualSrvQueries;
-    if (srvQueries.has_value()) {
+    if (srvQueries.has_value())
+    {
       actualSrvQueries = srvQueries.value();
-    } else {
-      actualSrvQueries = {
-        {"_sips._tcp." + domain, ServiceType::SIPS_TLS},
-        {"_sip._tcp." + domain, ServiceType::SIP_TCP},
-        {"_sip._udp." + domain, ServiceType::SIP_UDP},
-        {"_sip._sctp." + domain, ServiceType::SIP_SCTP}
-      };
-    }
-    
+    }
+    else
+    {
+      actualSrvQueries = {{"_sips._tcp." + domain, ServiceType::SIPS_TLS},
+                          {"_sip._tcp." + domain, ServiceType::SIP_TCP},
+                          {"_sip._udp." + domain, ServiceType::SIP_UDP},
+                          {"_sip._sctp." + domain, ServiceType::SIP_SCTP}};
+    }
+
     // Reorder based on preferences
     if (!preferredTransports.empty())
     {
       std::sort(actualSrvQueries.begin(), actualSrvQueries.end(),
-        [&preferredTransports](const auto& a, const auto& b)
-        {
-          auto pos_a = std::find(preferredTransports.begin(), preferredTransports.end(), a.second);
-          auto pos_b = std::find(preferredTransports.begin(), preferredTransports.end(), b.second);
-          
-          if (pos_a == preferredTransports.end() && pos_b == preferredTransports.end())
-          {
-            return false; // Both not preferred, keep original order
-          }
-          if (pos_a == preferredTransports.end())
-          {
-            return false; // a not preferred, b preferred
-          }
-          if (pos_b == preferredTransports.end())
-          {
-            return true; // a preferred, b not preferred
-          }
-          
-          return pos_a < pos_b; // Both preferred, order by preference
-        });
+                [&preferredTransports](const auto &a, const auto &b)
+                {
+                  auto pos_a =
+                    std::find(preferredTransports.begin(), preferredTransports.end(), a.second);
+                  auto pos_b =
+                    std::find(preferredTransports.begin(), preferredTransports.end(), b.second);
+
+                  if (pos_a == preferredTransports.end() && pos_b == preferredTransports.end())
+                  {
+                    return false; // Both not preferred, keep original order
+                  }
+                  if (pos_a == preferredTransports.end())
+                  {
+                    return false; // a not preferred, b preferred
+                  }
+                  if (pos_b == preferredTransports.end())
+                  {
+                    return true; // a preferred, b not preferred
+                  }
+
+                  return pos_a < pos_b; // Both preferred, order by preference
+                });
     }
-    
+
     // Query SRV records
-    for (const auto& [srvName, service] : actualSrvQueries)
+    for (const auto &[srvName, service] : actualSrvQueries)
     {
       try
       {
         DnsResult srvResult = query(DnsQuestion(srvName, DnsType::SRV, DnsClass::IN));
         processSrvRecords(srvResult.srv_records, service, result);
       }
-      catch (const DnsResolverException&)
+      catch (const DnsResolverException &)
       {
         // Skip failed queries
         continue;
       }
     }
-    
+
     // If no SRV records found, fall back to A/AAAA records
     if (result.targets.empty())
     {
@@ -792,7 +838,7 @@ public:
       resolveTargetAddresses(result);
       sortTargetsByPriority(result);
     }
-    
+
     return result;
   }
 
@@ -800,99 +846,108 @@ public:
   /// \param domain Domain to resolve
   /// \param callback Result callback
   /// \param preferredTransports Preferred transport types
-  /// \param srvQueries Custom SRV queries to perform (defaults to SIP services for backward compatibility)
-  void performDirectSrvResolutionAsync(const std::string& domain, ServiceResolutionCallback callback,
-                                      const std::vector<ServiceType>& preferredTransports,
-                                      const std::optional<std::vector<std::pair<std::string, ServiceType>>>& srvQueries = std::nullopt)
+  /// \param srvQueries Custom SRV queries to perform (defaults to SIP services for backward
+  /// compatibility)
+  void performDirectSrvResolutionAsync(
+    const std::string &domain, ServiceResolutionCallback callback,
+    const std::vector<ServiceType> &preferredTransports,
+    const std::optional<std::vector<std::pair<std::string, ServiceType>>> &srvQueries =
+      std::nullopt)
   {
     // Use provided SRV queries or default to common SIP services for backward compatibility
     std::vector<std::pair<std::string, ServiceType>> actualSrvQueries;
-    if (srvQueries.has_value()) {
+    if (srvQueries.has_value())
+    {
       actualSrvQueries = srvQueries.value();
-    } else {
-      actualSrvQueries = {
-        {"_sips._tcp." + domain, ServiceType::SIPS_TLS},
-        {"_sip._tcp." + domain, ServiceType::SIP_TCP},
-        {"_sip._udp." + domain, ServiceType::SIP_UDP},
-        {"_sip._sctp." + domain, ServiceType::SIP_SCTP}
-      };
-    }
-    
+    }
+    else
+    {
+      actualSrvQueries = {{"_sips._tcp." + domain, ServiceType::SIPS_TLS},
+                          {"_sip._tcp." + domain, ServiceType::SIP_TCP},
+                          {"_sip._udp." + domain, ServiceType::SIP_UDP},
+                          {"_sip._sctp." + domain, ServiceType::SIP_SCTP}};
+    }
+
     // Reorder based on preferences
     if (!preferredTransports.empty())
     {
       std::sort(actualSrvQueries.begin(), actualSrvQueries.end(),
-        [&preferredTransports](const auto& a, const auto& b)
-        {
-          auto pos_a = std::find(preferredTransports.begin(), preferredTransports.end(), a.second);
-          auto pos_b = std::find(preferredTransports.begin(), preferredTransports.end(), b.second);
-          
-          if (pos_a == preferredTransports.end() && pos_b == preferredTransports.end())
-          {
-            return false; // Both not preferred, keep original order
-          }
-          if (pos_a == preferredTransports.end())
-          {
-            return false; // a not preferred, b preferred
-          }
-          if (pos_b == preferredTransports.end())
-          {
-            return true; // a preferred, b not preferred
-          }
-          
-          return pos_a < pos_b; // Both preferred, order by preference
-        });
+                [&preferredTransports](const auto &a, const auto &b)
+                {
+                  auto pos_a =
+                    std::find(preferredTransports.begin(), preferredTransports.end(), a.second);
+                  auto pos_b =
+                    std::find(preferredTransports.begin(), preferredTransports.end(), b.second);
+
+                  if (pos_a == preferredTransports.end() && pos_b == preferredTransports.end())
+                  {
+                    return false; // Both not preferred, keep original order
+                  }
+                  if (pos_a == preferredTransports.end())
+                  {
+                    return false; // a not preferred, b preferred
+                  }
+                  if (pos_b == preferredTransports.end())
+                  {
+                    return true; // a preferred, b not preferred
+                  }
+
+                  return pos_a < pos_b; // Both preferred, order by preference
+                });
     }
-    
+
     // Chain SRV queries asynchronously
     auto result = std::make_shared<ServiceResolutionResult>(domain);
     auto remainingQueries = std::make_shared<std::atomic<size_t>>(actualSrvQueries.size());
     // firstCompleter ensures only the first thread to complete calls the callback
     auto firstCompleter = std::make_shared<std::atomic<bool>>(false);
-    
-    for (const auto& [srvName, service] : actualSrvQueries)
+
+    for (const auto &[srvName, service] : actualSrvQueries)
     {
       DnsQuestion srvQuestion(srvName, DnsType::SRV, DnsClass::IN);
-      
-      transport_->queryAsync(srvQuestion, [this, result, service, remainingQueries, firstCompleter, callback, domain, preferredTransports]
-        (const DnsResult& srvResult, const std::exception_ptr& srvError)
-      {
-        if (!srvError && !firstCompleter->load())
-        {
-          try
-          {
-            processSrvRecords(srvResult.srv_records, service, *result);
-          }
-          catch (...)
-          {
-            // Ignore individual SRV processing errors
-          }
-        }
-        
-        // Check if all SRV queries are complete
-        if (--(*remainingQueries) == 0 && !firstCompleter->exchange(true))
+
+      auto self = shared_from_this();
+      transport_->queryAsync(
+        srvQuestion,
+        [self, result, service, remainingQueries, firstCompleter, callback, domain,
+         preferredTransports](const DnsResult &srvResult, const std::exception_ptr &srvError)
         {
-          // If no SRV records found, fall back to A/AAAA
-          if (result->targets.empty())
+          if (!srvError && !firstCompleter->load())
           {
-            performFallbackResolutionAsync(domain, result, callback, preferredTransports);
+            try
+            {
+              self->processSrvRecords(srvResult.srv_records, service, *result);
+            }
+            catch (...)
+            {
+              // Ignore individual SRV processing errors
+            }
           }
-          else
+
+          // Check if all SRV queries are complete
+          if (--(*remainingQueries) == 0 && !firstCompleter->exchange(true))
           {
-            resolveTargetAddressesAsync(result, callback);
+            // If no SRV records found, fall back to A/AAAA
+            if (result->targets.empty())
+            {
+              self->performFallbackResolutionAsync(domain, result, callback, preferredTransports);
+            }
+            else
+            {
+              self->resolveTargetAddressesAsync(result, callback);
+            }
           }
-        }
-      });
+        });
     }
   }
 
 private:
-  std::shared_ptr<DnsTransport> transport_;     ///< DNS transport layer
-  std::shared_ptr<DnsCache> cache_;             ///< DNS cache (optional)
-  DnsConfig config_;                            ///< DNS configuration
-  
+  std::shared_ptr<DnsTransport> transport_; ///< DNS transport layer
+  std::shared_ptr<DnsCache> cache_;         ///< DNS cache (optional)
+  DnsConfig config_;                        ///< DNS configuration
+
   /// \brief Centralized random number generator for deterministic testing
-  mutable std::mt19937 rng_;                    ///< Thread-local not needed since resolver is stateful
+  mutable std::mt19937 rng_; ///< Thread-local not needed since resolver is stateful
 
   // =============================================================================
   // Input Validation Functions (RFC Compliance & Security)
@@ -901,31 +956,31 @@ private:
   /// \brief Validate hostname according to RFC 1035
   /// \param hostname Hostname to validate
   /// \return true if valid, false otherwise
-  bool validateHostname(const std::string& hostname) const
+  bool validateHostname(const std::string &hostname) const
   {
     if (hostname.empty() || hostname.length() > 255)
     {
       return false; // RFC 1035: max 255 chars
     }
-    
+
     if (hostname.front() == '.')
     {
       return false; // Leading dot not allowed
     }
-    
+
     // Handle FQDN (trailing dot indicates fully qualified domain name)
     std::string normalizedHostname = hostname;
     if (normalizedHostname.back() == '.')
     {
       normalizedHostname.pop_back(); // Remove trailing dot for validation
-      
-      // Empty after removing trailing dot is invalid  
+
+      // Empty after removing trailing dot is invalid
       if (normalizedHostname.empty())
       {
         return false;
       }
     }
-    
+
     // Check labels (separated by dots) using normalized hostname
     std::size_t labelStart = 0;
     for (std::size_t i = 0; i <= normalizedHostname.length(); ++i)
@@ -937,7 +992,7 @@ private:
         {
           return false; // RFC 1035: max 63 chars per label, no empty labels
         }
-        
+
         // Validate label characters
         for (std::size_t j = labelStart; j < i; ++j)
         {
@@ -951,31 +1006,31 @@ private:
             return false; // Hyphen not allowed at start/end of label
           }
         }
-        
+
         labelStart = i + 1;
       }
     }
-    
+
     return true;
   }
 
   /// \brief Validate NAPTR service field according to RFC 3403
   /// \param service NAPTR service string
   /// \return true if valid, false otherwise
-  bool validateNaptrService(const std::string& service) const
+  bool validateNaptrService(const std::string &service) const
   {
     if (service.empty() || service.length() > 255)
     {
       return false; // Reasonable length limit
     }
-    
+
     // Check for valid SIP service patterns
-    if (service == "SIPS+D2T" || service == "SIPS+D2S" || 
-        service == "SIP+D2T" || service == "SIP+D2U" || service == "SIP+D2S")
+    if (service == "SIPS+D2T" || service == "SIPS+D2S" || service == "SIP+D2T" ||
+        service == "SIP+D2U" || service == "SIP+D2S")
     {
       return true; // Known good SIP services
     }
-    
+
     // Basic format validation: should be alphanumeric with +, -, _
     for (char c : service)
     {
@@ -984,51 +1039,51 @@ private:
         return false; // Invalid character
       }
     }
-    
+
     return true;
   }
 
   /// \brief Validate NAPTR replacement field as hostname
-  /// \param replacement NAPTR replacement string  
+  /// \param replacement NAPTR replacement string
   /// \return true if valid, false otherwise
-  bool validateNaptrReplacement(const std::string& replacement) const
+  bool validateNaptrReplacement(const std::string &replacement) const
   {
     if (replacement == ".")
     {
       return true; // Terminal replacement
     }
-    
+
     return validateHostname(replacement);
   }
 
   /// \brief Validate NAPTR regex field (basic safety check)
   /// \param regex NAPTR regex pattern
   /// \return true if appears safe, false otherwise
-  bool validateNaptrRegex(const std::string& regex) const
+  bool validateNaptrRegex(const std::string &regex) const
   {
     if (regex.empty() || regex.length() > 255)
     {
       return false; // Reasonable length limit
     }
-    
+
     // Check for potentially dangerous regex constructs
     if (regex.find("(.*)(.*)") != std::string::npos)
     {
       return false; // Potential ReDoS pattern
     }
-    
+
     if (std::count(regex.begin(), regex.end(), '(') > 10)
     {
       return false; // Too many capture groups
     }
-    
+
     // Basic regex syntax validation
     try
     {
       std::regex testRegex(regex);
       return true;
     }
-    catch (const std::exception&)
+    catch (const std::exception &)
     {
       return false; // Invalid regex syntax
     }
@@ -1038,16 +1093,16 @@ private:
   /// \param input Input string to validate
   /// \param maxLength Maximum allowed length
   /// \return Sanitized string or empty if invalid
-  std::string sanitizeInput(const std::string& input, std::size_t maxLength = 255) const
+  std::string sanitizeInput(const std::string &input, std::size_t maxLength = 255) const
   {
     if (input.length() > maxLength)
     {
       return ""; // Reject oversized input
     }
-    
+
     std::string sanitized;
     sanitized.reserve(input.length());
-    
+
     for (char c : input)
     {
       // Allow printable ASCII characters only
@@ -1062,32 +1117,39 @@ private:
       }
       // Skip other characters
     }
-    
+
     return sanitized;
   }
 
   /// \brief Parse service type from NAPTR service field
   /// \param service NAPTR service string (e.g., "SIP+D2U", "SIPS+D2T", "HTTP+D2T")
   /// \return Parsed service type
-  ServiceType parseServiceType(const std::string& service) const
+  ServiceType parseServiceType(const std::string &service) const
   {
     // Validate service string first
     if (!validateNaptrService(service))
     {
       return ServiceType::Unknown;
     }
-    
+
     // SIP service mappings
-    if (service == "SIPS+D2T") return ServiceType::SIPS_TLS;
-    if (service == "SIPS+D2S") return ServiceType::SIPS_SCTP;
-    if (service == "SIP+D2T") return ServiceType::SIP_TCP;
-    if (service == "SIP+D2U") return ServiceType::SIP_UDP;
-    if (service == "SIP+D2S") return ServiceType::SIP_SCTP;
-    
+    if (service == "SIPS+D2T")
+      return ServiceType::SIPS_TLS;
+    if (service == "SIPS+D2S")
+      return ServiceType::SIPS_SCTP;
+    if (service == "SIP+D2T")
+      return ServiceType::SIP_TCP;
+    if (service == "SIP+D2U")
+      return ServiceType::SIP_UDP;
+    if (service == "SIP+D2S")
+      return ServiceType::SIP_SCTP;
+
     // HTTP service mappings
-    if (service == "HTTP+D2T") return ServiceType::HTTP_TCP;
-    if (service == "HTTPS+D2T") return ServiceType::HTTPS_TCP;
-    
+    if (service == "HTTP+D2T")
+      return ServiceType::HTTP_TCP;
+    if (service == "HTTPS+D2T")
+      return ServiceType::HTTPS_TCP;
+
     return ServiceType::Unknown;
   }
 
@@ -1098,14 +1160,22 @@ private:
   {
     switch (service)
     {
-      case ServiceType::SIPS_TLS: return 5061;
-      case ServiceType::SIPS_SCTP: return 5061;
-      case ServiceType::SIP_TCP: return 5060;
-      case ServiceType::SIP_UDP: return 5060;
-      case ServiceType::SIP_SCTP: return 5060;
-      case ServiceType::HTTP_TCP: return 80;
-      case ServiceType::HTTPS_TCP: return 443;
-      default: return 5060; // Default to SIP
+    case ServiceType::SIPS_TLS:
+      return 5061;
+    case ServiceType::SIPS_SCTP:
+      return 5061;
+    case ServiceType::SIP_TCP:
+      return 5060;
+    case ServiceType::SIP_UDP:
+      return 5060;
+    case ServiceType::SIP_SCTP:
+      return 5060;
+    case ServiceType::HTTP_TCP:
+      return 80;
+    case ServiceType::HTTPS_TCP:
+      return 443;
+    default:
+      return 5060; // Default to SIP
     }
   }
 
@@ -1113,11 +1183,12 @@ private:
   /// \param domain Domain to resolve
   /// \param preferredTransports Preferred transport types
   /// \return Service resolution result
-  ServiceResolutionResult performServiceResolution(const std::string& domain,
-                                                   const std::vector<ServiceType>& preferredTransports)
+  ServiceResolutionResult
+  performServiceResolution(const std::string &domain,
+                           const std::vector<ServiceType> &preferredTransports)
   {
     ServiceResolutionResult result(domain);
-    
+
     // Step 1: Query NAPTR records
     std::vector<NaptrRecord> naptrRecords;
     try
@@ -1125,37 +1196,37 @@ private:
       DnsResult naptrResult = query(DnsQuestion(domain, DnsType::NAPTR, DnsClass::IN));
       naptrRecords = naptrResult.naptr_records;
     }
-    catch (const DnsResolverException&)
+    catch (const DnsResolverException &)
     {
       // No NAPTR records, try direct SRV queries
       return performDirectSrvResolution(domain, preferredTransports, std::nullopt);
     }
-    
+
     // Step 2: Process NAPTR records to get SRV targets
     std::vector<std::pair<ServiceType, std::string>> srvTargets;
     processNaptrRecords(naptrRecords, srvTargets, preferredTransports);
-    
+
     // Step 3: Query SRV records for each target
-    for (const auto& [service, srvName] : srvTargets)
+    for (const auto &[service, srvName] : srvTargets)
     {
       try
       {
         DnsResult srvResult = query(DnsQuestion(srvName, DnsType::SRV, DnsClass::IN));
         processSrvRecords(srvResult.srv_records, service, result);
       }
-      catch (const DnsResolverException&)
+      catch (const DnsResolverException &)
       {
         // Skip failed SRV queries, continue with others
         continue;
       }
     }
-    
+
     // Step 4: Resolve hostnames to IP addresses
     resolveTargetAddresses(result);
-    
+
     // Step 5: Sort targets by priority
     sortTargetsByPriority(result);
-    
+
     return result;
   }
 
@@ -1163,103 +1234,107 @@ private:
   /// \param domain Domain to resolve
   /// \param callback Result callback
   /// \param preferredTransports Preferred transport types
-  void performServiceResolutionAsync(const std::string& domain, ServiceResolutionCallback callback,
-                                const std::vector<ServiceType>& preferredTransports)
+  void performServiceResolutionAsync(const std::string &domain, ServiceResolutionCallback callback,
+                                     const std::vector<ServiceType> &preferredTransports)
   {
     // Step 1: Start with async NAPTR query
     DnsQuestion naptrQuestion(domain, DnsType::NAPTR, DnsClass::IN);
-    
-    transport_->queryAsync(naptrQuestion, [this, domain, callback, preferredTransports]
-      (const DnsResult& naptrResult, const std::exception_ptr& naptrError)
-    {
-      if (naptrError)
-      {
-        // No NAPTR records, try direct SRV resolution
-        performDirectSrvResolutionAsync(domain, callback, preferredTransports, std::nullopt);
-        return;
-      }
-      
-      // Process NAPTR records to get SRV targets
-      std::vector<std::pair<ServiceType, std::string>> srvTargets;
-      try
-      {
-        processNaptrRecords(naptrResult.naptr_records, srvTargets, preferredTransports);
-      }
-      catch (const std::exception& e)
-      {
-        callback(ServiceResolutionResult(domain), std::make_exception_ptr(e));
-        return;
-      }
-      
-      if (srvTargets.empty())
-      {
-        // No valid SRV targets, try direct SRV resolution
-        performDirectSrvResolutionAsync(domain, callback, preferredTransports, std::nullopt);
-        return;
-      }
-      
-      // Chain SRV queries asynchronously
-      auto result = std::make_shared<ServiceResolutionResult>(domain);
-      auto remainingQueries = std::make_shared<std::atomic<size_t>>(srvTargets.size());
-      // firstCompleter ensures only the first thread to complete calls the callback
-      auto firstCompleter = std::make_shared<std::atomic<bool>>(false);
-      
-      for (const auto& [service, srvName] : srvTargets)
+
+    auto self = shared_from_this();
+    transport_->queryAsync(
+      naptrQuestion,
+      [self, domain, callback, preferredTransports](const DnsResult &naptrResult,
+                                                    const std::exception_ptr &naptrError)
       {
-        DnsQuestion srvQuestion(srvName, DnsType::SRV, DnsClass::IN);
-        
-        transport_->queryAsync(srvQuestion, [this, result, service, remainingQueries, firstCompleter, callback]
-          (const DnsResult& srvResult, const std::exception_ptr& srvError)
+        if (naptrError)
         {
-          if (!srvError && !firstCompleter->load())
-          {
-            try
-            {
-              processSrvRecords(srvResult.srv_records, service, *result);
-            }
-            catch (...)
+          // No NAPTR records, try direct SRV resolution
+          self->performDirectSrvResolutionAsync(domain, callback, preferredTransports, std::nullopt);
+          return;
+        }
+
+        // Process NAPTR records to get SRV targets
+        std::vector<std::pair<ServiceType, std::string>> srvTargets;
+        try
+        {
+          self->processNaptrRecords(naptrResult.naptr_records, srvTargets, preferredTransports);
+        }
+        catch (const std::exception &e)
+        {
+          callback(ServiceResolutionResult(domain), std::make_exception_ptr(e));
+          return;
+        }
+
+        if (srvTargets.empty())
+        {
+          // No valid SRV targets, try direct SRV resolution
+          self->performDirectSrvResolutionAsync(domain, callback, preferredTransports, std::nullopt);
+          return;
+        }
+
+        // Chain SRV queries asynchronously
+        auto result = std::make_shared<ServiceResolutionResult>(domain);
+        auto remainingQueries = std::make_shared<std::atomic<size_t>>(srvTargets.size());
+        // firstCompleter ensures only the first thread to complete calls the callback
+        auto firstCompleter = std::make_shared<std::atomic<bool>>(false);
+
+        for (const auto &[service, srvName] : srvTargets)
+        {
+          DnsQuestion srvQuestion(srvName, DnsType::SRV, DnsClass::IN);
+
+          self->transport_->queryAsync(
+            srvQuestion,
+            [self, result, service, remainingQueries, firstCompleter,
+             callback](const DnsResult &srvResult, const std::exception_ptr &srvError)
             {
-              // Ignore individual SRV processing errors
-            }
-          }
-          
-          // Check if all SRV queries are complete
-          if (--(*remainingQueries) == 0 && !firstCompleter->exchange(true))
-          {
-            // All SRV queries done, now resolve hostnames asynchronously
-            resolveTargetAddressesAsync(result, callback);
-          }
-        });
-      }
-    });
-  }
+              if (!srvError && !firstCompleter->load())
+              {
+                try
+                {
+                  self->processSrvRecords(srvResult.srv_records, service, *result);
+                }
+                catch (...)
+                {
+                  // Ignore individual SRV processing errors
+                }
+              }
 
+              // Check if all SRV queries are complete
+              if (--(*remainingQueries) == 0 && !firstCompleter->exchange(true))
+              {
+                // All SRV queries done, now resolve hostnames asynchronously
+                self->resolveTargetAddressesAsync(result, callback);
+              }
+            });
+        }
+      });
+  }
 
   /// \brief Process cached SIP resolution from NAPTR result
   /// \param result Result to populate
   /// \param naptrResult Cached NAPTR result
   /// \param preferredTransports Preferred transport types
-  void processCachedServiceResolution(ServiceResolutionResult& result, const DnsResult& naptrResult,
-                                 const std::vector<ServiceType>& preferredTransports)
+  void processCachedServiceResolution(ServiceResolutionResult &result, const DnsResult &naptrResult,
+                                      const std::vector<ServiceType> &preferredTransports)
   {
     // Step 1: Process NAPTR records to get SRV targets
     std::vector<std::pair<ServiceType, std::string>> srvTargets;
     processNaptrRecords(naptrResult.naptr_records, srvTargets, preferredTransports);
-    
+
     if (srvTargets.empty())
     {
       // No valid NAPTR targets found
       return;
     }
-    
+
     // Step 2: Try to get SRV records from cache for each target
-    for (const auto& [service, srvName] : srvTargets)
+    for (const auto &[service, srvName] : srvTargets)
     {
       if (!cache_)
       {
         continue;
       }
-      
+
       DnsQuestion srvQuestion(srvName, DnsType::SRV, DnsClass::IN);
       DnsResult srvResult;
       if (cache_->get(srvQuestion, srvResult))
@@ -1268,26 +1343,26 @@ private:
         processSrvRecords(srvResult.srv_records, service, result);
       }
     }
-    
+
     // Step 3: Try to resolve hostnames from cache
-    for (auto& target : result.targets)
+    for (auto &target : result.targets)
     {
       if (!cache_)
       {
         continue;
       }
-      
+
       // Try A records first
       DnsQuestion aQuestion(target.hostname, DnsType::A, DnsClass::IN);
       DnsResult aResult;
       if (cache_->get(aQuestion, aResult))
       {
-        for (const auto& record : aResult.a_records)
+        for (const auto &record : aResult.a_records)
         {
           target.addresses.push_back(record.address);
         }
       }
-      
+
       // Try AAAA records if no A records found or if we want both
       if (target.addresses.empty())
       {
@@ -1295,20 +1370,20 @@ private:
         DnsResult aaaaResult;
         if (cache_->get(aaaaQuestion, aaaaResult))
         {
-          for (const auto& record : aaaaResult.aaaa_records)
+          for (const auto &record : aaaaResult.aaaa_records)
           {
             target.addresses.push_back(record.address);
           }
         }
       }
     }
-    
+
     // Step 4: Remove targets with no resolved addresses
-    result.targets.erase(
-      std::remove_if(result.targets.begin(), result.targets.end(),
-        [](const ServiceTarget& target) { return target.addresses.empty(); }),
-      result.targets.end());
-    
+    result.targets.erase(std::remove_if(result.targets.begin(), result.targets.end(),
+                                        [](const ServiceTarget &target)
+                                        { return target.addresses.empty(); }),
+                         result.targets.end());
+
     // Step 5: Sort targets by priority
     sortTargetsByPriority(result);
   }
@@ -1317,40 +1392,41 @@ private:
   /// \param naptrRecords NAPTR records to process
   /// \param srvTargets Output vector of SRV targets
   /// \param preferredTransports Preferred transport types
-  void processNaptrRecords(const std::vector<NaptrRecord>& naptrRecords,
-                         std::vector<std::pair<ServiceType, std::string>>& srvTargets,
-                         const std::vector<ServiceType>& preferredTransports)
+  void processNaptrRecords(const std::vector<NaptrRecord> &naptrRecords,
+                           std::vector<std::pair<ServiceType, std::string>> &srvTargets,
+                           const std::vector<ServiceType> &preferredTransports)
   {
     // Sort NAPTR records by order then preference
     auto sortedRecords = naptrRecords;
     std::sort(sortedRecords.begin(), sortedRecords.end(),
-      [](const NaptrRecord& a, const NaptrRecord& b)
-      {
-        if (a.order != b.order)
-        {
-          return a.order < b.order;
-        }
-        return a.preference < b.preference;
-      });
-    
+              [](const NaptrRecord &a, const NaptrRecord &b)
+              {
+                if (a.order != b.order)
+                {
+                  return a.order < b.order;
+                }
+                return a.preference < b.preference;
+              });
+
     // Process records to extract SRV targets
-    for (const auto& record : sortedRecords)
+    for (const auto &record : sortedRecords)
     {
       ServiceType service = parseServiceType(record.service);
       if (service == ServiceType::Unknown)
       {
         continue;
       }
-      
+
       // Check if this service type is preferred (if preferences specified)
       if (!preferredTransports.empty())
       {
-        if (std::find(preferredTransports.begin(), preferredTransports.end(), service) == preferredTransports.end())
+        if (std::find(preferredTransports.begin(), preferredTransports.end(), service) ==
+            preferredTransports.end())
         {
           continue; // Skip non-preferred transports
         }
       }
-      
+
       // Extract SRV target from replacement field
       if (!record.replacement.empty() && record.flags.find('S') != std::string::npos)
       {
@@ -1363,10 +1439,10 @@ private:
   /// \param srvRecords SRV records to process
   /// \param service Service type for these records
   /// \param result Result to populate
-  void processSrvRecords(const std::vector<SrvRecord>& srvRecords, ServiceType service,
-                        ServiceResolutionResult& result)
+  void processSrvRecords(const std::vector<SrvRecord> &srvRecords, ServiceType service,
+                         ServiceResolutionResult &result)
   {
-    for (const auto& record : srvRecords)
+    for (const auto &record : srvRecords)
     {
       ServiceTarget target;
       target.hostname = record.target;
@@ -1374,64 +1450,62 @@ private:
       target.transport = service;
       target.priority = record.priority;
       target.weight = record.weight;
-      
+
       result.targets.push_back(target);
     }
   }
 
   /// \brief Resolve IP addresses for all targets
   /// \param result Result containing targets to resolve
-  void resolveTargetAddresses(ServiceResolutionResult& result)
+  void resolveTargetAddresses(ServiceResolutionResult &result)
   {
-    for (auto& target : result.targets)
+    for (auto &target : result.targets)
     {
       try
       {
         target.addresses = resolveHostname(target.hostname, false);
       }
-      catch (const DnsResolverException&)
+      catch (const DnsResolverException &)
       {
         // Skip targets that can't be resolved
         target.addresses.clear();
       }
     }
-    
+
     // Remove targets with no resolved addresses
-    result.targets.erase(
-      std::remove_if(result.targets.begin(), result.targets.end(),
-        [](const ServiceTarget& target) { return target.addresses.empty(); }),
-      result.targets.end());
+    result.targets.erase(std::remove_if(result.targets.begin(), result.targets.end(),
+                                        [](const ServiceTarget &target)
+                                        { return target.addresses.empty(); }),
+                         result.targets.end());
   }
 
   /// \brief Sort targets by priority (lower priority value = higher precedence)
   /// \param result Result to sort
-  void sortTargetsByPriority(ServiceResolutionResult& result)
+  void sortTargetsByPriority(ServiceResolutionResult &result)
   {
     std::sort(result.targets.begin(), result.targets.end(),
-      [](const ServiceTarget& a, const ServiceTarget& b)
-      {
-        return a.priority < b.priority;
-      });
+              [](const ServiceTarget &a, const ServiceTarget &b)
+              { return a.priority < b.priority; });
   }
 
   /// \brief Fallback to A/AAAA resolution when no SRV records exist
   /// \param domain Domain to resolve
   /// \param result Result to populate
   /// \param preferredTransports Preferred transport types
-  void performFallbackResolution(const std::string& domain, ServiceResolutionResult& result,
-                                const std::vector<ServiceType>& preferredTransports)
+  void performFallbackResolution(const std::string &domain, ServiceResolutionResult &result,
+                                 const std::vector<ServiceType> &preferredTransports)
   {
     try
     {
       auto addresses = resolveHostname(domain, false);
-      
+
       // Create targets for preferred transports (or default UDP if none specified)
       std::vector<ServiceType> transports = preferredTransports;
       if (transports.empty())
       {
         transports.push_back(ServiceType::SIP_UDP);
       }
-      
+
       for (ServiceType transport : transports)
       {
         ServiceTarget target;
@@ -1441,197 +1515,204 @@ private:
         target.priority = 0;
         target.weight = 0;
         target.addresses = addresses;
-        
+
         result.targets.push_back(target);
       }
     }
-    catch (const DnsResolverException&)
+    catch (const DnsResolverException &)
     {
       // No fallback possible
     }
   }
 
-
   /// \brief Perform fallback resolution asynchronously
   /// \param domain Domain to resolve
   /// \param result Shared result to populate
   /// \param callback Result callback
   /// \param preferredTransports Preferred transport types
-  void performFallbackResolutionAsync(const std::string& domain, 
-                                     std::shared_ptr<ServiceResolutionResult> result,
-                                     ServiceResolutionCallback callback,
-                                     const std::vector<ServiceType>& preferredTransports)
+  void performFallbackResolutionAsync(const std::string &domain,
+                                      std::shared_ptr<ServiceResolutionResult> result,
+                                      ServiceResolutionCallback callback,
+                                      const std::vector<ServiceType> &preferredTransports)
   {
     DnsQuestion aQuestion(domain, DnsType::A, DnsClass::IN);
-    
-    transport_->queryAsync(aQuestion, [this, domain, result, callback, preferredTransports]
-      (const DnsResult& aResult, const std::exception_ptr& aError)
-    {
-      std::vector<std::string> addresses;
-      
-      if (!aError)
-      {
-        for (const auto& record : aResult.a_records)
-        {
-          addresses.push_back(record.address);
-        }
-      }
-      
-      if (addresses.empty())
+
+    auto self = shared_from_this();
+    transport_->queryAsync(
+      aQuestion,
+      [self, domain, result, callback, preferredTransports](const DnsResult &aResult,
+                                                            const std::exception_ptr &aError)
       {
-        // Try AAAA if A failed
-        DnsQuestion aaaaQuestion(domain, DnsType::AAAA, DnsClass::IN);
-        
-        transport_->queryAsync(aaaaQuestion, [this, result, callback, domain, preferredTransports, addresses]
-          (const DnsResult& aaaaResult, const std::exception_ptr& aaaaError)
+        std::vector<std::string> addresses;
+
+        if (!aError)
         {
-          std::vector<std::string> finalAddresses = addresses;
-          
-          if (!aaaaError)
+          for (const auto &record : aResult.a_records)
           {
-            for (const auto& record : aaaaResult.aaaa_records)
-            {
-              finalAddresses.push_back(record.address);
-            }
+            addresses.push_back(record.address);
           }
-          
-          // Create fallback targets
+        }
+
+        if (addresses.empty())
+        {
+          // Try AAAA if A failed
+          DnsQuestion aaaaQuestion(domain, DnsType::AAAA, DnsClass::IN);
+
+          self->transport_->queryAsync(aaaaQuestion,
+                                 [self, result, callback, domain, preferredTransports, addresses](
+                                   const DnsResult &aaaaResult, const std::exception_ptr &aaaaError)
+                                 {
+                                   std::vector<std::string> finalAddresses = addresses;
+
+                                   if (!aaaaError)
+                                   {
+                                     for (const auto &record : aaaaResult.aaaa_records)
+                                     {
+                                       finalAddresses.push_back(record.address);
+                                     }
+                                   }
+
+                                   // Create fallback targets
+                                   std::vector<ServiceType> transports = preferredTransports;
+                                   if (transports.empty())
+                                   {
+                                     transports.push_back(ServiceType::SIP_UDP);
+                                   }
+
+                                   for (ServiceType transport : transports)
+                                   {
+                                     ServiceTarget target;
+                                     target.hostname = domain;
+                                     target.port = self->getDefaultServicePort(transport);
+                                     target.transport = transport;
+                                     target.priority = 0;
+                                     target.weight = 0;
+                                     target.addresses = finalAddresses;
+
+                                     result->targets.push_back(target);
+                                   }
+
+                                   callback(*result, nullptr);
+                                 });
+        }
+        else
+        {
+          // Create fallback targets with A records
           std::vector<ServiceType> transports = preferredTransports;
           if (transports.empty())
           {
             transports.push_back(ServiceType::SIP_UDP);
           }
-          
+
           for (ServiceType transport : transports)
           {
             ServiceTarget target;
             target.hostname = domain;
-            target.port = getDefaultServicePort(transport);
+            target.port = self->getDefaultServicePort(transport);
             target.transport = transport;
             target.priority = 0;
             target.weight = 0;
-            target.addresses = finalAddresses;
-            
+            target.addresses = addresses;
+
             result->targets.push_back(target);
           }
-          
+
           callback(*result, nullptr);
-        });
-      }
-      else
-      {
-        // Create fallback targets with A records
-        std::vector<ServiceType> transports = preferredTransports;
-        if (transports.empty())
-        {
-          transports.push_back(ServiceType::SIP_UDP);
-        }
-        
-        for (ServiceType transport : transports)
-        {
-          ServiceTarget target;
-          target.hostname = domain;
-          target.port = getDefaultServicePort(transport);
-          target.transport = transport;
-          target.priority = 0;
-          target.weight = 0;
-          target.addresses = addresses;
-          
-          result->targets.push_back(target);
         }
-        
-        callback(*result, nullptr);
-      }
-    });
+      });
   }
 
   /// \brief Resolve target addresses asynchronously
   /// \param result Result containing targets to resolve (must be shared_ptr for async safety)
   /// \param callback Result callback
-  void resolveTargetAddressesAsync(std::shared_ptr<ServiceResolutionResult> result, ServiceResolutionCallback callback)
+  void resolveTargetAddressesAsync(std::shared_ptr<ServiceResolutionResult> result,
+                                   ServiceResolutionCallback callback)
   {
     if (result->targets.empty())
     {
       callback(*result, nullptr);
       return;
     }
-    
+
     // Store initial target count to avoid race conditions during async operations
     const std::size_t initialTargetCount = result->targets.size();
     auto remainingTargets = std::make_shared<std::atomic<size_t>>(initialTargetCount);
-    
+
     // Process targets by index with bounds safety
     for (size_t targetIndex = 0; targetIndex < initialTargetCount; ++targetIndex)
     {
       std::string hostname = result->targets[targetIndex].hostname;
       DnsQuestion aQuestion(hostname, DnsType::A, DnsClass::IN);
-      
-      transport_->queryAsync(aQuestion, [this, targetIndex, initialTargetCount, remainingTargets, result, callback, hostname]
-        (const DnsResult& aResult, const std::exception_ptr& aError)
-      {
-        // Safe bounds check using initial count (targets vector won't be modified until all complete)
-        if (!aError && targetIndex < initialTargetCount)
+
+      transport_->queryAsync(
+        aQuestion,
+        [this, targetIndex, initialTargetCount, remainingTargets, result, callback,
+         hostname](const DnsResult &aResult, const std::exception_ptr &aError)
         {
-          for (const auto& record : aResult.a_records)
+          // Safe bounds check using initial count (targets vector won't be modified until all
+          // complete)
+          if (!aError && targetIndex < initialTargetCount)
           {
-            result->targets[targetIndex].addresses.push_back(record.address);
+            for (const auto &record : aResult.a_records)
+            {
+              result->targets[targetIndex].addresses.push_back(record.address);
+            }
           }
-        }
-        
-        // Try AAAA if no A records found
-        if (targetIndex < initialTargetCount && result->targets[targetIndex].addresses.empty())
-        {
-          DnsQuestion aaaaQuestion(hostname, DnsType::AAAA, DnsClass::IN);
-          
-          transport_->queryAsync(aaaaQuestion, [targetIndex, initialTargetCount, remainingTargets, result, callback]
-            (const DnsResult& aaaaResult, const std::exception_ptr& aaaaError)
+
+          // Try AAAA if no A records found
+          if (targetIndex < initialTargetCount && result->targets[targetIndex].addresses.empty())
           {
-            if (!aaaaError && targetIndex < initialTargetCount)
-            {
-              for (const auto& record : aaaaResult.aaaa_records)
+            DnsQuestion aaaaQuestion(hostname, DnsType::AAAA, DnsClass::IN);
+
+            transport_->queryAsync(
+              aaaaQuestion,
+              [targetIndex, initialTargetCount, remainingTargets, result,
+               callback](const DnsResult &aaaaResult, const std::exception_ptr &aaaaError)
               {
-                result->targets[targetIndex].addresses.push_back(record.address);
-              }
-            }
-            
+                if (!aaaaError && targetIndex < initialTargetCount)
+                {
+                  for (const auto &record : aaaaResult.aaaa_records)
+                  {
+                    result->targets[targetIndex].addresses.push_back(record.address);
+                  }
+                }
+
+                // Check if all targets are resolved
+                if (--(*remainingTargets) == 0)
+                {
+                  // Remove targets with no addresses and sort
+                  result->targets.erase(
+                    std::remove_if(result->targets.begin(), result->targets.end(),
+                                   [](const ServiceTarget &t) { return t.addresses.empty(); }),
+                    result->targets.end());
+
+                  std::sort(result->targets.begin(), result->targets.end(),
+                            [](const ServiceTarget &a, const ServiceTarget &b)
+                            { return a.priority < b.priority; });
+
+                  callback(*result, nullptr);
+                }
+              });
+          }
+          else
+          {
             // Check if all targets are resolved
             if (--(*remainingTargets) == 0)
             {
               // Remove targets with no addresses and sort
-              result->targets.erase(
-                std::remove_if(result->targets.begin(), result->targets.end(),
-                  [](const ServiceTarget& t) { return t.addresses.empty(); }),
-                result->targets.end());
-              
+              result->targets.erase(std::remove_if(result->targets.begin(), result->targets.end(),
+                                                   [](const ServiceTarget &t)
+                                                   { return t.addresses.empty(); }),
+                                    result->targets.end());
+
               std::sort(result->targets.begin(), result->targets.end(),
-                [](const ServiceTarget& a, const ServiceTarget& b) {
-                  return a.priority < b.priority;
-                });
-              
+                        [](const ServiceTarget &a, const ServiceTarget &b)
+                        { return a.priority < b.priority; });
+
               callback(*result, nullptr);
             }
-          });
-        }
-        else
-        {
-          // Check if all targets are resolved
-          if (--(*remainingTargets) == 0)
-          {
-            // Remove targets with no addresses and sort
-            result->targets.erase(
-              std::remove_if(result->targets.begin(), result->targets.end(),
-                [](const ServiceTarget& t) { return t.addresses.empty(); }),
-              result->targets.end());
-            
-            std::sort(result->targets.begin(), result->targets.end(),
-              [](const ServiceTarget& a, const ServiceTarget& b) {
-                return a.priority < b.priority;
-              });
-            
-            callback(*result, nullptr);
           }
-        }
-      });
+        });
     }
   }
 };
@@ -1644,14 +1725,14 @@ private:
 /// \deprecated Use ServiceType instead for broader applicability
 using SipServiceType = ServiceType;
 
-/// \brief Backward compatibility alias for SIP applications  
+/// \brief Backward compatibility alias for SIP applications
 /// \deprecated Use ServiceTarget instead for broader applicability
 using SipTarget = ServiceTarget;
 
 /// \brief Backward compatibility alias for SIP applications
-/// \deprecated Use ServiceResolutionResult instead for broader applicability 
+/// \deprecated Use ServiceResolutionResult instead for broader applicability
 using SipResolutionResult = ServiceResolutionResult;
 
 } // namespace dns
-} // namespace network  
+} // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/dns/dns_transport.hpp b/include/iora/network/dns/dns_transport.hpp
index 0ac13cc..37a2e0f 100644
--- a/include/iora/network/dns/dns_transport.hpp
+++ b/include/iora/network/dns/dns_transport.hpp
@@ -6,28 +6,28 @@
 
 #pragma once
 
-#include "dns_types.hpp"
 #include "dns_message.hpp"
+#include "dns_types.hpp"
 #include "dns_utils.hpp"
-#include "iora/network/unified_shared_transport.hpp"
 #include "iora/core/logger.hpp"
 #include "iora/core/thread_pool.hpp"
 #include "iora/core/timer.hpp"
-#include <memory>
-#include <functional>
-#include <map>
-#include <deque>
-#include <mutex>
-#include <condition_variable>
-#include <future>
-#include <atomic>
+#include "iora/network/unified_shared_transport.hpp"
 #include <algorithm>
+#include <array>
+#include <atomic>
 #include <cctype>
-#include <cstdint>
 #include <climits>
+#include <condition_variable>
+#include <cstdint>
+#include <deque>
+#include <functional>
+#include <future>
+#include <map>
+#include <memory>
+#include <mutex>
 #include <random>
 #include <thread>
-#include <array>
 
 namespace iora
 {
@@ -40,8 +40,8 @@ namespace dns
 class DnsTransportException : public std::runtime_error
 {
 public:
-  explicit DnsTransportException(const std::string& message)
-    : std::runtime_error("DNS Transport Error: " + message)
+  explicit DnsTransportException(const std::string &message)
+      : std::runtime_error("DNS Transport Error: " + message)
   {
   }
 };
@@ -49,8 +49,8 @@ public:
 class DnsTimeoutException : public DnsTransportException
 {
 public:
-  explicit DnsTimeoutException(const std::string& message = "DNS query timeout")
-    : DnsTransportException(message)
+  explicit DnsTimeoutException(const std::string &message = "DNS query timeout")
+      : DnsTransportException(message)
   {
   }
 };
@@ -59,10 +59,11 @@ class DnsServerException : public DnsTransportException
 {
 public:
   DnsResponseCode responseCode;
-  
-  DnsServerException(DnsResponseCode code, const std::string& message)
-    : DnsTransportException("DNS server error (" + std::to_string(static_cast<int>(code)) + "): " + message),
-      responseCode(code)
+
+  DnsServerException(DnsResponseCode code, const std::string &message)
+      : DnsTransportException("DNS server error (" + std::to_string(static_cast<int>(code)) +
+                              "): " + message),
+        responseCode(code)
   {
   }
 };
@@ -72,11 +73,11 @@ class DnsTransport : public std::enable_shared_from_this<DnsTransport>
 {
 public:
   /// \brief DNS query callback for asynchronous operations (unified)
-  using QueryCallback = std::function<void(const DnsResult& result, const std::exception_ptr& error)>;
+  using QueryCallback =
+    std::function<void(const DnsResult &result, const std::exception_ptr &error)>;
 
   /// \brief Constructor with configuration
-  explicit DnsTransport(const DnsConfig& config = {});
-  
+  explicit DnsTransport(const DnsConfig &config = {});
 
   /// \brief Destructor
   ~DnsTransport();
@@ -97,8 +98,7 @@ public:
   /// \param port DNS server port (0 = use configured port)
   /// \return DNS query result
   /// \throws DnsTransportException, DnsTimeoutException, DnsServerException
-  DnsResult query(const DnsQuestion& question, 
-                  const std::string& server = "",
+  DnsResult query(const DnsQuestion &question, const std::string &server = "",
                   std::uint16_t port = 0);
 
   /// \brief Send asynchronous DNS query
@@ -106,25 +106,22 @@ public:
   /// \param callback Response callback
   /// \param server DNS server address (empty = use configured servers)
   /// \param port DNS server port (0 = use configured port)
-  void queryAsync(const DnsQuestion& question,
-                  QueryCallback callback,
-                  const std::string& server = "",
-                  std::uint16_t port = 0);
+  void queryAsync(const DnsQuestion &question, QueryCallback callback,
+                  const std::string &server = "", std::uint16_t port = 0);
 
   /// \brief Send multiple questions in one query (synchronous)
   /// \param questions DNS questions to resolve
-  /// \param server DNS server address (empty = use configured servers)  
+  /// \param server DNS server address (empty = use configured servers)
   /// \param port DNS server port (0 = use configured port)
   /// \return DNS query result
-  DnsResult queryMultiple(const std::vector<DnsQuestion>& questions,
-                         const std::string& server = "",
-                         std::uint16_t port = 0);
+  DnsResult queryMultiple(const std::vector<DnsQuestion> &questions, const std::string &server = "",
+                          std::uint16_t port = 0);
 
   /// \brief Update configuration
-  void updateConfig(const DnsConfig& config);
+  void updateConfig(const DnsConfig &config);
 
   /// \brief Get current configuration
-  const DnsConfig& getConfig() const { return config_; }
+  const DnsConfig &getConfig() const { return config_; }
 
   /// \brief Get transport statistics (thread-safe atomic counters)
   struct Statistics
@@ -144,38 +141,40 @@ public:
 
 private:
   /// \brief Composite key for pending queries to avoid ID collisions
-  /// 
+  ///
   /// IMPORTANT: Server string normalization rules:
-  /// - For pending queries: use raw server string (e.g., "8.8.8.8") 
+  /// - For pending queries: use raw server string (e.g., "8.8.8.8")
   /// - For session management: UDP uses "server:port", TCP uses "server:port:tcp"
   /// - QueryKey always uses (queryId, server, port) triple without transport suffix
   /// - Server strings must be consistent (same case, format) for proper lookup
   struct QueryKey
   {
-    std::uint16_t queryId;  ///< DNS query ID (unique per server:port)
-    std::string server;     ///< DNS server address (normalized, no transport suffix)  
-    std::uint16_t port;     ///< DNS server port
-    
-    QueryKey(std::uint16_t id, const std::string& srv, std::uint16_t p)
-      : queryId(id), server(srv), port(p)
+    std::uint16_t queryId; ///< DNS query ID (unique per server:port)
+    std::string server;    ///< DNS server address (normalized, no transport suffix)
+    std::uint16_t port;    ///< DNS server port
+
+    QueryKey(std::uint16_t id, const std::string &srv, std::uint16_t p)
+        : queryId(id), server(srv), port(p)
     {
     }
-    
-    bool operator<(const QueryKey& other) const
+
+    bool operator<(const QueryKey &other) const
     {
-      if (queryId != other.queryId) return queryId < other.queryId;
-      if (server != other.server) return server < other.server;
+      if (queryId != other.queryId)
+        return queryId < other.queryId;
+      if (server != other.server)
+        return server < other.server;
       return port < other.port;
     }
-    
-    bool operator==(const QueryKey& other) const
+
+    bool operator==(const QueryKey &other) const
     {
       return queryId == other.queryId && server == other.server && port == other.port;
     }
   };
 
   /// \brief Pending query information
-  /// 
+  ///
   /// THREAD SAFETY: This structure is accessed from multiple threads:
   /// - Main thread: creates and registers
   /// - Transport callbacks: reads for completion
@@ -189,24 +188,23 @@ private:
     const std::string server;
     const std::uint16_t port;
     const std::vector<std::uint8_t> queryData;
-    
+
     // Mutable but single-writer fields (only modified by creating thread)
     std::promise<DnsResult> promise;
     QueryCallback callback;
     DnsTransportMode transportMode;
     bool tcpFallback;
-    
+
     // Thread-safe concurrent fields - accessed from multiple threads
     std::atomic<std::chrono::steady_clock::time_point> startTime;
     std::atomic<int> retryCount;
     std::atomic<std::uint64_t> activeTimerId{0}; // Currently scheduled retry timer (0 = none)
 
-    PendingQuery(std::uint16_t id, std::chrono::milliseconds to, 
-                const std::string& srv, std::uint16_t prt, 
-                std::vector<std::uint8_t> data)
-      : queryId(id), timeout(to), server(srv), port(prt), queryData(std::move(data)),
-        transportMode(DnsTransportMode::UDP), tcpFallback(false),
-        startTime(std::chrono::steady_clock::now()), retryCount(0)
+    PendingQuery(std::uint16_t id, std::chrono::milliseconds to, const std::string &srv,
+                 std::uint16_t prt, std::vector<std::uint8_t> data)
+        : queryId(id), timeout(to), server(srv), port(prt), queryData(std::move(data)),
+          transportMode(DnsTransportMode::UDP), tcpFallback(false),
+          startTime(std::chrono::steady_clock::now()), retryCount(0)
     {
     }
   };
@@ -214,67 +212,68 @@ private:
   /// \brief Send query using UDP transport
   void sendUdpQuery(std::shared_ptr<PendingQuery> query);
 
-  /// \brief Send query using TCP transport  
+  /// \brief Send query using TCP transport
   void sendTcpQuery(std::shared_ptr<PendingQuery> query);
 
   /// \brief Handle incoming UDP data
-  void handleUdpData(SessionId sessionId, const std::uint8_t* data, 
-                     std::size_t size, const IoResult& result);
+  void handleUdpData(SessionId sessionId, const std::uint8_t *data, std::size_t size,
+                     const IoResult &result);
 
   /// \brief Handle incoming TCP data
-  void handleTcpData(SessionId sessionId, const std::uint8_t* data,
-                     std::size_t size, const IoResult& result);
+  void handleTcpData(SessionId sessionId, const std::uint8_t *data, std::size_t size,
+                     const IoResult &result);
 
   /// \brief Handle transport errors
-  void handleTransportError(SessionId sessionId, const IoResult& result);
+  void handleTransportError(SessionId sessionId, const IoResult &result);
 
   /// \brief Handle transport connection events
-  void handleConnect(SessionId sessionId, const IoResult& result);
-  void handleClose(SessionId sessionId, const IoResult& result);
+  void handleConnect(SessionId sessionId, const IoResult &result);
+  void handleClose(SessionId sessionId, const IoResult &result);
 
   /// \brief Process DNS response
-  void processResponse(const std::uint8_t* data, std::size_t size, 
-                      DnsTransportMode mode, const std::string& sourceServer, 
-                      std::uint16_t sourcePort);
+  void processResponse(const std::uint8_t *data, std::size_t size, DnsTransportMode mode,
+                       const std::string &sourceServer, std::uint16_t sourcePort);
 
   /// \brief Complete pending query
-  void completeQuery(const QueryKey& key, const DnsResult& result);
-  void completeQuery(const QueryKey& key, const std::exception_ptr& error);
-  
+  void completeQuery(const QueryKey &key, const DnsResult &result);
+  void completeQuery(const QueryKey &key, const std::exception_ptr &error);
+
   /// \brief Find pending query by response data (thread-safe)
   /// \param queryId Query ID from DNS response
-  /// \param sourceServer Server that sent the response  
+  /// \param sourceServer Server that sent the response
   /// \param sourcePort Port that sent the response
   /// \return Shared pointer to pending query or nullptr if not found
-  std::shared_ptr<PendingQuery> 
-  findPendingQuery(std::uint16_t queryId, const std::string& sourceServer, std::uint16_t sourcePort);
+  std::shared_ptr<PendingQuery> findPendingQuery(std::uint16_t queryId,
+                                                 const std::string &sourceServer,
+                                                 std::uint16_t sourcePort);
 
   /// \brief Retry query logic
-  void retryQuery(std::shared_ptr<PendingQuery> query, const std::string& reason);
+  void retryQuery(std::shared_ptr<PendingQuery> query, const std::string &reason);
 
   /// \brief Cleanup expired queries
   void cleanupExpiredQueries();
 
   /// \brief Start cleanup timer
   void startCleanupTimer();
+  /// \brief Schedule timeout timer for a query
+  void scheduleQueryTimeout(std::shared_ptr<PendingQuery> query);
 
   /// \brief Get next DNS server from configured list
-  std::string getNextServer();
+  DnsServer getNextServer();
 
   /// \brief Prepare query data
-  std::vector<std::uint8_t> prepareQuery(const std::vector<DnsQuestion>& questions,
-                                          std::uint16_t queryId);
-  
+  std::vector<std::uint8_t> prepareQuery(const std::vector<DnsQuestion> &questions,
+                                         std::uint16_t queryId);
+
   /// \brief Calculate total maximum wait time for synchronous queries including retries
   /// \return Maximum possible duration including initial timeout and all retry delays with jitter
   std::chrono::milliseconds calculateMaxSyncWaitTime() const;
-  
+
   /// \brief Generate unique query ID for server:port combination
   /// \param server Target server
-  /// \param port Target port  
+  /// \param port Target port
   /// \return Unique query ID that doesn't conflict with pending queries to same server
-  std::uint16_t generateUniqueQueryId(const std::string& server, std::uint16_t port);
-
+  std::uint16_t generateUniqueQueryId(const std::string &server, std::uint16_t port);
 
   /// \brief Get transport for mode
   std::shared_ptr<UnifiedSharedTransport> getTransport(DnsTransportMode mode);
@@ -295,7 +294,7 @@ private:
   // State management
   std::atomic<bool> running_{false};
   mutable std::mutex stateMutex_;
-  
+
   // Query management
   std::map<QueryKey, std::shared_ptr<PendingQuery>> pendingQueries_;
   mutable std::mutex queriesMutex_;
@@ -318,10 +317,11 @@ private:
 
   // Session management
   std::map<std::string, SessionId> serverSessions_; // server:port -> SessionId
-  std::map<SessionId, std::pair<std::string, std::uint16_t>> sessionToServer_; // SessionId -> (server, port)
+  std::map<SessionId, std::pair<std::string, std::uint16_t>>
+    sessionToServer_; // SessionId -> (server, port)
   mutable std::mutex sessionsMutex_;
 
-  // TCP message framing (TCP DNS messages are length-prefixed)  
+  // TCP message framing (TCP DNS messages are length-prefixed)
   std::map<SessionId, std::deque<std::uint8_t>> tcpBuffers_;
   mutable std::mutex tcpBuffersMutex_;
 
@@ -330,34 +330,30 @@ private:
   std::thread cleanupThread_;
   std::condition_variable cleanupCv_;
   std::mutex cleanupMutex_;
-  
+
   // Centralized RNG for retry jitter
   mutable std::mt19937 rng_;
-  
+
   // Timer service for efficient retry scheduling (avoids sleeping in thread pool workers)
   std::shared_ptr<core::TimerService> timerService_;
 };
 
 // ==================== Implementation ====================
 
-inline DnsTransport::DnsTransport(const DnsConfig& config)
-  : config_(config)
+inline DnsTransport::DnsTransport(const DnsConfig &config) : config_(config)
 {
   if (config_.servers.empty())
   {
     throw DnsTransportException("No DNS servers configured");
   }
-  
-  // Normalize all server strings for consistent lookups
-  for (auto& server : config_.servers)
-  {
-    server = dns::normalizeServerString(server);
-  }
-  
+
+  // DnsServer structures are already normalized via fromString()
+  // No additional normalization needed
+
   // Initialize RNG for jitter
   std::random_device rd;
   rng_.seed(rd());
-  
+
   // Initialize timer service for efficient retry scheduling
   core::TimerServiceConfig timerConfig;
   timerConfig.threadName = "DnsRetryTimer";
@@ -365,16 +361,12 @@ inline DnsTransport::DnsTransport(const DnsConfig& config)
   timerService_ = std::make_shared<core::TimerService>(timerConfig);
 }
 
-
-inline DnsTransport::~DnsTransport()
-{
-  stop();
-}
+inline DnsTransport::~DnsTransport() { stop(); }
 
 inline void DnsTransport::start()
 {
   std::lock_guard<std::mutex> lock(stateMutex_);
-  
+
   if (running_.load())
   {
     return; // Already running
@@ -383,14 +375,14 @@ inline void DnsTransport::start()
   try
   {
     // Create transports based on configuration
-    if (config_.transportMode == DnsTransportMode::UDP || 
+    if (config_.transportMode == DnsTransportMode::UDP ||
         config_.transportMode == DnsTransportMode::Both)
     {
       udpTransport_ = createUdpTransport();
       udpTransport_->start();
     }
 
-    if (config_.transportMode == DnsTransportMode::TCP || 
+    if (config_.transportMode == DnsTransportMode::TCP ||
         config_.transportMode == DnsTransportMode::Both)
     {
       tcpTransport_ = createTcpTransport();
@@ -398,11 +390,11 @@ inline void DnsTransport::start()
     }
 
     // Timer service is already started by its constructor
-    
+
     running_.store(true);
     startCleanupTimer();
   }
-  catch (const std::exception& e)
+  catch (const std::exception &e)
   {
     running_.store(false);
     throw DnsTransportException("Failed to start DNS transport: " + std::string(e.what()));
@@ -412,7 +404,7 @@ inline void DnsTransport::start()
 inline void DnsTransport::stop()
 {
   std::lock_guard<std::mutex> lock(stateMutex_);
-  
+
   if (!running_.load())
   {
     return; // Already stopped
@@ -445,14 +437,26 @@ inline void DnsTransport::stop()
   {
     std::lock_guard<std::mutex> qlock(queriesMutex_);
     auto error = std::make_exception_ptr(DnsTransportException("Transport stopped"));
-    
-    for (auto& [key, query] : pendingQueries_)
+
+    for (auto &[key, query] : pendingQueries_)
     {
       if (query->callback)
       {
-        try { query->callback({}, error); } catch (...) {}
+        try
+        {
+          query->callback({}, error);
+        }
+        catch (...)
+        {
+        }
+      }
+      try
+      {
+        query->promise.set_exception(error);
+      }
+      catch (...)
+      {
       }
-      try { query->promise.set_exception(error); } catch (...) {}
     }
     pendingQueries_.clear();
   }
@@ -479,21 +483,16 @@ inline void DnsTransport::stop()
   }
 }
 
-inline bool DnsTransport::isRunning() const
-{
-  return running_.load();
-}
+inline bool DnsTransport::isRunning() const { return running_.load(); }
 
-inline DnsResult DnsTransport::query(const DnsQuestion& question,
-                                    const std::string& server,
-                                    std::uint16_t port)
+inline DnsResult DnsTransport::query(const DnsQuestion &question, const std::string &server,
+                                     std::uint16_t port)
 {
   return queryMultiple({question}, server, port);
 }
 
-inline DnsResult DnsTransport::queryMultiple(const std::vector<DnsQuestion>& questions,
-                                            const std::string& server,
-                                            std::uint16_t port)
+inline DnsResult DnsTransport::queryMultiple(const std::vector<DnsQuestion> &questions,
+                                             const std::string &server, std::uint16_t port)
 {
   if (!running_.load())
   {
@@ -506,15 +505,31 @@ inline DnsResult DnsTransport::queryMultiple(const std::vector<DnsQuestion>& que
   }
 
   // Determine target server and port
-  std::string targetServer = server.empty() ? getNextServer() : dns::normalizeServerString(server);
-  std::uint16_t targetPort = (port == 0) ? config_.port : port;
-  
+  DnsServer targetDnsServer;
+  if (server.empty())
+  {
+    targetDnsServer = getNextServer();
+  }
+  else
+  {
+    // Parse provided server string or use provided port
+    targetDnsServer = DnsServer::fromString(server);
+    if (port != 0)
+    {
+      targetDnsServer.port = port; // Override port if explicitly provided
+    }
+  }
+
+  std::string targetServer = targetDnsServer.address;
+  std::uint16_t targetPort = targetDnsServer.port;
+
   // Generate unique query ID for this server:port combination
   std::uint16_t queryId = generateUniqueQueryId(targetServer, targetPort);
   auto queryData = prepareQuery(questions, queryId);
 
   // Create pending query with immutable fields (thread-safe constructor)
-  auto query = std::make_shared<PendingQuery>(queryId, config_.timeout, targetServer, targetPort, std::move(queryData));
+  auto query = std::make_shared<PendingQuery>(queryId, config_.timeout, targetServer, targetPort,
+                                              std::move(queryData));
   query->transportMode = config_.transportMode;
 
   // Create composite key and register pending query
@@ -539,11 +554,12 @@ inline DnsResult DnsTransport::queryMultiple(const std::vector<DnsQuestion>& que
     // Wait for response with proper retry window calculation
     auto future = query->promise.get_future();
     auto maxWaitTime = calculateMaxSyncWaitTime();
-    iora::core::Logger::debug("DNS sync query max wait time: " + std::to_string(maxWaitTime.count()) + "ms " +
-                              "(timeout=" + std::to_string(config_.timeout.count()) + "ms, " +
-                              "retries=" + std::to_string(config_.retryCount) + ")");
+    iora::core::Logger::debug(
+      "DNS sync query max wait time: " + std::to_string(maxWaitTime.count()) + "ms " +
+      "(timeout=" + std::to_string(config_.timeout.count()) + "ms, " +
+      "retries=" + std::to_string(config_.retryCount) + ")");
     auto status = future.wait_for(maxWaitTime);
-    
+
     if (status == std::future_status::timeout)
     {
       // Remove from pending and count timeout for sync queries
@@ -551,12 +567,12 @@ inline DnsResult DnsTransport::queryMultiple(const std::vector<DnsQuestion>& que
         std::lock_guard<std::mutex> lock(queriesMutex_);
         pendingQueries_.erase(key);
       }
-      
+
       // Atomic increment - no mutex needed
       stats_.timeouts.fetch_add(1, std::memory_order_relaxed);
-      
-      throw DnsTimeoutException("Query timeout after " + 
-                                std::to_string(config_.timeout.count()) + "ms");
+
+      throw DnsTimeoutException("Query timeout after " + std::to_string(config_.timeout.count()) +
+                                "ms");
     }
 
     return future.get();
@@ -572,10 +588,8 @@ inline DnsResult DnsTransport::queryMultiple(const std::vector<DnsQuestion>& que
   }
 }
 
-inline void DnsTransport::queryAsync(const DnsQuestion& question,
-                                    QueryCallback callback,
-                                    const std::string& server,
-                                    std::uint16_t port)
+inline void DnsTransport::queryAsync(const DnsQuestion &question, QueryCallback callback,
+                                     const std::string &server, std::uint16_t port)
 {
   if (!running_.load())
   {
@@ -585,15 +599,31 @@ inline void DnsTransport::queryAsync(const DnsQuestion& question,
   }
 
   // Determine target server and port
-  std::string targetServer = server.empty() ? getNextServer() : dns::normalizeServerString(server);
-  std::uint16_t targetPort = (port == 0) ? config_.port : port;
-  
+  DnsServer targetDnsServer;
+  if (server.empty())
+  {
+    targetDnsServer = getNextServer();
+  }
+  else
+  {
+    // Parse provided server string or use provided port
+    targetDnsServer = DnsServer::fromString(server);
+    if (port != 0)
+    {
+      targetDnsServer.port = port; // Override port if explicitly provided
+    }
+  }
+
+  std::string targetServer = targetDnsServer.address;
+  std::uint16_t targetPort = targetDnsServer.port;
+
   // Generate unique query ID for this server:port combination
   std::uint16_t queryId = generateUniqueQueryId(targetServer, targetPort);
   auto queryData = prepareQuery({question}, queryId);
 
   // Create pending query with immutable fields (thread-safe constructor)
-  auto query = std::make_shared<PendingQuery>(queryId, config_.timeout, targetServer, targetPort, std::move(queryData));
+  auto query = std::make_shared<PendingQuery>(queryId, config_.timeout, targetServer, targetPort,
+                                              std::move(queryData));
   query->transportMode = config_.transportMode;
   query->callback = std::move(callback);
 
@@ -616,14 +646,14 @@ inline void DnsTransport::queryAsync(const DnsQuestion& question,
       sendUdpQuery(query);
     }
   }
-  catch (const std::exception& e)
+  catch (const std::exception &e)
   {
     // Remove from pending and call callback with error
     {
       std::lock_guard<std::mutex> lock(queriesMutex_);
       pendingQueries_.erase(key);
     }
-    
+
     auto error = std::make_exception_ptr(DnsTransportException(e.what()));
     query->callback({}, error);
   }
@@ -638,17 +668,15 @@ inline std::shared_ptr<UdpTransportAdapter> DnsTransport::createUdpTransport()
   // Set up callbacks using UnifiedCallbacks with shared_ptr capture for lifetime safety
   UnifiedCallbacks callbacks;
   auto self = shared_from_this(); // Ensure transport remains alive during async operations
-  callbacks.onData = [self](SessionId sid, const std::uint8_t* data, 
-                            std::size_t size, const IoResult& result) {
-    self->handleUdpData(sid, data, size, result);
-  };
-  callbacks.onConnect = [self](SessionId sid, const IoResult& result) {
-    self->handleConnect(sid, result);
-  };
-  callbacks.onClosed = [self](SessionId sid, const IoResult& result) {
-    self->handleClose(sid, result);
-  };
-  callbacks.onError = [self](TransportError error, const std::string& message) {
+  callbacks.onData =
+    [self](SessionId sid, const std::uint8_t *data, std::size_t size, const IoResult &result)
+  { self->handleUdpData(sid, data, size, result); };
+  callbacks.onConnect = [self](SessionId sid, const IoResult &result)
+  { self->handleConnect(sid, result); };
+  callbacks.onClosed = [self](SessionId sid, const IoResult &result)
+  { self->handleClose(sid, result); };
+  callbacks.onError = [self](TransportError error, const std::string &message)
+  {
     // Handle transport-level errors
   };
 
@@ -660,23 +688,21 @@ inline std::shared_ptr<TcpTlsTransportAdapter> DnsTransport::createTcpTransport(
 {
   SharedTransport::Config config{};
   SharedTransport::TlsConfig serverTls{}, clientTls{};
-  
+
   auto adapter = std::make_shared<TcpTlsTransportAdapter>(config, serverTls, clientTls);
 
   // Set up callbacks using UnifiedCallbacks with shared_ptr capture for lifetime safety
   UnifiedCallbacks callbacks;
   auto self = shared_from_this(); // Ensure transport remains alive during async operations
-  callbacks.onData = [self](SessionId sid, const std::uint8_t* data,
-                            std::size_t size, const IoResult& result) {
-    self->handleTcpData(sid, data, size, result);
-  };
-  callbacks.onConnect = [self](SessionId sid, const IoResult& result) {
-    self->handleConnect(sid, result);
-  };
-  callbacks.onClosed = [self](SessionId sid, const IoResult& result) {
-    self->handleClose(sid, result);
-  };
-  callbacks.onError = [self](TransportError error, const std::string& message) {
+  callbacks.onData =
+    [self](SessionId sid, const std::uint8_t *data, std::size_t size, const IoResult &result)
+  { self->handleTcpData(sid, data, size, result); };
+  callbacks.onConnect = [self](SessionId sid, const IoResult &result)
+  { self->handleConnect(sid, result); };
+  callbacks.onClosed = [self](SessionId sid, const IoResult &result)
+  { self->handleClose(sid, result); };
+  callbacks.onError = [self](TransportError error, const std::string &message)
+  {
     // Handle transport-level errors
   };
 
@@ -691,6 +717,11 @@ inline void DnsTransport::sendUdpQuery(std::shared_ptr<PendingQuery> query)
     throw DnsTransportException("UDP transport not available");
   }
 
+  // Log DNS query attempt for debugging server failover
+  iora::core::Logger::info("DNS sending UDP query: ID=" + std::to_string(query->queryId) +
+                           " server=" + query->server + ":" + std::to_string(query->port) +
+                           " retry=" + std::to_string(query->retryCount));
+
   // Get or create session to DNS server
   std::string serverKey = query->server + ":" + std::to_string(query->port);
   SessionId sessionId = 0;
@@ -716,19 +747,21 @@ inline void DnsTransport::sendUdpQuery(std::shared_ptr<PendingQuery> query)
   }
 
   // Send query data
-  bool sent = udpTransport_->send(sessionId, query->queryData.data(), 
-                                 query->queryData.size());
+  bool sent = udpTransport_->send(sessionId, query->queryData.data(), query->queryData.size());
   if (!sent)
   {
-    iora::core::Logger::error("DNS UDP query failed to send to " + query->server + ":" + 
+    iora::core::Logger::error("DNS UDP query failed to send to " + query->server + ":" +
                               std::to_string(query->port));
     throw DnsTransportException("Failed to send UDP query to " + query->server);
   }
 
-  iora::core::Logger::debug("DNS UDP query sent: ID=" + std::to_string(query->queryId) + 
-                            " to " + query->server + ":" + std::to_string(query->port) +
+  iora::core::Logger::debug("DNS UDP query sent: ID=" + std::to_string(query->queryId) + " to " +
+                            query->server + ":" + std::to_string(query->port) +
                             " size=" + std::to_string(query->queryData.size()) + "bytes");
 
+  // Schedule timeout timer for this query
+  scheduleQueryTimeout(query);
+
   // Atomic increments - no mutex needed
   stats_.totalQueries.fetch_add(1, std::memory_order_relaxed);
   stats_.udpQueries.fetch_add(1, std::memory_order_relaxed);
@@ -776,29 +809,33 @@ inline void DnsTransport::sendTcpQuery(std::shared_ptr<PendingQuery> query)
   bool sent = tcpTransport_->send(sessionId, tcpMessage.data(), tcpMessage.size());
   if (!sent)
   {
-    iora::core::Logger::error("DNS TCP query failed to send to " + query->server + ":" + 
+    iora::core::Logger::error("DNS TCP query failed to send to " + query->server + ":" +
                               std::to_string(query->port));
     throw DnsTransportException("Failed to send TCP query to " + query->server);
   }
 
-  iora::core::Logger::debug("DNS TCP query sent: ID=" + std::to_string(query->queryId) + 
-                            " to " + query->server + ":" + std::to_string(query->port) +
-                            " size=" + std::to_string(length) + "bytes (+" + 
+  iora::core::Logger::debug("DNS TCP query sent: ID=" + std::to_string(query->queryId) + " to " +
+                            query->server + ":" + std::to_string(query->port) +
+                            " size=" + std::to_string(length) + "bytes (+" +
                             std::to_string(tcpMessage.size() - length) + " length prefix)");
 
+  // Schedule timeout timer for this query
+  scheduleQueryTimeout(query);
+
   // Atomic increments - no mutex needed
   stats_.totalQueries.fetch_add(1, std::memory_order_relaxed);
   stats_.tcpQueries.fetch_add(1, std::memory_order_relaxed);
   if (query->tcpFallback)
   {
     stats_.tcpFallbacks.fetch_add(1, std::memory_order_relaxed);
-    iora::core::Logger::debug("DNS TCP fallback completed for query ID=" + 
-                              std::to_string(query->queryId) + " server=" + query->server + ":" + std::to_string(query->port));
+    iora::core::Logger::debug(
+      "DNS TCP fallback completed for query ID=" + std::to_string(query->queryId) +
+      " server=" + query->server + ":" + std::to_string(query->port));
   }
 }
 
-inline void DnsTransport::handleUdpData(SessionId sessionId, const std::uint8_t* data,
-                                       std::size_t size, const IoResult& result)
+inline void DnsTransport::handleUdpData(SessionId sessionId, const std::uint8_t *data,
+                                        std::size_t size, const IoResult &result)
 {
   if (!result.ok)
   {
@@ -819,7 +856,8 @@ inline void DnsTransport::handleUdpData(SessionId sessionId, const std::uint8_t*
     }
     else
     {
-      iora::core::Logger::error("DNS UDP response from unknown session ID " + std::to_string(sessionId));
+      iora::core::Logger::error("DNS UDP response from unknown session ID " +
+                                std::to_string(sessionId));
       return;
     }
   }
@@ -827,8 +865,8 @@ inline void DnsTransport::handleUdpData(SessionId sessionId, const std::uint8_t*
   processResponse(data, size, DnsTransportMode::UDP, server, port);
 }
 
-inline void DnsTransport::handleTcpData(SessionId sessionId, const std::uint8_t* data,
-                                       std::size_t size, const IoResult& result)
+inline void DnsTransport::handleTcpData(SessionId sessionId, const std::uint8_t *data,
+                                        std::size_t size, const IoResult &result)
 {
   if (!result.ok)
   {
@@ -839,8 +877,8 @@ inline void DnsTransport::handleTcpData(SessionId sessionId, const std::uint8_t*
   // TCP DNS messages are length-prefixed, may arrive in fragments
   {
     std::lock_guard<std::mutex> lock(tcpBuffersMutex_);
-    auto& buffer = tcpBuffers_[sessionId];
-    
+    auto &buffer = tcpBuffers_[sessionId];
+
     // Prevent unbounded buffer growth using configured limit
     if (buffer.size() + size > config_.maxTcpBufferSize)
     {
@@ -849,14 +887,14 @@ inline void DnsTransport::handleTcpData(SessionId sessionId, const std::uint8_t*
       tcpTransport_->close(sessionId);
       return;
     }
-    
+
     buffer.insert(buffer.end(), data, data + size);
 
     // Process complete messages
     while (buffer.size() >= 2)
     {
       std::uint16_t messageLength = (buffer[0] << 8) | buffer[1];
-      
+
       // Validate message length
       static const std::uint16_t MAX_DNS_MESSAGE_SIZE = 65535; // RFC 1035 max
       if (messageLength == 0 || messageLength > MAX_DNS_MESSAGE_SIZE)
@@ -866,26 +904,27 @@ inline void DnsTransport::handleTcpData(SessionId sessionId, const std::uint8_t*
         tcpTransport_->close(sessionId);
         return;
       }
-      
+
       // Check for integer overflow and bounds safety
       // Ensure messageLength is reasonable and won't cause overflow
       const std::size_t maxSafeSize = SIZE_MAX - 2;
       if (messageLength > maxSafeSize || messageLength > config_.maxTcpBufferSize)
       {
         // Message too large, clear buffer and close session
-        iora::core::Logger::error("DNS TCP message too large: " + std::to_string(messageLength) + 
-                                 " bytes, max=" + std::to_string(std::min(maxSafeSize, config_.maxTcpBufferSize)));
+        iora::core::Logger::error(
+          "DNS TCP message too large: " + std::to_string(messageLength) +
+          " bytes, max=" + std::to_string(std::min(maxSafeSize, config_.maxTcpBufferSize)));
         buffer.clear();
         tcpTransport_->close(sessionId);
         return;
       }
-      
+
       if (buffer.size() < 2 + static_cast<std::size_t>(messageLength))
       {
         // Incomplete message, wait for more data
         break;
       }
-      
+
       // Complete message available - look up server and port
       std::string server;
       std::uint16_t port;
@@ -899,7 +938,8 @@ inline void DnsTransport::handleTcpData(SessionId sessionId, const std::uint8_t*
         }
         else
         {
-          iora::core::Logger::error("DNS TCP response from unknown session ID " + std::to_string(sessionId));
+          iora::core::Logger::error("DNS TCP response from unknown session ID " +
+                                    std::to_string(sessionId));
           // Remove processed message from buffer using deque's efficient pop_front
           for (std::size_t i = 0; i < 2 + static_cast<std::size_t>(messageLength); ++i)
           {
@@ -908,11 +948,11 @@ inline void DnsTransport::handleTcpData(SessionId sessionId, const std::uint8_t*
           continue;
         }
       }
-      
+
       // Create vector from buffer data since deque doesn't have data() method
       std::vector<std::uint8_t> messageData(buffer.begin() + 2, buffer.begin() + 2 + messageLength);
       processResponse(messageData.data(), messageLength, DnsTransportMode::TCP, server, port);
-      
+
       // Remove processed message from buffer using deque's efficient pop_front
       for (std::size_t i = 0; i < 2 + static_cast<std::size_t>(messageLength); ++i)
       {
@@ -922,25 +962,25 @@ inline void DnsTransport::handleTcpData(SessionId sessionId, const std::uint8_t*
   }
 }
 
-inline void DnsTransport::processResponse(const std::uint8_t* data, std::size_t size,
-                                        DnsTransportMode mode, const std::string& sourceServer, 
-                                        std::uint16_t sourcePort)
+inline void DnsTransport::processResponse(const std::uint8_t *data, std::size_t size,
+                                          DnsTransportMode mode, const std::string &sourceServer,
+                                          std::uint16_t sourcePort)
 {
   try
   {
     DnsResult result = DnsMessage::parse(data, size);
     QueryKey key(result.header.id, sourceServer, sourcePort);
-    
+
     // Check for truncation (UDP only)
     if (mode == DnsTransportMode::UDP && result.isTruncated())
     {
       // Atomic increment - no mutex needed
       stats_.truncatedResponses.fetch_add(1, std::memory_order_relaxed);
-      
-      iora::core::Logger::debug("DNS response truncated (TC=1) for query ID=" + 
-                                std::to_string(result.header.id) + 
-                                " from " + sourceServer + ":" + std::to_string(sourcePort));
-      
+
+      iora::core::Logger::debug(
+        "DNS response truncated (TC=1) for query ID=" + std::to_string(result.header.id) +
+        " from " + sourceServer + ":" + std::to_string(sourcePort));
+
       // Find and retry with TCP if configured
       if (config_.transportMode == DnsTransportMode::Both)
       {
@@ -948,7 +988,7 @@ inline void DnsTransport::processResponse(const std::uint8_t* data, std::size_t
         auto it = pendingQueries_.find(key);
         if (it != pendingQueries_.end() && !it->second->tcpFallback)
         {
-          iora::core::Logger::debug("Initiating TCP fallback for truncated response, query ID=" + 
+          iora::core::Logger::debug("Initiating TCP fallback for truncated response, query ID=" +
                                     std::to_string(result.header.id));
           it->second->tcpFallback = true;
           sendTcpQuery(it->second);
@@ -961,18 +1001,19 @@ inline void DnsTransport::processResponse(const std::uint8_t* data, std::size_t
       }
     }
 
-    iora::core::Logger::debug("DNS response received: ID=" + std::to_string(result.header.id) + 
-                              " from " + sourceServer + ":" + std::to_string(sourcePort) +
-                              " via " + (mode == DnsTransportMode::TCP ? "TCP" : "UDP") +
+    iora::core::Logger::debug("DNS response received: ID=" + std::to_string(result.header.id) +
+                              " from " + sourceServer + ":" + std::to_string(sourcePort) + " via " +
+                              (mode == DnsTransportMode::TCP ? "TCP" : "UDP") +
                               " rcode=" + std::to_string(static_cast<int>(result.header.rcode)) +
                               " answers=" + std::to_string(result.header.ancount));
     completeQuery(key, result);
   }
-  catch (const std::exception& e)
+  catch (const std::exception &e)
   {
-    iora::core::Logger::warning("DNS response parse failed from " + sourceServer + ":" + 
-                            std::to_string(sourcePort) + " (" + std::to_string(size) + " bytes): " + e.what());
-    
+    iora::core::Logger::warning("DNS response parse failed from " + sourceServer + ":" +
+                                std::to_string(sourcePort) + " (" + std::to_string(size) +
+                                " bytes): " + e.what());
+
     // If we can extract query ID from malformed response, complete that query
     if (size >= 2)
     {
@@ -983,20 +1024,19 @@ inline void DnsTransport::processResponse(const std::uint8_t* data, std::size_t
     }
     else
     {
-      iora::core::Logger::error("DNS response too short to extract query ID from " + 
-                               sourceServer + ":" + std::to_string(sourcePort));
+      iora::core::Logger::error("DNS response too short to extract query ID from " + sourceServer +
+                                ":" + std::to_string(sourcePort));
     }
   }
 }
 
-
-inline void DnsTransport::handleTransportError(SessionId sessionId, const IoResult& result)
+inline void DnsTransport::handleTransportError(SessionId sessionId, const IoResult &result)
 {
   // Handle transport-level errors by finding queries specific to this session
   std::vector<std::shared_ptr<PendingQuery>> affectedQueries;
   std::string errorServer;
   std::uint16_t errorPort;
-  
+
   // First, identify which server:port this session corresponds to
   {
     std::lock_guard<std::mutex> lock(sessionsMutex_);
@@ -1008,15 +1048,16 @@ inline void DnsTransport::handleTransportError(SessionId sessionId, const IoResu
     }
     else
     {
-      iora::core::Logger::error("Transport error for unknown session ID " + std::to_string(sessionId));
+      iora::core::Logger::error("Transport error for unknown session ID " +
+                                std::to_string(sessionId));
       return;
     }
   }
-  
+
   // Find queries specifically targeting this server:port
   {
     std::lock_guard<std::mutex> lock(queriesMutex_);
-    for (const auto& [key, query] : pendingQueries_)
+    for (const auto &[key, query] : pendingQueries_)
     {
       if (query->server == errorServer && query->port == errorPort)
       {
@@ -1024,12 +1065,13 @@ inline void DnsTransport::handleTransportError(SessionId sessionId, const IoResu
       }
     }
   }
-  
-  iora::core::Logger::info("DNS transport error for " + errorServer + ":" + std::to_string(errorPort) + 
-                           " affecting " + std::to_string(affectedQueries.size()) + " queries: " + result.message);
-  
+
+  iora::core::Logger::info("DNS transport error for " + errorServer + ":" +
+                           std::to_string(errorPort) + " affecting " +
+                           std::to_string(affectedQueries.size()) + " queries: " + result.message);
+
   // Try to retry affected queries
-  for (auto& query : affectedQueries)
+  for (auto &query : affectedQueries)
   {
     if (query->retryCount.load() < config_.retryCount)
     {
@@ -1039,22 +1081,21 @@ inline void DnsTransport::handleTransportError(SessionId sessionId, const IoResu
     {
       // Max retries exceeded, complete with error
       auto error = std::make_exception_ptr(
-        DnsTransportException("Transport error after retries: " + result.message)
-      );
+        DnsTransportException("Transport error after retries: " + result.message));
       completeQuery(QueryKey(query->queryId, query->server, query->port), error);
     }
   }
-  
+
   // Atomic increment - no mutex needed
   stats_.errors.fetch_add(1, std::memory_order_relaxed);
 }
 
-inline void DnsTransport::handleConnect(SessionId sessionId, const IoResult& result)
+inline void DnsTransport::handleConnect(SessionId sessionId, const IoResult &result)
 {
   // Handle connection events
 }
 
-inline void DnsTransport::handleClose(SessionId sessionId, const IoResult& result)
+inline void DnsTransport::handleClose(SessionId sessionId, const IoResult &result)
 {
   // Remove closed sessions from mappings
   {
@@ -1080,7 +1121,7 @@ inline void DnsTransport::handleClose(SessionId sessionId, const IoResult& resul
   }
 }
 
-inline std::string DnsTransport::getNextServer()
+inline DnsServer DnsTransport::getNextServer()
 {
   if (config_.servers.empty())
   {
@@ -1088,11 +1129,17 @@ inline std::string DnsTransport::getNextServer()
   }
 
   std::size_t index = serverIndex_.fetch_add(1) % config_.servers.size();
-  return config_.servers[index];
+  DnsServer selectedServer = config_.servers[index];
+
+  iora::core::Logger::info("DNS getNextServer: selected server=" + selectedServer.toString() +
+                           " (index=" + std::to_string(index) + " of " +
+                           std::to_string(config_.servers.size()) + " servers)");
+
+  return selectedServer;
 }
 
-inline std::vector<std::uint8_t> DnsTransport::prepareQuery(const std::vector<DnsQuestion>& questions,
-                                                           std::uint16_t queryId)
+inline std::vector<std::uint8_t>
+DnsTransport::prepareQuery(const std::vector<DnsQuestion> &questions, std::uint16_t queryId)
 {
   return DnsMessage::buildQuery(questions, config_.recursionDesired, queryId);
 }
@@ -1125,21 +1172,18 @@ inline void DnsTransport::resetStatistics()
   stats_.truncatedResponses.store(0, std::memory_order_relaxed);
 }
 
-inline void DnsTransport::updateConfig(const DnsConfig& config)
+inline void DnsTransport::updateConfig(const DnsConfig &config)
 {
   std::lock_guard<std::mutex> lock(stateMutex_);
   config_ = config;
-  
+
   if (config_.servers.empty())
   {
     throw DnsTransportException("No DNS servers configured");
   }
-  
-  // Normalize all server strings for consistent lookups
-  for (auto& server : config_.servers)
-  {
-    server = dns::normalizeServerString(server);
-  }
+
+  // DnsServer structures are already normalized via fromString()
+  // No additional normalization needed
 }
 
 inline std::chrono::milliseconds DnsTransport::calculateMaxSyncWaitTime() const
@@ -1147,52 +1191,50 @@ inline std::chrono::milliseconds DnsTransport::calculateMaxSyncWaitTime() const
   // Calculate maximum total wait time for synchronous queries
   // Base timeout for initial attempt
   auto totalWait = config_.timeout;
-  
+
   // Calculate retry delays with exponential backoff and accurate per-retry jitter
   auto delay = config_.initialRetryDelay;
   std::chrono::milliseconds totalJitter{0};
-  
+
   for (int retry = 0; retry < config_.retryCount; ++retry)
   {
     totalWait += delay;
-    
+
     // Calculate jitter for this specific retry delay (more accurate than using maxRetryDelay)
     if (config_.jitterFactor > 0.0)
     {
       // Worst case: this retry gets maximum positive jitter based on actual delay
-      auto jitterForThisRetry = std::chrono::milliseconds(
-        static_cast<long>(delay.count() * config_.jitterFactor)
-      );
+      auto jitterForThisRetry =
+        std::chrono::milliseconds(static_cast<long>(delay.count() * config_.jitterFactor));
       totalJitter += jitterForThisRetry;
     }
-    
+
     // Apply exponential backoff multiplier
-    delay = std::chrono::milliseconds(
-      static_cast<long>(delay.count() * config_.retryMultiplier)
-    );
-    
+    delay = std::chrono::milliseconds(static_cast<long>(delay.count() * config_.retryMultiplier));
+
     // Cap at maximum delay
     if (delay > config_.maxRetryDelay)
     {
       delay = config_.maxRetryDelay;
     }
   }
-  
+
   // Add the accurately calculated jitter
   totalWait += totalJitter;
-  
+
   // Add safety margin for processing delays
   totalWait += std::chrono::milliseconds(2000); // 2 second margin
-  
+
   return totalWait;
 }
 
-inline std::uint16_t DnsTransport::generateUniqueQueryId(const std::string& server, std::uint16_t port)
+inline std::uint16_t DnsTransport::generateUniqueQueryId(const std::string &server,
+                                                         std::uint16_t port)
 {
   // Reduce mutex contention by generating candidates outside the lock
   constexpr int BATCH_SIZE = 10;
   constexpr int MAX_BATCHES = 100; // 1000 total attempts
-  
+
   for (int batch = 0; batch < MAX_BATCHES; ++batch)
   {
     // Generate a batch of candidates outside the lock
@@ -1201,7 +1243,7 @@ inline std::uint16_t DnsTransport::generateUniqueQueryId(const std::string& serv
     {
       candidates[i] = DnsMessage::generateQueryId();
     }
-    
+
     // Check candidates in a short critical section
     {
       std::lock_guard<std::mutex> lock(queriesMutex_);
@@ -1215,33 +1257,37 @@ inline std::uint16_t DnsTransport::generateUniqueQueryId(const std::string& serv
       }
     }
   }
-  
+
   // Fallback: sequential search for a free ID (pathological case recovery)
-  iora::core::Logger::warning("DNS query ID collision after 1000 random attempts, falling back to sequential search");
-  
+  iora::core::Logger::warning(
+    "DNS query ID collision after 1000 random attempts, falling back to sequential search");
+
   {
     std::lock_guard<std::mutex> lock(queriesMutex_);
-    
+
     // Sequential search through the entire 16-bit space
-    for (std::uint32_t id = 1; id <= 65535; ++id) 
+    for (std::uint32_t id = 1; id <= 65535; ++id)
     {
       std::uint16_t queryId = static_cast<std::uint16_t>(id);
       QueryKey testKey(queryId, server, port);
       if (pendingQueries_.find(testKey) == pendingQueries_.end())
       {
-        iora::core::Logger::debug("Found free query ID " + std::to_string(queryId) + " via sequential search");
+        iora::core::Logger::debug("Found free query ID " + std::to_string(queryId) +
+                                  " via sequential search");
         return queryId;
       }
     }
   }
-  
+
   // This should never happen unless we have 65535 concurrent queries to the same server:port
-  throw DnsTransportException("Exhausted all query IDs for server " + server + ":" + std::to_string(port) + 
+  throw DnsTransportException("Exhausted all query IDs for server " + server + ":" +
+                              std::to_string(port) +
                               " (65535 concurrent queries - system overload)");
 }
 
 inline std::shared_ptr<DnsTransport::PendingQuery>
-DnsTransport::findPendingQuery(std::uint16_t queryId, const std::string& sourceServer, std::uint16_t sourcePort)
+DnsTransport::findPendingQuery(std::uint16_t queryId, const std::string &sourceServer,
+                               std::uint16_t sourcePort)
 {
   std::lock_guard<std::mutex> lock(queriesMutex_);
   QueryKey key(queryId, sourceServer, sourcePort);
@@ -1253,11 +1299,10 @@ DnsTransport::findPendingQuery(std::uint16_t queryId, const std::string& sourceS
   return nullptr;
 }
 
-
-inline void DnsTransport::completeQuery(const QueryKey& key, const DnsResult& result)
+inline void DnsTransport::completeQuery(const QueryKey &key, const DnsResult &result)
 {
   std::shared_ptr<PendingQuery> query;
-  
+
   {
     std::lock_guard<std::mutex> lock(queriesMutex_);
     auto it = pendingQueries_.find(key);
@@ -1267,7 +1312,7 @@ inline void DnsTransport::completeQuery(const QueryKey& key, const DnsResult& re
       pendingQueries_.erase(it);
     }
   }
-  
+
   if (query)
   {
     // Cancel active retry timer if any
@@ -1277,54 +1322,73 @@ inline void DnsTransport::completeQuery(const QueryKey& key, const DnsResult& re
       timerService_->cancel(activeTimer);
       query->activeTimerId.store(0, std::memory_order_relaxed);
     }
-    
+
     // Calculate query duration for performance monitoring (atomic read)
     auto queryDuration = std::chrono::duration_cast<std::chrono::milliseconds>(
-        std::chrono::steady_clock::now() - query->startTime.load()
-    ).count();
+                           std::chrono::steady_clock::now() - query->startTime.load())
+                           .count();
 
     // All DNS protocol responses are valid results (NOERROR, NXDOMAIN, SERVFAIL, etc.)
     // The resolver layer will decide whether to throw exceptions based on response codes
     {
       // Log different response types appropriately
-      if (result.header.rcode == DnsResponseCode::NOERROR) {
-        iora::core::Logger::debug("DNS query completed successfully: ID=" + std::to_string(query->queryId) +
-                                 " server=" + query->server + ":" + std::to_string(query->port) +
-                                 " duration=" + std::to_string(queryDuration) + "ms" +
-                                 " retries=" + std::to_string(query->retryCount.load()) +
-                                 " answers=" + std::to_string(result.header.ancount));
-      } else if (result.header.rcode == DnsResponseCode::NXDOMAIN) {
-        iora::core::Logger::info("DNS query completed with NXDOMAIN: ID=" + std::to_string(query->queryId) +
-                                " server=" + query->server + ":" + std::to_string(query->port) +
-                                " duration=" + std::to_string(queryDuration) + "ms" +
-                                " retries=" + std::to_string(query->retryCount.load()) +
-                                " rcode=" + result.getResponseCodeString());
-      } else {
-        iora::core::Logger::info("DNS query completed with server error: ID=" + std::to_string(query->queryId) +
-                                " server=" + query->server + ":" + std::to_string(query->port) +
-                                " duration=" + std::to_string(queryDuration) + "ms" +
-                                " retries=" + std::to_string(query->retryCount.load()) +
-                                " rcode=" + result.getResponseCodeString());
+      if (result.header.rcode == DnsResponseCode::NOERROR)
+      {
+        iora::core::Logger::debug(
+          "DNS query completed successfully: ID=" + std::to_string(query->queryId) +
+          " server=" + query->server + ":" + std::to_string(query->port) +
+          " duration=" + std::to_string(queryDuration) + "ms" +
+          " retries=" + std::to_string(query->retryCount.load()) +
+          " answers=" + std::to_string(result.header.ancount));
+      }
+      else if (result.header.rcode == DnsResponseCode::NXDOMAIN)
+      {
+        iora::core::Logger::info(
+          "DNS query completed with NXDOMAIN: ID=" + std::to_string(query->queryId) +
+          " server=" + query->server + ":" + std::to_string(query->port) +
+          " duration=" + std::to_string(queryDuration) + "ms" + " retries=" +
+          std::to_string(query->retryCount.load()) + " rcode=" + result.getResponseCodeString());
+      }
+      else
+      {
+        iora::core::Logger::info(
+          "DNS query completed with server error: ID=" + std::to_string(query->queryId) +
+          " server=" + query->server + ":" + std::to_string(query->port) +
+          " duration=" + std::to_string(queryDuration) + "ms" + " retries=" +
+          std::to_string(query->retryCount.load()) + " rcode=" + result.getResponseCodeString());
       }
 
       if (query->callback)
       {
-        try { query->callback(result, nullptr); } catch (...) {}
+        try
+        {
+          query->callback(result, nullptr);
+        }
+        catch (...)
+        {
+        }
+      }
+      try
+      {
+        query->promise.set_value(result);
+      }
+      catch (...)
+      {
       }
-      try { query->promise.set_value(result); } catch (...) {}
     }
   }
   else
   {
-    iora::core::Logger::warning("DNS query completion for unknown query: ID=" + std::to_string(key.queryId) +
-                            " server=" + key.server + ":" + std::to_string(key.port));
+    iora::core::Logger::warning(
+      "DNS query completion for unknown query: ID=" + std::to_string(key.queryId) +
+      " server=" + key.server + ":" + std::to_string(key.port));
   }
 }
 
-inline void DnsTransport::completeQuery(const QueryKey& key, const std::exception_ptr& error)
+inline void DnsTransport::completeQuery(const QueryKey &key, const std::exception_ptr &error)
 {
   std::shared_ptr<PendingQuery> query;
-  
+
   {
     std::lock_guard<std::mutex> lock(queriesMutex_);
     auto it = pendingQueries_.find(key);
@@ -1334,7 +1398,7 @@ inline void DnsTransport::completeQuery(const QueryKey& key, const std::exceptio
       pendingQueries_.erase(it);
     }
   }
-  
+
   if (query)
   {
     // Cancel active retry timer if any
@@ -1344,19 +1408,19 @@ inline void DnsTransport::completeQuery(const QueryKey& key, const std::exceptio
       timerService_->cancel(activeTimer);
       query->activeTimerId.store(0, std::memory_order_relaxed);
     }
-    
+
     // Calculate query duration for performance monitoring (atomic read)
     auto queryDuration = std::chrono::duration_cast<std::chrono::milliseconds>(
-        std::chrono::steady_clock::now() - query->startTime.load()
-    ).count();
+                           std::chrono::steady_clock::now() - query->startTime.load())
+                           .count();
 
     // Log the error with context
     std::string errorMessage = "unknown error";
-    try 
+    try
     {
       std::rethrow_exception(error);
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       errorMessage = e.what();
     }
@@ -1365,20 +1429,31 @@ inline void DnsTransport::completeQuery(const QueryKey& key, const std::exceptio
       errorMessage = "non-standard exception";
     }
 
-    iora::core::Logger::error("DNS query failed: ID=" + std::to_string(query->queryId) +
-                             " server=" + query->server + ":" + std::to_string(query->port) +
-                             " duration=" + std::to_string(queryDuration) + "ms" +
-                             " retries=" + std::to_string(query->retryCount.load()) +
-                             " error=" + errorMessage);
+    iora::core::Logger::error(
+      "DNS query failed: ID=" + std::to_string(query->queryId) + " server=" + query->server + ":" +
+      std::to_string(query->port) + " duration=" + std::to_string(queryDuration) + "ms" +
+      " retries=" + std::to_string(query->retryCount.load()) + " error=" + errorMessage);
 
     // Atomic increment - no mutex needed
     stats_.errors.fetch_add(1, std::memory_order_relaxed);
-    
+
     if (query->callback)
     {
-      try { query->callback({}, error); } catch (...) {}
+      try
+      {
+        query->callback({}, error);
+      }
+      catch (...)
+      {
+      }
+    }
+    try
+    {
+      query->promise.set_exception(error);
+    }
+    catch (...)
+    {
     }
-    try { query->promise.set_exception(error); } catch (...) {}
   }
 }
 
@@ -1386,19 +1461,99 @@ inline void DnsTransport::startCleanupTimer()
 {
   cleanupRunning_.store(true);
   auto self = shared_from_this(); // Ensure transport remains alive during cleanup thread
-  cleanupThread_ = std::thread([self]() {
-    while (self->cleanupRunning_.load())
+  cleanupThread_ = std::thread(
+    [self]()
     {
-      std::unique_lock<std::mutex> lock(self->cleanupMutex_);
-      if (self->cleanupCv_.wait_for(lock, std::chrono::seconds(10), 
-                                   [self] { return !self->cleanupRunning_.load(); }))
+      while (self->cleanupRunning_.load())
       {
-        break; // Shutdown requested
+        std::unique_lock<std::mutex> lock(self->cleanupMutex_);
+        if (self->cleanupCv_.wait_for(lock, std::chrono::seconds(10),
+                                      [self] { return !self->cleanupRunning_.load(); }))
+        {
+          break; // Shutdown requested
+        }
+
+        self->cleanupExpiredQueries();
       }
-      
-      self->cleanupExpiredQueries();
-    }
-  });
+    });
+}
+
+inline void DnsTransport::scheduleQueryTimeout(std::shared_ptr<PendingQuery> query)
+{
+  auto self = shared_from_this();
+
+  // Cancel existing timeout timer if any (important for TCP fallback scenarios)
+  std::uint64_t existingTimerId = query->activeTimerId.load(std::memory_order_relaxed);
+  if (existingTimerId != 0)
+  {
+    timerService_->cancel(existingTimerId);
+    query->activeTimerId.store(0, std::memory_order_relaxed);
+  }
+
+  // Schedule a timeout timer for the configured query timeout
+  std::uint64_t timerId = timerService_->scheduleAfter(
+    query->timeout,
+    [self, query]()
+    {
+      // Check if transport is still running before accessing any members
+      if (!self->running_.load())
+      {
+        return; // Transport has been stopped/destroyed
+      }
+
+      // Also check if timer service is still valid (defensive programming)
+      if (!self->timerService_)
+      {
+        return; // Timer service has been destroyed
+      }
+
+      // Check if query is still pending (not completed/cancelled)
+      QueryKey key(query->queryId, query->server, query->port);
+
+      std::shared_ptr<PendingQuery> pendingQuery;
+      {
+        std::lock_guard<std::mutex> lock(self->queriesMutex_);
+        auto it = self->pendingQueries_.find(key);
+        if (it == self->pendingQueries_.end())
+        {
+          return; // Query already completed or cancelled
+        }
+        pendingQuery = it->second;
+
+        // Remove from pending queries
+        self->pendingQueries_.erase(it);
+      }
+
+      // Clear the timer ID since timeout fired
+      pendingQuery->activeTimerId.store(0, std::memory_order_relaxed);
+
+      // Complete query with timeout error
+      auto error = std::make_exception_ptr(DnsTimeoutException(
+        "Query timeout after " + std::to_string(query->timeout.count()) + "ms"));
+
+      if (pendingQuery->callback)
+      {
+        pendingQuery->callback({}, error);
+      }
+      else
+      {
+        // Sync query - set promise
+        try
+        {
+          pendingQuery->promise.set_exception(error);
+        }
+        catch (const std::future_error &)
+        {
+          // Promise already set - ignore
+        }
+      }
+
+      // Update timeout statistics
+      self->stats_.timeouts.fetch_add(1, std::memory_order_relaxed);
+    });
+
+  // Store timer ID for potential cancellation
+  query->activeTimerId.store(timerId, std::memory_order_relaxed);
 }
 
 inline void DnsTransport::cleanupExpiredQueries()
@@ -1409,7 +1564,7 @@ inline void DnsTransport::cleanupExpiredQueries()
   // Phase 1: Collect expired queries with minimal lock time
   {
     std::lock_guard<std::mutex> lock(queriesMutex_);
-    for (const auto& [key, query] : pendingQueries_)
+    for (const auto &[key, query] : pendingQueries_)
     {
       if (now - query->startTime.load() > query->timeout)
       {
@@ -1422,8 +1577,8 @@ inline void DnsTransport::cleanupExpiredQueries()
   std::size_t actualTimeouts = 0;
   std::vector<QueryKey> toRemove;
   std::vector<std::shared_ptr<PendingQuery>> toComplete;
-  
-  for (const auto& [key, query] : expiredQueries)
+
+  for (const auto &[key, query] : expiredQueries)
   {
     if (query->retryCount.load() < config_.retryCount)
     {
@@ -1443,7 +1598,7 @@ inline void DnsTransport::cleanupExpiredQueries()
   if (!toRemove.empty())
   {
     std::lock_guard<std::mutex> lock(queriesMutex_);
-    for (const auto& key : toRemove)
+    for (const auto &key : toRemove)
     {
       pendingQueries_.erase(key);
     }
@@ -1451,13 +1606,25 @@ inline void DnsTransport::cleanupExpiredQueries()
 
   // Phase 4: Complete callbacks without holding any locks
   auto error = std::make_exception_ptr(DnsTimeoutException("Query timeout after maximum retries"));
-  for (const auto& query : toComplete)
+  for (const auto &query : toComplete)
   {
     if (query->callback)
     {
-      try { query->callback({}, error); } catch (...) {}
+      try
+      {
+        query->callback({}, error);
+      }
+      catch (...)
+      {
+      }
+    }
+    try
+    {
+      query->promise.set_exception(error);
+    }
+    catch (...)
+    {
     }
-    try { query->promise.set_exception(error); } catch (...) {}
   }
 
   if (actualTimeouts > 0)
@@ -1467,16 +1634,18 @@ inline void DnsTransport::cleanupExpiredQueries()
   }
 }
 
-inline void DnsTransport::retryQuery(std::shared_ptr<PendingQuery> query, const std::string& reason)
+inline void DnsTransport::retryQuery(std::shared_ptr<PendingQuery> query, const std::string &reason)
 {
   if (query->retryCount.load() >= config_.retryCount)
   {
     // Maximum retries exceeded, complete with error
     // Log total attempts made (retryCount + 1 = initial attempt + retries)
-    iora::core::Logger::debug("DNS query retry limit exceeded: ID=" + std::to_string(query->queryId) + 
-                              " server=" + query->server + ":" + std::to_string(query->port) +
-                              " reason=" + reason + " totalAttempts=" + std::to_string(query->retryCount.load() + 1));
-    auto error = std::make_exception_ptr(DnsTimeoutException("Maximum retries exceeded: " + reason));
+    iora::core::Logger::debug(
+      "DNS query retry limit exceeded: ID=" + std::to_string(query->queryId) +
+      " server=" + query->server + ":" + std::to_string(query->port) + " reason=" + reason +
+      " totalAttempts=" + std::to_string(query->retryCount.load() + 1));
+    auto error =
+      std::make_exception_ptr(DnsTimeoutException("Maximum retries exceeded: " + reason));
     completeQuery(QueryKey(query->queryId, query->server, query->port), error);
     return;
   }
@@ -1485,83 +1654,90 @@ inline void DnsTransport::retryQuery(std::shared_ptr<PendingQuery> query, const
   auto baseDelay = config_.initialRetryDelay;
   for (int i = 0; i < query->retryCount.load(); ++i)
   {
-    baseDelay = std::chrono::milliseconds(
-      static_cast<long>(baseDelay.count() * config_.retryMultiplier)
-    );
+    baseDelay =
+      std::chrono::milliseconds(static_cast<long>(baseDelay.count() * config_.retryMultiplier));
   }
-  
+
   // Cap at maximum delay
   if (baseDelay > config_.maxRetryDelay)
   {
     baseDelay = config_.maxRetryDelay;
   }
-  
+
   // Add jitter to prevent thundering herd
   if (config_.jitterFactor > 0.0)
   {
-    std::uniform_real_distribution<double> dis(
-      1.0 - config_.jitterFactor, 
-      1.0 + config_.jitterFactor
-    );
-    
+    std::uniform_real_distribution<double> dis(1.0 - config_.jitterFactor,
+                                               1.0 + config_.jitterFactor);
+
     auto jitter = dis(rng_);
-    baseDelay = std::chrono::milliseconds(
-      static_cast<long>(baseDelay.count() * jitter)
-    );
+    baseDelay = std::chrono::milliseconds(static_cast<long>(baseDelay.count() * jitter));
   }
-  
+
   // Increment retry count atomically
   int newRetryCount = query->retryCount.fetch_add(1) + 1;
-  
+
   // Log the upcoming attempt number (retryCount + 1 = initial + retries)
-  iora::core::Logger::debug("DNS query retry scheduled: ID=" + std::to_string(query->queryId) + 
+  iora::core::Logger::debug("DNS query retry scheduled: ID=" + std::to_string(query->queryId) +
                             " server=" + query->server + ":" + std::to_string(query->port) +
-                            " reason=" + reason + " upcomingAttempt=" + std::to_string(newRetryCount + 1) +
+                            " reason=" + reason +
+                            " upcomingAttempt=" + std::to_string(newRetryCount + 1) +
                             " delay=" + std::to_string(baseDelay.count()) + "ms");
-  
+
   // Schedule retry after delay using timer service (avoids sleeping in worker threads)
-  std::uint64_t timerId = timerService_->scheduleAfter(baseDelay, [this, query]() {
-    // Check if query is still valid (not completed/cancelled)
-    // SAFE: queryId, server, port are const fields, so QueryKey is always consistent
+  auto self = shared_from_this();
+  std::uint64_t timerId = timerService_->scheduleAfter(
+    baseDelay,
+    [self, query]()
     {
-      std::lock_guard<std::mutex> lock(queriesMutex_);
-      QueryKey key(query->queryId, query->server, query->port);
-      auto it = pendingQueries_.find(key);
-      if (it == pendingQueries_.end())
+      // Check if transport is still running before accessing any members
+      if (!self->running_.load())
       {
-        return; // Query already completed or cancelled
+        return; // Transport has been stopped/destroyed
       }
-    }
-    
-    // Update start time for timeout calculations (fixes retry/timeout race)
-    query->startTime.store(std::chrono::steady_clock::now());
-    
-    // Retry the query
-    try
-    {
-      if (query->transportMode == DnsTransportMode::UDP)
+
+      // Check if query is still valid (not completed/cancelled)
+      // SAFE: queryId, server, port are const fields, so QueryKey is always consistent
       {
-        sendUdpQuery(query);
+        std::lock_guard<std::mutex> lock(self->queriesMutex_);
+        QueryKey key(query->queryId, query->server, query->port);
+        auto it = self->pendingQueries_.find(key);
+        if (it == self->pendingQueries_.end())
+        {
+          return; // Query already completed or cancelled
+        }
       }
-      else if (query->transportMode == DnsTransportMode::TCP)
+
+      // Update start time for timeout calculations (fixes retry/timeout race)
+      query->startTime.store(std::chrono::steady_clock::now());
+
+      // Retry the query
+      try
       {
-        sendTcpQuery(query);
+        if (query->transportMode == DnsTransportMode::UDP)
+        {
+          self->sendUdpQuery(query);
+        }
+        else if (query->transportMode == DnsTransportMode::TCP)
+        {
+          self->sendTcpQuery(query);
+        }
+
+        // Atomic increment - no mutex needed
+        self->stats_.retries.fetch_add(1, std::memory_order_relaxed);
       }
-      
-      // Atomic increment - no mutex needed
-      stats_.retries.fetch_add(1, std::memory_order_relaxed);
-    }
-    catch (const std::exception& e)
-    {
-      // Retry failed, complete with error
-      auto error = std::make_exception_ptr(DnsTransportException("Retry failed: " + std::string(e.what())));
-      completeQuery(QueryKey(query->queryId, query->server, query->port), error);
-    }
-    
-    // Clear timer ID when callback completes (success or error)
-    query->activeTimerId.store(0, std::memory_order_relaxed);
-  });
-  
+      catch (const std::exception &e)
+      {
+        // Retry failed, complete with error
+        auto error =
+          std::make_exception_ptr(DnsTransportException("Retry failed: " + std::string(e.what())));
+        self->completeQuery(QueryKey(query->queryId, query->server, query->port), error);
+      }
+
+      // Clear timer ID when callback completes (success or error)
+      query->activeTimerId.store(0, std::memory_order_relaxed);
+    });
+
   // Store timer ID for potential cancellation
   query->activeTimerId.store(timerId, std::memory_order_relaxed);
 }
diff --git a/include/iora/network/dns/dns_types.hpp b/include/iora/network/dns/dns_types.hpp
index bc3a217..a0ade6a 100644
--- a/include/iora/network/dns/dns_types.hpp
+++ b/include/iora/network/dns/dns_types.hpp
@@ -6,13 +6,13 @@
 
 #pragma once
 
+#include <algorithm>
+#include <cctype>
+#include <chrono>
 #include <cstdint>
+#include <optional>
 #include <string>
 #include <vector>
-#include <chrono>
-#include <optional>
-#include <algorithm>
-#include <cctype>
 
 namespace iora
 {
@@ -24,86 +24,94 @@ namespace dns
 /// \brief DNS message opcodes (RFC 1035)
 enum class DnsOpcode : std::uint8_t
 {
-  Query = 0,        ///< Standard query
-  IQuery = 1,       ///< Inverse query (obsolete)
-  Status = 2,       ///< Server status request
-  Notify = 4,       ///< Zone change notification (RFC 1996)
-  Update = 5        ///< Dynamic update (RFC 2136)
+  Query = 0,  ///< Standard query
+  IQuery = 1, ///< Inverse query (obsolete)
+  Status = 2, ///< Server status request
+  Notify = 4, ///< Zone change notification (RFC 1996)
+  Update = 5  ///< Dynamic update (RFC 2136)
 };
 
 /// \brief DNS response codes (RFC 1035, RFC 2136, RFC 6895)
 enum class DnsResponseCode : std::uint8_t
 {
-  NOERROR = 0,      ///< No error
-  FORMERR = 1,      ///< Format error
-  SERVFAIL = 2,     ///< Server failure
-  NXDOMAIN = 3,     ///< Name does not exist
-  NOTIMP = 4,       ///< Not implemented
-  REFUSED = 5,      ///< Query refused
-  YXDOMAIN = 6,     ///< Name exists when it should not
-  YXRRSET = 7,      ///< RR set exists when it should not
-  NXRRSET = 8,      ///< RR set that should exist does not
-  NOTAUTH = 9,      ///< Not authorized
-  NOTZONE = 10,     ///< Name not contained in zone
-  BADVERS = 16      ///< Bad OPT version (RFC 6891)
+  NOERROR = 0,  ///< No error
+  FORMERR = 1,  ///< Format error
+  SERVFAIL = 2, ///< Server failure
+  NXDOMAIN = 3, ///< Name does not exist
+  NOTIMP = 4,   ///< Not implemented
+  REFUSED = 5,  ///< Query refused
+  YXDOMAIN = 6, ///< Name exists when it should not
+  YXRRSET = 7,  ///< RR set exists when it should not
+  NXRRSET = 8,  ///< RR set that should exist does not
+  NOTAUTH = 9,  ///< Not authorized
+  NOTZONE = 10, ///< Name not contained in zone
+  BADVERS = 16  ///< Bad OPT version (RFC 6891)
 };
 
 /// \brief DNS record types (RFC 1035 and extensions, SIP-focused)
 enum class DnsType : std::uint16_t
 {
   // Basic types
-  A = 1,            ///< IPv4 address
-  NS = 2,           ///< Name server
-  CNAME = 5,        ///< Canonical name
-  SOA = 6,          ///< Start of authority
-  PTR = 12,         ///< Pointer record
-  MX = 15,          ///< Mail exchange
-  TXT = 16,         ///< Text record
-  AAAA = 28,        ///< IPv6 address
+  A = 1,     ///< IPv4 address
+  NS = 2,    ///< Name server
+  CNAME = 5, ///< Canonical name
+  SOA = 6,   ///< Start of authority
+  PTR = 12,  ///< Pointer record
+  MX = 15,   ///< Mail exchange
+  TXT = 16,  ///< Text record
+  AAAA = 28, ///< IPv6 address
 
   // SIP-critical record types (first-class citizens)
-  SRV = 33,         ///< Service location (RFC 2052, critical for SIP)
-  NAPTR = 35,       ///< Naming Authority Pointer (RFC 3403, essential for SIP)
+  SRV = 33,   ///< Service location (RFC 2052, critical for SIP)
+  NAPTR = 35, ///< Naming Authority Pointer (RFC 3403, essential for SIP)
 
   // Query types
-  AXFR = 252,       ///< Zone transfer
-  MAILB = 253,      ///< Mail box records
-  MAILA = 254,      ///< Mail agent records
-  ANY = 255         ///< All records
+  AXFR = 252,  ///< Zone transfer
+  MAILB = 253, ///< Mail box records
+  MAILA = 254, ///< Mail agent records
+  ANY = 255    ///< All records
+};
+
+/// \brief Address resolution policy for hostname queries
+enum class AddressResolutionPolicy : std::uint8_t
+{
+  IPv4Only = 0,  ///< Query A records only, ignore IPv6
+  IPv6Only = 1,  ///< Query AAAA records only, ignore IPv4
+  IPv4First = 2, ///< Query both A/AAAA, sort IPv4 addresses first
+  IPv6First = 3  ///< Query both A/AAAA, sort IPv6 addresses first
 };
 
 /// \brief DNS record class (RFC 1035)
 enum class DnsClass : std::uint16_t
 {
-  IN = 1,           ///< Internet class
-  CS = 2,           ///< CSNET class (obsolete)
-  CH = 3,           ///< CHAOS class
-  HS = 4,           ///< Hesiod class
-  ANY = 255         ///< Any class
+  IN = 1,   ///< Internet class
+  CS = 2,   ///< CSNET class (obsolete)
+  CH = 3,   ///< CHAOS class
+  HS = 4,   ///< Hesiod class
+  ANY = 255 ///< Any class
 };
 
 /// \brief DNS message flags and header structure
 struct DnsHeader
 {
-  std::uint16_t id;                 ///< Query identifier
-  bool qr;                          ///< Query/Response flag
-  DnsOpcode opcode;                 ///< Operation code
-  bool aa;                          ///< Authoritative answer
-  bool tc;                          ///< Truncation flag
-  bool rd;                          ///< Recursion desired
-  bool ra;                          ///< Recursion available
-  std::uint8_t z;                   ///< Reserved for future use (must be zero)
-  DnsResponseCode rcode;            ///< Response code
-  std::uint16_t qdcount;            ///< Question count
-  std::uint16_t ancount;            ///< Answer count
-  std::uint16_t nscount;            ///< Authority count
-  std::uint16_t arcount;            ///< Additional count
+  std::uint16_t id;      ///< Query identifier
+  bool qr;               ///< Query/Response flag
+  DnsOpcode opcode;      ///< Operation code
+  bool aa;               ///< Authoritative answer
+  bool tc;               ///< Truncation flag
+  bool rd;               ///< Recursion desired
+  bool ra;               ///< Recursion available
+  std::uint8_t z;        ///< Reserved for future use (must be zero)
+  DnsResponseCode rcode; ///< Response code
+  std::uint16_t qdcount; ///< Question count
+  std::uint16_t ancount; ///< Answer count
+  std::uint16_t nscount; ///< Authority count
+  std::uint16_t arcount; ///< Additional count
 
   /// \brief Default constructor
   DnsHeader()
-    : id(0), qr(false), opcode(DnsOpcode::Query), aa(false), tc(false),
-      rd(true), ra(false), z(0), rcode(DnsResponseCode::NOERROR),
-      qdcount(0), ancount(0), nscount(0), arcount(0)
+      : id(0), qr(false), opcode(DnsOpcode::Query), aa(false), tc(false), rd(true), ra(false), z(0),
+        rcode(DnsResponseCode::NOERROR), qdcount(0), ancount(0), nscount(0), arcount(0)
   {
   }
 };
@@ -111,14 +119,13 @@ struct DnsHeader
 /// \brief DNS question section
 struct DnsQuestion
 {
-  std::string qname;                ///< Domain name
-  DnsType qtype;                    ///< Query type
-  DnsClass qclass;                  ///< Query class
+  std::string qname; ///< Domain name
+  DnsType qtype;     ///< Query type
+  DnsClass qclass;   ///< Query class
 
   /// \brief Constructor
-  DnsQuestion(const std::string& name = "", DnsType type = DnsType::A, 
-              DnsClass cls = DnsClass::IN)
-    : qname(name), qtype(type), qclass(cls)
+  DnsQuestion(const std::string &name = "", DnsType type = DnsType::A, DnsClass cls = DnsClass::IN)
+      : qname(name), qtype(type), qclass(cls)
   {
   }
 };
@@ -126,12 +133,12 @@ struct DnsQuestion
 /// \brief Cache key for DNS queries (hashable and comparable)
 struct DnsCacheKey
 {
-  std::string qname;                ///< Domain name (case-insensitive)
-  DnsType qtype;                    ///< Query type
-  DnsClass qclass;                  ///< Query class
+  std::string qname; ///< Domain name (case-insensitive)
+  DnsType qtype;     ///< Query type
+  DnsClass qclass;   ///< Query class
 
   /// \brief Create cache key from DNS question
-  static DnsCacheKey fromQuestion(const DnsQuestion& question)
+  static DnsCacheKey fromQuestion(const DnsQuestion &question)
   {
     DnsCacheKey key;
     // Convert to lowercase for case-insensitive comparison
@@ -143,31 +150,32 @@ struct DnsCacheKey
   }
 
   /// \brief Equality operator for cache lookup
-  bool operator==(const DnsCacheKey& other) const
+  bool operator==(const DnsCacheKey &other) const
   {
     return qname == other.qname && qtype == other.qtype && qclass == other.qclass;
   }
 
   /// \brief Less-than operator for ordered containers
-  bool operator<(const DnsCacheKey& other) const
+  bool operator<(const DnsCacheKey &other) const
   {
-    if (qname != other.qname) return qname < other.qname;
-    if (qtype != other.qtype) return static_cast<uint16_t>(qtype) < static_cast<uint16_t>(other.qtype);
+    if (qname != other.qname)
+      return qname < other.qname;
+    if (qtype != other.qtype)
+      return static_cast<uint16_t>(qtype) < static_cast<uint16_t>(other.qtype);
     return static_cast<uint16_t>(qclass) < static_cast<uint16_t>(other.qclass);
   }
 };
 
 } // namespace dns
-} // namespace network  
+} // namespace network
 } // namespace iora
 
 // Hash specialization for DnsCacheKey to work with std::unordered_map
 namespace std
 {
-template<>
-struct hash<iora::network::dns::DnsCacheKey>
+template <> struct hash<iora::network::dns::DnsCacheKey>
 {
-  std::size_t operator()(const iora::network::dns::DnsCacheKey& key) const
+  std::size_t operator()(const iora::network::dns::DnsCacheKey &key) const
   {
     std::size_t h1 = std::hash<std::string>{}(key.qname);
     std::size_t h2 = std::hash<std::uint16_t>{}(static_cast<std::uint16_t>(key.qtype));
@@ -175,26 +183,29 @@ struct hash<iora::network::dns::DnsCacheKey>
     return h1 ^ (h2 << 1) ^ (h3 << 2);
   }
 };
-}
+} // namespace std
 
-namespace iora {
-namespace network {
-namespace dns {
+namespace iora
+{
+namespace network
+{
+namespace dns
+{
 
 /// \brief Base DNS resource record
 struct DnsResourceRecord
 {
-  std::string name;                 ///< Domain name
-  DnsType type;                     ///< Record type
-  DnsClass cls;                     ///< Record class
-  std::uint32_t ttl;                ///< Time to live (seconds)
-  std::uint16_t rdlength;           ///< Resource data length
-  std::vector<std::uint8_t> rdata;  ///< Resource data (raw)
+  std::string name;                ///< Domain name
+  DnsType type;                    ///< Record type
+  DnsClass cls;                    ///< Record class
+  std::uint32_t ttl;               ///< Time to live (seconds)
+  std::uint16_t rdlength;          ///< Resource data length
+  std::vector<std::uint8_t> rdata; ///< Resource data (raw)
 
   /// \brief Constructor
-  DnsResourceRecord(const std::string& n = "", DnsType t = DnsType::A,
-                    DnsClass c = DnsClass::IN, std::uint32_t ttl_val = 0)
-    : name(n), type(t), cls(c), ttl(ttl_val), rdlength(0)
+  DnsResourceRecord(const std::string &n = "", DnsType t = DnsType::A, DnsClass c = DnsClass::IN,
+                    std::uint32_t ttl_val = 0)
+      : name(n), type(t), cls(c), ttl(ttl_val), rdlength(0)
   {
   }
 
@@ -205,26 +216,22 @@ struct DnsResourceRecord
   }
 
   /// \brief Check if record has expired
-  bool hasExpired() const
-  {
-    return std::chrono::steady_clock::now() >= getExpirationTime();
-  }
+  bool hasExpired() const { return std::chrono::steady_clock::now() >= getExpirationTime(); }
 };
 
 /// \brief SRV record structure (RFC 2052) - Critical for SIP
 struct SrvRecord : public DnsResourceRecord
 {
-  std::uint16_t priority;           ///< Priority (lower = higher priority)
-  std::uint16_t weight;             ///< Weight for load balancing
-  std::uint16_t port;               ///< Service port
-  std::string target;               ///< Target hostname
+  std::uint16_t priority; ///< Priority (lower = higher priority)
+  std::uint16_t weight;   ///< Weight for load balancing
+  std::uint16_t port;     ///< Service port
+  std::string target;     ///< Target hostname
 
   /// \brief Constructor
-  SrvRecord(const std::string& name = "", std::uint16_t prio = 0,
-            std::uint16_t w = 0, std::uint16_t p = 0, 
-            const std::string& tgt = "", std::uint32_t ttl_val = 0)
-    : DnsResourceRecord(name, DnsType::SRV, DnsClass::IN, ttl_val),
-      priority(prio), weight(w), port(p), target(tgt)
+  SrvRecord(const std::string &name = "", std::uint16_t prio = 0, std::uint16_t w = 0,
+            std::uint16_t p = 0, const std::string &tgt = "", std::uint32_t ttl_val = 0)
+      : DnsResourceRecord(name, DnsType::SRV, DnsClass::IN, ttl_val), priority(prio), weight(w),
+        port(p), target(tgt)
   {
   }
 };
@@ -232,21 +239,19 @@ struct SrvRecord : public DnsResourceRecord
 /// \brief NAPTR record structure (RFC 3403) - Essential for SIP
 struct NaptrRecord : public DnsResourceRecord
 {
-  std::uint16_t order;              ///< Order of processing
-  std::uint16_t preference;         ///< Preference within same order
-  std::string flags;                ///< Control flags (e.g., "S", "A", "U")
-  std::string service;              ///< Service type (e.g., "SIP+D2U")
-  std::string regexp;               ///< Regular expression for transformation
-  std::string replacement;          ///< Replacement domain name
+  std::uint16_t order;      ///< Order of processing
+  std::uint16_t preference; ///< Preference within same order
+  std::string flags;        ///< Control flags (e.g., "S", "A", "U")
+  std::string service;      ///< Service type (e.g., "SIP+D2U")
+  std::string regexp;       ///< Regular expression for transformation
+  std::string replacement;  ///< Replacement domain name
 
   /// \brief Constructor
-  NaptrRecord(const std::string& name = "", std::uint16_t ord = 0,
-              std::uint16_t pref = 0, const std::string& f = "",
-              const std::string& s = "", const std::string& re = "",
-              const std::string& repl = "", std::uint32_t ttl_val = 0)
-    : DnsResourceRecord(name, DnsType::NAPTR, DnsClass::IN, ttl_val),
-      order(ord), preference(pref), flags(f), service(s), 
-      regexp(re), replacement(repl)
+  NaptrRecord(const std::string &name = "", std::uint16_t ord = 0, std::uint16_t pref = 0,
+              const std::string &f = "", const std::string &s = "", const std::string &re = "",
+              const std::string &repl = "", std::uint32_t ttl_val = 0)
+      : DnsResourceRecord(name, DnsType::NAPTR, DnsClass::IN, ttl_val), order(ord),
+        preference(pref), flags(f), service(s), regexp(re), replacement(repl)
   {
   }
 };
@@ -254,27 +259,23 @@ struct NaptrRecord : public DnsResourceRecord
 /// \brief A record structure (IPv4 address)
 struct ARecord : public DnsResourceRecord
 {
-  std::string address;              ///< IPv4 address string
+  std::string address; ///< IPv4 address string
 
   /// \brief Constructor
-  ARecord(const std::string& name = "", const std::string& addr = "",
-          std::uint32_t ttl_val = 0)
-    : DnsResourceRecord(name, DnsType::A, DnsClass::IN, ttl_val),
-      address(addr)
+  ARecord(const std::string &name = "", const std::string &addr = "", std::uint32_t ttl_val = 0)
+      : DnsResourceRecord(name, DnsType::A, DnsClass::IN, ttl_val), address(addr)
   {
   }
 };
 
-/// \brief AAAA record structure (IPv6 address)  
+/// \brief AAAA record structure (IPv6 address)
 struct AAAARecord : public DnsResourceRecord
 {
-  std::string address;              ///< IPv6 address string
+  std::string address; ///< IPv6 address string
 
   /// \brief Constructor
-  AAAARecord(const std::string& name = "", const std::string& addr = "",
-             std::uint32_t ttl_val = 0)
-    : DnsResourceRecord(name, DnsType::AAAA, DnsClass::IN, ttl_val),
-      address(addr)
+  AAAARecord(const std::string &name = "", const std::string &addr = "", std::uint32_t ttl_val = 0)
+      : DnsResourceRecord(name, DnsType::AAAA, DnsClass::IN, ttl_val), address(addr)
   {
   }
 };
@@ -282,13 +283,11 @@ struct AAAARecord : public DnsResourceRecord
 /// \brief CNAME record structure
 struct CnameRecord : public DnsResourceRecord
 {
-  std::string cname;                ///< Canonical name
+  std::string cname; ///< Canonical name
 
   /// \brief Constructor
-  CnameRecord(const std::string& name = "", const std::string& cn = "",
-              std::uint32_t ttl_val = 0)
-    : DnsResourceRecord(name, DnsType::CNAME, DnsClass::IN, ttl_val),
-      cname(cn)
+  CnameRecord(const std::string &name = "", const std::string &cn = "", std::uint32_t ttl_val = 0)
+      : DnsResourceRecord(name, DnsType::CNAME, DnsClass::IN, ttl_val), cname(cn)
   {
   }
 };
@@ -296,14 +295,14 @@ struct CnameRecord : public DnsResourceRecord
 /// \brief MX record structure
 struct MxRecord : public DnsResourceRecord
 {
-  std::uint16_t preference;         ///< Mail server preference
-  std::string exchange;             ///< Mail server hostname
+  std::uint16_t preference; ///< Mail server preference
+  std::string exchange;     ///< Mail server hostname
 
   /// \brief Constructor
-  MxRecord(const std::string& name = "", std::uint16_t pref = 0,
-           const std::string& exch = "", std::uint32_t ttl_val = 0)
-    : DnsResourceRecord(name, DnsType::MX, DnsClass::IN, ttl_val),
-      preference(pref), exchange(exch)
+  MxRecord(const std::string &name = "", std::uint16_t pref = 0, const std::string &exch = "",
+           std::uint32_t ttl_val = 0)
+      : DnsResourceRecord(name, DnsType::MX, DnsClass::IN, ttl_val), preference(pref),
+        exchange(exch)
   {
   }
 };
@@ -311,14 +310,12 @@ struct MxRecord : public DnsResourceRecord
 /// \brief TXT record structure
 struct TxtRecord : public DnsResourceRecord
 {
-  std::vector<std::string> text;    ///< Text strings
+  std::vector<std::string> text; ///< Text strings
 
   /// \brief Constructor
-  TxtRecord(const std::string& name = "", 
-            const std::vector<std::string>& txt = {},
+  TxtRecord(const std::string &name = "", const std::vector<std::string> &txt = {},
             std::uint32_t ttl_val = 0)
-    : DnsResourceRecord(name, DnsType::TXT, DnsClass::IN, ttl_val),
-      text(txt)
+      : DnsResourceRecord(name, DnsType::TXT, DnsClass::IN, ttl_val), text(txt)
   {
   }
 };
@@ -326,13 +323,11 @@ struct TxtRecord : public DnsResourceRecord
 /// \brief PTR record structure (reverse DNS)
 struct PtrRecord : public DnsResourceRecord
 {
-  std::string ptrdname;             ///< Pointer domain name
+  std::string ptrdname; ///< Pointer domain name
 
   /// \brief Constructor
-  PtrRecord(const std::string& name = "", const std::string& ptr = "",
-            std::uint32_t ttl_val = 0)
-    : DnsResourceRecord(name, DnsType::PTR, DnsClass::IN, ttl_val),
-      ptrdname(ptr)
+  PtrRecord(const std::string &name = "", const std::string &ptr = "", std::uint32_t ttl_val = 0)
+      : DnsResourceRecord(name, DnsType::PTR, DnsClass::IN, ttl_val), ptrdname(ptr)
   {
   }
 };
@@ -340,23 +335,21 @@ struct PtrRecord : public DnsResourceRecord
 /// \brief SOA record structure (Start of Authority, RFC 1035)
 struct SoaRecord : public DnsResourceRecord
 {
-  std::string mname;                ///< Primary nameserver
-  std::string rname;                ///< Responsible person email
-  std::uint32_t serial;             ///< Serial number
-  std::uint32_t refresh;            ///< Refresh interval (seconds)
-  std::uint32_t retry;              ///< Retry interval (seconds) 
-  std::uint32_t expire;             ///< Expire time (seconds)
-  std::uint32_t minimum;            ///< Minimum TTL for negative caching (RFC 2308)
+  std::string mname;     ///< Primary nameserver
+  std::string rname;     ///< Responsible person email
+  std::uint32_t serial;  ///< Serial number
+  std::uint32_t refresh; ///< Refresh interval (seconds)
+  std::uint32_t retry;   ///< Retry interval (seconds)
+  std::uint32_t expire;  ///< Expire time (seconds)
+  std::uint32_t minimum; ///< Minimum TTL for negative caching (RFC 2308)
 
   /// \brief Constructor
-  SoaRecord(const std::string& name = "", const std::string& primary = "",
-            const std::string& email = "", std::uint32_t ser = 0,
-            std::uint32_t ref = 0, std::uint32_t ret = 0, 
-            std::uint32_t exp = 0, std::uint32_t min = 0, 
+  SoaRecord(const std::string &name = "", const std::string &primary = "",
+            const std::string &email = "", std::uint32_t ser = 0, std::uint32_t ref = 0,
+            std::uint32_t ret = 0, std::uint32_t exp = 0, std::uint32_t min = 0,
             std::uint32_t ttl_val = 0)
-    : DnsResourceRecord(name, DnsType::SOA, DnsClass::IN, ttl_val),
-      mname(primary), rname(email), serial(ser), refresh(ref), 
-      retry(ret), expire(exp), minimum(min)
+      : DnsResourceRecord(name, DnsType::SOA, DnsClass::IN, ttl_val), mname(primary), rname(email),
+        serial(ser), refresh(ref), retry(ret), expire(exp), minimum(min)
   {
   }
 };
@@ -364,67 +357,60 @@ struct SoaRecord : public DnsResourceRecord
 /// \brief DNS query result container
 struct DnsResult
 {
-  DnsHeader header;                 ///< Response header
-  std::vector<DnsQuestion> questions; ///< Question section
-  std::vector<DnsResourceRecord> answers; ///< Answer section
-  std::vector<DnsResourceRecord> authority; ///< Authority section
+  DnsHeader header;                          ///< Response header
+  std::vector<DnsQuestion> questions;        ///< Question section
+  std::vector<DnsResourceRecord> answers;    ///< Answer section
+  std::vector<DnsResourceRecord> authority;  ///< Authority section
   std::vector<DnsResourceRecord> additional; ///< Additional section
-  
+
   // Parsed typed records for convenience (SIP-focused)
   std::vector<ARecord> a_records;
   std::vector<AAAARecord> aaaa_records;
-  std::vector<SrvRecord> srv_records;       ///< Critical for SIP
-  std::vector<NaptrRecord> naptr_records;   ///< Essential for SIP
+  std::vector<SrvRecord> srv_records;     ///< Critical for SIP
+  std::vector<NaptrRecord> naptr_records; ///< Essential for SIP
   std::vector<CnameRecord> cname_records;
   std::vector<MxRecord> mx_records;
   std::vector<TxtRecord> txt_records;
   std::vector<PtrRecord> ptr_records;
-  std::vector<SoaRecord> soa_records;       ///< SOA records (for negative caching)
+  std::vector<SoaRecord> soa_records; ///< SOA records (for negative caching)
 
   /// \brief Check if response indicates success
-  bool isSuccess() const
-  {
-    return header.rcode == DnsResponseCode::NOERROR && 
-           header.ancount > 0;
-  }
+  bool isSuccess() const { return header.rcode == DnsResponseCode::NOERROR && header.ancount > 0; }
 
   /// \brief Check if response was truncated (needs TCP retry)
-  bool isTruncated() const
-  {
-    return header.tc;
-  }
+  bool isTruncated() const { return header.tc; }
 
   /// \brief Get human-readable response code string
   std::string getResponseCodeString() const
   {
     switch (header.rcode)
     {
-      case DnsResponseCode::NOERROR:
-        return "NOERROR";
-      case DnsResponseCode::FORMERR:
-        return "FORMERR";
-      case DnsResponseCode::SERVFAIL:
-        return "SERVFAIL";
-      case DnsResponseCode::NXDOMAIN:
-        return "NXDOMAIN";
-      case DnsResponseCode::NOTIMP:
-        return "NOTIMP";
-      case DnsResponseCode::REFUSED:
-        return "REFUSED";
-      case DnsResponseCode::YXDOMAIN:
-        return "YXDOMAIN";
-      case DnsResponseCode::YXRRSET:
-        return "YXRRSET";
-      case DnsResponseCode::NXRRSET:
-        return "NXRRSET";
-      case DnsResponseCode::NOTAUTH:
-        return "NOTAUTH";
-      case DnsResponseCode::NOTZONE:
-        return "NOTZONE";
-      case DnsResponseCode::BADVERS:
-        return "BADVERS";
-      default:
-        return "UNKNOWN(" + std::to_string(static_cast<uint8_t>(header.rcode)) + ")";
+    case DnsResponseCode::NOERROR:
+      return "NOERROR";
+    case DnsResponseCode::FORMERR:
+      return "FORMERR";
+    case DnsResponseCode::SERVFAIL:
+      return "SERVFAIL";
+    case DnsResponseCode::NXDOMAIN:
+      return "NXDOMAIN";
+    case DnsResponseCode::NOTIMP:
+      return "NOTIMP";
+    case DnsResponseCode::REFUSED:
+      return "REFUSED";
+    case DnsResponseCode::YXDOMAIN:
+      return "YXDOMAIN";
+    case DnsResponseCode::YXRRSET:
+      return "YXRRSET";
+    case DnsResponseCode::NXRRSET:
+      return "NXRRSET";
+    case DnsResponseCode::NOTAUTH:
+      return "NOTAUTH";
+    case DnsResponseCode::NOTZONE:
+      return "NOTZONE";
+    case DnsResponseCode::BADVERS:
+      return "BADVERS";
+    default:
+      return "UNKNOWN(" + std::to_string(static_cast<uint8_t>(header.rcode)) + ")";
     }
   }
 };
@@ -432,13 +418,77 @@ struct DnsResult
 /// \brief DNS transport mode
 enum class DnsTransportMode
 {
-  UDP,              ///< UDP transport (primary)
-  TCP,              ///< TCP transport (fallback)
-  Both              ///< Try UDP first, fallback to TCP
+  UDP, ///< UDP transport (primary)
+  TCP, ///< TCP transport (fallback)
+  Both ///< Try UDP first, fallback to TCP
+};
+
+/// \brief DNS server configuration with per-server port support
+struct DnsServer
+{
+  std::string address; ///< DNS server IP address (IPv4 or IPv6)
+  std::uint16_t port;  ///< DNS server port
+
+  /// \brief Default constructor
+  DnsServer() : address(""), port(53) {}
+
+  /// \brief Constructor for server with explicit port
+  DnsServer(const std::string &addr, std::uint16_t p = 53) : address(addr), port(p) {}
+
+  /// \brief Parse server string in "address" or "address:port" format
+  /// \param serverStr Server string to parse (e.g., "8.8.8.8" or "8.8.8.8:53")
+  /// \return DnsServer instance with parsed address and port
+  static DnsServer fromString(const std::string &serverStr)
+  {
+    size_t colonPos = serverStr.find_last_of(':');
+    if (colonPos != std::string::npos)
+    {
+      // Extract IP and port
+      std::string ip = serverStr.substr(0, colonPos);
+      std::string portStr = serverStr.substr(colonPos + 1);
+
+      // Parse port number
+      try
+      {
+        auto serverPort = static_cast<std::uint16_t>(std::stoi(portStr));
+        return DnsServer(ip, serverPort);
+      }
+      catch (const std::exception &)
+      {
+        // Invalid port format, treat entire string as IP with default port
+        return DnsServer(serverStr, 53);
+      }
+    }
+    else
+    {
+      // No port specified, use default
+      return DnsServer(serverStr, 53);
+    }
+  }
+
+  /// \brief Convert to string representation
+  /// \return String in "address:port" format
+  std::string toString() const
+  {
+    if (port != 53)
+    {
+      return address + ":" + std::to_string(port);
+    }
+    else
+    {
+      return address; // Omit standard port for cleaner display
+    }
+  }
+
+  /// \brief Equality operator
+  bool operator==(const DnsServer &other) const
+  {
+    return address == other.address && port == other.port;
+  }
 };
 
 /// \brief DNS client configuration with comprehensive timeout and retry settings
-/// 
+///
 /// This structure configures all aspects of DNS client behavior including timeouts,
 /// retry policies, caching, and transport selection. All timeout values use
 /// std::chrono types for type safety and clarity.
@@ -447,128 +497,198 @@ struct DnsConfig
   // =============================================================================
   // Server Configuration
   // =============================================================================
-  
-  /// \brief DNS servers to query (IPv4 addresses)
-  /// Default: Google DNS (8.8.8.8) and Cloudflare DNS (1.1.1.1)
-  std::vector<std::string> servers{"8.8.8.8", "1.1.1.1"};
-  
-  /// \brief DNS server port
-  /// Default: 53 (standard DNS port)
-  std::uint16_t port{53};
-  
+
+  /// \brief DNS servers to query with per-server port configuration
+  /// Default: Google DNS (8.8.8.8:53) and Cloudflare DNS (1.1.1.1:53)
+  std::vector<DnsServer> servers{DnsServer("8.8.8.8", 53), DnsServer("1.1.1.1", 53)};
+
   // =============================================================================
   // Timeout Configuration (with clear units and defaults)
   // =============================================================================
-  
+
   /// \brief Initial query timeout before first retry
   /// Default: 5000ms (5 seconds)
   /// Range: 1000ms - 30000ms recommended
   /// Used for: UDP/TCP query response timeout
   std::chrono::milliseconds timeout{5000};
-  
+
   /// \brief TCP-specific connection and query timeout
-  /// Default: 10000ms (10 seconds) 
+  /// Default: 10000ms (10 seconds)
   /// Range: 5000ms - 60000ms recommended
   /// Used for: TCP connection establishment + query response
   /// Note: Should be >= timeout since TCP requires connection setup
   std::chrono::milliseconds tcpTimeout{10000};
-  
+
   /// \brief Cache entry time-to-live override
   /// Default: 300s (5 minutes)
   /// Range: 60s - 86400s recommended
   /// Used for: Maximum cache retention time (actual TTL from DNS records may be shorter)
   std::chrono::seconds cacheTimeout{300};
-  
+
   // =============================================================================
   // Retry Policy Configuration (exponential backoff with jitter)
   // =============================================================================
-  
+
   /// \brief Maximum number of retry attempts per query
   /// Default: 3 retries (total 4 attempts including initial)
   /// Range: 0-10 recommended
   int retryCount{3};
-  
+
   /// \brief Initial delay before first retry
   /// Default: 500ms
   /// Range: 100ms - 5000ms recommended
   /// Note: Subsequent delays use exponential backoff (delay *= retryMultiplier)
   std::chrono::milliseconds initialRetryDelay{500};
-  
+
   /// \brief Exponential backoff multiplier for retry delays
   /// Default: 2.0 (double delay each retry)
   /// Range: 1.1 - 3.0 recommended
-  /// Examples: 
+  /// Examples:
   ///   2.0  delays: 500ms, 1000ms, 2000ms, 4000ms
   ///   1.5  delays: 500ms, 750ms, 1125ms, 1687ms
   double retryMultiplier{2.0};
-  
+
   /// \brief Maximum retry delay cap
   /// Default: 10000ms (10 seconds)
   /// Range: 1000ms - 30000ms recommended
   /// Note: Prevents exponential backoff from becoming too large
   std::chrono::milliseconds maxRetryDelay{10000};
-  
+
   /// \brief Jitter factor to randomize retry delays (prevents thundering herd)
   /// Default: 0.1 (10% randomization)
   /// Range: 0.0 (no jitter) - 0.5 (50% jitter) recommended
   /// Formula: actual_delay = base_delay * (1.0  jitterFactor)
   double jitterFactor{0.1};
-  
+
   // =============================================================================
   // Caching Configuration
   // =============================================================================
-  
+
   /// \brief Enable DNS result caching
   /// Default: true
   bool enableCache{true};
-  
+
   /// \brief Maximum cache entries (ignored - ExpiringCache uses time-based expiration)
   /// Default: 10000 (kept for API compatibility)
   /// Note: Actual cache size limited by TTL expiration, not entry count
   std::size_t maxCacheSize{10000};
-  
+
   // =============================================================================
   // Transport Configuration
   // =============================================================================
-  
+
   /// \brief Transport mode preference
   /// Default: Both (UDP with TCP fallback on truncation)
   /// Options: UDP_Only, TCP_Only, Both
   DnsTransportMode transportMode{DnsTransportMode::Both};
-  
+
   /// \brief Request recursion from DNS server (RD flag)
   /// Default: true (most common for client queries)
   bool recursionDesired{true};
-  
+
   /// \brief Maximum UDP message size before TCP fallback
   /// Default: 512 bytes (RFC 1035 minimum)
   /// Range: 512 - 4096 bytes
   /// Note: Larger values may cause fragmentation issues
   std::size_t maxUdpSize{512};
-  
+
   /// \brief Maximum TCP receive buffer size per session
   /// Default: 65536 bytes (64KB per session)
   /// Range: 8192 - 1048576 bytes (8KB - 1MB)
   /// Note: Prevents unbounded memory usage under high load or attacks.
   /// Sessions exceeding this limit will be closed to prevent DoS.
   std::size_t maxTcpBufferSize{65536};
-  
+
+  // =============================================================================
+  // Address Resolution Configuration
+  // =============================================================================
+
+  /// \brief Address resolution policy for hostname queries
+  /// Default: IPv4First (compatible with current behavior)
+  /// - IPv4Only: Only queries A records (like current prefer_ipv6=false)
+  /// - IPv6Only: Only queries AAAA records (like current prefer_ipv6=true with no A fallback)
+  /// - IPv4First: Queries both A/AAAA, returns IPv4 addresses first, then IPv6
+  /// - IPv6First: Queries both A/AAAA, returns IPv6 addresses first, then IPv4
+  /// Note: SRV records always take precedence over this policy
+  AddressResolutionPolicy addressResolutionPolicy{AddressResolutionPolicy::IPv4First};
+
   /// \brief Default constructor
   DnsConfig() = default;
+
+  /// \brief Backward compatibility constructor with server list and global port
+  /// \param serverList List of server addresses (without ports)
+  /// \param globalPort Port to use for all servers
+  DnsConfig(const std::vector<std::string> &serverList, std::uint16_t globalPort = 53)
+  {
+    servers.clear();
+    servers.reserve(serverList.size());
+    for (const auto &serverAddr : serverList)
+    {
+      servers.emplace_back(serverAddr, globalPort);
+    }
+  }
+
+  /// \brief Backward compatibility constructor with mixed server strings
+  /// \param serverStrings List of server strings in "address" or "address:port" format
+  explicit DnsConfig(const std::vector<std::string> &serverStrings)
+  {
+    servers.clear();
+    servers.reserve(serverStrings.size());
+    for (const auto &serverStr : serverStrings)
+    {
+      servers.push_back(DnsServer::fromString(serverStr));
+    }
+  }
+
+  /// \brief Backward compatibility constructor with initializer list
+  /// \param serverStrings Initializer list of server strings
+  DnsConfig(std::initializer_list<std::string> serverStrings)
+  {
+    servers.clear();
+    servers.reserve(serverStrings.size());
+    for (const auto &serverStr : serverStrings)
+    {
+      servers.push_back(DnsServer::fromString(serverStr));
+    }
+  }
+
+  /// \brief Backward compatibility setter for server strings
+  /// \param serverStrings List of server strings
+  void setServers(const std::vector<std::string> &serverStrings)
+  {
+    servers.clear();
+    servers.reserve(serverStrings.size());
+    for (const auto &serverStr : serverStrings)
+    {
+      servers.push_back(DnsServer::fromString(serverStr));
+    }
+  }
+
+  /// \brief Backward compatibility setter for server strings (initializer list)
+  /// \param serverStrings Initializer list of server strings
+  void setServers(std::initializer_list<std::string> serverStrings)
+  {
+    servers.clear();
+    servers.reserve(serverStrings.size());
+    for (const auto &serverStr : serverStrings)
+    {
+      servers.push_back(DnsServer::fromString(serverStr));
+    }
+  }
 };
 
 /// \brief DNS protocol constants
 namespace constants
 {
-  constexpr std::uint16_t DNS_PORT = 53;
-  constexpr std::size_t DNS_HEADER_SIZE = 12;
-  constexpr std::size_t DNS_MAX_UDP_SIZE = 512;
-  constexpr std::size_t DNS_MAX_TCP_SIZE = 65535;
-  constexpr std::size_t DNS_MAX_LABEL_SIZE = 63;
-  constexpr std::size_t DNS_MAX_NAME_SIZE = 253;
-  constexpr std::uint8_t DNS_COMPRESSION_MASK = 0xC0;
-  constexpr std::uint16_t DNS_COMPRESSION_POINTER_MASK = 0x3FFF;
-}
+constexpr std::uint16_t DNS_PORT = 53;
+constexpr std::size_t DNS_HEADER_SIZE = 12;
+constexpr std::size_t DNS_MAX_UDP_SIZE = 512;
+constexpr std::size_t DNS_MAX_TCP_SIZE = 65535;
+constexpr std::size_t DNS_MAX_LABEL_SIZE = 63;
+constexpr std::size_t DNS_MAX_NAME_SIZE = 253;
+constexpr std::uint8_t DNS_COMPRESSION_MASK = 0xC0;
+constexpr std::uint16_t DNS_COMPRESSION_POINTER_MASK = 0x3FFF;
+} // namespace constants
 
 } // namespace dns
 } // namespace network
diff --git a/include/iora/network/dns/dns_utils.hpp b/include/iora/network/dns/dns_utils.hpp
index 9226eab..cc98a25 100644
--- a/include/iora/network/dns/dns_utils.hpp
+++ b/include/iora/network/dns/dns_utils.hpp
@@ -6,9 +6,9 @@
 
 #pragma once
 
-#include <string>
 #include <algorithm>
 #include <cctype>
+#include <string>
 
 namespace iora
 {
@@ -18,46 +18,47 @@ namespace dns
 {
 
 /// \brief Normalize server string for consistent DNS key creation and comparison
-/// 
+///
 /// Handles IPv6, IPv4, and hostname normalization according to these rules:
-/// - IPv6 with brackets: [2001:DB8::1]  [2001:db8::1] 
+/// - IPv6 with brackets: [2001:DB8::1]  [2001:db8::1]
 /// - IPv6 with zone: [2001:DB8::1%Eth0]  [2001:db8::1%Eth0] (zone case preserved)
 /// - Bare IPv6: 2001:DB8::1  2001:db8::1
 /// - IPv4: 192.168.1.1  192.168.1.1 (unchanged)
 /// - Hostnames: DNS.Google.COM  dns.google.com (case-insensitive)
 /// - Whitespace is always trimmed from both ends
-/// 
+///
 /// IMPORTANT: External callers must use consistent formatting:
 /// - Always use bracket notation for IPv6 in mixed environments
-/// - Zone IDs are case-sensitive (interface names)  
+/// - Zone IDs are case-sensitive (interface names)
 /// - DNS names are case-insensitive per RFC 1035
-/// 
+///
 /// \param server Server address string (IPv4, IPv6, hostname)
 /// \return Canonicalized server string for consistent matching
-inline std::string normalizeServerString(const std::string& server)
+inline std::string normalizeServerString(const std::string &server)
 {
   std::string normalized = server;
-  
+
   // Trim whitespace
   size_t start = normalized.find_first_not_of(" \t\n\r");
-  if (start == std::string::npos) return ""; // All whitespace
-  
+  if (start == std::string::npos)
+    return ""; // All whitespace
+
   size_t end = normalized.find_last_not_of(" \t\n\r");
   normalized = normalized.substr(start, end - start + 1);
-  
+
   // Handle IPv6 address canonicalization
   if (normalized.front() == '[' && normalized.back() == ']')
   {
     // IPv6 bracket notation: [2001:db8::1] or [2001:db8::1%eth0]
     std::string ipv6_part = normalized.substr(1, normalized.length() - 2);
-    
+
     // Handle zone ID (scope) - keep it but normalize case
     size_t zone_pos = ipv6_part.find('%');
     if (zone_pos != std::string::npos)
     {
       std::string addr_part = ipv6_part.substr(0, zone_pos);
       std::string zone_part = ipv6_part.substr(zone_pos + 1);
-      
+
       // Convert address part to lowercase, keep zone case-sensitive (may be interface name)
       std::transform(addr_part.begin(), addr_part.end(), addr_part.begin(), ::tolower);
       return "[" + addr_part + "%" + zone_part + "]";
@@ -78,7 +79,7 @@ inline std::string normalizeServerString(const std::string& server)
     {
       std::string addr_part = normalized.substr(0, zone_pos);
       std::string zone_part = normalized.substr(zone_pos + 1);
-      
+
       // Convert address part to lowercase, keep zone case-sensitive
       std::transform(addr_part.begin(), addr_part.end(), addr_part.begin(), ::tolower);
       return addr_part + "%" + zone_part;
@@ -102,7 +103,7 @@ inline std::string normalizeServerString(const std::string& server)
         break;
       }
     }
-    
+
     if (hasLetters)
     {
       // Hostname - convert to lowercase for DNS case-insensitivity
@@ -110,10 +111,10 @@ inline std::string normalizeServerString(const std::string& server)
     }
     // IPv4 addresses are kept as-is (case doesn't matter for digits/dots)
   }
-  
+
   return normalized;
 }
 
 } // namespace dns
-} // namespace network  
+} // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/dns_client.hpp b/include/iora/network/dns_client.hpp
index ef7b9d3..d9a819a 100644
--- a/include/iora/network/dns_client.hpp
+++ b/include/iora/network/dns_client.hpp
@@ -6,21 +6,21 @@
 
 #pragma once
 
-#include "dns/dns_types.hpp"
-#include "dns/dns_message.hpp"
-#include "dns/dns_transport.hpp"
 #include "dns/dns_cache.hpp"
+#include "dns/dns_message.hpp"
 #include "dns/dns_resolver.hpp"
+#include "dns/dns_transport.hpp"
+#include "dns/dns_types.hpp"
 #include "dns/dns_utils.hpp"
-#include <memory>
-#include <string>
-#include <vector>
-#include <future>
 #include <algorithm>
-#include <cctype>
-#include <sstream>
 #include <atomic>
+#include <cctype>
 #include <functional>
+#include <future>
+#include <memory>
+#include <sstream>
+#include <string>
+#include <vector>
 
 namespace iora
 {
@@ -28,7 +28,7 @@ namespace network
 {
 
 /// \brief Async DNS request handle for cancellation
-/// 
+///
 /// Provides simple boolean cancellation interface for async DNS operations.
 /// Uses atomic operations for thread-safety across multi-threaded callbacks.
 class AsyncDnsRequest
@@ -36,57 +36,50 @@ class AsyncDnsRequest
 public:
   /// \brief Default constructor (invalid request)
   AsyncDnsRequest() = default;
-  
+
   /// \brief Cancel the DNS request (best-effort)
-  /// 
+  ///
   /// Attempts to cancel the DNS request. Cancellation is best-effort and may not
   /// prevent callback delivery if the transport has already started processing.
-  /// 
+  ///
   /// \return true if successfully cancelled, false if already completed or cancelled
   bool cancel()
   {
-    if (!state_) return false;
+    if (!state_)
+      return false;
     return !state_->cancelled.exchange(true, std::memory_order_acq_rel);
   }
-  
+
   /// \brief Check if request was cancelled
-  /// 
+  ///
   /// Note: Due to best-effort cancellation semantics, a cancelled request
   /// may still have its callback invoked if transport processing had already begun.
-  /// 
+  ///
   /// \return true if cancelled
-  bool isCancelled() const
-  {
-    return state_ && state_->cancelled.load(std::memory_order_acquire);
-  }
-  
+  bool isCancelled() const { return state_ && state_->cancelled.load(std::memory_order_acquire); }
+
   /// \brief Check if request completed
   /// \return true if completed (successfully or with error)
-  bool isCompleted() const
-  {
-    return state_ && state_->completed.load(std::memory_order_acquire);
-  }
-  
+  bool isCompleted() const { return state_ && state_->completed.load(std::memory_order_acquire); }
+
   /// \brief Get hostname being queried
   /// \return hostname string, empty if invalid request
-  std::string getHostname() const
-  {
-    return state_ ? state_->hostname : "";
-  }
-  
+  std::string getHostname() const { return state_ ? state_->hostname : ""; }
+
   /// \brief Mark request as completed (for cancellation)
   /// \internal Used by CancellableFuture to update completion state
   void markCompleted()
   {
-    if (state_) {
+    if (state_)
+    {
       state_->completed.store(true, std::memory_order_release);
     }
   }
-  
+
 private:
   friend class DnsClient;
-  template<typename T> friend struct CancellableFuture;
-  
+  template <typename T> friend struct CancellableFuture;
+
   /// \brief Internal state shared between request handle and transport
   struct RequestState
   {
@@ -94,77 +87,69 @@ private:
     std::atomic<bool> completed{false};
     std::atomic<bool> deliveryAttempted{false}; // Guards against double callback delivery
     std::string hostname;
-    
+
     RequestState(std::string host) : hostname(std::move(host)) {}
   };
-  
+
   /// \brief Constructor for valid request
-  explicit AsyncDnsRequest(std::shared_ptr<RequestState> state)
-    : state_(std::move(state)) {}
-  
+  explicit AsyncDnsRequest(std::shared_ptr<RequestState> state) : state_(std::move(state)) {}
+
   std::shared_ptr<RequestState> state_;
 };
 
 /// \brief Future with cancellation support for DNS operations
-/// 
+///
 /// Combines std::future with AsyncDnsRequest for cancellable future-based operations.
-template<typename T>
-struct CancellableFuture
+template <typename T> struct CancellableFuture
 {
   std::future<T> future;
   AsyncDnsRequest request;
-  std::shared_ptr<std::promise<T>> promise_; // Store promise for immediate cancellation
+  std::shared_ptr<std::promise<T>> promise_;      // Store promise for immediate cancellation
   std::shared_ptr<std::atomic<bool>> promiseSet_; // Shared atomic guard
-  
+
   /// \brief Cancel the underlying DNS request (immediate when safe)
-  /// 
+  ///
   /// Attempts to cancel the DNS request. If cancellation is successful and no async
   /// operation has delivered results yet, immediately sets the promise to wake waiting
   /// threads. Uses atomic guards to prevent race conditions with callbacks.
-  /// 
+  ///
   /// \return true if successfully cancelled
-  bool cancel() 
-  { 
+  bool cancel()
+  {
     bool cancelResult = request.cancel();
-    
-    if (cancelResult && promise_) {
-      // Try using the specific promiseSet atomic if available (for resolveAAsync style)
-      if (promiseSet_) {
+
+    if (cancelResult && promise_)
+    {
+      // Use promiseSet atomic guard to prevent race with callback
+      if (promiseSet_)
+      {
         bool expected = false;
-        if (promiseSet_->compare_exchange_strong(expected, true, std::memory_order_acq_rel)) {
-          try {
-            promise_->set_exception(std::make_exception_ptr(dns::DnsResolverException("DNS request cancelled")));
-          } catch (const std::future_error&) {
-            // Promise already set - should not happen due to atomic guard
+        if (promiseSet_->compare_exchange_strong(expected, true, std::memory_order_acq_rel))
+        {
+          try
+          {
+            promise_->set_exception(
+              std::make_exception_ptr(dns::DnsResolverException("DNS request cancelled")));
           }
-        }
-        // Always mark as completed if cancellation succeeded, regardless of promise setting
-        request.markCompleted();
-      }
-      // For resolveServiceDomainFuture style, try using the request state's deliveryAttempted
-      else if (request.state_) {
-        bool expected = false;
-        if (request.state_->deliveryAttempted.compare_exchange_strong(expected, true, std::memory_order_acq_rel)) {
-          try {
-            promise_->set_exception(std::make_exception_ptr(dns::DnsResolverException("DNS request cancelled")));
-          } catch (const std::future_error&) {
+          catch (const std::future_error &)
+          {
             // Promise already set - should not happen due to atomic guard
           }
         }
-        // Always mark as completed if cancellation succeeded, regardless of promise setting
-        request.state_->completed.store(true, std::memory_order_release);
       }
+      // Always mark as completed if cancellation succeeded
+      request.markCompleted();
     }
-    
+
     return cancelResult;
   }
-  
+
   /// \brief Check if request was cancelled
   bool isCancelled() const { return request.isCancelled(); }
-  
+
   /// \brief Check if request completed
   bool isCompleted() const { return request.isCompleted(); }
-  
+
   /// \brief Get hostname being queried
   std::string getHostname() const { return request.getHostname(); }
 };
@@ -175,10 +160,11 @@ struct CancellableFuture
 /// \param promise The promise for immediate cancellation
 /// \param promiseSet The atomic guard for promise setting
 /// \return CancellableFuture combining both
-template<typename T>
-CancellableFuture<T> make_cancellable_future(std::future<T>&& future, AsyncDnsRequest&& request, 
-                                            std::shared_ptr<std::promise<T>> promise = nullptr,
-                                            std::shared_ptr<std::atomic<bool>> promiseSet = nullptr)
+template <typename T>
+CancellableFuture<T>
+make_cancellable_future(std::future<T> &&future, AsyncDnsRequest &&request,
+                        std::shared_ptr<std::promise<T>> promise = nullptr,
+                        std::shared_ptr<std::atomic<bool>> promiseSet = nullptr)
 {
   return CancellableFuture<T>{std::move(future), std::move(request), promise, promiseSet};
 }
@@ -200,14 +186,14 @@ CancellableFuture<T> make_cancellable_future(std::future<T>&& future, AsyncDnsRe
 /// \code
 /// // Create client with default configuration
 /// DnsClient client;
-/// 
+///
 /// // Resolve service domain (SIP example)
 /// auto serviceResult = client.resolveServiceDomain("example.com");
 /// for (const auto& target : serviceResult.targets) {
-///   std::cout << target.hostname << ":" << target.port 
+///   std::cout << target.hostname << ":" << target.port
 ///             << " (" << target.getTransportString() << ")\n";
 /// }
-/// 
+///
 /// // Standard DNS query
 /// auto aRecords = client.resolveA("www.example.com");
 /// for (const auto& addr : aRecords) {
@@ -218,25 +204,18 @@ class DnsClient
 {
 public:
   /// \brief Default constructor with standard configuration
-  DnsClient()
-    : DnsClient(dns::DnsConfig{})
-  {
-  }
+  DnsClient() : DnsClient(dns::DnsConfig{}) {}
 
   /// \brief Constructor with custom configuration
   /// \param config DNS client configuration
-  explicit DnsClient(const dns::DnsConfig& config)
-    : config_(config)
-  {
-    initialize();
-  }
+  explicit DnsClient(const dns::DnsConfig &config) : config_(config) { initialize(); }
 
   /// \brief Constructor with custom transport (for testing)
   /// \param transport Custom transport implementation
   /// \param config DNS client configuration
-  explicit DnsClient(std::shared_ptr<UnifiedSharedTransport> transport, 
-                     const dns::DnsConfig& config = dns::DnsConfig{})
-    : config_(config), customTransport_(transport)
+  explicit DnsClient(std::shared_ptr<UnifiedSharedTransport> transport,
+                     const dns::DnsConfig &config = dns::DnsConfig{})
+      : config_(config), customTransport_(transport)
   {
     initialize();
   }
@@ -251,7 +230,7 @@ public:
   /// \brief Start the DNS client (compatibility method)
   /// \return Always returns true - transport is started in constructor
   bool start() { return true; }
-  
+
   /// \brief Stop the DNS client (compatibility method)
   /// Cleanup handled by destructor
   void stop() { /* No explicit action needed - RAII */ }
@@ -259,31 +238,36 @@ public:
   /// \brief Resolve hostname to IP addresses (compatibility method)
   /// \param hostname Hostname to resolve
   /// \return HostResult with IPv4 and IPv6 addresses
-  struct HostResult {
+  struct HostResult
+  {
     std::vector<std::string> ipv4;
     std::vector<std::string> ipv6;
     bool success = false;
   };
-  
-  HostResult resolveHost(const std::string& hostname) {
-    try {
+
+  HostResult resolveHost(const std::string &hostname)
+  {
+    try
+    {
       HostResult result;
       result.ipv4 = resolveA(hostname);
-      result.ipv6 = resolveAAAA(hostname);  
+      result.ipv6 = resolveAAAA(hostname);
       result.success = !result.ipv4.empty() || !result.ipv6.empty();
       return result;
-    } catch (...) {
+    }
+    catch (...)
+    {
       return {}; // Return empty result on error
     }
   }
 
   // Disable copy constructor and assignment operator
-  DnsClient(const DnsClient&) = delete;
-  DnsClient& operator=(const DnsClient&) = delete;
+  DnsClient(const DnsClient &) = delete;
+  DnsClient &operator=(const DnsClient &) = delete;
 
-  // Enable move constructor and assignment operator  
-  DnsClient(DnsClient&&) = default;
-  DnsClient& operator=(DnsClient&&) = default;
+  // Enable move constructor and assignment operator
+  DnsClient(DnsClient &&) = default;
+  DnsClient &operator=(DnsClient &&) = default;
 
   // =============================================================================
   // Service Discovery Methods (RFC 3263 NAPTRSRVA/AAAA chain)
@@ -294,32 +278,36 @@ public:
   /// \param preferredTransports Preferred transport types in order of preference
   /// \return Service resolution result with prioritized targets
   /// \throws dns::DnsResolverException on resolution failure
-  dns::ServiceResolutionResult resolveServiceDomain(const std::string& domain,
-                                               const std::vector<dns::ServiceType>& preferredTransports = {})
+  dns::ServiceResolutionResult
+  resolveServiceDomain(const std::string &domain,
+                       const std::vector<dns::ServiceType> &preferredTransports = {})
   {
     return resolver_->resolveServiceDomain(domain, preferredTransports);
   }
 
   /// \brief Resolve custom service domain with specific SRV record queries
   /// \param domain Service domain to resolve (e.g., "example.com")
-  /// \param srvQueries Custom SRV queries to try (e.g., {{"_xmpp-client._tcp.example.com", dns::ServiceType::TCP}})
+  /// \param srvQueries Custom SRV queries to try (e.g., {{"_xmpp-client._tcp.example.com",
+  /// dns::ServiceType::TCP}})
   /// \param preferredTransports Preferred transport types in order of preference
   /// \return Service resolution result with prioritized targets
   /// \throws dns::DnsResolverException on resolution failure
-  dns::ServiceResolutionResult resolveCustomServiceDomain(const std::string& domain,
-                                                     const std::vector<std::pair<std::string, dns::ServiceType>>& srvQueries,
-                                                     const std::vector<dns::ServiceType>& preferredTransports = {})
+  dns::ServiceResolutionResult resolveCustomServiceDomain(
+    const std::string &domain,
+    const std::vector<std::pair<std::string, dns::ServiceType>> &srvQueries,
+    const std::vector<dns::ServiceType> &preferredTransports = {})
   {
-    return resolver_->performDirectSrvResolution(domain, preferredTransports, std::make_optional(srvQueries));
+    return resolver_->performDirectSrvResolution(domain, preferredTransports,
+                                                 std::make_optional(srvQueries));
   }
 
-  /// \brief Resolve service domain asynchronously  
+  /// \brief Resolve service domain asynchronously
   /// \param domain Service domain to resolve
   /// \param callback Callback function for result notification
   /// \param preferredTransports Preferred transport types in order of preference
-  void resolveServiceDomainAsync(const std::string& domain,
-                                dns::DnsResolver::ServiceResolutionCallback callback,
-                                const std::vector<dns::ServiceType>& preferredTransports = {})
+  void resolveServiceDomainAsync(const std::string &domain,
+                                 dns::DnsResolver::ServiceResolutionCallback callback,
+                                 const std::vector<dns::ServiceType> &preferredTransports = {})
   {
     resolver_->resolveServiceDomainAsync(domain, callback, preferredTransports);
   }
@@ -329,65 +317,82 @@ public:
   /// \param srvQueries Custom SRV queries to try
   /// \param callback Callback function for result notification
   /// \param preferredTransports Preferred transport types in order of preference
-  void resolveCustomServiceDomainAsync(const std::string& domain,
-                                      const std::vector<std::pair<std::string, dns::ServiceType>>& srvQueries,
-                                      dns::DnsResolver::ServiceResolutionCallback callback,
-                                      const std::vector<dns::ServiceType>& preferredTransports = {})
+  void resolveCustomServiceDomainAsync(
+    const std::string &domain,
+    const std::vector<std::pair<std::string, dns::ServiceType>> &srvQueries,
+    dns::DnsResolver::ServiceResolutionCallback callback,
+    const std::vector<dns::ServiceType> &preferredTransports = {})
   {
-    resolver_->performDirectSrvResolutionAsync(domain, callback, preferredTransports, std::make_optional(srvQueries));
+    resolver_->performDirectSrvResolutionAsync(domain, callback, preferredTransports,
+                                               std::make_optional(srvQueries));
   }
 
   /// \brief Resolve service domain and return future
   /// \param domain Service domain to resolve
   /// \param preferredTransports Preferred transport types in order of preference
   /// \return CancellableFuture containing service resolution result
-  CancellableFuture<dns::ServiceResolutionResult> resolveServiceDomainFuture(const std::string& domain,
-                                                                         const std::vector<dns::ServiceType>& preferredTransports = {})
+  CancellableFuture<dns::ServiceResolutionResult>
+  resolveServiceDomainFuture(const std::string &domain,
+                             const std::vector<dns::ServiceType> &preferredTransports = {})
   {
     auto state = std::make_shared<AsyncDnsRequest::RequestState>(domain);
     auto promise = std::make_shared<std::promise<dns::ServiceResolutionResult>>();
+    auto promiseSet = std::make_shared<std::atomic<bool>>(false);
     auto future = promise->get_future();
-    
+
     // Create async request handle
     AsyncDnsRequest request(state);
 
-    resolveServiceDomainAsync(domain, [promise, state](const dns::ServiceResolutionResult& result, const std::exception_ptr& ex)
-    {
-      // Atomic delivery guard - prevent double callback delivery
-      bool expected = false;
-      if (!state->deliveryAttempted.compare_exchange_strong(expected, true, std::memory_order_acq_rel)) {
-        return; // Another thread already delivered
-      }
-      
-      // Check for cancellation after securing delivery guard
-      if (state->cancelled.load(std::memory_order_acquire)) {
-        try {
-          promise->set_exception(std::make_exception_ptr(dns::DnsResolverException("DNS request cancelled")));
-        } catch (const std::future_error&) {
-          // Promise already set - ignore
+    resolveServiceDomainAsync(
+      domain,
+      [promise, promiseSet, state](const dns::ServiceResolutionResult &result, const std::exception_ptr &ex)
+      {
+        // Atomic guard against double-set
+        bool expected = false;
+        if (!promiseSet->compare_exchange_strong(expected, true,
+                                                  std::memory_order_acq_rel))
+        {
+          return; // Promise already set by cancellation or another callback
         }
-        state->completed.store(true, std::memory_order_release);
-        return;
-      }
-      
-      try {
-        if (ex)
+
+        // Check for cancellation after securing delivery guard
+        if (state->cancelled.load(std::memory_order_acquire))
         {
-          promise->set_exception(ex);
+          try
+          {
+            promise->set_exception(
+              std::make_exception_ptr(dns::DnsResolverException("DNS request cancelled")));
+          }
+          catch (const std::future_error &)
+          {
+            // Promise already set - ignore
+          }
+          state->completed.store(true, std::memory_order_release);
+          return;
         }
-        else
+
+        try
         {
-          promise->set_value(result);
+          if (ex)
+          {
+            promise->set_exception(ex);
+          }
+          else
+          {
+            promise->set_value(result);
+          }
         }
-      } catch (const std::future_error&) {
-        // Promise already set - ignore
-      }
-      
-      // Set completion flag after processing callback
-      state->completed.store(true, std::memory_order_release);
-    }, preferredTransports);
+        catch (const std::future_error &)
+        {
+          // Promise already set - ignore
+        }
+
+        // Set completion flag after processing callback
+        state->completed.store(true, std::memory_order_release);
+      },
+      preferredTransports);
 
-    return make_cancellable_future(std::move(future), std::move(request), promise);
+    return make_cancellable_future(std::move(future), std::move(request), promise, promiseSet);
   }
 
   // =============================================================================
@@ -398,16 +403,13 @@ public:
   /// \param question DNS question to resolve
   /// \return DNS query result
   /// \throws dns::DnsResolverException on query failure
-  dns::DnsResult query(const dns::DnsQuestion& question)
-  {
-    return resolver_->query(question);
-  }
+  dns::DnsResult query(const dns::DnsQuestion &question) { return resolver_->query(question); }
 
   /// \brief Perform DNS query asynchronously
   /// \param question DNS question to resolve
   /// \param callback Callback function for result notification
-  void queryAsync(const dns::DnsQuestion& question,
-                  std::function<void(const dns::DnsResult&, const std::exception_ptr&)> callback)
+  void queryAsync(const dns::DnsQuestion &question,
+                  std::function<void(const dns::DnsResult &, const std::exception_ptr &)> callback)
   {
     resolver_->queryAsync(question, callback);
   }
@@ -416,21 +418,21 @@ public:
   /// \param hostname Hostname to resolve
   /// \return Vector of IPv4 address strings
   /// \throws dns::DnsResolverException on resolution failure
-  std::vector<std::string> resolveA(const std::string& hostname)
+  std::vector<std::string> resolveA(const std::string &hostname)
   {
     dns::DnsResult result = query(dns::DnsQuestion(hostname, dns::DnsType::A, dns::DnsClass::IN));
-    
+
     std::vector<std::string> addresses;
-    for (const auto& record : result.a_records)
+    for (const auto &record : result.a_records)
     {
       addresses.push_back(record.address);
     }
-    
+
     if (addresses.empty())
     {
       throw dns::DnsNoRecordsException(hostname, dns::DnsType::A);
     }
-    
+
     return addresses;
   }
 
@@ -438,66 +440,77 @@ public:
   /// \param hostname Hostname to resolve
   /// \param callback Callback function called on completion or error
   /// \return AsyncDnsRequest for cancellation
-  /// 
+  ///
   /// \warning Callback may execute on different threads:
   ///          - Immediate errors: caller thread
-  ///          - Network responses: transport thread  
+  ///          - Network responses: transport thread
   ///          - Timeouts: timer thread
   /// \warning Client must ensure thread-safe callback implementation
-  AsyncDnsRequest resolveA(const std::string& hostname, 
-                          std::function<void(std::vector<std::string>, std::exception_ptr)> callback);
+  AsyncDnsRequest
+  resolveA(const std::string &hostname,
+           std::function<void(std::vector<std::string>, std::exception_ptr)> callback);
 
   /// \brief Resolve A records asynchronously with cancellable future wrapper
   /// \param hostname Hostname to resolve
   /// \return CancellableFuture containing vector of IPv4 address strings and cancellation handle
-  CancellableFuture<std::vector<std::string>> resolveAAsync(const std::string& hostname)
+  CancellableFuture<std::vector<std::string>> resolveAAsync(const std::string &hostname)
   {
     auto promise = std::make_shared<std::promise<std::vector<std::string>>>();
     auto promiseSet = std::make_shared<std::atomic<bool>>(false);
     auto future = promise->get_future();
-    
-    auto request = resolveA(hostname, [promise, promiseSet, hostname](std::vector<std::string> addresses, std::exception_ptr error) {
+
+    auto request = resolveA(
+      hostname,
+      [promise, promiseSet, hostname](std::vector<std::string> addresses, std::exception_ptr error)
+      {
         // Atomic guard against double-set
         bool expected = false;
-        if (!promiseSet->compare_exchange_strong(expected, true, std::memory_order_acq_rel)) {
-            return; // Promise already set by cancellation or another callback
+        if (!promiseSet->compare_exchange_strong(expected, true, std::memory_order_acq_rel))
+        {
+          return; // Promise already set by cancellation or another callback
         }
-        
-        try {
-            if (error) {
-                promise->set_exception(error);
-            } else {
-                promise->set_value(std::move(addresses));
-            }
-        } catch (const std::future_error&) {
-            // Ignore double-set errors (defensive programming)
-            // This shouldn't happen due to atomic guard above, but handle gracefully
+
+        try
+        {
+          if (error)
+          {
+            promise->set_exception(error);
+          }
+          else
+          {
+            promise->set_value(std::move(addresses));
+          }
         }
-    });
-    
+        catch (const std::future_error &)
+        {
+          // Ignore double-set errors (defensive programming)
+          // This shouldn't happen due to atomic guard above, but handle gracefully
+        }
+      });
+
     return make_cancellable_future(std::move(future), std::move(request), promise, promiseSet);
   }
 
-
   /// \brief Resolve AAAA records (IPv6 addresses)
   /// \param hostname Hostname to resolve
   /// \return Vector of IPv6 address strings
   /// \throws dns::DnsResolverException on resolution failure
-  std::vector<std::string> resolveAAAA(const std::string& hostname)
+  std::vector<std::string> resolveAAAA(const std::string &hostname)
   {
-    dns::DnsResult result = query(dns::DnsQuestion(hostname, dns::DnsType::AAAA, dns::DnsClass::IN));
-    
+    dns::DnsResult result =
+      query(dns::DnsQuestion(hostname, dns::DnsType::AAAA, dns::DnsClass::IN));
+
     std::vector<std::string> addresses;
-    for (const auto& record : result.aaaa_records)
+    for (const auto &record : result.aaaa_records)
     {
       addresses.push_back(record.address);
     }
-    
+
     if (addresses.empty())
     {
       throw dns::DnsNoRecordsException(hostname, dns::DnsType::AAAA);
     }
-    
+
     return addresses;
   }
 
@@ -506,7 +519,7 @@ public:
   /// \param prefer_ipv6 Prefer IPv6 addresses if available
   /// \return Vector of IP address strings
   /// \throws dns::DnsResolverException on resolution failure
-  std::vector<std::string> resolveHostname(const std::string& hostname, bool prefer_ipv6 = false)
+  std::vector<std::string> resolveHostname(const std::string &hostname, bool prefer_ipv6 = false)
   {
     return resolver_->resolveHostname(hostname, prefer_ipv6);
   }
@@ -515,15 +528,15 @@ public:
   /// \param service Service name (e.g., "_sip._tcp.example.com")
   /// \return Vector of SRV records
   /// \throws dns::DnsResolverException on resolution failure
-  std::vector<dns::SrvRecord> resolveSRV(const std::string& service)
+  std::vector<dns::SrvRecord> resolveSRV(const std::string &service)
   {
     dns::DnsResult result = query(dns::DnsQuestion(service, dns::DnsType::SRV, dns::DnsClass::IN));
-    
+
     if (result.srv_records.empty())
     {
       throw dns::DnsNoRecordsException(service, dns::DnsType::SRV);
     }
-    
+
     return result.srv_records;
   }
 
@@ -531,15 +544,15 @@ public:
   /// \param domain Domain name to query
   /// \return Vector of NAPTR records
   /// \throws dns::DnsResolverException on resolution failure
-  std::vector<dns::NaptrRecord> resolveNAPTR(const std::string& domain)
+  std::vector<dns::NaptrRecord> resolveNAPTR(const std::string &domain)
   {
     dns::DnsResult result = query(dns::DnsQuestion(domain, dns::DnsType::NAPTR, dns::DnsClass::IN));
-    
+
     if (result.naptr_records.empty())
     {
       throw dns::DnsNoRecordsException(domain, dns::DnsType::NAPTR);
     }
-    
+
     return result.naptr_records;
   }
 
@@ -547,21 +560,22 @@ public:
   /// \param hostname Hostname to resolve
   /// \return Vector of canonical names
   /// \throws dns::DnsResolverException on resolution failure
-  std::vector<std::string> resolveCNAME(const std::string& hostname)
+  std::vector<std::string> resolveCNAME(const std::string &hostname)
   {
-    dns::DnsResult result = query(dns::DnsQuestion(hostname, dns::DnsType::CNAME, dns::DnsClass::IN));
-    
+    dns::DnsResult result =
+      query(dns::DnsQuestion(hostname, dns::DnsType::CNAME, dns::DnsClass::IN));
+
     std::vector<std::string> names;
-    for (const auto& record : result.cname_records)
+    for (const auto &record : result.cname_records)
     {
       names.push_back(record.cname);
     }
-    
+
     if (names.empty())
     {
       throw dns::DnsNoRecordsException(hostname, dns::DnsType::CNAME);
     }
-    
+
     return names;
   }
 
@@ -569,15 +583,15 @@ public:
   /// \param domain Domain name to query
   /// \return Vector of MX records
   /// \throws dns::DnsResolverException on resolution failure
-  std::vector<dns::MxRecord> resolveMX(const std::string& domain)
+  std::vector<dns::MxRecord> resolveMX(const std::string &domain)
   {
     dns::DnsResult result = query(dns::DnsQuestion(domain, dns::DnsType::MX, dns::DnsClass::IN));
-    
+
     if (result.mx_records.empty())
     {
       throw dns::DnsNoRecordsException(domain, dns::DnsType::MX);
     }
-    
+
     return result.mx_records;
   }
 
@@ -585,15 +599,15 @@ public:
   /// \param domain Domain name to query
   /// \return Vector of TXT records
   /// \throws dns::DnsResolverException on resolution failure
-  std::vector<dns::TxtRecord> resolveTXT(const std::string& domain)
+  std::vector<dns::TxtRecord> resolveTXT(const std::string &domain)
   {
     dns::DnsResult result = query(dns::DnsQuestion(domain, dns::DnsType::TXT, dns::DnsClass::IN));
-    
+
     if (result.txt_records.empty())
     {
       throw dns::DnsNoRecordsException(domain, dns::DnsType::TXT);
     }
-    
+
     return result.txt_records;
   }
 
@@ -601,22 +615,23 @@ public:
   /// \param ip IP address to reverse resolve
   /// \return Vector of hostnames
   /// \throws dns::DnsResolverException on resolution failure
-  std::vector<std::string> resolvePTR(const std::string& ip)
+  std::vector<std::string> resolvePTR(const std::string &ip)
   {
     std::string reverseQuery = createReverseQuery(ip);
-    dns::DnsResult result = query(dns::DnsQuestion(reverseQuery, dns::DnsType::PTR, dns::DnsClass::IN));
-    
+    dns::DnsResult result =
+      query(dns::DnsQuestion(reverseQuery, dns::DnsType::PTR, dns::DnsClass::IN));
+
     std::vector<std::string> hostnames;
-    for (const auto& record : result.ptr_records)
+    for (const auto &record : result.ptr_records)
     {
       hostnames.push_back(record.ptrdname);
     }
-    
+
     if (hostnames.empty())
     {
       throw dns::DnsNoRecordsException(ip, dns::DnsType::PTR);
     }
-    
+
     return hostnames;
   }
 
@@ -646,7 +661,7 @@ public:
 
   /// \brief Remove specific entry from cache
   /// \param question DNS question to remove from cache
-  void removeCacheEntry(const dns::DnsQuestion& question)
+  void removeCacheEntry(const dns::DnsQuestion &question)
   {
     if (cache_)
     {
@@ -671,12 +686,13 @@ public:
 
   /// \brief Resolve SIP domain using RFC 3263 procedure
   /// \deprecated Use resolveServiceDomain() instead for broader applicability
-  /// \param domain SIP domain to resolve (e.g., "example.com")  
+  /// \param domain SIP domain to resolve (e.g., "example.com")
   /// \param preferredTransports Preferred transport types in order of preference
   /// \return SIP resolution result with prioritized targets
   /// \throws dns::DnsResolverException on resolution failure
-  dns::SipResolutionResult resolveSipDomain(const std::string& domain,
-                                       const std::vector<dns::SipServiceType>& preferredTransports = {})
+  dns::SipResolutionResult
+  resolveSipDomain(const std::string &domain,
+                   const std::vector<dns::SipServiceType> &preferredTransports = {})
   {
     return resolveServiceDomain(domain, preferredTransports);
   }
@@ -686,20 +702,17 @@ public:
   /// \param domain SIP domain to resolve
   /// \param callback Callback function for result notification
   /// \param preferredTransports Preferred transport types in order of preference
-  void resolveSipDomainAsync(const std::string& domain,
-                             std::function<void(const dns::SipResolutionResult&, const std::exception_ptr&)> callback,
-                             const std::vector<dns::SipServiceType>& preferredTransports = {})
+  void resolveSipDomainAsync(
+    const std::string &domain,
+    std::function<void(const dns::SipResolutionResult &, const std::exception_ptr &)> callback,
+    const std::vector<dns::SipServiceType> &preferredTransports = {})
   {
     resolveServiceDomainAsync(domain, callback, preferredTransports);
   }
 
-
   /// \brief Check if caching is enabled
   /// \return true if caching is enabled
-  bool isCacheEnabled() const
-  {
-    return cache_ != nullptr;
-  }
+  bool isCacheEnabled() const { return cache_ != nullptr; }
 
   // =============================================================================
   // Configuration and Status
@@ -707,65 +720,77 @@ public:
 
   /// \brief Get current DNS configuration
   /// \return Current configuration
-  const dns::DnsConfig& getConfig() const
-  {
-    return config_;
-  }
+  const dns::DnsConfig &getConfig() const { return config_; }
 
   /// \brief Update DNS configuration
   /// \param config New configuration
   /// \note This will recreate transport and resolver with new settings
-  void updateConfig(const dns::DnsConfig& config)
+  void updateConfig(const dns::DnsConfig &config)
   {
     config_ = config;
     initialize(); // Reinitialize with new config
   }
 
+  /// \brief Set DNS servers (replaces all existing servers)
+  /// \param servers List of DNS server addresses (e.g., {"8.8.8.8", "1.1.1.1:53", "2001:4860:4860::8888"})
+  /// \note Servers without explicit port use default port 53. IPv6 addresses supported.
+  void setDnsServers(const std::vector<std::string> &servers)
+  {
+    config_.setServers(servers);
+    initialize(); // Reinitialize with new servers
+  }
+
   /// \brief Add DNS server to configuration
-  /// \param server DNS server IP address
-  void addDnsServer(const std::string& server)
+  /// \param server DNS server in "address" or "address:port" format
+  void addDnsServer(const std::string &server)
   {
-    // Normalize server string using canonical DNS transport logic (handles IPv6, zones, etc.)
-    std::string normalizedServer = dns::normalizeServerString(server);
-    
-    auto servers = config_.servers;
-    if (std::find(servers.begin(), servers.end(), normalizedServer) == servers.end())
+    // Parse server string to DnsServer structure
+    dns::DnsServer dnsServer = dns::DnsServer::fromString(server);
+
+    // Check if server already exists
+    auto &servers = config_.servers;
+    if (std::find(servers.begin(), servers.end(), dnsServer) == servers.end())
     {
-      servers.push_back(normalizedServer);
-      config_.servers = servers;
+      servers.push_back(dnsServer);
       initialize(); // Reinitialize with new servers
     }
   }
 
   /// \brief Remove DNS server from configuration
-  /// \param server DNS server IP address to remove
-  void removeDnsServer(const std::string& server)
+  /// \param server DNS server in "address" or "address:port" format to remove
+  void removeDnsServer(const std::string &server)
   {
-    // Normalize server string using canonical DNS transport logic (handles IPv6, zones, etc.)
-    std::string normalizedServer = dns::normalizeServerString(server);
-    
-    auto& servers = config_.servers;
-    servers.erase(std::remove(servers.begin(), servers.end(), normalizedServer), servers.end());
-    
+    // Parse server string to DnsServer structure
+    dns::DnsServer dnsServer = dns::DnsServer::fromString(server);
+
+    auto &servers = config_.servers;
+    servers.erase(std::remove(servers.begin(), servers.end(), dnsServer), servers.end());
+
     if (servers.empty())
     {
       // Restore defaults if all servers removed
-      servers = {"8.8.8.8", "1.1.1.1"};
+      servers = {dns::DnsServer("8.8.8.8", 53), dns::DnsServer("1.1.1.1", 53)};
     }
-    
+
     initialize(); // Reinitialize with updated servers
   }
 
   /// \brief Get list of configured DNS servers
-  /// \return Vector of DNS server addresses
+  /// \return Vector of DNS server addresses in "address:port" format
   std::vector<std::string> getDnsServers() const
   {
-    return config_.servers;
+    std::vector<std::string> result;
+    result.reserve(config_.servers.size());
+    for (const auto &server : config_.servers)
+    {
+      result.push_back(server.toString());
+    }
+    return result;
   }
 
   /// \brief Set cache cleanup callback for monitoring
   /// \param callback Function to call after cache cleanup operations
-  void setCacheCleanupCallback(std::function<void(const dns::DnsCacheStats&)> callback)
+  void setCacheCleanupCallback(std::function<void(const dns::DnsCacheStats &)> callback)
   {
     if (cache_)
     {
@@ -774,22 +799,18 @@ public:
   }
 
 private:
-  dns::DnsConfig config_;                            ///< DNS configuration
+  dns::DnsConfig config_;                                   ///< DNS configuration
   std::shared_ptr<UnifiedSharedTransport> customTransport_; ///< Custom transport (optional)
-  std::shared_ptr<dns::DnsTransport> transport_;     ///< DNS transport layer
-  std::shared_ptr<dns::DnsCache> cache_;             ///< DNS cache (optional)
-  std::shared_ptr<dns::DnsResolver> resolver_;       ///< DNS resolver
-
+  std::shared_ptr<dns::DnsTransport> transport_;            ///< DNS transport layer
+  std::shared_ptr<dns::DnsCache> cache_;                    ///< DNS cache (optional)
+  std::shared_ptr<dns::DnsResolver> resolver_;              ///< DNS resolver
 
   /// \brief Initialize all DNS components based on current configuration
   void initialize()
   {
-    // Normalize all server strings for consistent handling using canonical logic
-    for (auto& server : config_.servers)
-    {
-      server = dns::normalizeServerString(server);
-    }
-    
+    // DnsServer structure already handles normalization via fromString()
+    // No additional normalization needed
+
     // Create cache if enabled
     if (config_.enableCache)
     {
@@ -811,7 +832,7 @@ private:
     {
       transport_->start();
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       throw dns::DnsResolverException("Failed to start DNS transport: " + std::string(e.what()));
     }
@@ -820,78 +841,81 @@ private:
   /// \brief Create IPv6 reverse DNS query string (ip6.arpa)
   /// \param ipv6 IPv6 address string
   /// \return Reverse DNS query string for IPv6
-  std::string createIpv6ReverseQuery(const std::string& ipv6) const
+  std::string createIpv6ReverseQuery(const std::string &ipv6) const
   {
     // Normalize IPv6 address - remove brackets and expand to full form
     std::string addr = ipv6;
-    
+
     // Remove brackets if present
     if (addr.front() == '[' && addr.back() == ']')
     {
       addr = addr.substr(1, addr.length() - 2);
     }
-    
+
     // Split on '%' to remove zone ID if present
     size_t zone_pos = addr.find('%');
     if (zone_pos != std::string::npos)
     {
       addr = addr.substr(0, zone_pos);
     }
-    
+
     // Expand IPv6 address to full 32-character hex representation
     std::string expanded = expandIpv6Address(addr);
-    
+
     // Convert to nibble-reversed format for ip6.arpa
     std::string result;
-    for (int i = 31; i >= 0; --i)  // Reverse order of nibbles
+    for (int i = 31; i >= 0; --i) // Reverse order of nibbles
     {
       result += expanded[i];
       result += '.';
     }
     result += "ip6.arpa";
-    
+
     return result;
   }
-  
+
   /// \brief Expand IPv6 address to full 32-character hex representation
   /// \param ipv6 IPv6 address string (without brackets or zone)
   /// \return 32-character lowercase hex string
-  std::string expandIpv6Address(const std::string& ipv6) const
+  std::string expandIpv6Address(const std::string &ipv6) const
   {
     std::vector<std::string> groups;
     std::string expanded;
-    
+
     // Handle :: expansion
     size_t double_colon = ipv6.find("::");
     if (double_colon != std::string::npos)
     {
       std::string left = ipv6.substr(0, double_colon);
       std::string right = ipv6.substr(double_colon + 2);
-      
+
       // Count existing groups
       int left_groups = left.empty() ? 0 : std::count(left.begin(), left.end(), ':') + 1;
       int right_groups = right.empty() ? 0 : std::count(right.begin(), right.end(), ':') + 1;
       int missing_groups = 8 - left_groups - right_groups;
-      
+
       // Build expanded form
-      if (!left.empty()) expanded = left + ":";
+      if (!left.empty())
+        expanded = left + ":";
       for (int i = 0; i < missing_groups; ++i)
       {
         expanded += "0000:";
       }
-      if (!right.empty()) expanded += right;
-      else expanded.pop_back(); // Remove trailing ':'
+      if (!right.empty())
+        expanded += right;
+      else
+        expanded.pop_back(); // Remove trailing ':'
     }
     else
     {
       expanded = ipv6;
     }
-    
+
     // Parse groups and pad to 4 hex digits each
     std::stringstream ss(expanded);
     std::string group;
     std::string result;
-    
+
     while (std::getline(ss, group, ':'))
     {
       // Pad to 4 characters with leading zeros
@@ -903,19 +927,19 @@ private:
       std::transform(group.begin(), group.end(), group.begin(), ::tolower);
       result += group;
     }
-    
+
     if (result.length() != 32)
     {
       throw dns::DnsResolverException("Invalid IPv6 address format: " + ipv6);
     }
-    
+
     return result;
   }
 
   /// \brief Create reverse DNS query string from IP address
   /// \param ip IP address (IPv4 or IPv6)
   /// \return Reverse DNS query string
-  std::string createReverseQuery(const std::string& ip) const
+  std::string createReverseQuery(const std::string &ip) const
   {
     // Detect IPv4 vs IPv6
     if (ip.find(':') != std::string::npos)
@@ -929,101 +953,121 @@ private:
       std::vector<std::string> octets;
       std::stringstream ss(ip);
       std::string octet;
-      
+
       while (std::getline(ss, octet, '.'))
       {
         octets.push_back(octet);
       }
-      
+
       if (octets.size() != 4)
       {
         throw dns::DnsResolverException("Invalid IPv4 address for reverse query: " + ip);
       }
-      
+
       // Reverse the octets and append .in-addr.arpa
       return octets[3] + "." + octets[2] + "." + octets[1] + "." + octets[0] + ".in-addr.arpa";
     }
   }
-  
+
   /// \brief Internal implementation of async A record resolution
   /// \pre transport_ must be valid (checked by caller)
   /// \pre state must be valid (provided by caller)
-  void resolveAInternal(const std::string& hostname, 
-                       std::function<void(std::vector<std::string>, std::exception_ptr)> callback,
-                       std::shared_ptr<AsyncDnsRequest::RequestState> state)
+  void resolveAInternal(const std::string &hostname,
+                        std::function<void(std::vector<std::string>, std::exception_ptr)> callback,
+                        std::shared_ptr<AsyncDnsRequest::RequestState> state)
   {
     dns::DnsQuestion question(hostname, dns::DnsType::A, dns::DnsClass::IN);
-    
-    transport_->queryAsync(question, [callback = std::move(callback), state](
-                          const dns::DnsResult& result, std::exception_ptr error) mutable {
-      
-      // Atomic delivery guard - only first caller proceeds
-      bool expectedDelivery = false;
-      if (!state->deliveryAttempted.compare_exchange_strong(expectedDelivery, true, std::memory_order_acq_rel)) {
-        return; // Already delivered or being delivered by another thread
-      }
-      
-      // Check cancellation after securing delivery slot
-      if (state->cancelled.load(std::memory_order_acquire)) {
-        // Invoke callback with cancellation exception to prevent future hanging
-        callback({}, std::make_exception_ptr(dns::DnsResolverException("DNS request cancelled")));
-        state->completed.store(true, std::memory_order_release);
-        return;
-      }
-      
-      // Process result and invoke callback
-      try {
-        if (error) {
-          callback({}, error);
-        } else {
-          std::vector<std::string> addresses;
-          for (const auto& record : result.a_records) {
-            addresses.push_back(record.address);
+
+    transport_->queryAsync(
+      question,
+      [callback = std::move(callback), state](const dns::DnsResult &result,
+                                              std::exception_ptr error) mutable
+      {
+        // Atomic delivery guard - only first caller proceeds
+        bool expectedDelivery = false;
+        if (!state->deliveryAttempted.compare_exchange_strong(expectedDelivery, true,
+                                                              std::memory_order_acq_rel))
+        {
+          return; // Already delivered or being delivered by another thread
+        }
+
+        // Check cancellation after securing delivery slot
+        if (state->cancelled.load(std::memory_order_acquire))
+        {
+          // Invoke callback with cancellation exception to prevent future hanging
+          callback({}, std::make_exception_ptr(dns::DnsResolverException("DNS request cancelled")));
+          state->completed.store(true, std::memory_order_release);
+          return;
+        }
+
+        // Process result and invoke callback
+        try
+        {
+          if (error)
+          {
+            callback({}, error);
           }
-          
-          if (addresses.empty()) {
-            auto noRecordsError = std::make_exception_ptr(dns::DnsNoRecordsException(state->hostname, dns::DnsType::A));
-            callback({}, noRecordsError);
-          } else {
-            callback(std::move(addresses), nullptr);
+          else
+          {
+            std::vector<std::string> addresses;
+            for (const auto &record : result.a_records)
+            {
+              addresses.push_back(record.address);
+            }
+
+            if (addresses.empty())
+            {
+              auto noRecordsError = std::make_exception_ptr(
+                dns::DnsNoRecordsException(state->hostname, dns::DnsType::A));
+              callback({}, noRecordsError);
+            }
+            else
+            {
+              callback(std::move(addresses), nullptr);
+            }
           }
         }
-      }
-      catch (...) {
-        callback({}, std::current_exception());
-      }
-      
-      // Mark completed after callback processing
-      state->completed.store(true, std::memory_order_release);
-    });
+        catch (...)
+        {
+          callback({}, std::current_exception());
+        }
+
+        // Mark completed after callback processing
+        state->completed.store(true, std::memory_order_release);
+      });
   }
 };
 
 // =============================================================================
-// ASYNC API IMPLEMENTATIONS  
+// ASYNC API IMPLEMENTATIONS
 // =============================================================================
 
-inline AsyncDnsRequest DnsClient::resolveA(const std::string& hostname, 
-                                          std::function<void(std::vector<std::string>, std::exception_ptr)> callback)
+inline AsyncDnsRequest
+DnsClient::resolveA(const std::string &hostname,
+                    std::function<void(std::vector<std::string>, std::exception_ptr)> callback)
 {
   // Create request state for cancellation tracking
   auto state = std::make_shared<AsyncDnsRequest::RequestState>(hostname);
-  
+
   // Check for immediate errors
-  if (!transport_) {
-    auto error = std::make_exception_ptr(dns::DnsResolverException("DNS transport not initialized"));
+  if (!transport_)
+  {
+    auto error =
+      std::make_exception_ptr(dns::DnsResolverException("DNS transport not initialized"));
     callback({}, error);
     return AsyncDnsRequest{}; // Return invalid request
   }
-  
-  try {
+
+  try
+  {
     // Start async resolution
     resolveAInternal(hostname, std::move(callback), state);
-    
+
     // Return cancellable request handle
     return AsyncDnsRequest(state);
   }
-  catch (...) {
+  catch (...)
+  {
     // Immediate error - call callback on caller thread
     callback({}, std::current_exception());
     return AsyncDnsRequest{}; // Return invalid request
diff --git a/include/iora/network/event_batch_processor.hpp b/include/iora/network/event_batch_processor.hpp
index 6fd4fd1..fec97d3 100644
--- a/include/iora/network/event_batch_processor.hpp
+++ b/include/iora/network/event_batch_processor.hpp
@@ -6,344 +6,331 @@
 
 #pragma once
 
-#include <vector>
+#include <atomic>
+#include <cerrno>
 #include <chrono>
 #include <functional>
+#include <memory>
+#include <system_error>
 #include <sys/epoll.h>
-#include <atomic>
+#include <vector>
 
 namespace iora
 {
 namespace network
 {
 
-  // Configuration for batch processing
-  struct BatchProcessingConfig
-  {
-    std::size_t maxBatchSize{64}; // Maximum events to process per batch
-    std::chrono::microseconds maxBatchDelay{
-        100}; // Maximum time to wait for batch to fill
-    std::chrono::microseconds adaptiveThreshold{
-        50};                         // Threshold for adaptive batch sizing
-    bool enableAdaptiveSizing{true}; // Enable adaptive batch size adjustment
-    double loadFactor{0.75}; // Target CPU utilization for adaptive sizing
-  };
-
-  // Statistics for batch processing performance
-  struct BatchProcessingStats
+// Configuration for batch processing
+struct BatchProcessingConfig
+{
+  std::size_t maxBatchSize{64};                    // Maximum events to process per batch
+  std::chrono::microseconds maxBatchDelay{100};    // Maximum time to wait for batch to fill
+  std::chrono::microseconds adaptiveThreshold{50}; // Threshold for adaptive batch sizing
+  bool enableAdaptiveSizing{true};                 // Enable adaptive batch size adjustment
+  double loadFactor{0.75};                         // Target CPU utilization for adaptive sizing
+};
+
+// Statistics for batch processing performance
+struct BatchProcessingStats
+{
+  std::uint64_t totalBatches{0};
+  std::uint64_t totalEvents{0};
+  std::uint64_t maxBatchSize{0};
+  std::uint64_t minBatchSize{0};
+  std::uint64_t adaptiveAdjustments{0};
+  std::chrono::microseconds totalBatchTime{0};
+  std::chrono::microseconds avgBatchTime{0};
+  double throughputEventsPerSec{0.0};
+};
+
+// Event handler types
+using EventHandler = std::function<void(int fd, uint32_t events)>;
+using BatchCompleteHandler =
+  std::function<void(std::size_t batchSize, std::chrono::microseconds processingTime)>;
+
+// Batch event processor
+class EventBatchProcessor
+{
+public:
+  explicit EventBatchProcessor(const BatchProcessingConfig &config = {}) : config_(config)
   {
-    std::uint64_t totalBatches{0};
-    std::uint64_t totalEvents{0};
-    std::uint64_t maxBatchSize{0};
-    std::uint64_t minBatchSize{0};
-    std::uint64_t adaptiveAdjustments{0};
-    std::chrono::microseconds totalBatchTime{0};
-    std::chrono::microseconds avgBatchTime{0};
-    double throughputEventsPerSec{0.0};
-  };
-
-  // Event handler types
-  using EventHandler = std::function<void(int fd, uint32_t events)>;
-  using BatchCompleteHandler = std::function<void(
-      std::size_t batchSize, std::chrono::microseconds processingTime)>;
-
-  // Batch event processor
-  class EventBatchProcessor
+    events_.resize(config_.maxBatchSize);
+  }
+
+  // Process events in batches with adaptive sizing
+  template <typename SpecialEventHandler>
+  void processBatch(int epollFd, const EventHandler &generalHandler,
+                    const SpecialEventHandler &specialHandler,
+                    const BatchCompleteHandler &onBatchComplete = nullptr)
   {
-  public:
-    explicit EventBatchProcessor(const BatchProcessingConfig& config = {})
-      : config_(config)
-    {
-      events_.resize(config_.maxBatchSize);
-    }
+    auto batchStart = std::chrono::high_resolution_clock::now();
 
-    // Process events in batches with adaptive sizing
-    template <typename SpecialEventHandler>
-    void processBatch(int epollFd, const EventHandler& generalHandler,
-                      const SpecialEventHandler& specialHandler,
-                      const BatchCompleteHandler& onBatchComplete = nullptr)
-    {
-      auto batchStart = std::chrono::high_resolution_clock::now();
+    // Determine batch size (adaptive or fixed)
+    std::size_t currentBatchSize = getCurrentBatchSize();
 
-      // Determine batch size (adaptive or fixed)
-      std::size_t currentBatchSize = getCurrentBatchSize();
+    // Wait for events with timeout
+    int timeout = static_cast<int>(config_.maxBatchDelay.count() / 1000); // Convert to ms
+    int n = ::epoll_wait(epollFd, events_.data(), static_cast<int>(currentBatchSize), timeout);
 
-      // Wait for events with timeout
-      int timeout = static_cast<int>(config_.maxBatchDelay.count() /
-                                     1000); // Convert to ms
-      int n = ::epoll_wait(epollFd, events_.data(),
-                           static_cast<int>(currentBatchSize), timeout);
+    if (n < 0)
+    {
+      if (errno == EINTR)
+        return;
+      throw std::system_error(errno, std::system_category(), "epoll_wait failed");
+    }
 
-      if (n < 0)
-      {
-        if (errno == EINTR)
-          return;
-        throw std::system_error(errno, std::system_category(),
-                                "epoll_wait failed");
-      }
+    if (n == 0)
+      return; // Timeout with no events
 
-      if (n == 0)
-        return; // Timeout with no events
+    // Process the batch of events
+    std::vector<std::pair<int, uint32_t>> normalEvents;
+    normalEvents.reserve(n);
 
-      // Process the batch of events
-      std::vector<std::pair<int, uint32_t>> normalEvents;
-      normalEvents.reserve(n);
+    for (int i = 0; i < n; ++i)
+    {
+      int fd = events_[i].data.fd;
+      uint32_t eventMask = events_[i].events;
 
-      for (int i = 0; i < n; ++i)
+      // Handle special file descriptors first (eventfd, timerfd, etc.)
+      if (specialHandler(fd, eventMask))
       {
-        int fd = events_[i].data.fd;
-        uint32_t eventMask = events_[i].events;
-
-        // Handle special file descriptors first (eventfd, timerfd, etc.)
-        if (specialHandler(fd, eventMask))
-        {
-          continue; // Special handler processed this event
-        }
-
-        // Queue normal events for batch processing
-        normalEvents.emplace_back(fd, eventMask);
+        continue; // Special handler processed this event
       }
 
-      // Process normal events in batch
-      for (const auto& [fd, eventMask] : normalEvents)
-      {
-        generalHandler(fd, eventMask);
-      }
+      // Queue normal events for batch processing
+      normalEvents.emplace_back(fd, eventMask);
+    }
 
-      auto batchEnd = std::chrono::high_resolution_clock::now();
-      auto batchTime = std::chrono::duration_cast<std::chrono::microseconds>(
-          batchEnd - batchStart);
+    // Process normal events in batch
+    for (const auto &[fd, eventMask] : normalEvents)
+    {
+      generalHandler(fd, eventMask);
+    }
 
-      // Update statistics
-      updateStats(n, batchTime);
+    auto batchEnd = std::chrono::high_resolution_clock::now();
+    auto batchTime = std::chrono::duration_cast<std::chrono::microseconds>(batchEnd - batchStart);
 
-      // Adaptive sizing adjustment
-      if (config_.enableAdaptiveSizing)
-      {
-        adjustBatchSize(n, batchTime);
-      }
+    // Update statistics
+    updateStats(n, batchTime);
 
-      // Notify batch completion
-      if (onBatchComplete)
-      {
-        onBatchComplete(n, batchTime);
-      }
+    // Adaptive sizing adjustment
+    if (config_.enableAdaptiveSizing)
+    {
+      adjustBatchSize(n, batchTime);
     }
 
-    // Process with predefined special FD handlers
-    void processBatchWithSpecialFDs(
-        int epollFd, int eventFd, int timerFd,
-        const EventHandler& generalHandler,
-        const std::function<void()>& onEventFd = nullptr,
-        const std::function<void()>& onTimerFd = nullptr,
-        const BatchCompleteHandler& onBatchComplete = nullptr)
+    // Notify batch completion
+    if (onBatchComplete)
     {
-      auto specialHandler = [eventFd, timerFd, onEventFd,
-                             onTimerFd](int fd, uint32_t /*events*/) -> bool
-      {
-        if (fd == eventFd)
-        {
-          if (onEventFd)
-            onEventFd();
-          return true;
-        }
-        if (fd == timerFd)
-        {
-          if (onTimerFd)
-            onTimerFd();
-          return true;
-        }
-        return false; // Not a special FD
-      };
-
-      processBatch(epollFd, generalHandler, specialHandler, onBatchComplete);
+      onBatchComplete(n, batchTime);
     }
+  }
 
-    BatchProcessingStats getStats() const
+  // Process with predefined special FD handlers
+  void processBatchWithSpecialFDs(int epollFd, int eventFd, int timerFd,
+                                  const EventHandler &generalHandler,
+                                  const std::function<void()> &onEventFd = nullptr,
+                                  const std::function<void()> &onTimerFd = nullptr,
+                                  const BatchCompleteHandler &onBatchComplete = nullptr)
+  {
+    auto specialHandler = [eventFd, timerFd, onEventFd, onTimerFd](int fd,
+                                                                   uint32_t /*events*/) -> bool
     {
-      auto stats = stats_;
-
-      if (stats.totalBatches > 0)
+      if (fd == eventFd)
       {
-        stats.avgBatchTime = std::chrono::microseconds(
-            stats.totalBatchTime.count() / stats.totalBatches);
+        if (onEventFd)
+          onEventFd();
+        return true;
       }
-
-      if (stats.totalBatchTime.count() > 0)
+      if (fd == timerFd)
       {
-        double seconds = stats.totalBatchTime.count() / 1000000.0;
-        stats.throughputEventsPerSec = stats.totalEvents / seconds;
+        if (onTimerFd)
+          onTimerFd();
+        return true;
       }
+      return false; // Not a special FD
+    };
 
-      return stats;
-    }
+    processBatch(epollFd, generalHandler, specialHandler, onBatchComplete);
+  }
+
+  BatchProcessingStats getStats() const
+  {
+    auto stats = stats_;
 
-    void resetStats()
+    if (stats.totalBatches > 0)
     {
-      stats_ = {};
-      lastAdjustment_ = std::chrono::steady_clock::now();
+      stats.avgBatchTime =
+        std::chrono::microseconds(stats.totalBatchTime.count() / stats.totalBatches);
     }
 
-    void updateConfig(const BatchProcessingConfig& config)
+    if (stats.totalBatchTime.count() > 0)
     {
-      config_ = config;
-      events_.resize(config_.maxBatchSize);
-
-      // Reset adaptive sizing
-      if (config_.enableAdaptiveSizing)
-      {
-        currentBatchSize_ = config_.maxBatchSize / 2; // Start in middle
-      }
-      else
-      {
-        currentBatchSize_ = config_.maxBatchSize;
-      }
+      double seconds = stats.totalBatchTime.count() / 1000000.0;
+      stats.throughputEventsPerSec = stats.totalEvents / seconds;
     }
 
-    BatchProcessingConfig getConfig() const { return config_; }
+    return stats;
+  }
 
-    // Force a specific batch size for testing
-    void setFixedBatchSize(std::size_t size)
+  void resetStats()
+  {
+    stats_ = {};
+    lastAdjustment_ = std::chrono::steady_clock::now();
+  }
+
+  void updateConfig(const BatchProcessingConfig &config)
+  {
+    config_ = config;
+    events_.resize(config_.maxBatchSize);
+
+    // Reset adaptive sizing
+    if (config_.enableAdaptiveSizing)
     {
-      config_.enableAdaptiveSizing = false;
-      currentBatchSize_ = std::min(size, config_.maxBatchSize);
+      currentBatchSize_ = config_.maxBatchSize / 2; // Start in middle
     }
-
-  private:
-    std::size_t getCurrentBatchSize() const
+    else
     {
-      if (!config_.enableAdaptiveSizing)
-      {
-        return config_.maxBatchSize;
-      }
-
-      return currentBatchSize_;
+      currentBatchSize_ = config_.maxBatchSize;
     }
+  }
 
-    void updateStats(int eventCount, std::chrono::microseconds processingTime)
-    {
-      stats_.totalBatches++;
-      stats_.totalEvents += eventCount;
-      stats_.totalBatchTime += processingTime;
+  BatchProcessingConfig getConfig() const { return config_; }
 
-      if (eventCount > static_cast<int>(stats_.maxBatchSize))
-      {
-        stats_.maxBatchSize = eventCount;
-      }
+  // Force a specific batch size for testing
+  void setFixedBatchSize(std::size_t size)
+  {
+    config_.enableAdaptiveSizing = false;
+    currentBatchSize_ = std::min(size, config_.maxBatchSize);
+  }
 
-      if (stats_.minBatchSize == 0 ||
-          eventCount < static_cast<int>(stats_.minBatchSize))
-      {
-        stats_.minBatchSize = eventCount;
-      }
+private:
+  std::size_t getCurrentBatchSize() const
+  {
+    if (!config_.enableAdaptiveSizing)
+    {
+      return config_.maxBatchSize;
     }
 
-    void adjustBatchSize(int actualEvents,
-                         std::chrono::microseconds processingTime)
+    return currentBatchSize_;
+  }
+
+  void updateStats(int eventCount, std::chrono::microseconds processingTime)
+  {
+    stats_.totalBatches++;
+    stats_.totalEvents += eventCount;
+    stats_.totalBatchTime += processingTime;
+
+    if (eventCount > static_cast<int>(stats_.maxBatchSize))
     {
-      auto now = std::chrono::steady_clock::now();
+      stats_.maxBatchSize = eventCount;
+    }
 
-      // Only adjust every 100ms to avoid thrashing
-      if (now - lastAdjustment_ < std::chrono::milliseconds(100))
-      {
-        return;
-      }
+    if (stats_.minBatchSize == 0 || eventCount < static_cast<int>(stats_.minBatchSize))
+    {
+      stats_.minBatchSize = eventCount;
+    }
+  }
 
-      lastAdjustment_ = now;
+  void adjustBatchSize(int actualEvents, std::chrono::microseconds processingTime)
+  {
+    auto now = std::chrono::steady_clock::now();
 
-      // Calculate utilization based on processing time vs available time
-      double utilization = static_cast<double>(processingTime.count()) /
-                           static_cast<double>(config_.maxBatchDelay.count());
+    // Only adjust every 100ms to avoid thrashing
+    if (now - lastAdjustment_ < std::chrono::milliseconds(100))
+    {
+      return;
+    }
 
-      bool shouldIncrease = false;
-      bool shouldDecrease = false;
+    lastAdjustment_ = now;
 
-      // Increase batch size if:
-      // 1. We filled the batch completely AND processing time is acceptable
-      // 2. Utilization is below target load factor
-      if ((actualEvents == static_cast<int>(currentBatchSize_)) &&
-          (utilization < config_.loadFactor))
-      {
-        shouldIncrease = true;
-      }
+    // Calculate utilization based on processing time vs available time
+    double utilization = static_cast<double>(processingTime.count()) /
+                         static_cast<double>(config_.maxBatchDelay.count());
 
-      // Decrease batch size if:
-      // 1. Processing time is too high (above threshold)
-      // 2. We consistently get small batches
-      if (processingTime > config_.adaptiveThreshold ||
-          utilization > config_.loadFactor)
-      {
-        shouldDecrease = true;
-      }
+    bool shouldIncrease = false;
+    bool shouldDecrease = false;
 
-      if (shouldIncrease && currentBatchSize_ < config_.maxBatchSize)
-      {
-        // Increase by 25% or at least 1
-        std::size_t increase = std::max(1UL, currentBatchSize_ / 4);
-        currentBatchSize_ =
-            std::min(config_.maxBatchSize, currentBatchSize_ + increase);
-        stats_.adaptiveAdjustments++;
-      }
-      else if (shouldDecrease && currentBatchSize_ > 1)
-      {
-        // Decrease by 25% but at least keep 1
-        std::size_t decrease = std::max(1UL, currentBatchSize_ / 4);
-        currentBatchSize_ = std::max(1UL, currentBatchSize_ - decrease);
-        stats_.adaptiveAdjustments++;
-      }
+    // Increase batch size if:
+    // 1. We filled the batch completely AND processing time is acceptable
+    // 2. Utilization is below target load factor
+    if ((actualEvents == static_cast<int>(currentBatchSize_)) && (utilization < config_.loadFactor))
+    {
+      shouldIncrease = true;
     }
 
-  private:
-    BatchProcessingConfig config_;
-    std::vector<epoll_event> events_;
-    BatchProcessingStats stats_;
-
-    // Adaptive sizing state
-    std::size_t currentBatchSize_;
-    std::chrono::steady_clock::time_point lastAdjustment_{
-        std::chrono::steady_clock::now()};
-  };
+    // Decrease batch size if:
+    // 1. Processing time is too high (above threshold)
+    // 2. We consistently get small batches
+    if (processingTime > config_.adaptiveThreshold || utilization > config_.loadFactor)
+    {
+      shouldDecrease = true;
+    }
 
-  // Helper function to create processor with common configuration
-  inline std::unique_ptr<EventBatchProcessor>
-  createOptimizedProcessor(std::size_t expectedLoad = 32)
-  {
-    BatchProcessingConfig config;
-    config.maxBatchSize = std::max(8UL, expectedLoad * 2); // 2x expected load
-    config.maxBatchDelay = std::chrono::microseconds(50);  // Low latency
-    config.adaptiveThreshold = std::chrono::microseconds(25);
-    config.enableAdaptiveSizing = true;
-    config.loadFactor = 0.7; // Target 70% utilization
-
-    return std::make_unique<EventBatchProcessor>(config);
+    if (shouldIncrease && currentBatchSize_ < config_.maxBatchSize)
+    {
+      // Increase by 25% or at least 1
+      std::size_t increase = std::max(1UL, currentBatchSize_ / 4);
+      currentBatchSize_ = std::min(config_.maxBatchSize, currentBatchSize_ + increase);
+      stats_.adaptiveAdjustments++;
+    }
+    else if (shouldDecrease && currentBatchSize_ > 1)
+    {
+      // Decrease by 25% but at least keep 1
+      std::size_t decrease = std::max(1UL, currentBatchSize_ / 4);
+      currentBatchSize_ = std::max(1UL, currentBatchSize_ - decrease);
+      stats_.adaptiveAdjustments++;
+    }
   }
 
-  // Helper for high-throughput scenarios
-  inline std::unique_ptr<EventBatchProcessor> createHighThroughputProcessor()
-  {
-    BatchProcessingConfig config;
-    config.maxBatchSize = 128; // Large batches
-    config.maxBatchDelay =
-        std::chrono::microseconds(200); // Allow more batching
-    config.adaptiveThreshold = std::chrono::microseconds(150);
-    config.enableAdaptiveSizing = true;
-    config.loadFactor = 0.8; // Higher utilization acceptable
-
-    return std::make_unique<EventBatchProcessor>(config);
-  }
+private:
+  BatchProcessingConfig config_;
+  std::vector<epoll_event> events_;
+  BatchProcessingStats stats_;
 
-  // Helper for low-latency scenarios
-  inline std::unique_ptr<EventBatchProcessor> createLowLatencyProcessor()
-  {
-    BatchProcessingConfig config;
-    config.maxBatchSize = 16;                             // Small batches
-    config.maxBatchDelay = std::chrono::microseconds(10); // Very low delay
-    config.adaptiveThreshold = std::chrono::microseconds(5);
-    config.enableAdaptiveSizing = true;
-    config.loadFactor = 0.5; // Prefer low latency over utilization
-
-    return std::make_unique<EventBatchProcessor>(config);
-  }
+  // Adaptive sizing state
+  std::size_t currentBatchSize_;
+  std::chrono::steady_clock::time_point lastAdjustment_{std::chrono::steady_clock::now()};
+};
+
+// Helper function to create processor with common configuration
+inline std::unique_ptr<EventBatchProcessor> createOptimizedProcessor(std::size_t expectedLoad = 32)
+{
+  BatchProcessingConfig config;
+  config.maxBatchSize = std::max(8UL, expectedLoad * 2); // 2x expected load
+  config.maxBatchDelay = std::chrono::microseconds(50);  // Low latency
+  config.adaptiveThreshold = std::chrono::microseconds(25);
+  config.enableAdaptiveSizing = true;
+  config.loadFactor = 0.7; // Target 70% utilization
+
+  return std::make_unique<EventBatchProcessor>(config);
+}
+
+// Helper for high-throughput scenarios
+inline std::unique_ptr<EventBatchProcessor> createHighThroughputProcessor()
+{
+  BatchProcessingConfig config;
+  config.maxBatchSize = 128;                             // Large batches
+  config.maxBatchDelay = std::chrono::microseconds(200); // Allow more batching
+  config.adaptiveThreshold = std::chrono::microseconds(150);
+  config.enableAdaptiveSizing = true;
+  config.loadFactor = 0.8; // Higher utilization acceptable
+
+  return std::make_unique<EventBatchProcessor>(config);
+}
+
+// Helper for low-latency scenarios
+inline std::unique_ptr<EventBatchProcessor> createLowLatencyProcessor()
+{
+  BatchProcessingConfig config;
+  config.maxBatchSize = 16;                             // Small batches
+  config.maxBatchDelay = std::chrono::microseconds(10); // Very low delay
+  config.adaptiveThreshold = std::chrono::microseconds(5);
+  config.enableAdaptiveSizing = true;
+  config.loadFactor = 0.5; // Prefer low latency over utilization
+
+  return std::make_unique<EventBatchProcessor>(config);
+}
 
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/http_client.hpp b/include/iora/network/http_client.hpp
index d2ada46..2a6cb48 100644
--- a/include/iora/network/http_client.hpp
+++ b/include/iora/network/http_client.hpp
@@ -7,913 +7,891 @@
 
 #pragma once
 
+#include <atomic>
+#include <chrono>
+#include <ctime>
+#include <fstream>
+#include <functional>
+#include <future>
 #include <iostream>
-#include <stdexcept>
-#include <string>
 #include <mutex>
-#include <unordered_map>
 #include <optional>
-#include <chrono>
-#include <future>
-#include <functional>
-#include <thread>
-#include <sstream>
-#include <fstream>
 #include <regex>
-#include <ctime>
-#include <atomic>
+#include <sstream>
+#include <stdexcept>
+#include <string>
+#include <thread>
+#include <unordered_map>
 
-#include "iora/parsers/json.hpp"
-#include "iora/network/unified_shared_transport.hpp"
 #include "iora/network/dns_client.hpp"
+#include "iora/network/unified_shared_transport.hpp"
 #include "iora/parsers/http_message.hpp"
+#include "iora/parsers/json.hpp"
 
 namespace iora
 {
 namespace network
 {
 
-  // Use the std::map<std::string, std::string> from http_message.hpp which has
-  // case-insensitive comparison
-
-  /// \brief Modern HTTP client using hybrid transport for sync/async operations
-  /// \details
-  ///   - Built on UnifiedSharedTransport for reliable networking
-  ///   - Uses DnsClient for domain resolution
-  ///   - Supports both synchronous and asynchronous operations
-  ///   - Connection pooling with automatic cleanup
-  ///   - TLS/HTTPS support via transport layer
-  class HttpClient
+// Use the std::map<std::string, std::string> from http_message.hpp which has
+// case-insensitive comparison
+
+/// \brief Modern HTTP client using hybrid transport for sync/async operations
+/// \details
+///   - Built on UnifiedSharedTransport for reliable networking
+///   - Uses DnsClient for domain resolution
+///   - Supports both synchronous and asynchronous operations
+///   - Connection pooling with automatic cleanup
+///   - TLS/HTTPS support via transport layer
+class HttpClient
+{
+public:
+  /// \brief TLS configuration for HTTPS requests
+  struct TlsConfig
   {
-  public:
-    /// \brief TLS configuration for HTTPS requests
-    struct TlsConfig
-    {
-      std::string caFile;
-      std::string clientCertFile;
-      std::string clientKeyFile;
-      bool verifyPeer = true;
-    };
-
-    /// \brief HTTP response structure
-    struct Response
-    {
-      int statusCode = 0;
-      std::string statusText;
-      std::map<std::string, std::string> headers;
-      std::string body;
-      bool success() const { return statusCode >= 200 && statusCode < 300; }
-    };
-
-    /// \brief JSON parsing configuration
-    struct JsonConfig
-    {
-      std::size_t maxPayloadSize = 10 * 1024 * 1024;  // Maximum JSON payload size in bytes (10MB default)
-      parsers::ParseLimits parseLimits;  // JSON parsing limits (depth, array size, etc.)
-    };
-
-    /// \brief Configuration for HTTP client
-    struct Config
-    {
-      std::chrono::milliseconds connectTimeout;
-      std::chrono::milliseconds requestTimeout;
-      int maxRedirects;
-      bool followRedirects;
-      std::string userAgent;
-      bool reuseConnections;
-      std::chrono::seconds connectionIdleTimeout;
-      JsonConfig jsonConfig;  // JSON parsing configuration
-
-      Config()
-        : connectTimeout(2000),
-          requestTimeout(3000),
-          maxRedirects(5),
-          followRedirects(true),
-          userAgent("Iora-HttpClient/1.0"),
-          reuseConnections(true),
-          connectionIdleTimeout(300),
-          jsonConfig{}
-      {
-      }
+    std::string caFile;
+    std::string clientCertFile;
+    std::string clientKeyFile;
+    bool verifyPeer = true;
+  };
 
-      /// \brief Create a config optimized for localhost/testing
-      static Config forLocalhost()
-      {
-        Config c;
-        c.connectTimeout = std::chrono::milliseconds(100);
-        c.requestTimeout = std::chrono::milliseconds(200);
-        return c;
-      }
-    };
+  /// \brief HTTP response structure
+  struct Response
+  {
+    int statusCode = 0;
+    std::string statusText;
+    std::map<std::string, std::string> headers;
+    std::string body;
+    bool success() const { return statusCode >= 200 && statusCode < 300; }
+  };
 
-  private:
-    void ensureInitialized() const
-    {
-      if (!_transport)
-      {
-        // Create TCP transport for HTTP/HTTPS
-        auto transportConfig = UnifiedSharedTransport::Config::minimal(
-            UnifiedSharedTransport::Protocol::TCP);
-        transportConfig.connectTimeout =
-            std::chrono::duration_cast<std::chrono::seconds>(
-                _config.connectTimeout);
-        transportConfig.defaultSyncTimeout = _config.requestTimeout;
-        transportConfig.idleTimeout = _config.connectionIdleTimeout;
-
-        // Enable TLS for HTTPS with current TLS configuration
-        transportConfig.clientTls.enabled = true;
-        transportConfig.clientTls.defaultMode = TlsMode::Client;
-        transportConfig.clientTls.verifyPeer = _tlsConfig.verifyPeer;
-
-        _transport = std::make_unique<UnifiedSharedTransport>(transportConfig);
-        bool startResult = _transport->start();
-        if (!startResult)
-        {
-          throw std::runtime_error(
-              "Failed to start HTTP client transport layer");
-        }
+  /// \brief JSON parsing configuration
+  struct JsonConfig
+  {
+    std::size_t maxPayloadSize =
+      10 * 1024 * 1024;               // Maximum JSON payload size in bytes (10MB default)
+    parsers::ParseLimits parseLimits; // JSON parsing limits (depth, array size, etc.)
+  };
 
-        // Create DNS client for domain resolution
-        _dnsClient = std::make_unique<DnsClient>();
-        _dnsClient->start();
-      }
+  /// \brief Configuration for HTTP client
+  struct Config
+  {
+    std::chrono::milliseconds connectTimeout;
+    std::chrono::milliseconds requestTimeout;
+    int maxRedirects;
+    bool followRedirects;
+    std::string userAgent;
+    bool reuseConnections;
+    std::chrono::seconds connectionIdleTimeout;
+    JsonConfig jsonConfig; // JSON parsing configuration
+
+    Config()
+        : connectTimeout(2000), requestTimeout(3000), maxRedirects(5), followRedirects(true),
+          userAgent("Iora-HttpClient/1.0"), reuseConnections(true), connectionIdleTimeout(300),
+          jsonConfig{}
+    {
     }
 
-    mutable std::mutex _mutex;
-    Config _config;
-    TlsConfig _tlsConfig;
-
-    // Transport and DNS client (initialized lazily)
-    mutable std::unique_ptr<UnifiedSharedTransport> _transport;
-    mutable std::unique_ptr<DnsClient> _dnsClient;
-
-    // Simple connection pool: host:port -> SessionId
-    mutable std::unordered_map<std::string, SessionId> _connections;
-    mutable std::unordered_map<SessionId, std::chrono::steady_clock::time_point>
-        _connectionLastUsed;
-    mutable SyncAsyncTransport::ConnectCallback _connectCallback;
+    /// \brief Create a config optimized for localhost/testing
+    static Config forLocalhost()
+    {
+      Config c;
+      c.connectTimeout = std::chrono::milliseconds(100);
+      c.requestTimeout = std::chrono::milliseconds(200);
+      return c;
+    }
+  };
 
-    /// \brief URL parsing structure
-    struct ParsedUrl
+private:
+  void ensureInitialized() const
+  {
+    if (!_transport)
     {
-      std::string scheme;
-      std::string host;
-      std::uint16_t port;
-      std::string path;
-      std::string query;
+      // Create TCP transport for HTTP/HTTPS
+      auto transportConfig =
+        UnifiedSharedTransport::Config::minimal(UnifiedSharedTransport::Protocol::TCP);
+      transportConfig.connectTimeout =
+        std::chrono::duration_cast<std::chrono::seconds>(_config.connectTimeout);
+      transportConfig.defaultSyncTimeout = _config.requestTimeout;
+      transportConfig.idleTimeout = _config.connectionIdleTimeout;
 
-      bool isHttps() const { return scheme == "https"; }
-      std::string getPathWithQuery() const
-      {
-        if (query.empty())
-          return path.empty() ? "/" : path;
-        return (path.empty() ? "/" : path) + "?" + query;
-      }
-      std::string getHostPort() const
+      // Enable TLS for HTTPS with current TLS configuration
+      transportConfig.clientTls.enabled = true;
+      transportConfig.clientTls.defaultMode = TlsMode::Client;
+      transportConfig.clientTls.verifyPeer = _tlsConfig.verifyPeer;
+
+      _transport = std::make_unique<UnifiedSharedTransport>(transportConfig);
+      bool startResult = _transport->start();
+      if (!startResult)
       {
-        return host + ":" + std::to_string(port);
+        throw std::runtime_error("Failed to start HTTP client transport layer");
       }
-    };
 
-  public:
-    /// \brief Constructor with optional configuration
-    explicit HttpClient(const Config& config = Config{}) : _config(config)
-    {
-      // Transport and DNS client are created lazily to allow TLS config to be
-      // set first
+      // Create DNS client for domain resolution
+      _dnsClient = std::make_unique<DnsClient>();
+      _dnsClient->start();
     }
+  }
 
-    ~HttpClient() { cleanup(); }
+  mutable std::mutex _mutex;
+  Config _config;
+  TlsConfig _tlsConfig;
 
-    // Delete copy operations to prevent issues with transport ownership
-    HttpClient(const HttpClient&) = delete;
-    HttpClient& operator=(const HttpClient&) = delete;
+  // Transport and DNS client (initialized lazily)
+  mutable std::unique_ptr<UnifiedSharedTransport> _transport;
+  mutable std::unique_ptr<DnsClient> _dnsClient;
 
-    // Allow move operations
-    HttpClient(HttpClient&&) = default;
-    HttpClient& operator=(HttpClient&&) = default;
+  // Simple connection pool: host:port -> SessionId
+  mutable std::unordered_map<std::string, SessionId> _connections;
+  mutable std::unordered_map<SessionId, std::chrono::steady_clock::time_point> _connectionLastUsed;
+  mutable SyncAsyncTransport::ConnectCallback _connectCallback;
 
-    /// \brief Set TLS configuration
-    void setTlsConfig(const TlsConfig& config)
+  /// \brief URL parsing structure
+  struct ParsedUrl
+  {
+    std::string scheme;
+    std::string host;
+    std::uint16_t port;
+    std::string path;
+    std::string query;
+
+    bool isHttps() const { return scheme == "https"; }
+    std::string getPathWithQuery() const
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      _tlsConfig = config;
-      // TLS config is applied per-connection during connect
+      if (query.empty())
+        return path.empty() ? "/" : path;
+      return (path.empty() ? "/" : path) + "?" + query;
     }
+    std::string getHostPort() const { return host + ":" + std::to_string(port); }
+  };
+
+public:
+  /// \brief Constructor with optional configuration
+  explicit HttpClient(const Config &config = Config{}) : _config(config)
+  {
+    // Transport and DNS client are created lazily to allow TLS config to be
+    // set first
+  }
+
+  ~HttpClient() { cleanup(); }
+
+  // Delete copy operations to prevent issues with transport ownership
+  HttpClient(const HttpClient &) = delete;
+  HttpClient &operator=(const HttpClient &) = delete;
+
+  // Allow move operations
+  HttpClient(HttpClient &&) = default;
+  HttpClient &operator=(HttpClient &&) = default;
+
+  /// \brief Set TLS configuration
+  void setTlsConfig(const TlsConfig &config)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    _tlsConfig = config;
+    // TLS config is applied per-connection during connect
+  }
+
+  /// \brief Set DNS servers for domain resolution
+  /// \param servers List of DNS server addresses (e.g., {"8.8.8.8", "1.1.1.1:53", "192.168.1.1"})
+  /// \note Servers without explicit port use default port 53. Must be set before making requests.
+  void setDnsServers(const std::vector<std::string> &servers)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    ensureInitialized();
+    _dnsClient->setDnsServers(servers);
+  }
+
+  /// \brief Add DNS server to existing configuration
+  /// \param server DNS server address (e.g., "8.8.8.8" or "1.1.1.1:53")
+  void addDnsServer(const std::string &server)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    ensureInitialized();
+    _dnsClient->addDnsServer(server);
+  }
+
+  /// \brief Get current DNS servers
+  /// \return Vector of DNS server addresses in "address:port" format
+  std::vector<std::string> getDnsServers()
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    ensureInitialized();
+    return _dnsClient->getDnsServers();
+  }
+
+  /// \brief Perform synchronous GET request
+  Response get(const std::string &url, const std::map<std::string, std::string> &headers = {},
+               int retries = 0)
+  {
+    return performRequest("GET", url, "", headers, retries);
+  }
+
+  /// \brief Perform synchronous POST request with JSON body
+  Response postJson(const std::string &url, const parsers::Json &body,
+                    const std::map<std::string, std::string> &headers = {}, int retries = 0)
+  {
+    std::map<std::string, std::string> jsonHeaders = headers;
+    jsonHeaders["Content-Type"] = "application/json";
+    std::string jsonBody = body.dump();
+    return performRequest("POST", url, jsonBody, jsonHeaders, retries);
+  }
+
+  /// \brief Perform synchronous POST request with string body
+  Response post(const std::string &url, const std::string &body,
+                const std::map<std::string, std::string> &headers = {}, int retries = 0)
+  {
+    return performRequest("POST", url, body, headers, retries);
+  }
+
+  /// \brief Perform synchronous DELETE request
+  Response deleteRequest(const std::string &url,
+                         const std::map<std::string, std::string> &headers = {}, int retries = 0)
+  {
+    return performRequest("DELETE", url, "", headers, retries);
+  }
+
+  /// \brief Perform asynchronous GET request
+  std::future<Response> getAsync(const std::string &url,
+                                 const std::map<std::string, std::string> &headers = {},
+                                 int retries = 0)
+  {
+    return std::async(std::launch::async,
+                      [this, url, headers, retries]() { return get(url, headers, retries); });
+  }
+
+  /// \brief Perform asynchronous POST request with JSON body
+  std::future<Response> postJsonAsync(const std::string &url, const parsers::Json &body,
+                                      const std::map<std::string, std::string> &headers = {},
+                                      int retries = 0)
+  {
+    return std::async(std::launch::async, [this, url, body, headers, retries]()
+                      { return postJson(url, body, headers, retries); });
+  }
+
+  /// \brief Stream HTTP response via callback (for server-sent events, etc.)
+  void postStream(const std::string &url, const parsers::Json &body,
+                  const std::map<std::string, std::string> &headers,
+                  const std::function<void(const std::string &)> &onChunk, int retries = 0)
+  {
+    std::map<std::string, std::string> streamHeaders = headers;
+    streamHeaders["Accept"] = "text/event-stream";
+    streamHeaders["Cache-Control"] = "no-cache";
 
-    /// \brief Perform synchronous GET request
-    Response get(const std::string& url,
-                 const std::map<std::string, std::string>& headers = {},
-                 int retries = 0)
+    Response response = postJson(url, body, streamHeaders, retries);
+    if (!response.success())
     {
-      return performRequest("GET", url, "", headers, retries);
+      throw std::runtime_error("HTTP request failed: " + std::to_string(response.statusCode));
     }
 
-    /// \brief Perform synchronous POST request with JSON body
-    Response postJson(const std::string& url, const parsers::Json& body,
-                      const std::map<std::string, std::string>& headers = {},
-                      int retries = 0)
+    // Split response body into lines and call onChunk for each
+    std::istringstream stream(response.body);
+    std::string line;
+    while (std::getline(stream, line))
     {
-      std::map<std::string, std::string> jsonHeaders = headers;
-      jsonHeaders["Content-Type"] = "application/json";
-      std::string jsonBody = body.dump();
-      return performRequest("POST", url, jsonBody, jsonHeaders, retries);
+      onChunk(line);
     }
+  }
 
-    /// \brief Perform synchronous POST request with string body
-    Response post(const std::string& url, const std::string& body,
-                  const std::map<std::string, std::string>& headers = {},
-                  int retries = 0)
+  /// \brief Upload file via multipart form data
+  Response postFile(const std::string &url, const std::string &fieldName,
+                    const std::string &filePath,
+                    const std::map<std::string, std::string> &headers = {}, int retries = 0)
+  {
+    // Read file content
+    std::ifstream file(filePath, std::ios::binary);
+    if (!file)
     {
-      return performRequest("POST", url, body, headers, retries);
+      throw std::runtime_error("Cannot read file: " + filePath);
     }
 
-    /// \brief Perform synchronous DELETE request
-    Response
-    deleteRequest(const std::string& url,
-                  const std::map<std::string, std::string>& headers = {},
-                  int retries = 0)
+    std::string fileContent((std::istreambuf_iterator<char>(file)),
+                            std::istreambuf_iterator<char>());
+    file.close();
+
+    // Extract filename from path
+    std::string filename = filePath;
+    auto pos = filename.find_last_of("/\\");
+    if (pos != std::string::npos)
     {
-      return performRequest("DELETE", url, "", headers, retries);
+      filename = filename.substr(pos + 1);
     }
 
-    /// \brief Perform asynchronous GET request
-    std::future<Response>
-    getAsync(const std::string& url,
-             const std::map<std::string, std::string>& headers = {},
-             int retries = 0)
+    // Create multipart form data
+    std::string boundary = "----IoraBoundary" + std::to_string(std::time(nullptr));
+    std::ostringstream body;
+    body << "--" << boundary << "\r\n";
+    body << "Content-Disposition: form-data; name=\"" << fieldName << "\"; filename=\"" << filename
+         << "\"\r\n";
+    body << "Content-Type: application/octet-stream\r\n\r\n";
+    body << fileContent;
+    body << "\r\n--" << boundary << "--\r\n";
+
+    std::map<std::string, std::string> multipartHeaders = headers;
+    multipartHeaders["Content-Type"] = "multipart/form-data; boundary=" + boundary;
+
+    return performRequest("POST", url, body.str(), multipartHeaders, retries);
+  }
+
+  /// \brief Parse JSON response or throw on error (with default config)
+  static parsers::Json parseJsonOrThrow(const Response &response)
+  {
+    JsonConfig defaultConfig;
+    return parseJsonOrThrow(response, defaultConfig);
+  }
+
+  /// \brief Parse JSON response or throw on error (with custom config)
+  static parsers::Json parseJsonOrThrow(const Response &response, const JsonConfig &jsonConfig)
+  {
+    if (!response.success())
     {
-      return std::async(std::launch::async, [this, url, headers, retries]()
-                        { return get(url, headers, retries); });
+      throw std::runtime_error("HTTP failed with status: " + std::to_string(response.statusCode));
     }
 
-    /// \brief Perform asynchronous POST request with JSON body
-    std::future<Response>
-    postJsonAsync(const std::string& url, const parsers::Json& body,
-                  const std::map<std::string, std::string>& headers = {},
-                  int retries = 0)
+    if (response.body.size() > jsonConfig.maxPayloadSize)
     {
-      return std::async(std::launch::async,
-                        [this, url, body, headers, retries]()
-                        { return postJson(url, body, headers, retries); });
+      throw std::runtime_error("JSON response exceeds maximum size limit of " +
+                               std::to_string(jsonConfig.maxPayloadSize) + " bytes");
     }
 
-    /// \brief Stream HTTP response via callback (for server-sent events, etc.)
-    void postStream(const std::string& url, const parsers::Json& body,
-                    const std::map<std::string, std::string>& headers,
-                    const std::function<void(const std::string&)>& onChunk,
-                    int retries = 0)
+    auto result = parsers::Json::parse(response.body, jsonConfig.parseLimits);
+    if (!result.ok)
     {
-      std::map<std::string, std::string> streamHeaders = headers;
-      streamHeaders["Accept"] = "text/event-stream";
-      streamHeaders["Cache-Control"] = "no-cache";
+      throw std::runtime_error("JSON parse error: " + result.error.message);
+    }
+    return std::move(result.value);
+  }
 
-      Response response = postJson(url, body, streamHeaders, retries);
-      if (!response.success())
-      {
-        throw std::runtime_error("HTTP request failed: " +
-                                 std::to_string(response.statusCode));
-      }
+  /// \brief Cleanup connections and resources
+  void cleanup()
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
 
-      // Split response body into lines and call onChunk for each
-      std::istringstream stream(response.body);
-      std::string line;
-      while (std::getline(stream, line))
-      {
-        onChunk(line);
-      }
+    // Close all connections
+    for (const auto &[hostPort, sessionId] : _connections)
+    {
+      _transport->close(sessionId);
     }
+    _connections.clear();
+    _connectionLastUsed.clear();
 
-    /// \brief Upload file via multipart form data
-    Response postFile(const std::string& url, const std::string& fieldName,
-                      const std::string& filePath,
-                      const std::map<std::string, std::string>& headers = {},
-                      int retries = 0)
+    if (_transport)
     {
-      // Read file content
-      std::ifstream file(filePath, std::ios::binary);
-      if (!file)
-      {
-        throw std::runtime_error("Cannot read file: " + filePath);
-      }
-
-      std::string fileContent((std::istreambuf_iterator<char>(file)),
-                              std::istreambuf_iterator<char>());
-      file.close();
+      _transport->stop();
+    }
 
-      // Extract filename from path
-      std::string filename = filePath;
-      auto pos = filename.find_last_of("/\\");
-      if (pos != std::string::npos)
-      {
-        filename = filename.substr(pos + 1);
-      }
+    if (_dnsClient)
+    {
+      _dnsClient->stop();
+    }
+  }
 
-      // Create multipart form data
-      std::string boundary =
-          "----IoraBoundary" + std::to_string(std::time(nullptr));
-      std::ostringstream body;
-      body << "--" << boundary << "\r\n";
-      body << "Content-Disposition: form-data; name=\"" << fieldName
-           << "\"; filename=\"" << filename << "\"\r\n";
-      body << "Content-Type: application/octet-stream\r\n\r\n";
-      body << fileContent;
-      body << "\r\n--" << boundary << "--\r\n";
+private:
+  /// \brief Parse URL into components
+  ParsedUrl parseUrl(const std::string &url) const
+  {
+    ParsedUrl parsed;
 
-      std::map<std::string, std::string> multipartHeaders = headers;
-      multipartHeaders["Content-Type"] =
-          "multipart/form-data; boundary=" + boundary;
+    // Simple regex-based URL parsing
+    std::regex urlRegex(
+      R"(^(https?):\/\/([^:\/\s]+)(?::(\d+))?(\/?[^?\s]*)(?:\?([^#\s]*))?(?:#.*)?$)");
+    std::smatch match;
 
-      return performRequest("POST", url, body.str(), multipartHeaders, retries);
+    if (!std::regex_match(url, match, urlRegex))
+    {
+      throw std::invalid_argument("Invalid URL format: " + url);
     }
 
-    /// \brief Parse JSON response or throw on error (with default config)
-    static parsers::Json parseJsonOrThrow(const Response& response)
+    parsed.scheme = match[1].str();
+    parsed.host = match[2].str();
+
+    // Default ports
+    if (match[3].matched)
     {
-      JsonConfig defaultConfig;
-      return parseJsonOrThrow(response, defaultConfig);
+      parsed.port = static_cast<std::uint16_t>(std::stoi(match[3].str()));
     }
-
-    /// \brief Parse JSON response or throw on error (with custom config)
-    static parsers::Json parseJsonOrThrow(const Response& response,
-                                         const JsonConfig& jsonConfig)
+    else
     {
-      if (!response.success())
-      {
-        throw std::runtime_error("HTTP failed with status: " +
-                                 std::to_string(response.statusCode));
-      }
+      parsed.port = (parsed.scheme == "https") ? 443 : 80;
+    }
 
-      if (response.body.size() > jsonConfig.maxPayloadSize)
-      {
-        throw std::runtime_error("JSON response exceeds maximum size limit of " +
-                                std::to_string(jsonConfig.maxPayloadSize) + " bytes");
-      }
+    parsed.path = match[4].str();
+    if (parsed.path.empty())
+      parsed.path = "/";
 
-      auto result = parsers::Json::parse(response.body, jsonConfig.parseLimits);
-      if (!result.ok)
-      {
-        throw std::runtime_error("JSON parse error: " + result.error.message);
-      }
-      return std::move(result.value);
-    }
+    parsed.query = match[5].str();
 
-    /// \brief Cleanup connections and resources
-    void cleanup()
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
+    return parsed;
+  }
 
-      // Close all connections
-      for (const auto& [hostPort, sessionId] : _connections)
-      {
-        _transport->close(sessionId);
-      }
-      _connections.clear();
-      _connectionLastUsed.clear();
+  /// \brief Get or create connection to host
+  SessionId getConnection(const ParsedUrl &parsedUrl)
+  {
+    // EMERGENCY TIMEOUT: Wrap entire connection attempt with ultimate timeout
+    auto emergencyStart = std::chrono::steady_clock::now();
+    auto emergencyTimeout = std::chrono::milliseconds(5000); // 5 seconds maximum
 
-      if (_transport)
-      {
-        _transport->stop();
-      }
+    std::lock_guard<std::mutex> lock(_mutex);
 
-      if (_dnsClient)
-      {
-        _dnsClient->stop();
-      }
-    }
+    std::string hostPort = parsedUrl.getHostPort();
 
-  private:
-    /// \brief Parse URL into components
-    ParsedUrl parseUrl(const std::string& url) const
+    // Check for existing connection
+    auto it = _connections.find(hostPort);
+    if (it != _connections.end())
     {
-      ParsedUrl parsed;
+      // Check if connection is still alive and not idle
+      auto sessionId = it->second;
+      auto health = _transport->getConnectionHealth(sessionId);
 
-      // Simple regex-based URL parsing
-      std::regex urlRegex(
-          R"(^(https?):\/\/([^:\/\s]+)(?::(\d+))?(\/?[^?\s]*)(?:\?([^#\s]*))?(?:#.*)?$)");
-      std::smatch match;
-
-      if (!std::regex_match(url, match, urlRegex))
+      if (health.isHealthy)
       {
-        throw std::invalid_argument("Invalid URL format: " + url);
+        auto now = std::chrono::steady_clock::now();
+        auto lastUsed = _connectionLastUsed[sessionId];
+
+        if (now - lastUsed < _config.connectionIdleTimeout)
+        {
+          _connectionLastUsed[sessionId] = now;
+          return sessionId;
+        }
       }
 
-      parsed.scheme = match[1].str();
-      parsed.host = match[2].str();
+      // Connection is dead or idle, remove it
+      _transport->close(sessionId);
+      _connections.erase(it);
+      _connectionLastUsed.erase(sessionId);
+    }
 
-      // Default ports
-      if (match[3].matched)
+    // Resolve hostname if needed
+    std::string resolvedHost = parsedUrl.host;
+    if (!isIPAddress(parsedUrl.host))
+    {
+      // Handle localhost specially
+      if (parsedUrl.host == "localhost")
       {
-        parsed.port = static_cast<std::uint16_t>(std::stoi(match[3].str()));
+        resolvedHost = "127.0.0.1";
       }
       else
       {
-        parsed.port = (parsed.scheme == "https") ? 443 : 80;
+        try
+        {
+          auto result = _dnsClient->resolveHost(parsedUrl.host);
+          if (!result.ipv4.empty())
+          {
+            resolvedHost = result.ipv4[0]; // Use first IPv4 address
+          }
+          else if (!result.ipv6.empty())
+          {
+            resolvedHost = result.ipv6[0]; // Use first IPv6 address
+          }
+        }
+        catch (const std::exception &e)
+        {
+          // DNS resolution failed, try connecting with hostname directly
+          // The transport layer might handle this
+        }
       }
+    }
 
-      parsed.path = match[4].str();
-      if (parsed.path.empty())
-        parsed.path = "/";
+    // Create new connection with callback-based timeout
+    TlsMode tlsMode = parsedUrl.isHttps() ? TlsMode::Client : TlsMode::None;
 
-      parsed.query = match[5].str();
+    // Call connect directly - the transport layer now handles timeouts
+    // properly
+    SessionId sessionId = _transport->connect(resolvedHost, parsedUrl.port, tlsMode);
 
-      return parsed;
+    // Emergency timeout check
+    if (std::chrono::steady_clock::now() - emergencyStart > emergencyTimeout)
+    {
+      throw std::runtime_error("EMERGENCY TIMEOUT: Connection attempt to " + hostPort +
+                               " exceeded 5 seconds");
     }
-
-    /// \brief Get or create connection to host
-    SessionId getConnection(const ParsedUrl& parsedUrl)
+    if (sessionId == 0)
     {
-      // EMERGENCY TIMEOUT: Wrap entire connection attempt with ultimate timeout
-      auto emergencyStart = std::chrono::steady_clock::now();
-      auto emergencyTimeout =
-          std::chrono::milliseconds(5000); // 5 seconds maximum
+      throw std::runtime_error("Failed to initiate connection to " + hostPort);
+    }
 
-      std::lock_guard<std::mutex> lock(_mutex);
+    // Use aggressive polling with immediate failure detection for localhost
+    auto startTime = std::chrono::steady_clock::now();
 
-      std::string hostPort = parsedUrl.getHostPort();
+    // For localhost connections, we expect immediate failure - don't wait
+    // long
+    auto maxWaitTime =
+      (resolvedHost == "127.0.0.1") ? std::chrono::milliseconds(100) : _config.connectTimeout;
 
-      // Check for existing connection
-      auto it = _connections.find(hostPort);
-      if (it != _connections.end())
-      {
-        // Check if connection is still alive and not idle
-        auto sessionId = it->second;
-        auto health = _transport->getConnectionHealth(sessionId);
-
-        if (health.isHealthy)
-        {
-          auto now = std::chrono::steady_clock::now();
-          auto lastUsed = _connectionLastUsed[sessionId];
+    while (true)
+    {
+      auto health = _transport->getConnectionHealth(sessionId);
 
-          if (now - lastUsed < _config.connectionIdleTimeout)
-          {
-            _connectionLastUsed[sessionId] = now;
-            return sessionId;
-          }
-        }
+      // If connection becomes healthy, we're done
+      if (health.isHealthy)
+      {
+        break;
+      }
 
-        // Connection is dead or idle, remove it
+      // Check for explicit errors (this should catch failed connections)
+      if (health.errorCount > 0)
+      {
         _transport->close(sessionId);
-        _connections.erase(it);
-        _connectionLastUsed.erase(sessionId);
+        throw std::runtime_error("Connection failed to " + hostPort + " (" +
+                                 health.lastErrorMessage + ")");
       }
 
-      // Resolve hostname if needed
-      std::string resolvedHost = parsedUrl.host;
-      if (!isIPAddress(parsedUrl.host))
+      // Check for timeout
+      auto elapsed = std::chrono::steady_clock::now() - startTime;
+      if (elapsed > maxWaitTime)
       {
-        // Handle localhost specially
-        if (parsedUrl.host == "localhost")
-        {
-          resolvedHost = "127.0.0.1";
-        }
-        else
-        {
-          try
-          {
-            auto result = _dnsClient->resolveHost(parsedUrl.host);
-            if (!result.ipv4.empty())
-            {
-              resolvedHost = result.ipv4[0]; // Use first IPv4 address
-            }
-            else if (!result.ipv6.empty())
-            {
-              resolvedHost = result.ipv6[0]; // Use first IPv6 address
-            }
-          }
-          catch (const std::exception& e)
-          {
-            // DNS resolution failed, try connecting with hostname directly
-            // The transport layer might handle this
-          }
-        }
+        _transport->close(sessionId);
+        auto elapsedMs = std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count();
+        throw std::runtime_error("Connection timeout to " + hostPort + " after " +
+                                 std::to_string(elapsedMs) + "ms");
       }
 
-      // Create new connection with callback-based timeout
-      TlsMode tlsMode = parsedUrl.isHttps() ? TlsMode::Client : TlsMode::None;
-
-      // Call connect directly - the transport layer now handles timeouts
-      // properly
-      SessionId sessionId =
-          _transport->connect(resolvedHost, parsedUrl.port, tlsMode);
-
       // Emergency timeout check
       if (std::chrono::steady_clock::now() - emergencyStart > emergencyTimeout)
       {
-        throw std::runtime_error("EMERGENCY TIMEOUT: Connection attempt to " +
-                                 hostPort + " exceeded 5 seconds");
-      }
-      if (sessionId == 0)
-      {
-        throw std::runtime_error("Failed to initiate connection to " +
-                                 hostPort);
+        _transport->close(sessionId);
+        throw std::runtime_error("EMERGENCY TIMEOUT: Connection polling to " + hostPort +
+                                 " exceeded 5 seconds");
       }
 
-      // Use aggressive polling with immediate failure detection for localhost
-      auto startTime = std::chrono::steady_clock::now();
-
-      // For localhost connections, we expect immediate failure - don't wait
-      // long
-      auto maxWaitTime = (resolvedHost == "127.0.0.1")
-                             ? std::chrono::milliseconds(100)
-                             : _config.connectTimeout;
-
-      while (true)
+      // For debugging: if this is a localhost connection and we've waited
+      // more than 50ms, something is wrong
+      if (resolvedHost == "127.0.0.1" && elapsed > std::chrono::milliseconds(50))
       {
-        auto health = _transport->getConnectionHealth(sessionId);
-
-        // If connection becomes healthy, we're done
-        if (health.isHealthy)
-        {
-          break;
-        }
-
-        // Check for explicit errors (this should catch failed connections)
-        if (health.errorCount > 0)
-        {
-          _transport->close(sessionId);
-          throw std::runtime_error("Connection failed to " + hostPort + " (" +
-                                   health.lastErrorMessage + ")");
-        }
-
-        // Check for timeout
-        auto elapsed = std::chrono::steady_clock::now() - startTime;
-        if (elapsed > maxWaitTime)
-        {
-          _transport->close(sessionId);
-          auto elapsedMs =
-              std::chrono::duration_cast<std::chrono::milliseconds>(elapsed)
-                  .count();
-          throw std::runtime_error("Connection timeout to " + hostPort +
-                                   " after " + std::to_string(elapsedMs) +
-                                   "ms");
-        }
-
-        // Emergency timeout check
-        if (std::chrono::steady_clock::now() - emergencyStart >
-            emergencyTimeout)
-        {
-          _transport->close(sessionId);
-          throw std::runtime_error("EMERGENCY TIMEOUT: Connection polling to " +
-                                   hostPort + " exceeded 5 seconds");
-        }
-
-        // For debugging: if this is a localhost connection and we've waited
-        // more than 50ms, something is wrong
-        if (resolvedHost == "127.0.0.1" &&
-            elapsed > std::chrono::milliseconds(50))
-        {
-          _transport->close(sessionId);
-          auto elapsedMs =
-              std::chrono::duration_cast<std::chrono::milliseconds>(elapsed)
-                  .count();
-          throw std::runtime_error("Localhost connection taking too long - "
-                                   "should fail immediately. Waited " +
-                                   std::to_string(elapsedMs) + "ms");
-        }
-
-        // Very short sleep to check frequently
-        std::this_thread::sleep_for(std::chrono::milliseconds(1));
+        _transport->close(sessionId);
+        auto elapsedMs = std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count();
+        throw std::runtime_error("Localhost connection taking too long - "
+                                 "should fail immediately. Waited " +
+                                 std::to_string(elapsedMs) + "ms");
       }
 
-      // Store connection
-      _connections[hostPort] = sessionId;
-      _connectionLastUsed[sessionId] = std::chrono::steady_clock::now();
-
-      return sessionId;
+      // Very short sleep to check frequently
+      std::this_thread::sleep_for(std::chrono::milliseconds(1));
     }
 
-    /// \brief Check if string is an IP address
-    bool isIPAddress(const std::string& str) const
+    // Store connection
+    _connections[hostPort] = sessionId;
+    _connectionLastUsed[sessionId] = std::chrono::steady_clock::now();
+
+    return sessionId;
+  }
+
+  /// \brief Check if string is an IP address
+  bool isIPAddress(const std::string &str) const
+  {
+    // Simple IPv4 check (could be enhanced for IPv6)
+    std::regex ipv4Regex(R"(^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$)");
+    return std::regex_match(str, ipv4Regex);
+  }
+
+  /// \brief Perform HTTP request with retry logic
+  Response performRequest(const std::string &method, const std::string &url,
+                          const std::string &body,
+                          const std::map<std::string, std::string> &headers, int retries)
+  {
     {
-      // Simple IPv4 check (could be enhanced for IPv6)
-      std::regex ipv4Regex(R"(^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$)");
-      return std::regex_match(str, ipv4Regex);
+      std::lock_guard<std::mutex> lock(_mutex);
+      ensureInitialized();
     }
 
-    /// \brief Perform HTTP request with retry logic
-    Response performRequest(const std::string& method, const std::string& url,
-                            const std::string& body,
-                            const std::map<std::string, std::string>& headers,
-                            int retries)
+    // Log the outgoing request
+    iora::core::Logger::info("HttpClient: " + method + " " + url +
+                             " (body size: " + std::to_string(body.size()) + " bytes)");
+
+    int attempt = 0;
+    while (true)
     {
+      try
       {
-        std::lock_guard<std::mutex> lock(_mutex);
-        ensureInitialized();
-      }
+        auto response = executeRequest(method, url, body, headers);
 
-      // Log the outgoing request
-      iora::core::Logger::info("HttpClient: " + method + " " + url +
-                               " (body size: " + std::to_string(body.size()) +
-                               " bytes)");
+        // Log the response
+        iora::core::Logger::info(
+          "HttpClient: Received " + std::to_string(response.statusCode) + " response from " + url +
+          " (body size: " + std::to_string(response.body.size()) + " bytes)");
 
-      int attempt = 0;
-      while (true)
+        return response;
+      }
+      catch (const std::exception &e)
       {
-        try
+        if (attempt >= retries)
         {
-          auto response = executeRequest(method, url, body, headers);
-
-          // Log the response
-          iora::core::Logger::info(
-              "HttpClient: Received " + std::to_string(response.statusCode) +
-              " response from " + url + " (body size: " +
-              std::to_string(response.body.size()) + " bytes)");
-
-          return response;
+          iora::core::Logger::error("HttpClient: Request to " + url + " failed after " +
+                                    std::to_string(attempt + 1) + " attempts: " + e.what());
+          throw;
         }
-        catch (const std::exception& e)
-        {
-          if (attempt >= retries)
-          {
-            iora::core::Logger::error(
-                "HttpClient: Request to " + url + " failed after " +
-                std::to_string(attempt + 1) + " attempts: " + e.what());
-            throw;
-          }
 
-          // Log retry attempt
-          iora::core::Logger::debug("HttpClient: Retrying request to " + url +
-                                    " (attempt " + std::to_string(attempt + 1) +
-                                    "/" + std::to_string(retries + 1) +
-                                    "): " + e.what());
+        // Log retry attempt
+        iora::core::Logger::debug("HttpClient: Retrying request to " + url + " (attempt " +
+                                  std::to_string(attempt + 1) + "/" + std::to_string(retries + 1) +
+                                  "): " + e.what());
 
-          // Exponential backoff with jitter
-          int backoffMs = (1 << attempt) * 100 + (rand() % 100);
-          std::this_thread::sleep_for(std::chrono::milliseconds(backoffMs));
-          attempt++;
-        }
+        // Exponential backoff with jitter
+        int backoffMs = (1 << attempt) * 100 + (rand() % 100);
+        std::this_thread::sleep_for(std::chrono::milliseconds(backoffMs));
+        attempt++;
       }
     }
+  }
 
-    /// \brief Execute single HTTP request
-    Response executeRequest(const std::string& method, const std::string& url,
-                            const std::string& body,
-                            const std::map<std::string, std::string>& headers)
-    {
-      auto parsedUrl = parseUrl(url);
+  /// \brief Execute single HTTP request
+  Response executeRequest(const std::string &method, const std::string &url,
+                          const std::string &body,
+                          const std::map<std::string, std::string> &headers)
+  {
+    auto parsedUrl = parseUrl(url);
 
-      // Use normal timeout - optimization will be handled at transport level
-      std::chrono::milliseconds sendTimeout = _config.requestTimeout;
+    // Use normal timeout - optimization will be handled at transport level
+    std::chrono::milliseconds sendTimeout = _config.requestTimeout;
 
-      auto sessionId = getConnection(parsedUrl);
+    auto sessionId = getConnection(parsedUrl);
 
-      // Set session to sync mode BEFORE sending request so response data gets
-      // buffered correctly
-      if (!_transport->setReadMode(sessionId, ReadMode::Sync))
-      {
-        throw std::runtime_error("Failed to set session to sync read mode");
-      }
+    // Set session to sync mode BEFORE sending request so response data gets
+    // buffered correctly
+    if (!_transport->setReadMode(sessionId, ReadMode::Sync))
+    {
+      throw std::runtime_error("Failed to set session to sync read mode");
+    }
 
-      // Build HTTP request
-      std::ostringstream request;
-      request << method << " " << parsedUrl.getPathWithQuery()
-              << " HTTP/1.1\r\n";
-      request << "Host: " << parsedUrl.host << "\r\n";
-      request << "User-Agent: " << _config.userAgent << "\r\n";
-      request << "Connection: "
-              << (_config.reuseConnections ? "keep-alive" : "close") << "\r\n";
-
-      // Add custom headers
-      for (const auto& [name, value] : headers)
-      {
-        request << name << ": " << value << "\r\n";
-      }
+    // Build HTTP request
+    std::ostringstream request;
+    request << method << " " << parsedUrl.getPathWithQuery() << " HTTP/1.1\r\n";
+    request << "Host: " << parsedUrl.host << "\r\n";
+    request << "User-Agent: " << _config.userAgent << "\r\n";
+    request << "Connection: " << (_config.reuseConnections ? "keep-alive" : "close") << "\r\n";
 
-      // Add body if present
-      if (!body.empty())
-      {
-        request << "Content-Length: " << body.size() << "\r\n";
-      }
+    // Add custom headers
+    for (const auto &[name, value] : headers)
+    {
+      request << name << ": " << value << "\r\n";
+    }
 
-      request << "\r\n";
-      if (!body.empty())
-      {
-        request << body;
-      }
+    // Add body if present
+    if (!body.empty())
+    {
+      request << "Content-Length: " << body.size() << "\r\n";
+    }
 
-      std::string requestStr = request.str();
+    request << "\r\n";
+    if (!body.empty())
+    {
+      request << body;
+    }
 
-      // Send request synchronously
-      auto sendResult = _transport->sendSync(sessionId, requestStr.data(),
-                                             requestStr.size(), sendTimeout);
-      if (!sendResult.ok)
-      {
-        _transport->setReadMode(sessionId, ReadMode::Async);
-        throw std::runtime_error("Failed to send HTTP request: " +
-                                 sendResult.errorMessage);
-      }
+    std::string requestStr = request.str();
 
-      // Receive response synchronously by accumulating data until we have a
-      // complete HTTP response
-      std::string responseData;
-      char buffer[8192];
+    // Send request synchronously
+    auto sendResult =
+      _transport->sendSync(sessionId, requestStr.data(), requestStr.size(), sendTimeout);
+    if (!sendResult.ok)
+    {
+      _transport->setReadMode(sessionId, ReadMode::Async);
+      throw std::runtime_error("Failed to send HTTP request: " + sendResult.errorMessage);
+    }
 
-      try
+    // Receive response synchronously by accumulating data until we have a
+    // complete HTTP response
+    std::string responseData;
+    char buffer[8192];
+
+    try
+    {
+      while (true)
       {
-        while (true)
-        {
-          std::size_t len = sizeof(buffer);
+        std::size_t len = sizeof(buffer);
 
-          auto recvResult =
-              _transport->receiveSync(sessionId, buffer, len, sendTimeout);
+        auto recvResult = _transport->receiveSync(sessionId, buffer, len, sendTimeout);
 
-          if (recvResult.ok && len > 0)
-          {
-            responseData.append(buffer, len);
+        if (recvResult.ok && len > 0)
+        {
+          responseData.append(buffer, len);
 
-            // Check if we have complete HTTP response
-            if (isCompleteHttpResponse(responseData))
-            {
-              break;
-            }
-          }
-          else if (!recvResult.ok &&
-                   recvResult.error == TransportError::Timeout)
+          // Check if we have complete HTTP response
+          if (isCompleteHttpResponse(responseData))
           {
-            throw std::runtime_error("HTTP response timeout");
+            break;
           }
-          else if (!recvResult.ok)
-          {
-            throw std::runtime_error(
-                "Connection closed before receiving complete HTTP response");
-          }
-          // If len == 0, the receiveSync will have waited for the timeout
-          // already, so continue
         }
-
-        // Reset read mode back to async for connection reuse
-        _transport->setReadMode(sessionId, ReadMode::Async);
-        return parseHttpResponse(responseData);
-      }
-      catch (...)
-      {
-        // Reset read mode on any exception
-        _transport->setReadMode(sessionId, ReadMode::Async);
-        throw;
+        else if (!recvResult.ok && recvResult.error == TransportError::Timeout)
+        {
+          throw std::runtime_error("HTTP response timeout");
+        }
+        else if (!recvResult.ok)
+        {
+          throw std::runtime_error("Connection closed before receiving complete HTTP response");
+        }
+        // If len == 0, the receiveSync will have waited for the timeout
+        // already, so continue
       }
-    }
 
-    /// \brief Check if we have a complete HTTP response
-    bool isCompleteHttpResponse(const std::string& data) const
+      // Reset read mode back to async for connection reuse
+      _transport->setReadMode(sessionId, ReadMode::Async);
+      return parseHttpResponse(responseData);
+    }
+    catch (...)
     {
-      // Look for end of headers
-      auto headerEnd = data.find("\r\n\r\n");
-      if (headerEnd == std::string::npos)
-      {
-        return false; // Headers not complete
-      }
+      // Reset read mode on any exception
+      _transport->setReadMode(sessionId, ReadMode::Async);
+      throw;
+    }
+  }
 
-      // Parse headers to check for Content-Length or Transfer-Encoding
-      std::string headers = data.substr(0, headerEnd);
-      std::string body = data.substr(headerEnd + 4);
+  /// \brief Check if we have a complete HTTP response
+  bool isCompleteHttpResponse(const std::string &data) const
+  {
+    // Look for end of headers
+    auto headerEnd = data.find("\r\n\r\n");
+    if (headerEnd == std::string::npos)
+    {
+      return false; // Headers not complete
+    }
 
-      // Look for Content-Length
-      std::regex contentLengthRegex(R"(Content-Length:\s*(\d+))",
-                                    std::regex_constants::icase);
-      std::smatch match;
-      if (std::regex_search(headers, match, contentLengthRegex))
-      {
-        std::size_t contentLength = std::stoul(match[1].str());
-        return body.size() >= contentLength;
-      }
+    // Parse headers to check for Content-Length or Transfer-Encoding
+    std::string headers = data.substr(0, headerEnd);
+    std::string body = data.substr(headerEnd + 4);
 
-      // Look for Transfer-Encoding: chunked
-      std::regex chunkedRegex(R"(Transfer-Encoding:\s*chunked)",
-                              std::regex_constants::icase);
-      if (std::regex_search(headers, chunkedRegex))
-      {
-        // Simple chunked detection - look for final chunk (0\r\n\r\n)
-        return data.find("0\r\n\r\n") != std::string::npos;
-      }
+    // Look for Content-Length
+    std::regex contentLengthRegex(R"(Content-Length:\s*(\d+))", std::regex_constants::icase);
+    std::smatch match;
+    if (std::regex_search(headers, match, contentLengthRegex))
+    {
+      std::size_t contentLength = std::stoul(match[1].str());
+      return body.size() >= contentLength;
+    }
 
-      // No content length specified, assume complete (HTTP/1.0 style)
-      return true;
+    // Look for Transfer-Encoding: chunked
+    std::regex chunkedRegex(R"(Transfer-Encoding:\s*chunked)", std::regex_constants::icase);
+    if (std::regex_search(headers, chunkedRegex))
+    {
+      // Simple chunked detection - look for final chunk (0\r\n\r\n)
+      return data.find("0\r\n\r\n") != std::string::npos;
     }
 
-    /// \brief Parse HTTP response from raw data
-    Response parseHttpResponse(const std::string& data) const
+    // No content length specified, assume complete (HTTP/1.0 style)
+    return true;
+  }
+
+  /// \brief Parse HTTP response from raw data
+  Response parseHttpResponse(const std::string &data) const
+  {
+    Response response;
+
+    // Find end of headers
+    auto headerEnd = data.find("\r\n\r\n");
+    if (headerEnd == std::string::npos)
     {
-      Response response;
+      throw std::runtime_error("Invalid HTTP response: no header separator found");
+    }
 
-      // Find end of headers
-      auto headerEnd = data.find("\r\n\r\n");
-      if (headerEnd == std::string::npos)
-      {
-        throw std::runtime_error(
-            "Invalid HTTP response: no header separator found");
-      }
+    std::string headerSection = data.substr(0, headerEnd);
+    std::string bodySection = data.substr(headerEnd + 4);
 
-      std::string headerSection = data.substr(0, headerEnd);
-      std::string bodySection = data.substr(headerEnd + 4);
+    // Parse status line
+    std::istringstream headerStream(headerSection);
+    std::string statusLine;
+    std::getline(headerStream, statusLine);
 
-      // Parse status line
-      std::istringstream headerStream(headerSection);
-      std::string statusLine;
-      std::getline(headerStream, statusLine);
+    // Remove trailing \r if present
+    if (!statusLine.empty() && statusLine.back() == '\r')
+    {
+      statusLine.pop_back();
+    }
 
-      // Remove trailing \r if present
-      if (!statusLine.empty() && statusLine.back() == '\r')
-      {
-        statusLine.pop_back();
-      }
+    // Parse status code and text
+    std::regex statusRegex(R"(HTTP/\d\.\d\s+(\d+)\s*(.*))");
+    std::smatch statusMatch;
+    if (std::regex_match(statusLine, statusMatch, statusRegex))
+    {
+      response.statusCode = std::stoi(statusMatch[1].str());
+      response.statusText = statusMatch[2].str();
+    }
+    else
+    {
+      throw std::runtime_error("Invalid HTTP status line: " + statusLine);
+    }
 
-      // Parse status code and text
-      std::regex statusRegex(R"(HTTP/\d\.\d\s+(\d+)\s*(.*))");
-      std::smatch statusMatch;
-      if (std::regex_match(statusLine, statusMatch, statusRegex))
-      {
-        response.statusCode = std::stoi(statusMatch[1].str());
-        response.statusText = statusMatch[2].str();
-      }
-      else
+    // Parse headers
+    std::string headerLine;
+    while (std::getline(headerStream, headerLine))
+    {
+      if (!headerLine.empty() && headerLine.back() == '\r')
       {
-        throw std::runtime_error("Invalid HTTP status line: " + statusLine);
+        headerLine.pop_back();
       }
 
-      // Parse headers
-      std::string headerLine;
-      while (std::getline(headerStream, headerLine))
+      auto colonPos = headerLine.find(':');
+      if (colonPos != std::string::npos)
       {
-        if (!headerLine.empty() && headerLine.back() == '\r')
-        {
-          headerLine.pop_back();
-        }
-
-        auto colonPos = headerLine.find(':');
-        if (colonPos != std::string::npos)
-        {
-          std::string name = headerLine.substr(0, colonPos);
-          std::string value = headerLine.substr(colonPos + 1);
+        std::string name = headerLine.substr(0, colonPos);
+        std::string value = headerLine.substr(colonPos + 1);
 
-          // Trim whitespace
-          name.erase(0, name.find_first_not_of(" \t"));
-          name.erase(name.find_last_not_of(" \t") + 1);
-          value.erase(0, value.find_first_not_of(" \t"));
-          value.erase(value.find_last_not_of(" \t") + 1);
+        // Trim whitespace
+        name.erase(0, name.find_first_not_of(" \t"));
+        name.erase(name.find_last_not_of(" \t") + 1);
+        value.erase(0, value.find_first_not_of(" \t"));
+        value.erase(value.find_last_not_of(" \t") + 1);
 
-          response.headers[name] = value;
-        }
+        response.headers[name] = value;
       }
+    }
 
-      // Handle body based on Content-Length or Transfer-Encoding
-      auto contentLengthIt = response.headers.find("Content-Length");
-      if (contentLengthIt != response.headers.end())
+    // Handle body based on Content-Length or Transfer-Encoding
+    auto contentLengthIt = response.headers.find("Content-Length");
+    if (contentLengthIt != response.headers.end())
+    {
+      std::size_t contentLength = std::stoul(contentLengthIt->second);
+      response.body = bodySection.substr(0, contentLength);
+    }
+    else
+    {
+      auto transferEncodingIt = response.headers.find("Transfer-Encoding");
+      if (transferEncodingIt != response.headers.end() &&
+          transferEncodingIt->second.find("chunked") != std::string::npos)
       {
-        std::size_t contentLength = std::stoul(contentLengthIt->second);
-        response.body = bodySection.substr(0, contentLength);
+        response.body = decodeChunkedBody(bodySection);
       }
       else
       {
-        auto transferEncodingIt = response.headers.find("Transfer-Encoding");
-        if (transferEncodingIt != response.headers.end() &&
-            transferEncodingIt->second.find("chunked") != std::string::npos)
-        {
-          response.body = decodeChunkedBody(bodySection);
-        }
-        else
-        {
-          response.body = bodySection;
-        }
+        response.body = bodySection;
       }
-
-      return response;
     }
 
-    /// \brief Decode chunked transfer encoding
-    std::string decodeChunkedBody(const std::string& chunkedData) const
-    {
-      std::string result;
-      std::istringstream stream(chunkedData);
-      std::string line;
-
-      while (std::getline(stream, line))
-      {
-        // Remove \r if present
-        if (!line.empty() && line.back() == '\r')
-        {
-          line.pop_back();
-        }
+    return response;
+  }
 
-        // Parse chunk size (hex)
-        std::size_t chunkSize = std::stoul(line, nullptr, 16);
-        if (chunkSize == 0)
-        {
-          break; // End of chunks
-        }
+  /// \brief Decode chunked transfer encoding
+  std::string decodeChunkedBody(const std::string &chunkedData) const
+  {
+    std::string result;
+    std::istringstream stream(chunkedData);
+    std::string line;
 
-        // Read chunk data
-        std::string chunkData(chunkSize, '\0');
-        stream.read(&chunkData[0], chunkSize);
-        result += chunkData;
+    while (std::getline(stream, line))
+    {
+      // Remove \r if present
+      if (!line.empty() && line.back() == '\r')
+      {
+        line.pop_back();
+      }
 
-        // Skip trailing CRLF
-        std::getline(stream, line);
+      // Parse chunk size (hex)
+      std::size_t chunkSize = std::stoul(line, nullptr, 16);
+      if (chunkSize == 0)
+      {
+        break; // End of chunks
       }
 
-      return result;
+      // Read chunk data
+      std::string chunkData(chunkSize, '\0');
+      stream.read(&chunkData[0], chunkSize);
+      result += chunkData;
+
+      // Skip trailing CRLF
+      std::getline(stream, line);
     }
-  };
+
+    return result;
+  }
+};
 
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/object_pool.hpp b/include/iora/network/object_pool.hpp
index ebcf5c9..11658a1 100644
--- a/include/iora/network/object_pool.hpp
+++ b/include/iora/network/object_pool.hpp
@@ -7,200 +7,194 @@
 
 #pragma once
 
+#include <atomic>
+#include <functional>
 #include <memory>
 #include <mutex>
 #include <vector>
-#include <functional>
-#include <atomic>
 
 namespace iora
 {
 namespace network
 {
 
-  template <typename T> class ObjectPool
-  {
-  public:
-    using Factory = std::function<std::unique_ptr<T>()>;
-    using Resetter = std::function<void(T*)>;
+template <typename T> class ObjectPool
+{
+public:
+  using Factory = std::function<std::unique_ptr<T>()>;
+  using Resetter = std::function<void(T *)>;
 
-    explicit ObjectPool(Factory factory, Resetter resetter = nullptr,
-                        std::size_t initialSize = 0)
+  explicit ObjectPool(Factory factory, Resetter resetter = nullptr, std::size_t initialSize = 0)
       : factory_(std::move(factory)), resetter_(std::move(resetter))
+  {
+    // Pre-populate pool
+    for (std::size_t i = 0; i < initialSize; ++i)
     {
-      // Pre-populate pool
-      for (std::size_t i = 0; i < initialSize; ++i)
+      if (auto obj = factory_())
       {
-        if (auto obj = factory_())
-        {
-          available_.push_back(std::move(obj));
-          created_.fetch_add(1, std::memory_order_relaxed);
-        }
+        available_.push_back(std::move(obj));
+        created_.fetch_add(1, std::memory_order_relaxed);
       }
     }
+  }
 
-    // Acquire an object from the pool
-    std::unique_ptr<T> acquire()
-    {
-      std::lock_guard<std::mutex> lock(mutex_);
-
-      if (!available_.empty())
-      {
-        auto obj = std::move(available_.back());
-        available_.pop_back();
-        acquired_.fetch_add(1, std::memory_order_relaxed);
-        return obj;
-      }
-
-      // Pool empty, create new object
-      created_.fetch_add(1, std::memory_order_relaxed);
-      return factory_();
-    }
+  // Acquire an object from the pool
+  std::unique_ptr<T> acquire()
+  {
+    std::lock_guard<std::mutex> lock(mutex_);
 
-    // Return an object to the pool
-    void release(std::unique_ptr<T> obj)
+    if (!available_.empty())
     {
-      if (!obj)
-        return;
-
-      // Reset object state if resetter provided
-      if (resetter_)
-      {
-        resetter_(obj.get());
-      }
+      auto obj = std::move(available_.back());
+      available_.pop_back();
+      acquired_.fetch_add(1, std::memory_order_relaxed);
+      return obj;
+    }
 
-      std::lock_guard<std::mutex> lock(mutex_);
+    // Pool empty, create new object
+    created_.fetch_add(1, std::memory_order_relaxed);
+    return factory_();
+  }
 
-      // Limit pool size to prevent unbounded growth
-      if (available_.size() < maxPoolSize_)
-      {
-        available_.push_back(std::move(obj));
-        released_.fetch_add(1, std::memory_order_relaxed);
-      }
-      else
-      {
-        // Let object be destroyed
-        destroyed_.fetch_add(1, std::memory_order_relaxed);
-      }
-    }
+  // Return an object to the pool
+  void release(std::unique_ptr<T> obj)
+  {
+    if (!obj)
+      return;
 
-    // Pool statistics
-    struct Stats
+    // Reset object state if resetter provided
+    if (resetter_)
     {
-      std::size_t available;
-      std::size_t totalCreated;
-      std::size_t totalAcquired;
-      std::size_t totalReleased;
-      std::size_t totalDestroyed;
-    };
-
-    Stats getStats() const
-    {
-      std::lock_guard<std::mutex> lock(mutex_);
-      return {available_.size(), created_.load(std::memory_order_relaxed),
-              acquired_.load(std::memory_order_relaxed),
-              released_.load(std::memory_order_relaxed),
-              destroyed_.load(std::memory_order_relaxed)};
+      resetter_(obj.get());
     }
 
-    void setMaxPoolSize(std::size_t size)
+    std::lock_guard<std::mutex> lock(mutex_);
+
+    // Limit pool size to prevent unbounded growth
+    if (available_.size() < maxPoolSize_)
     {
-      std::lock_guard<std::mutex> lock(mutex_);
-      maxPoolSize_ = size;
-      
-      // Trim existing pool if it exceeds the new max size
-      while (available_.size() > maxPoolSize_)
-      {
-        available_.pop_back();
-        destroyed_.fetch_add(1, std::memory_order_relaxed);
-      }
+      available_.push_back(std::move(obj));
+      released_.fetch_add(1, std::memory_order_relaxed);
     }
-
-    void clear()
+    else
     {
-      std::lock_guard<std::mutex> lock(mutex_);
-      available_.clear();
+      // Let object be destroyed
+      destroyed_.fetch_add(1, std::memory_order_relaxed);
     }
+  }
 
-  private:
-    Factory factory_;
-    Resetter resetter_;
-    mutable std::mutex mutex_;
-    std::vector<std::unique_ptr<T>> available_;
-    std::size_t maxPoolSize_{100}; // Prevent unbounded growth
-
-    // Statistics
-    std::atomic<std::size_t> created_{0};
-    std::atomic<std::size_t> acquired_{0};
-    std::atomic<std::size_t> released_{0};
-    std::atomic<std::size_t> destroyed_{0};
+  // Pool statistics
+  struct Stats
+  {
+    std::size_t available;
+    std::size_t totalCreated;
+    std::size_t totalAcquired;
+    std::size_t totalReleased;
+    std::size_t totalDestroyed;
   };
 
-  // RAII wrapper for automatic return to pool
-  template <typename T> class PooledObject
+  Stats getStats() const
   {
-  public:
-    PooledObject(std::unique_ptr<T> obj, ObjectPool<T>* pool)
-      : obj_(std::move(obj)), pool_(pool)
-    {
-    }
+    std::lock_guard<std::mutex> lock(mutex_);
+    return {available_.size(), created_.load(std::memory_order_relaxed),
+            acquired_.load(std::memory_order_relaxed), released_.load(std::memory_order_relaxed),
+            destroyed_.load(std::memory_order_relaxed)};
+  }
 
-    ~PooledObject()
+  void setMaxPoolSize(std::size_t size)
+  {
+    std::lock_guard<std::mutex> lock(mutex_);
+    maxPoolSize_ = size;
+
+    // Trim existing pool if it exceeds the new max size
+    while (available_.size() > maxPoolSize_)
     {
-      if (obj_ && pool_)
-      {
-        pool_->release(std::move(obj_));
-      }
+      available_.pop_back();
+      destroyed_.fetch_add(1, std::memory_order_relaxed);
     }
+  }
+
+  void clear()
+  {
+    std::lock_guard<std::mutex> lock(mutex_);
+    available_.clear();
+  }
 
-    // Move-only semantics
-    PooledObject(const PooledObject&) = delete;
-    PooledObject& operator=(const PooledObject&) = delete;
+private:
+  Factory factory_;
+  Resetter resetter_;
+  mutable std::mutex mutex_;
+  std::vector<std::unique_ptr<T>> available_;
+  std::size_t maxPoolSize_{100}; // Prevent unbounded growth
+
+  // Statistics
+  std::atomic<std::size_t> created_{0};
+  std::atomic<std::size_t> acquired_{0};
+  std::atomic<std::size_t> released_{0};
+  std::atomic<std::size_t> destroyed_{0};
+};
+
+// RAII wrapper for automatic return to pool
+template <typename T> class PooledObject
+{
+public:
+  PooledObject(std::unique_ptr<T> obj, ObjectPool<T> *pool) : obj_(std::move(obj)), pool_(pool) {}
 
-    PooledObject(PooledObject&& other) noexcept
-      : obj_(std::move(other.obj_)), pool_(other.pool_)
+  ~PooledObject()
+  {
+    if (obj_ && pool_)
     {
-      other.pool_ = nullptr;
+      pool_->release(std::move(obj_));
     }
+  }
+
+  // Move-only semantics
+  PooledObject(const PooledObject &) = delete;
+  PooledObject &operator=(const PooledObject &) = delete;
+
+  PooledObject(PooledObject &&other) noexcept : obj_(std::move(other.obj_)), pool_(other.pool_)
+  {
+    other.pool_ = nullptr;
+  }
 
-    PooledObject& operator=(PooledObject&& other) noexcept
+  PooledObject &operator=(PooledObject &&other) noexcept
+  {
+    if (this != &other)
     {
-      if (this != &other)
+      // Return current object to pool
+      if (obj_ && pool_)
       {
-        // Return current object to pool
-        if (obj_ && pool_)
-        {
-          pool_->release(std::move(obj_));
-        }
-
-        obj_ = std::move(other.obj_);
-        pool_ = other.pool_;
-        other.pool_ = nullptr;
+        pool_->release(std::move(obj_));
       }
-      return *this;
-    }
 
-    T* get() const { return obj_.get(); }
-    T& operator*() const { return *obj_; }
-    T* operator->() const { return obj_.get(); }
-    explicit operator bool() const { return static_cast<bool>(obj_); }
-
-    // Release ownership without returning to pool
-    std::unique_ptr<T> release()
-    {
-      pool_ = nullptr;
-      return std::move(obj_);
+      obj_ = std::move(other.obj_);
+      pool_ = other.pool_;
+      other.pool_ = nullptr;
     }
+    return *this;
+  }
 
-  private:
-    std::unique_ptr<T> obj_;
-    ObjectPool<T>* pool_;
-  };
+  T *get() const { return obj_.get(); }
+  T &operator*() const { return *obj_; }
+  T *operator->() const { return obj_.get(); }
+  explicit operator bool() const { return static_cast<bool>(obj_); }
 
-  template <typename T> PooledObject<T> makePooled(ObjectPool<T>& pool)
+  // Release ownership without returning to pool
+  std::unique_ptr<T> release()
   {
-    return PooledObject<T>(pool.acquire(), &pool);
+    pool_ = nullptr;
+    return std::move(obj_);
   }
 
+private:
+  std::unique_ptr<T> obj_;
+  ObjectPool<T> *pool_;
+};
+
+template <typename T> PooledObject<T> makePooled(ObjectPool<T> &pool)
+{
+  return PooledObject<T>(pool.acquire(), &pool);
+}
+
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/shared_transport.hpp b/include/iora/network/shared_transport.hpp
old mode 100755
new mode 100644
index 269a76a..b5306ad
--- a/include/iora/network/shared_transport.hpp
+++ b/include/iora/network/shared_transport.hpp
@@ -50,2058 +50,1982 @@
 #include <sys/timerfd.h>
 #include <unistd.h>
 
-#include <openssl/ssl.h>
-#include <openssl/err.h>
-#include "transport_types.hpp"
 #include "iora/core/logger.hpp"
 #include "iora/core/timer.hpp"
+#include "transport_types.hpp"
+#include "sync_async_transport.hpp"
+#include <openssl/err.h>
+#include <openssl/ssl.h>
 
 namespace iora
 {
 namespace network
 {
 
-  // Forward declaration - BasicTransportStats is defined in
-  // sync_async_transport.hpp
-  struct BasicTransportStats;
-
-  /// \brief Shared TCP/TLS transport (single-threaded epoll loop).
-  /// \note Linux-only.
-  class SharedTransport
-  {
-  public:
-    /// \brief Runtime configuration.
-    struct Config
-    {
-      int epollMaxEvents{256};
-      std::size_t ioReadChunk{64 * 1024};
-      std::size_t maxWriteQueue{1024};
-      bool closeOnBackpressure{true};
-
-      std::chrono::seconds idleTimeout{600};
-      std::chrono::seconds maxConnAge{std::chrono::seconds::zero()};
-      // High-resolution timers (milliseconds precision)
-      std::chrono::milliseconds handshakeTimeout{30000};
-      std::chrono::milliseconds connectTimeout{30000};
-      std::chrono::milliseconds writeStallTimeout{0};
-      std::chrono::seconds gcInterval{5}; // Keep for legacy cleanup
-      bool enableHighResolutionTimers{true}; // Enable TimerService integration
-
-      bool useEdgeTriggered{true};
-      bool enableTcpNoDelay{true};
-      int soRcvBuf{0};
-      int soSndBuf{0};
-
-      struct TcpKeepalive
-      {
-        bool enable{false};
-        int idleSec{60};
-        int intvlSec{10};
-        int cnt{3};
-      } tcpKeepalive;
-    };
-
-    /// \brief TLS configuration (OpenSSL).
-    struct TlsConfig
-    {
-      bool enabled{false};
-      TlsMode defaultMode{TlsMode::None};
-      std::string certFile;
-      std::string keyFile;
-      std::string caFile;
-      std::string ciphers;
-      std::string alpn; ///< semicolon-separated, e.g. "h2;http/1.1"
-      bool verifyPeer{false};
-    };
-
-    /// \brief Callback bundle (all optional).
-    struct Callbacks
-    {
-      std::function<void(SessionId, const std::string&, const IoResult&)>
-          onAccept;
-      std::function<void(SessionId, const IoResult&)> onConnect;
-      std::function<void(SessionId, const std::uint8_t*, std::size_t,
-                         const IoResult&)>
-          onData;
-      std::function<void(SessionId, const IoResult&)> onClosed;
-      std::function<void(TransportError, const std::string&)> onError;
-    };
-
-    /// \brief Basic counters (monotonic).
-    struct Stats
-    {
-      std::uint64_t accepted{0}, connected{0}, closed{0}, errors{0},
-          tlsHandshakes{0}, tlsFailures{0}, bytesIn{0}, bytesOut{0},
-          epollWakeups{0}, commands{0}, gcRuns{0}, gcClosedIdle{0},
-          gcClosedAged{0}, backpressureCloses{0};
-      std::size_t sessionsCurrent{0}, sessionsPeak{0};
-    };
-
-    /// \brief Construct with config and TLS contexts.
-    SharedTransport(const Config& cfg, const TlsConfig& srv,
-                    const TlsConfig& cli)
-      : _cfg(cfg), _srvTls(srv), _cliTls(cli)
-    {
-      // Ensure OpenSSL is initialized once per process
-      std::call_once(_sslGlobalInitFlag, initSslGlobal);
-      
-      // Initialize high-resolution timer service if enabled
-      if (_cfg.enableHighResolutionTimers)
-      {
-        _timerConfig.limits.maxConcurrentTimers = 10000;
-        _timerConfig.enableStatistics = true;
-        _timerConfig.threadName = "SharedTransportTimer";
-        _timerService = std::make_unique<iora::core::TimerService>(_timerConfig);
-      }
-    }
-
-    /// \brief Destructor; calls stop() if needed.
-    ~SharedTransport() { stop(); }
-
-    SharedTransport(const SharedTransport&) = delete;
-    SharedTransport& operator=(const SharedTransport&) = delete;
+/// \brief Shared TCP/TLS transport (single-threaded epoll loop).
+/// \note Linux-only.
+class SharedTransport
+{
+public:
+  /// \brief Runtime configuration.
+  struct Config
+  {
+    int epollMaxEvents{256};
+    std::size_t ioReadChunk{64 * 1024};
+    std::size_t maxWriteQueue{1024};
+    bool closeOnBackpressure{true};
+
+    std::chrono::seconds idleTimeout{600};
+    std::chrono::seconds maxConnAge{std::chrono::seconds::zero()};
+    // High-resolution timers (milliseconds precision)
+    std::chrono::milliseconds handshakeTimeout{30000};
+    std::chrono::milliseconds connectTimeout{30000};
+    std::chrono::milliseconds writeStallTimeout{0};
+    std::chrono::seconds gcInterval{5};    // Keep for legacy cleanup
+    bool enableHighResolutionTimers{true}; // Enable TimerService integration
+
+    bool useEdgeTriggered{true};
+    bool enableTcpNoDelay{true};
+    int soRcvBuf{0};
+    int soSndBuf{0};
+
+    struct TcpKeepalive
+    {
+      bool enable{false};
+      int idleSec{60};
+      int intvlSec{10};
+      int cnt{3};
+    } tcpKeepalive;
+  };
 
-    /// \brief Install callbacks (may be called before or after start()).
-    void setCallbacks(const Callbacks& cbs)
-    {
-      std::lock_guard<std::mutex> g(_cbMutex);
-      _cbs = cbs;
-    }
+  /// \brief TLS configuration (OpenSSL).
+  struct TlsConfig
+  {
+    bool enabled{false};
+    TlsMode defaultMode{TlsMode::None};
+    std::string certFile;
+    std::string keyFile;
+    std::string caFile;
+    std::string ciphers;
+    std::string alpn; ///< semicolon-separated, e.g. "h2;http/1.1"
+    bool verifyPeer{false};
+  };
 
-    // ITransportBase interface implementation - individual callback setters
-    // These methods preserve existing callbacks and only update the specific
-    // one
-    void setDataCallback(std::function<void(SessionId, const std::uint8_t*,
-                                            std::size_t, const IoResult&)>
-                             cb)
-    {
-      std::lock_guard<std::mutex> g(_cbMutex);
-      _cbs.onData = cb;
-    }
+  /// \brief Callback bundle (all optional).
+  struct Callbacks
+  {
+    std::function<void(SessionId, const std::string &, const IoResult &)> onAccept;
+    std::function<void(SessionId, const IoResult &)> onConnect;
+    std::function<void(SessionId, const std::uint8_t *, std::size_t, const IoResult &)> onData;
+    std::function<void(SessionId, const IoResult &)> onClosed;
+    std::function<void(TransportError, const std::string &)> onError;
+  };
 
-    void setAcceptCallback(
-        std::function<void(SessionId, const std::string&, const IoResult&)> cb)
-    {
-      std::lock_guard<std::mutex> g(_cbMutex);
-      _cbs.onAccept = cb;
-    }
+  /// \brief Basic counters (monotonic).
+  struct Stats
+  {
+    std::uint64_t accepted{0}, connected{0}, closed{0}, errors{0}, tlsHandshakes{0}, tlsFailures{0},
+      bytesIn{0}, bytesOut{0}, epollWakeups{0}, commands{0}, gcRuns{0}, gcClosedIdle{0},
+      gcClosedAged{0}, backpressureCloses{0};
+    std::size_t sessionsCurrent{0}, sessionsPeak{0};
+  };
 
-    void setConnectCallback(std::function<void(SessionId, const IoResult&)> cb)
-    {
-      std::lock_guard<std::mutex> g(_cbMutex);
-      _cbs.onConnect = cb;
-    }
+  /// \brief Construct with config and TLS contexts.
+  SharedTransport(const Config &cfg, const TlsConfig &srv, const TlsConfig &cli)
+      : _cfg(cfg), _srvTls(srv), _cliTls(cli)
+  {
+    // Ensure OpenSSL is initialized once per process
+    std::call_once(_sslGlobalInitFlag, initSslGlobal);
 
-    void setCloseCallback(std::function<void(SessionId, const IoResult&)> cb)
+    // Initialize high-resolution timer service if enabled
+    if (_cfg.enableHighResolutionTimers)
     {
-      std::lock_guard<std::mutex> g(_cbMutex);
-      _cbs.onClosed = cb;
+      _timerConfig.limits.maxConcurrentTimers = 10000;
+      _timerConfig.enableStatistics = true;
+      _timerConfig.threadName = "SharedTransportTimer";
+      _timerService = std::make_unique<iora::core::TimerService>(_timerConfig);
     }
+  }
 
-    void
-    setErrorCallback(std::function<void(TransportError, const std::string&)> cb)
-    {
-      std::lock_guard<std::mutex> g(_cbMutex);
-      _cbs.onError = cb;
-    }
+  /// \brief Destructor; calls stop() if needed.
+  ~SharedTransport() { stop(); }
 
-    /// \brief Start I/O thread and initialize TLS contexts.
-    /// \return true on success; false on failure (inspect lastFatalError()).
-    bool start()
-    {
-      bool exp = false;
-      if (!_running.compare_exchange_strong(exp, true))
-      {
-        return false;
-      }
+  SharedTransport(const SharedTransport &) = delete;
+  SharedTransport &operator=(const SharedTransport &) = delete;
 
-      if (!initTls())
-      {
-        _running.store(false);
-        return false;
-      }
+  /// \brief Install callbacks (may be called before or after start()).
+  void setCallbacks(const Callbacks &cbs)
+  {
+    std::lock_guard<std::mutex> g(_cbMutex);
+    _cbs = cbs;
+  }
 
-      _epollFd = ::epoll_create1(EPOLL_CLOEXEC);
-      if (_epollFd < 0)
-      {
-        setLastFatal(IoResult::failure(TransportError::Config,
-                                       "epoll_create1: " + lastErr(), errno));
-        err(TransportError::Config, "epoll_create1: " + lastErr());
-        _running.store(false);
-        freeTls();
-        return false;
-      }
+  // ITransportBase interface implementation - individual callback setters
+  // These methods preserve existing callbacks and only update the specific
+  // one
+  void setDataCallback(
+    std::function<void(SessionId, const std::uint8_t *, std::size_t, const IoResult &)> cb)
+  {
+    std::lock_guard<std::mutex> g(_cbMutex);
+    _cbs.onData = cb;
+  }
 
-      _eventFd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
-      if (_eventFd < 0)
-      {
-        setLastFatal(IoResult::failure(TransportError::Config,
-                                       "eventfd: " + lastErr(), errno));
-        err(TransportError::Config, "eventfd: " + lastErr());
-        cleanupStartFail();
-        return false;
-      }
-      addEpoll(_eventFd, EPOLLIN);
+  void setAcceptCallback(std::function<void(SessionId, const std::string &, const IoResult &)> cb)
+  {
+    std::lock_guard<std::mutex> g(_cbMutex);
+    _cbs.onAccept = cb;
+  }
 
-      _timerFd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
-      if (_timerFd < 0)
-      {
-        setLastFatal(IoResult::failure(TransportError::Config,
-                                       "timerfd_create: " + lastErr(), errno));
-        err(TransportError::Config, "timerfd_create: " + lastErr());
-        cleanupStartFail();
-        return false;
-      }
-      addEpoll(_timerFd, EPOLLIN);
-      armGc(_cfg.gcInterval);
+  void setConnectCallback(std::function<void(SessionId, const IoResult &)> cb)
+  {
+    std::lock_guard<std::mutex> g(_cbMutex);
+    _cbs.onConnect = cb;
+  }
 
-      try
-      {
-        _loop = std::thread([this] { loop(); });
-      }
-      catch (const std::exception& ex)
-      {
-        setLastFatal(IoResult::failure(
-            TransportError::Config, std::string("thread start: ") + ex.what()));
-        cleanupStartFail();
-        return false;
-      }
+  void setCloseCallback(std::function<void(SessionId, const IoResult &)> cb)
+  {
+    std::lock_guard<std::mutex> g(_cbMutex);
+    _cbs.onClosed = cb;
+  }
 
-      return true;
-    }
+  void setErrorCallback(std::function<void(TransportError, const std::string &)> cb)
+  {
+    std::lock_guard<std::mutex> g(_cbMutex);
+    _cbs.onError = cb;
+  }
 
-    /// \brief Stop I/O thread and release resources.
-    void stop()
+  /// \brief Start I/O thread and initialize TLS contexts.
+  /// \return true on success; false on failure (inspect lastFatalError()).
+  bool start()
+  {
+    bool exp = false;
+    if (!_running.compare_exchange_strong(exp, true))
     {
-      bool exp = true;
-      if (!_running.compare_exchange_strong(exp, false))
-      {
-        return;
-      }
-      enqueue(Command::shutdown());
-      if (_loop.joinable())
-      {
-        _loop.join();
-      }
+      return false;
     }
 
-    /// \brief Add a listening socket (IPv4/IPv6), optionally with TLS for
-    /// server.
-    ListenerId addListener(const std::string& bind, std::uint16_t port,
-                           TlsMode tls)
+    if (!initTls())
     {
-      ListenerCfg lc;
-      lc.id = _nextListenerId++;
-      lc.addr = bind;
-      lc.port = port;
-      lc.tls = tls;
-      enqueue(Command::addListener(lc));
-      return lc.id;
+      _running.store(false);
+      return false;
     }
 
-    /// \brief Begin an outbound connection (async); result via onConnect.
-    SessionId connect(const std::string& host, std::uint16_t port, TlsMode tls)
+    _epollFd = ::epoll_create1(EPOLL_CLOEXEC);
+    if (_epollFd < 0)
     {
-      SessionId sid = _nextSessionId++;
-      ConnectReq cr{sid, host, port, tls};
-      enqueue(Command::connect(cr));
-      return sid;
+      setLastFatal(IoResult::failure(TransportError::Config, "epoll_create1: " + lastErr(), errno));
+      err(TransportError::Config, "epoll_create1: " + lastErr());
+      _running.store(false);
+      freeTls();
+      return false;
     }
 
-    /// \brief Queue a send on a session (non-blocking; may enqueue on EAGAIN).
-    bool send(SessionId sid, const void* data, std::size_t n)
+    _eventFd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
+    if (_eventFd < 0)
     {
-      if (n == 0)
-      {
-        return true;
-      }
-      ByteBuffer b(n);
-      std::memcpy(b.data(), data, n);
-      SendReq sr;
-      sr.sid = sid;
-      sr.payload = std::move(b);
-      return enqueue(Command::send(std::move(sr)));
-    }
-
-    /// \brief Close a session (idempotent). onClosed will fire.
-    bool close(SessionId sid) { return enqueue(Command::close(sid)); }
-
-    /// \brief Reconfigure runtime knobs; safe while running.
-    void reconfigure(const Config& c) { enqueue(Command::reconf(c)); }
-
-    /// \brief Snapshot of counters.
-    Stats stats() const
-    {
-      Stats copy;
-      copy.accepted = _atomicStats.accepted.load();
-      copy.connected = _atomicStats.connected.load();
-      copy.closed = _atomicStats.closed.load();
-      copy.errors = _atomicStats.errors.load();
-      copy.tlsHandshakes = _atomicStats.tlsHandshakes.load();
-      copy.tlsFailures = _atomicStats.tlsFailures.load();
-      copy.bytesIn = _atomicStats.bytesIn.load();
-      copy.bytesOut = _atomicStats.bytesOut.load();
-      copy.epollWakeups = _atomicStats.epollWakeups.load();
-      copy.commands = _atomicStats.commands.load();
-      copy.gcRuns = _atomicStats.gcRuns.load();
-      copy.gcClosedIdle = _atomicStats.gcClosedIdle.load();
-      copy.gcClosedAged = _atomicStats.gcClosedAged.load();
-      copy.backpressureCloses = _atomicStats.backpressureCloses.load();
-      copy.sessionsCurrent = _atomicStats.sessionsCurrent.load();
-      copy.sessionsPeak = _atomicStats.sessionsPeak.load();
-      return copy;
-    }
-
-    /// \brief Basic stats for ITransportBase compatibility
-    BasicTransportStats getBasicStats() const
-    {
-      BasicTransportStats basic{};
-      basic.accepted = _atomicStats.accepted.load();
-      basic.connected = _atomicStats.connected.load();
-      basic.closed = _atomicStats.closed.load();
-      basic.errors = _atomicStats.errors.load();
-      basic.bytesIn = _atomicStats.bytesIn.load();
-      basic.bytesOut = _atomicStats.bytesOut.load();
-      basic.sessionsCurrent = _atomicStats.sessionsCurrent.load();
-      return basic;
-    }
-
-    /// \brief Sticky last fatal error (since process start). Valid after
-    /// start() failure.
-    IoResult lastFatalError() const
-    {
-      std::lock_guard<std::mutex> g(_fatalMx);
-      return _lastFatal;
-    }
-
-  private:
-    // ===== helpers =====
-
-    static std::string lastErr()
-    {
-      int e = errno;
-      char buf[128];
-#if defined(__GLIBC__) && !defined(__APPLE__)
-      ::strerror_r(e, buf, sizeof(buf));
-      return std::string(buf);
-#else
-      return std::string(std::strerror(e));
-#endif
+      setLastFatal(IoResult::failure(TransportError::Config, "eventfd: " + lastErr(), errno));
+      err(TransportError::Config, "eventfd: " + lastErr());
+      cleanupStartFail();
+      return false;
     }
+    addEpoll(_eventFd, EPOLLIN);
 
-    bool addEpoll(int fd, std::uint32_t ev)
+    _timerFd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
+    if (_timerFd < 0)
     {
-      epoll_event e{};
-      e.events = ev;
-      e.data.fd = fd;
-      return ::epoll_ctl(_epollFd, EPOLL_CTL_ADD, fd, &e) == 0;
+      setLastFatal(
+        IoResult::failure(TransportError::Config, "timerfd_create: " + lastErr(), errno));
+      err(TransportError::Config, "timerfd_create: " + lastErr());
+      cleanupStartFail();
+      return false;
     }
+    addEpoll(_timerFd, EPOLLIN);
+    armGc(_cfg.gcInterval);
 
-    bool modEpoll(int fd, std::uint32_t ev)
+    try
     {
-      epoll_event e{};
-      e.events = ev;
-      e.data.fd = fd;
-      return ::epoll_ctl(_epollFd, EPOLL_CTL_MOD, fd, &e) == 0;
+      _loop = std::thread([this] { loop(); });
     }
-
-    void delEpoll(int fd)
+    catch (const std::exception &ex)
     {
-      ::epoll_ctl(_epollFd, EPOLL_CTL_DEL, fd, nullptr);
+      setLastFatal(
+        IoResult::failure(TransportError::Config, std::string("thread start: ") + ex.what()));
+      cleanupStartFail();
+      return false;
     }
 
-    static std::string keyFromSockaddr(const sockaddr_storage& ss)
+    return true;
+  }
+
+  /// \brief Stop I/O thread and release resources.
+  void stop()
+  {
+    bool exp = true;
+    if (!_running.compare_exchange_strong(exp, false))
     {
-      char h[NI_MAXHOST]{}, s[NI_MAXSERV]{};
-      socklen_t sl = (ss.ss_family == AF_INET) ? sizeof(sockaddr_in)
-                                               : sizeof(sockaddr_in6);
-      if (::getnameinfo(reinterpret_cast<const sockaddr*>(&ss), sl, h,
-                        sizeof(h), s, sizeof(s),
-                        NI_NUMERICHOST | NI_NUMERICSERV) == 0)
-      {
-        std::string out(h);
-        out.push_back(':');
-        out.append(s);
-        return out;
-      }
-      return {};
+      return;
     }
-
-    void armGc(std::chrono::seconds sec)
+    enqueue(Command::shutdown());
+    if (_loop.joinable())
     {
-      itimerspec its{};
-      its.it_interval.tv_sec = sec.count();
-      its.it_value.tv_sec = sec.count();
-      ::timerfd_settime(_timerFd, 0, &its, nullptr);
+      _loop.join();
     }
+  }
 
+  /// \brief Add a listening socket (IPv4/IPv6), optionally with TLS for
+  /// server.
+  ListenerId addListener(const std::string &bind, std::uint16_t port, TlsMode tls)
+  {
+    ListenerCfg lc;
+    lc.id = _nextListenerId++;
+    lc.addr = bind;
+    lc.port = port;
+    lc.tls = tls;
+    enqueue(Command::addListener(lc));
+    return lc.id;
+  }
 
-    void cleanupStartFail()
-    {
-      if (_timerFd >= 0)
-      {
-        ::close(_timerFd);
-        _timerFd = -1;
-      }
-      if (_eventFd >= 0)
-      {
-        ::close(_eventFd);
-        _eventFd = -1;
-      }
-      if (_epollFd >= 0)
-      {
-        ::close(_epollFd);
-        _epollFd = -1;
-      }
-      freeTls();
-      _running.store(false);
-    }
+  /// \brief Begin an outbound connection (async); result via onConnect.
+  SessionId connect(const std::string &host, std::uint16_t port, TlsMode tls)
+  {
+    SessionId sid = _nextSessionId++;
+    ConnectReq cr{sid, host, port, tls};
+    enqueue(Command::connect(cr));
+    return sid;
+  }
 
-    void err(TransportError te, const std::string& m)
+  /// \brief Queue a send on a session (non-blocking; may enqueue on EAGAIN).
+  bool send(SessionId sid, const void *data, std::size_t n)
+  {
+    if (n == 0)
     {
-      _atomicStats.errors++;
-      std::lock_guard<std::mutex> g(_cbMutex);
-      if (_cbs.onError)
-      {
-        _cbs.onError(te, m);
-      }
+      return true;
     }
+    ByteBuffer b(n);
+    std::memcpy(b.data(), data, n);
+    SendReq sr;
+    sr.sid = sid;
+    sr.payload = std::move(b);
+    return enqueue(Command::send(std::move(sr)));
+  }
 
-    void setLastFatal(const IoResult& r) const
-    {
-      std::lock_guard<std::mutex> g(_fatalMx);
-      _lastFatal = r;
-    }
+  /// \brief Close a session (idempotent). onClosed will fire.
+  bool close(SessionId sid) { return enqueue(Command::close(sid)); }
 
-    struct ListenerCfg
-    {
-      ListenerId id{};
-      std::string addr;
-      std::uint16_t port{};
-      TlsMode tls{TlsMode::None};
-    };
+  /// \brief Reconfigure runtime knobs; safe while running.
+  void reconfigure(const Config &c) { enqueue(Command::reconf(c)); }
 
-    struct ConnectReq
-    {
-      SessionId sid{};
-      std::string host;
-      std::uint16_t port{};
-      TlsMode tls{TlsMode::None};
-    };
+  /// \brief Snapshot of counters.
+  Stats stats() const
+  {
+    Stats copy;
+    copy.accepted = _atomicStats.accepted.load();
+    copy.connected = _atomicStats.connected.load();
+    copy.closed = _atomicStats.closed.load();
+    copy.errors = _atomicStats.errors.load();
+    copy.tlsHandshakes = _atomicStats.tlsHandshakes.load();
+    copy.tlsFailures = _atomicStats.tlsFailures.load();
+    copy.bytesIn = _atomicStats.bytesIn.load();
+    copy.bytesOut = _atomicStats.bytesOut.load();
+    copy.epollWakeups = _atomicStats.epollWakeups.load();
+    copy.commands = _atomicStats.commands.load();
+    copy.gcRuns = _atomicStats.gcRuns.load();
+    copy.gcClosedIdle = _atomicStats.gcClosedIdle.load();
+    copy.gcClosedAged = _atomicStats.gcClosedAged.load();
+    copy.backpressureCloses = _atomicStats.backpressureCloses.load();
+    copy.sessionsCurrent = _atomicStats.sessionsCurrent.load();
+    copy.sessionsPeak = _atomicStats.sessionsPeak.load();
+    return copy;
+  }
 
-    struct SendReq
-    {
-      SessionId sid{};
-      ByteBuffer payload;
-    };
+  /// \brief Basic stats for ITransportBase compatibility
+  BasicTransportStats getBasicStats() const
+  {
+    BasicTransportStats basic{};
+    basic.accepted = _atomicStats.accepted.load();
+    basic.connected = _atomicStats.connected.load();
+    basic.closed = _atomicStats.closed.load();
+    basic.errors = _atomicStats.errors.load();
+    basic.bytesIn = _atomicStats.bytesIn.load();
+    basic.bytesOut = _atomicStats.bytesOut.load();
+    basic.sessionsCurrent = _atomicStats.sessionsCurrent.load();
+    return basic;
+  }
 
-    enum class Cmd
-    {
-      Shutdown,
-      AddListener,
-      Connect,
-      Send,
-      Close,
-      Reconf
-    };
+  /// \brief Sticky last fatal error (since process start). Valid after
+  /// start() failure.
+  IoResult lastFatalError() const
+  {
+    std::lock_guard<std::mutex> g(_fatalMx);
+    return _lastFatal;
+  }
 
-    struct Command
-    {
-      Cmd t;
-      ListenerCfg l;
-      ConnectReq c;
-      SendReq s;
-      SessionId closeSid{};
-      Config cfg;
+private:
+  // ===== helpers =====
 
-      static Command shutdown() { return Command{Cmd::Shutdown}; }
-      static Command addListener(const ListenerCfg& lc)
-      {
-        Command x{Cmd::AddListener};
-        x.l = lc;
-        return x;
-      }
-      static Command connect(const ConnectReq& cr)
-      {
-        Command x{Cmd::Connect};
-        x.c = cr;
-        return x;
-      }
-      static Command send(SendReq&& sr)
-      {
-        Command x{Cmd::Send};
-        x.s = std::move(sr);
-        return x;
-      }
-      static Command close(SessionId sid)
-      {
-        Command x{Cmd::Close};
-        x.closeSid = sid;
-        return x;
-      }
-      static Command reconf(const Config& cfg)
-      {
-        Command x{Cmd::Reconf};
-        x.cfg = cfg;
-        return x;
-      }
-    };
+  static std::string lastErr()
+  {
+    int e = errno;
+    char buf[128];
+#if defined(__GLIBC__) && !defined(__APPLE__)
+    ::strerror_r(e, buf, sizeof(buf));
+    return std::string(buf);
+#else
+    return std::string(std::strerror(e));
+#endif
+  }
 
-    bool enqueue(const Command& cmd)
-    {
-      try
-      {
-        {
-          std::lock_guard<std::mutex> g(_cmdMutex);
-          _cmds.push_back(cmd);
-          _atomicStats.commands++;
-        }
-        std::uint64_t one = 1;
-        (void) ::write(_eventFd, &one, sizeof(one));
-        return true;
-      }
-      catch (const std::exception& ex)
-      {
-        setLastFatal(
-            IoResult::failure(TransportError::Unknown,
-                              std::string("enqueue(copy): ") + ex.what()));
-        std::lock_guard<std::mutex> g(_cbMutex);
-        if (_cbs.onError)
-        {
-          _cbs.onError(TransportError::Unknown,
-                       std::string("enqueue(copy): ") + ex.what());
-        }
-        return false;
-      }
+  bool addEpoll(int fd, std::uint32_t ev)
+  {
+    epoll_event e{};
+    e.events = ev;
+    e.data.fd = fd;
+    return ::epoll_ctl(_epollFd, EPOLL_CTL_ADD, fd, &e) == 0;
+  }
+
+  bool modEpoll(int fd, std::uint32_t ev)
+  {
+    epoll_event e{};
+    e.events = ev;
+    e.data.fd = fd;
+    return ::epoll_ctl(_epollFd, EPOLL_CTL_MOD, fd, &e) == 0;
+  }
+
+  void delEpoll(int fd) { ::epoll_ctl(_epollFd, EPOLL_CTL_DEL, fd, nullptr); }
+
+  static std::string keyFromSockaddr(const sockaddr_storage &ss)
+  {
+    char h[NI_MAXHOST]{}, s[NI_MAXSERV]{};
+    socklen_t sl = (ss.ss_family == AF_INET) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
+    if (::getnameinfo(reinterpret_cast<const sockaddr *>(&ss), sl, h, sizeof(h), s, sizeof(s),
+                      NI_NUMERICHOST | NI_NUMERICSERV) == 0)
+    {
+      std::string out(h);
+      out.push_back(':');
+      out.append(s);
+      return out;
     }
+    return {};
+  }
+
+  void armGc(std::chrono::seconds sec)
+  {
+    itimerspec its{};
+    its.it_interval.tv_sec = sec.count();
+    its.it_value.tv_sec = sec.count();
+    ::timerfd_settime(_timerFd, 0, &its, nullptr);
+  }
 
-    bool enqueue(Command&& cmd)
+  void cleanupStartFail()
+  {
+    if (_timerFd >= 0)
     {
-      try
-      {
-        {
-          std::lock_guard<std::mutex> g(_cmdMutex);
-          _cmds.push_back(std::move(cmd));
-          _atomicStats.commands++;
-        }
-        std::uint64_t one = 1;
-        (void) ::write(_eventFd, &one, sizeof(one));
-        return true;
-      }
-      catch (const std::exception& ex)
-      {
-        setLastFatal(
-            IoResult::failure(TransportError::Unknown,
-                              std::string("enqueue(move): ") + ex.what()));
-        std::lock_guard<std::mutex> g(_cbMutex);
-        if (_cbs.onError)
-        {
-          _cbs.onError(TransportError::Unknown,
-                       std::string("enqueue(move): ") + ex.what());
-        }
-        return false;
-      }
+      ::close(_timerFd);
+      _timerFd = -1;
     }
-
-    void drainEvt()
+    if (_eventFd >= 0)
     {
-      std::uint64_t n = 0;
-      while (::read(_eventFd, &n, sizeof(n)) > 0)
-      {
-      }
+      ::close(_eventFd);
+      _eventFd = -1;
     }
-
-    void drainTim()
+    if (_epollFd >= 0)
     {
-      std::uint64_t n = 0;
-      while (::read(_timerFd, &n, sizeof(n)) > 0)
-      {
-      }
+      ::close(_epollFd);
+      _epollFd = -1;
     }
+    freeTls();
+    _running.store(false);
+  }
 
-    enum class TlsState
+  void err(TransportError te, const std::string &m)
+  {
+    _atomicStats.errors++;
+    std::lock_guard<std::mutex> g(_cbMutex);
+    if (_cbs.onError)
     {
-      None,
-      Handshake,
-      Open
-    };
+      _cbs.onError(te, m);
+    }
+  }
 
-    struct Session
+  void setLastFatal(const IoResult &r) const
+  {
+    std::lock_guard<std::mutex> g(_fatalMx);
+    _lastFatal = r;
+  }
+
+  struct ListenerCfg
+  {
+    ListenerId id{};
+    std::string addr;
+    std::uint16_t port{};
+    TlsMode tls{TlsMode::None};
+  };
+
+  struct ConnectReq
+  {
+    SessionId sid{};
+    std::string host;
+    std::uint16_t port{};
+    TlsMode tls{TlsMode::None};
+  };
+
+  struct SendReq
+  {
+    SessionId sid{};
+    ByteBuffer payload;
+  };
+
+  enum class Cmd
+  {
+    Shutdown,
+    AddListener,
+    Connect,
+    Send,
+    Close,
+    Reconf
+  };
+
+  struct Command
+  {
+    Cmd t;
+    ListenerCfg l;
+    ConnectReq c;
+    SendReq s;
+    SessionId closeSid{};
+    Config cfg;
+
+    static Command shutdown() { return Command{Cmd::Shutdown}; }
+    static Command addListener(const ListenerCfg &lc)
+    {
+      Command x{Cmd::AddListener};
+      x.l = lc;
+      return x;
+    }
+    static Command connect(const ConnectReq &cr)
     {
-      SessionId id{};
-      int fd{-1};
-      sockaddr_storage peer{};
-      socklen_t peerLen{0};
-      std::string peerKey;
-
-      TlsMode tlsMode{TlsMode::None};
-      SSL* ssl{nullptr};
-      TlsState tlsState{TlsState::None};
-      MonoTime tlsStart{};
-
-      std::deque<ByteBuffer> wq;
-      bool wantWrite{false};
-      bool closed{false};
-
-      MonoTime created{}, lastActivity{};
-
-      // Safety-net tracking
-      bool connectPending{false};
-      MonoTime connectStart{};
-      MonoTime lastWriteProgress{};
-      // High-resolution timer IDs (0 = not scheduled)
-      std::uint64_t connectTimeoutId{0};
-      std::uint64_t handshakeTimeoutId{0};
-      std::uint64_t writeStallTimeoutId{0};
-    };
-
-    // ===== High-resolution timer helpers (after Session struct) =====
-    
-    void scheduleConnectTimeout(Session* s)
-    {
-      if (!_timerService || _cfg.connectTimeout.count() == 0 || s->connectTimeoutId != 0)
-      {
-        return;
-      }
-      
-      s->connectTimeoutId = _timerService->scheduleAfter(
-          _cfg.connectTimeout,
-          [this, sid = s->id]()
-          {
-            handleConnectTimeout(sid);
-          });
+      Command x{Cmd::Connect};
+      x.c = cr;
+      return x;
     }
-    
-    void scheduleHandshakeTimeout(Session* s)
+    static Command send(SendReq &&sr)
     {
-      if (!_timerService || _cfg.handshakeTimeout.count() == 0 || s->handshakeTimeoutId != 0)
-      {
-        return;
-      }
-      
-      s->handshakeTimeoutId = _timerService->scheduleAfter(
-          _cfg.handshakeTimeout,
-          [this, sid = s->id]()
-          {
-            handleHandshakeTimeout(sid);
-          });
+      Command x{Cmd::Send};
+      x.s = std::move(sr);
+      return x;
     }
-    
-    void scheduleWriteStallTimeout(Session* s)
+    static Command close(SessionId sid)
     {
-      if (!_timerService || _cfg.writeStallTimeout.count() == 0 || s->writeStallTimeoutId != 0)
-      {
-        return;
-      }
-      
-      s->writeStallTimeoutId = _timerService->scheduleAfter(
-          _cfg.writeStallTimeout,
-          [this, sid = s->id]()
-          {
-            handleWriteStallTimeout(sid);
-          });
+      Command x{Cmd::Close};
+      x.closeSid = sid;
+      return x;
     }
-    
-    void cancelConnectTimeout(Session* s)
+    static Command reconf(const Config &cfg)
     {
-      if (_timerService && s->connectTimeoutId != 0)
-      {
-        _timerService->cancel(s->connectTimeoutId);
-        s->connectTimeoutId = 0;
-      }
+      Command x{Cmd::Reconf};
+      x.cfg = cfg;
+      return x;
     }
-    
-    void cancelHandshakeTimeout(Session* s)
+  };
+
+  bool enqueue(const Command &cmd)
+  {
+    try
     {
-      if (_timerService && s->handshakeTimeoutId != 0)
       {
-        _timerService->cancel(s->handshakeTimeoutId);
-        s->handshakeTimeoutId = 0;
+        std::lock_guard<std::mutex> g(_cmdMutex);
+        _cmds.push_back(cmd);
+        _atomicStats.commands++;
       }
+      std::uint64_t one = 1;
+      (void)::write(_eventFd, &one, sizeof(one));
+      return true;
     }
-    
-    void cancelWriteStallTimeout(Session* s)
+    catch (const std::exception &ex)
     {
-      if (_timerService && s->writeStallTimeoutId != 0)
+      setLastFatal(
+        IoResult::failure(TransportError::Unknown, std::string("enqueue(copy): ") + ex.what()));
+      std::lock_guard<std::mutex> g(_cbMutex);
+      if (_cbs.onError)
       {
-        _timerService->cancel(s->writeStallTimeoutId);
-        s->writeStallTimeoutId = 0;
+        _cbs.onError(TransportError::Unknown, std::string("enqueue(copy): ") + ex.what());
       }
+      return false;
     }
-    
-    void cancelAllTimers(Session* s)
-    {
-      cancelConnectTimeout(s);
-      cancelHandshakeTimeout(s);
-      cancelWriteStallTimeout(s);
-    }
-    
-    void handleConnectTimeout(SessionId sid)
+  }
+
+  bool enqueue(Command &&cmd)
+  {
+    try
     {
-      auto it = _sessions.find(sid);
-      if (it != _sessions.end())
       {
-        auto* s = it->second.get();
-        s->connectTimeoutId = 0; // Mark as expired
-        if (s->connectPending)
-        {
-          closeNow(s, TransportError::Timeout, "Connect timeout", 0);
-        }
+        std::lock_guard<std::mutex> g(_cmdMutex);
+        _cmds.push_back(std::move(cmd));
+        _atomicStats.commands++;
       }
+      std::uint64_t one = 1;
+      (void)::write(_eventFd, &one, sizeof(one));
+      return true;
     }
-    
-    void handleHandshakeTimeout(SessionId sid)
+    catch (const std::exception &ex)
     {
-      auto it = _sessions.find(sid);
-      if (it != _sessions.end())
+      setLastFatal(
+        IoResult::failure(TransportError::Unknown, std::string("enqueue(move): ") + ex.what()));
+      std::lock_guard<std::mutex> g(_cbMutex);
+      if (_cbs.onError)
       {
-        auto* s = it->second.get();
-        s->handshakeTimeoutId = 0; // Mark as expired
-        if (s->tlsState == TlsState::Handshake)
-        {
-          closeNow(s, TransportError::TLSHandshake, "TLS handshake timeout", 0);
-        }
+        _cbs.onError(TransportError::Unknown, std::string("enqueue(move): ") + ex.what());
       }
+      return false;
     }
-    
-    void handleWriteStallTimeout(SessionId sid)
+  }
+
+  void drainEvt()
+  {
+    std::uint64_t n = 0;
+    while (::read(_eventFd, &n, sizeof(n)) > 0)
     {
-      auto it = _sessions.find(sid);
-      if (it != _sessions.end())
-      {
-        auto* s = it->second.get();
-        s->writeStallTimeoutId = 0; // Mark as expired
-        if (!s->wq.empty())
-        {
-          closeNow(s, TransportError::Timeout, "Write stall timeout", 0);
-        }
-      }
     }
+  }
 
-    struct Listener
+  void drainTim()
+  {
+    std::uint64_t n = 0;
+    while (::read(_timerFd, &n, sizeof(n)) > 0)
     {
-      ListenerId id{};
-      int fd{-1};
-      std::string bind;
-      TlsMode tls{TlsMode::None};
-    };
+    }
+  }
+
+  enum class TlsState
+  {
+    None,
+    Handshake,
+    Open
+  };
+
+  struct Session
+  {
+    SessionId id{};
+    int fd{-1};
+    sockaddr_storage peer{};
+    socklen_t peerLen{0};
+    std::string peerKey;
+
+    TlsMode tlsMode{TlsMode::None};
+    SSL *ssl{nullptr};
+    TlsState tlsState{TlsState::None};
+    MonoTime tlsStart{};
+
+    std::deque<ByteBuffer> wq;
+    bool wantWrite{false};
+    bool closed{false};
+
+    MonoTime created{}, lastActivity{};
+
+    // Safety-net tracking
+    bool connectPending{false};
+    MonoTime connectStart{};
+    MonoTime lastWriteProgress{};
+    // High-resolution timer IDs (0 = not scheduled)
+    std::uint64_t connectTimeoutId{0};
+    std::uint64_t handshakeTimeoutId{0};
+    std::uint64_t writeStallTimeoutId{0};
+  };
+
+  // ===== High-resolution timer helpers (after Session struct) =====
 
-    struct Tag
+  void scheduleConnectTimeout(Session *s)
+  {
+    if (!_timerService || _cfg.connectTimeout.count() == 0 || s->connectTimeoutId != 0)
     {
-      bool isListener{false};
-      Listener* lst{nullptr};
-      Session* sess{nullptr};
-    };
+      return;
+    }
+
+    s->connectTimeoutId = _timerService->scheduleAfter(_cfg.connectTimeout, [this, sid = s->id]()
+                                                       { handleConnectTimeout(sid); });
+  }
 
-    void loop()
+  void scheduleHandshakeTimeout(Session *s)
+  {
+    if (!_timerService || _cfg.handshakeTimeout.count() == 0 || s->handshakeTimeoutId != 0)
     {
-      std::vector<epoll_event> evs((std::size_t) _cfg.epollMaxEvents);
-      while (_running.load())
-      {
-        int n = ::epoll_wait(_epollFd, evs.data(), (int) evs.size(), -1);
-        if (n < 0)
-        {
-          if (errno == EINTR)
-          {
-            continue;
-          }
-          err(TransportError::Unknown, "epoll_wait: " + lastErr());
-          continue;
-        }
-        _atomicStats.epollWakeups++;
+      return;
+    }
 
-        for (int i = 0; i < n; ++i)
-        {
-          int fd = evs[(std::size_t) i].data.fd;
-          std::uint32_t events = evs[(std::size_t) i].events;
+    s->handshakeTimeoutId = _timerService->scheduleAfter(
+      _cfg.handshakeTimeout, [this, sid = s->id]() { handleHandshakeTimeout(sid); });
+  }
 
-          if (fd == _eventFd)
-          {
-            drainEvt();
-            process();
-            continue;
-          }
-          if (fd == _timerFd)
-          {
-            drainTim();
-            runGc();
-            continue;
-          }
+  void scheduleWriteStallTimeout(Session *s)
+  {
+    if (!_timerService || _cfg.writeStallTimeout.count() == 0 || s->writeStallTimeoutId != 0)
+    {
+      return;
+    }
 
-          auto it = _fdTags.find(fd);
-          if (it == _fdTags.end())
-          {
-            continue;
-          }
-          Tag* t = it->second.get();
-          if (t->isListener)
-          {
-            onListener(t->lst);
-          }
-          else
-          {
-            onSession(t->sess, events);
-          }
-        }
-      }
+    s->writeStallTimeoutId = _timerService->scheduleAfter(
+      _cfg.writeStallTimeout, [this, sid = s->id]() { handleWriteStallTimeout(sid); });
+  }
 
-      // Draining on shutdown
-      process();
-      // Collect sessions to close to avoid iterator invalidation
-      std::vector<Session*> toClose;
-      toClose.reserve(_sessions.size());
-      for (auto& kv : _sessions)
-        toClose.push_back(kv.second.get());
+  void cancelConnectTimeout(Session *s)
+  {
+    if (_timerService && s->connectTimeoutId != 0)
+    {
+      _timerService->cancel(s->connectTimeoutId);
+      s->connectTimeoutId = 0;
+    }
+  }
 
-      // Close all sessions safely (but don't erase from _sessions yet)
-      for (auto* s : toClose)
-      {
-        if (!s || s->closed)
-          continue;
-        s->closed = true;
-        delEpoll(s->fd);
-        ::close(s->fd);
-        if (s->ssl)
-        {
-          ::SSL_free(s->ssl);
-          s->ssl = nullptr;
-        }
-        _atomicStats.closed++;
-        _atomicStats.sessionsCurrent--;
-        {
-          std::lock_guard<std::mutex> g(_cbMutex);
-          if (_cbs.onClosed)
-          {
-            IoResult r =
-                IoResult::failure(TransportError::Unknown, "shutdown", 0, 0);
-            _cbs.onClosed(s->id, r);
-          }
-        }
-      }
-      _sessions.clear();
-
-      // Close listeners
-      std::vector<Listener*> listenersToClose;
-      listenersToClose.reserve(_listeners.size());
-      for (auto& kv : _listeners)
-        listenersToClose.push_back(kv.second.get());
-
-      for (auto* lst : listenersToClose)
-        closeListenerNow(lst);
-      _listeners.clear();
-      if (_timerFd >= 0)
-      {
-        delEpoll(_timerFd);
-        ::close(_timerFd);
-        _timerFd = -1;
-      }
-      if (_eventFd >= 0)
-      {
-        delEpoll(_eventFd);
-        ::close(_eventFd);
-        _eventFd = -1;
-      }
-      if (_epollFd >= 0)
-      {
-        ::close(_epollFd);
-        _epollFd = -1;
-      }
-      freeTls();
+  void cancelHandshakeTimeout(Session *s)
+  {
+    if (_timerService && s->handshakeTimeoutId != 0)
+    {
+      _timerService->cancel(s->handshakeTimeoutId);
+      s->handshakeTimeoutId = 0;
     }
+  }
 
-    void process()
+  void cancelWriteStallTimeout(Session *s)
+  {
+    if (_timerService && s->writeStallTimeoutId != 0)
     {
-      std::deque<Command> q;
-      {
-        std::lock_guard<std::mutex> g(_cmdMutex);
-        q.swap(_cmds);
-      }
+      _timerService->cancel(s->writeStallTimeoutId);
+      s->writeStallTimeoutId = 0;
+    }
+  }
 
-      for (auto& c : q)
+  void cancelAllTimers(Session *s)
+  {
+    cancelConnectTimeout(s);
+    cancelHandshakeTimeout(s);
+    cancelWriteStallTimeout(s);
+  }
+
+  void handleConnectTimeout(SessionId sid)
+  {
+    auto it = _sessions.find(sid);
+    if (it != _sessions.end())
+    {
+      auto *s = it->second.get();
+      s->connectTimeoutId = 0; // Mark as expired
+      if (s->connectPending)
       {
-        try
-        {
-          switch (c.t)
-          {
-          case Cmd::Shutdown:
-            _running.store(false);
-            break;
-          case Cmd::AddListener:
-            doAddListener(c.l);
-            break;
-          case Cmd::Connect:
-            doConnect(c.c);
-            break;
-          case Cmd::Send:
-            doSend(std::move(c.s));
-            break;
-          case Cmd::Close:
-          {
-            auto it = _sessions.find(c.closeSid);
-            if (it != _sessions.end())
-            {
-              closeNow(it->second.get(), TransportError::Unknown,
-                       "closed by app", 0);
-            }
-            break;
-          }
-          case Cmd::Reconf:
-            _cfg = c.cfg;
-            armGc(_cfg.gcInterval);
-            break;
-          }
-        }
-        catch (const std::exception& ex)
-        {
-          std::lock_guard<std::mutex> g(_cbMutex);
-          if (_cbs.onError)
-          {
-            _cbs.onError(TransportError::Unknown,
-                         std::string("cmd dispatch: ") + ex.what());
-          }
-        }
+        closeNow(s, TransportError::Timeout, "Connect timeout", 0);
       }
     }
+  }
 
-    bool doAddListener(const ListenerCfg& lc)
+  void handleHandshakeTimeout(SessionId sid)
+  {
+    auto it = _sessions.find(sid);
+    if (it != _sessions.end())
     {
-      int sfd = -1;
-      sockaddr_storage ss{};
-      socklen_t sl = 0;
-
-      in6_addr t6{};
-      if (::inet_pton(AF_INET6, lc.addr.c_str(), &t6) == 1)
+      auto *s = it->second.get();
+      s->handshakeTimeoutId = 0; // Mark as expired
+      if (s->tlsState == TlsState::Handshake)
       {
-        sfd = ::socket(AF_INET6, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
-        if (sfd < 0)
-        {
-          err(TransportError::Socket, "socket v6: " + lastErr());
-          return false;
-        }
-        int v6only = 0;
-        ::setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
-        sockaddr_in6 sa6{};
-        sa6.sin6_family = AF_INET6;
-        sa6.sin6_port = htons(lc.port);
-        sa6.sin6_addr = t6;
-        std::memcpy(&ss, &sa6, sizeof(sa6));
-        sl = sizeof(sa6);
-      }
-      else
-      {
-        in_addr t4{};
-        if (::inet_pton(AF_INET, lc.addr.c_str(), &t4) != 1)
-        {
-          err(TransportError::Bind, "inet_pton failed");
-          return false;
-        }
-        sfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
-        if (sfd < 0)
-        {
-          err(TransportError::Socket, "socket v4: " + lastErr());
-          return false;
-        }
-        int one = 1;
-        ::setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
-#ifdef SO_REUSEPORT
-        ::setsockopt(sfd, SOL_SOCKET, SO_REUSEPORT, &one, sizeof(one));
-#endif
-        sockaddr_in sa4{};
-        sa4.sin_family = AF_INET;
-        sa4.sin_port = htons(lc.port);
-        sa4.sin_addr = t4;
-        std::memcpy(&ss, &sa4, sizeof(sa4));
-        sl = sizeof(sa4);
+        closeNow(s, TransportError::TLSHandshake, "TLS handshake timeout", 0);
       }
+    }
+  }
 
-      if (_cfg.soRcvBuf > 0)
-        ::setsockopt(sfd, SOL_SOCKET, SO_RCVBUF, &_cfg.soRcvBuf, sizeof(int));
-      if (_cfg.soSndBuf > 0)
-        ::setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &_cfg.soSndBuf, sizeof(int));
-
-      if (::bind(sfd, reinterpret_cast<sockaddr*>(&ss), sl) < 0)
-      {
-        err(TransportError::Bind, "bind: " + lastErr());
-        ::close(sfd);
-        return false;
-      }
-      if (::listen(sfd, 256) < 0)
+  void handleWriteStallTimeout(SessionId sid)
+  {
+    auto it = _sessions.find(sid);
+    if (it != _sessions.end())
+    {
+      auto *s = it->second.get();
+      s->writeStallTimeoutId = 0; // Mark as expired
+      if (!s->wq.empty())
       {
-        err(TransportError::Listen, "listen: " + lastErr());
-        ::close(sfd);
-        return false;
+        closeNow(s, TransportError::Timeout, "Write stall timeout", 0);
       }
+    }
+  }
 
-      auto lst = std::make_unique<Listener>();
-      lst->id = lc.id;
-      lst->fd = sfd;
-      lst->bind = lc.addr + ":" + std::to_string(lc.port);
-      lst->tls = lc.tls;
-      std::uint32_t ev = EPOLLIN;
-      if (_cfg.useEdgeTriggered)
-        ev |= EPOLLET;
-      addEpoll(sfd, ev);
-
-      auto tag = std::make_unique<Tag>();
-      tag->isListener = true;
-      tag->lst = lst.get();
-      _fdTags.emplace(sfd, std::move(tag));
+  struct Listener
+  {
+    ListenerId id{};
+    int fd{-1};
+    std::string bind;
+    TlsMode tls{TlsMode::None};
+  };
 
-      _listeners.emplace(lst->id, std::move(lst));
-      return true;
-    }
+  struct Tag
+  {
+    bool isListener{false};
+    Listener *lst{nullptr};
+    Session *sess{nullptr};
+  };
 
-    void onListener(Listener* lst)
+  void loop()
+  {
+    std::vector<epoll_event> evs((std::size_t)_cfg.epollMaxEvents);
+    while (_running.load())
     {
-      for (;;)
+      int n = ::epoll_wait(_epollFd, evs.data(), (int)evs.size(), -1);
+      if (n < 0)
       {
-        sockaddr_storage peer{};
-        socklen_t pl = sizeof(peer);
-        int cfd = ::accept4(lst->fd, reinterpret_cast<sockaddr*>(&peer), &pl,
-                            SOCK_NONBLOCK | SOCK_CLOEXEC);
-        if (cfd < 0)
-        {
-          if (errno == EAGAIN || errno == EWOULDBLOCK)
-          {
-            break;
-          }
-          err(TransportError::Accept, "accept4: " + lastErr());
-          break;
-        }
-        applySockOpts(cfd);
-
-        SessionId sid = _nextSessionId++;
-        auto s = std::make_unique<Session>();
-        s->id = sid;
-        s->fd = cfd;
-        std::memcpy(&s->peer, &peer, pl);
-        s->peerLen = pl;
-        s->peerKey = keyFromSockaddr(peer);
-        s->created = MonoClock::now();
-        s->lastActivity = s->created;
-        s->lastWriteProgress = s->created;
-
-        if (lst->tls == TlsMode::Server && _srvTls.enabled && _sslSrv)
+        if (errno == EINTR)
         {
-          s->tlsMode = TlsMode::Server;
-          s->ssl = ::SSL_new(_sslSrv);
-          if (!s->ssl)
-          {
-            err(TransportError::TLSHandshake, "SSL_new(server) failed");
-            ::close(cfd);
-            continue; // not inserted anywhere yet
-          }
-          ::SSL_set_fd(s->ssl, cfd);
-          ::SSL_set_accept_state(s->ssl);
-          s->tlsState = TlsState::Handshake;
-          s->tlsStart = MonoClock::now();
-          scheduleHandshakeTimeout(s.get());
+          continue;
         }
+        err(TransportError::Unknown, "epoll_wait: " + lastErr());
+        continue;
+      }
+      _atomicStats.epollWakeups++;
 
-        _sessions.emplace(sid, std::move(s));
-        bumpSess();
-
-        std::uint32_t ev = EPOLLIN;
-        if (_cfg.useEdgeTriggered)
-          ev |= EPOLLET;
-        addEpoll(cfd, ev);
-
-        auto tg = std::make_unique<Tag>();
-        tg->isListener = false;
-        tg->sess = _sessions[sid].get();
-        _fdTags.emplace(cfd, std::move(tg));
+      for (int i = 0; i < n; ++i)
+      {
+        int fd = evs[(std::size_t)i].data.fd;
+        std::uint32_t events = evs[(std::size_t)i].events;
 
-        _atomicStats.accepted++;
-        std::lock_guard<std::mutex> g(_cbMutex);
-        if (_cbs.onAccept)
+        if (fd == _eventFd)
         {
-          _cbs.onAccept(sid, _sessions[sid]->peerKey, IoResult::success());
+          drainEvt();
+          process();
+          continue;
+        }
+        if (fd == _timerFd)
+        {
+          drainTim();
+          runGc();
+          continue;
         }
-      }
-    }
-
-    bool doConnect(const ConnectReq& cr)
-    {
-      addrinfo hints{};
-      hints.ai_family = AF_UNSPEC;
-      hints.ai_socktype = SOCK_STREAM;
-      hints.ai_protocol = IPPROTO_TCP;
-      addrinfo* res = nullptr;
-      std::string ps = std::to_string(cr.port);
-
-      // CRITICAL FIX: Skip getaddrinfo() for IP addresses to prevent I/O thread
-      // from hanging For IP addresses, we can directly use them without DNS
-      // resolution
-      int rc = 0;
-
-      // Check if host is already an IP address (IPv4 or IPv6)
-      struct sockaddr_in sa4;
-      struct sockaddr_in6 sa6;
-      bool isIPv4 = (inet_pton(AF_INET, cr.host.c_str(), &(sa4.sin_addr)) == 1);
-      bool isIPv6 =
-          (inet_pton(AF_INET6, cr.host.c_str(), &(sa6.sin6_addr)) == 1);
 
-      if (isIPv4 || isIPv6)
-      {
-        // For IP addresses, create minimal addrinfo structure manually
-        res = new addrinfo();
-        memset(res, 0, sizeof(addrinfo));
-        res->ai_family = isIPv4 ? AF_INET : AF_INET6;
-        res->ai_socktype = SOCK_STREAM;
-        res->ai_protocol = IPPROTO_TCP;
-
-        if (isIPv4)
+        auto it = _fdTags.find(fd);
+        if (it == _fdTags.end())
         {
-          res->ai_addrlen = sizeof(sockaddr_in);
-          auto* addr4 = new sockaddr_in();
-          memset(addr4, 0, sizeof(sockaddr_in));
-          addr4->sin_family = AF_INET;
-          addr4->sin_port = htons(cr.port);
-          addr4->sin_addr = sa4.sin_addr;
-          res->ai_addr = reinterpret_cast<sockaddr*>(addr4);
+          continue;
         }
-        else
+        Tag *t = it->second.get();
+        if (t->isListener)
         {
-          res->ai_addrlen = sizeof(sockaddr_in6);
-          auto* addr6 = new sockaddr_in6();
-          memset(addr6, 0, sizeof(sockaddr_in6));
-          addr6->sin6_family = AF_INET6;
-          addr6->sin6_port = htons(cr.port);
-          addr6->sin6_addr = sa6.sin6_addr;
-          res->ai_addr = reinterpret_cast<sockaddr*>(addr6);
+          onListener(t->lst);
         }
-        rc = 0; // Success
-      }
-      else
-      {
-        // For hostnames, use getaddrinfo with timeout
-        auto dnsTimeout = std::chrono::seconds(2);
-        auto dnsResult = std::async(
-            std::launch::async,
-            [&]() {
-              return ::getaddrinfo(cr.host.c_str(), ps.c_str(), &hints, &res);
-            });
-
-        auto dnsStatus = dnsResult.wait_for(dnsTimeout);
-        if (dnsStatus == std::future_status::timeout)
+        else
         {
-          std::lock_guard<std::mutex> g(_cbMutex);
-          std::string timeoutMsg =
-              "DNS_TIMEOUT_FIX_TRIGGERED: getaddrinfo timeout after " +
-              std::to_string(dnsTimeout.count()) + "s for " + cr.host + ":" +
-              ps;
-          if (_cbs.onConnect)
-          {
-            _cbs.onConnect(
-                cr.sid, IoResult::failure(TransportError::Resolve, timeoutMsg));
-          }
-          err(TransportError::Resolve, timeoutMsg);
-          return false;
+          onSession(t->sess, events);
         }
+      }
+    }
 
-        rc = dnsResult.get();
+    // Draining on shutdown
+    process();
+    // Collect sessions to close to avoid iterator invalidation
+    std::vector<Session *> toClose;
+    toClose.reserve(_sessions.size());
+    for (auto &kv : _sessions)
+      toClose.push_back(kv.second.get());
+
+    // Close all sessions safely (but don't erase from _sessions yet)
+    for (auto *s : toClose)
+    {
+      if (!s || s->closed)
+        continue;
+      s->closed = true;
+      delEpoll(s->fd);
+      ::close(s->fd);
+      if (s->ssl)
+      {
+        ::SSL_free(s->ssl);
+        s->ssl = nullptr;
       }
-      if (rc != 0 || !res)
+      _atomicStats.closed++;
+      _atomicStats.sessionsCurrent--;
       {
         std::lock_guard<std::mutex> g(_cbMutex);
-        if (_cbs.onConnect)
+        if (_cbs.onClosed)
         {
-          _cbs.onConnect(cr.sid,
-                         IoResult::failure(TransportError::Resolve,
-                                           std::string("getaddrinfo: ") +
-                                               gai_strerror(rc)));
+          IoResult r = IoResult::failure(TransportError::Unknown, "shutdown", 0, 0);
+          _cbs.onClosed(s->id, r);
         }
-        err(TransportError::Resolve, "getaddrinfo failed");
-        return false;
       }
+    }
+    _sessions.clear();
+
+    // Close listeners
+    std::vector<Listener *> listenersToClose;
+    listenersToClose.reserve(_listeners.size());
+    for (auto &kv : _listeners)
+      listenersToClose.push_back(kv.second.get());
+
+    for (auto *lst : listenersToClose)
+      closeListenerNow(lst);
+    _listeners.clear();
+    if (_timerFd >= 0)
+    {
+      delEpoll(_timerFd);
+      ::close(_timerFd);
+      _timerFd = -1;
+    }
+    if (_eventFd >= 0)
+    {
+      delEpoll(_eventFd);
+      ::close(_eventFd);
+      _eventFd = -1;
+    }
+    if (_epollFd >= 0)
+    {
+      ::close(_epollFd);
+      _epollFd = -1;
+    }
+    freeTls();
+  }
+
+  void process()
+  {
+    std::deque<Command> q;
+    {
+      std::lock_guard<std::mutex> g(_cmdMutex);
+      q.swap(_cmds);
+    }
 
-      int cfd = -1;
-      addrinfo* chosen = nullptr;
-      for (addrinfo* ai = res; ai; ai = ai->ai_next)
+    for (auto &c : q)
+    {
+      try
       {
-        cfd = ::socket(ai->ai_family,
-                       SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
-        if (cfd < 0)
+        switch (c.t)
         {
-          continue;
-        }
-        applySockOpts(cfd);
-        int connectResult = ::connect(cfd, ai->ai_addr, ai->ai_addrlen);
-        if (connectResult == 0 || errno == EINPROGRESS)
-        {
-          chosen = ai;
+        case Cmd::Shutdown:
+          _running.store(false);
           break;
-        }
-        // CRITICAL FIX for SIP: Immediately handle connection refused for local
-        // connections This prevents hanging when connecting to non-existent
-        // local ports
-        if (errno == ECONNREFUSED || errno == ENETUNREACH ||
-            errno == EHOSTUNREACH)
+        case Cmd::AddListener:
+          doAddListener(c.l);
+          break;
+        case Cmd::Connect:
+          doConnect(c.c);
+          break;
+        case Cmd::Send:
+          doSend(std::move(c.s));
+          break;
+        case Cmd::Close:
         {
-          // Connection definitively failed - don't retry other addresses for
-          // same host
-          ::close(cfd);
-          cfd = -1;
-
-          // Clean up addrinfo before returning
-          if (isIPv4 || isIPv6)
-          {
-            if (res && res->ai_addr)
-            {
-              delete res->ai_addr;
-            }
-            delete res;
-          }
-          else
-          {
-            ::freeaddrinfo(res);
-          }
-
-          // Report immediate failure
-          std::lock_guard<std::mutex> g(_cbMutex);
-          if (_cbs.onConnect)
+          auto it = _sessions.find(c.closeSid);
+          if (it != _sessions.end())
           {
-            std::string errMsg = "Connection refused to " + cr.host + ":" +
-                                 ps.c_str() + " - " + lastErr();
-            _cbs.onConnect(cr.sid, IoResult::failure(TransportError::Connect,
-                                                     errMsg, errno, 0));
+            closeNow(it->second.get(), TransportError::Unknown, "closed by app", 0);
           }
-          err(TransportError::Connect,
-              "connect immediately failed: " + lastErr());
-          return false;
+          break;
+        }
+        case Cmd::Reconf:
+          _cfg = c.cfg;
+          armGc(_cfg.gcInterval);
+          break;
         }
-        ::close(cfd);
-        cfd = -1;
       }
-
-      // Custom cleanup for manually created addrinfo structure
-      if (isIPv4 || isIPv6)
+      catch (const std::exception &ex)
       {
-        if (res && res->ai_addr)
+        std::lock_guard<std::mutex> g(_cbMutex);
+        if (_cbs.onError)
         {
-          delete res->ai_addr;
+          _cbs.onError(TransportError::Unknown, std::string("cmd dispatch: ") + ex.what());
         }
-        delete res;
       }
-      else
+    }
+  }
+
+  bool doAddListener(const ListenerCfg &lc)
+  {
+    int sfd = -1;
+    sockaddr_storage ss{};
+    socklen_t sl = 0;
+
+    in6_addr t6{};
+    if (::inet_pton(AF_INET6, lc.addr.c_str(), &t6) == 1)
+    {
+      sfd = ::socket(AF_INET6, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
+      if (sfd < 0)
+      {
+        err(TransportError::Socket, "socket v6: " + lastErr());
+        return false;
+      }
+      int v6only = 0;
+      ::setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
+      sockaddr_in6 sa6{};
+      sa6.sin6_family = AF_INET6;
+      sa6.sin6_port = htons(lc.port);
+      sa6.sin6_addr = t6;
+      std::memcpy(&ss, &sa6, sizeof(sa6));
+      sl = sizeof(sa6);
+    }
+    else
+    {
+      in_addr t4{};
+      if (::inet_pton(AF_INET, lc.addr.c_str(), &t4) != 1)
+      {
+        err(TransportError::Bind, "inet_pton failed");
+        return false;
+      }
+      sfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
+      if (sfd < 0)
       {
-        ::freeaddrinfo(res);
+        err(TransportError::Socket, "socket v4: " + lastErr());
+        return false;
       }
+      int one = 1;
+      ::setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
+#ifdef SO_REUSEPORT
+      ::setsockopt(sfd, SOL_SOCKET, SO_REUSEPORT, &one, sizeof(one));
+#endif
+      sockaddr_in sa4{};
+      sa4.sin_family = AF_INET;
+      sa4.sin_port = htons(lc.port);
+      sa4.sin_addr = t4;
+      std::memcpy(&ss, &sa4, sizeof(sa4));
+      sl = sizeof(sa4);
+    }
+
+    if (_cfg.soRcvBuf > 0)
+      ::setsockopt(sfd, SOL_SOCKET, SO_RCVBUF, &_cfg.soRcvBuf, sizeof(int));
+    if (_cfg.soSndBuf > 0)
+      ::setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &_cfg.soSndBuf, sizeof(int));
+
+    if (::bind(sfd, reinterpret_cast<sockaddr *>(&ss), sl) < 0)
+    {
+      err(TransportError::Bind, "bind: " + lastErr());
+      ::close(sfd);
+      return false;
+    }
+    if (::listen(sfd, 256) < 0)
+    {
+      err(TransportError::Listen, "listen: " + lastErr());
+      ::close(sfd);
+      return false;
+    }
 
+    auto lst = std::make_unique<Listener>();
+    lst->id = lc.id;
+    lst->fd = sfd;
+    lst->bind = lc.addr + ":" + std::to_string(lc.port);
+    lst->tls = lc.tls;
+    std::uint32_t ev = EPOLLIN;
+    if (_cfg.useEdgeTriggered)
+      ev |= EPOLLET;
+    addEpoll(sfd, ev);
+
+    auto tag = std::make_unique<Tag>();
+    tag->isListener = true;
+    tag->lst = lst.get();
+    _fdTags.emplace(sfd, std::move(tag));
+
+    _listeners.emplace(lst->id, std::move(lst));
+    return true;
+  }
+
+  void onListener(Listener *lst)
+  {
+    for (;;)
+    {
+      sockaddr_storage peer{};
+      socklen_t pl = sizeof(peer);
+      int cfd =
+        ::accept4(lst->fd, reinterpret_cast<sockaddr *>(&peer), &pl, SOCK_NONBLOCK | SOCK_CLOEXEC);
       if (cfd < 0)
       {
-        std::lock_guard<std::mutex> g(_cbMutex);
-        if (_cbs.onConnect)
+        if (errno == EAGAIN || errno == EWOULDBLOCK)
         {
-          _cbs.onConnect(cr.sid, IoResult::failure(TransportError::Connect,
-                                                   lastErr(), errno, 0));
+          break;
         }
-        err(TransportError::Connect, "connect: " + lastErr());
-        return false;
+        err(TransportError::Accept, "accept4: " + lastErr());
+        break;
       }
+      applySockOpts(cfd);
 
+      SessionId sid = _nextSessionId++;
       auto s = std::make_unique<Session>();
-      s->id = cr.sid;
+      s->id = sid;
       s->fd = cfd;
+      std::memcpy(&s->peer, &peer, pl);
+      s->peerLen = pl;
+      s->peerKey = keyFromSockaddr(peer);
       s->created = MonoClock::now();
       s->lastActivity = s->created;
       s->lastWriteProgress = s->created;
-      s->connectPending = true;
-      s->connectStart = MonoClock::now();
-      scheduleConnectTimeout(s.get());
-
-      if (chosen)
-      {
-        sockaddr_storage peer{};
-        socklen_t pl = (socklen_t) chosen->ai_addrlen;
-        std::memcpy(&peer, chosen->ai_addr, pl);
-        s->peerLen = pl;
-        s->peerKey = keyFromSockaddr(peer);
-        std::memcpy(&s->peer, &peer, pl);
-      }
 
-      if (cr.tls == TlsMode::Client && _cliTls.enabled && _sslCli)
+      if (lst->tls == TlsMode::Server && _srvTls.enabled && _sslSrv)
       {
-        s->tlsMode = TlsMode::Client;
-        s->ssl = ::SSL_new(_sslCli);
+        s->tlsMode = TlsMode::Server;
+        s->ssl = ::SSL_new(_sslSrv);
         if (!s->ssl)
         {
-          err(TransportError::TLSHandshake, "SSL_new(client) failed");
+          err(TransportError::TLSHandshake, "SSL_new(server) failed");
           ::close(cfd);
-          return false; // not inserted yet => no tags to clean
+          continue; // not inserted anywhere yet
         }
         ::SSL_set_fd(s->ssl, cfd);
-        ::SSL_set_connect_state(s->ssl);
+        ::SSL_set_accept_state(s->ssl);
         s->tlsState = TlsState::Handshake;
         s->tlsStart = MonoClock::now();
         scheduleHandshakeTimeout(s.get());
       }
 
-      _sessions.emplace(s->id, std::move(s));
+      _sessions.emplace(sid, std::move(s));
       bumpSess();
 
-      std::uint32_t ev = EPOLLIN | EPOLLOUT;
+      std::uint32_t ev = EPOLLIN;
       if (_cfg.useEdgeTriggered)
         ev |= EPOLLET;
       addEpoll(cfd, ev);
+
       auto tg = std::make_unique<Tag>();
       tg->isListener = false;
-      tg->sess = _sessions[cr.sid].get();
+      tg->sess = _sessions[sid].get();
       _fdTags.emplace(cfd, std::move(tg));
-      return true;
+
+      _atomicStats.accepted++;
+      std::lock_guard<std::mutex> g(_cbMutex);
+      if (_cbs.onAccept)
+      {
+        _cbs.onAccept(sid, _sessions[sid]->peerKey, IoResult::success());
+      }
     }
+  }
 
-    void onSession(Session* s, std::uint32_t events)
-    {
-      if (!s || s->closed)
+  bool doConnect(const ConnectReq &cr)
+  {
+    addrinfo hints{};
+    hints.ai_family = AF_UNSPEC;
+    hints.ai_socktype = SOCK_STREAM;
+    hints.ai_protocol = IPPROTO_TCP;
+    addrinfo *res = nullptr;
+    std::string ps = std::to_string(cr.port);
+
+    // CRITICAL FIX: Skip getaddrinfo() for IP addresses to prevent I/O thread
+    // from hanging For IP addresses, we can directly use them without DNS
+    // resolution
+    int rc = 0;
+
+    // Check if host is already an IP address (IPv4 or IPv6)
+    struct sockaddr_in sa4;
+    struct sockaddr_in6 sa6;
+    bool isIPv4 = (inet_pton(AF_INET, cr.host.c_str(), &(sa4.sin_addr)) == 1);
+    bool isIPv6 = (inet_pton(AF_INET6, cr.host.c_str(), &(sa6.sin6_addr)) == 1);
+
+    if (isIPv4 || isIPv6)
+    {
+      // For IP addresses, create minimal addrinfo structure manually
+      res = new addrinfo();
+      memset(res, 0, sizeof(addrinfo));
+      res->ai_family = isIPv4 ? AF_INET : AF_INET6;
+      res->ai_socktype = SOCK_STREAM;
+      res->ai_protocol = IPPROTO_TCP;
+
+      if (isIPv4)
+      {
+        res->ai_addrlen = sizeof(sockaddr_in);
+        auto *addr4 = new sockaddr_in();
+        memset(addr4, 0, sizeof(sockaddr_in));
+        addr4->sin_family = AF_INET;
+        addr4->sin_port = htons(cr.port);
+        addr4->sin_addr = sa4.sin_addr;
+        res->ai_addr = reinterpret_cast<sockaddr *>(addr4);
+      }
+      else
       {
-        return;
+        res->ai_addrlen = sizeof(sockaddr_in6);
+        auto *addr6 = new sockaddr_in6();
+        memset(addr6, 0, sizeof(sockaddr_in6));
+        addr6->sin6_family = AF_INET6;
+        addr6->sin6_port = htons(cr.port);
+        addr6->sin6_addr = sa6.sin6_addr;
+        res->ai_addr = reinterpret_cast<sockaddr *>(addr6);
       }
+      rc = 0; // Success
+    }
+    else
+    {
+      // For hostnames, use getaddrinfo with timeout
+      auto dnsTimeout = std::chrono::seconds(2);
+      auto dnsResult =
+        std::async(std::launch::async,
+                   [&]() { return ::getaddrinfo(cr.host.c_str(), ps.c_str(), &hints, &res); });
 
-      if (events & EPOLLOUT)
+      auto dnsStatus = dnsResult.wait_for(dnsTimeout);
+      if (dnsStatus == std::future_status::timeout)
       {
-        int err = 0;
-        socklen_t el = sizeof(err);
-        if (::getsockopt(s->fd, SOL_SOCKET, SO_ERROR, &err, &el) == 0 &&
-            err != 0)
+        std::lock_guard<std::mutex> g(_cbMutex);
+        std::string timeoutMsg = "DNS_TIMEOUT_FIX_TRIGGERED: getaddrinfo timeout after " +
+                                 std::to_string(dnsTimeout.count()) + "s for " + cr.host + ":" + ps;
+        if (_cbs.onConnect)
         {
-          closeNow(s, TransportError::Connect, std::strerror(err), 0);
-          return;
+          _cbs.onConnect(cr.sid, IoResult::failure(TransportError::Resolve, timeoutMsg));
         }
+        err(TransportError::Resolve, timeoutMsg);
+        return false;
+      }
+
+      rc = dnsResult.get();
+    }
+    if (rc != 0 || !res)
+    {
+      std::lock_guard<std::mutex> g(_cbMutex);
+      if (_cbs.onConnect)
+      {
+        _cbs.onConnect(cr.sid, IoResult::failure(TransportError::Resolve,
+                                                 std::string("getaddrinfo: ") + gai_strerror(rc)));
       }
+      err(TransportError::Resolve, "getaddrinfo failed");
+      return false;
+    }
 
-      if (s->tlsMode != TlsMode::None && s->tlsState == TlsState::Handshake)
+    int cfd = -1;
+    addrinfo *chosen = nullptr;
+    for (addrinfo *ai = res; ai; ai = ai->ai_next)
+    {
+      cfd = ::socket(ai->ai_family, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
+      if (cfd < 0)
       {
-        if (!driveHandshake(s))
-        {
-          return;
-        } // progressed or closed; if still handshaking, return
+        continue;
       }
-      else
+      applySockOpts(cfd);
+      int connectResult = ::connect(cfd, ai->ai_addr, ai->ai_addrlen);
+      if (connectResult == 0 || errno == EINPROGRESS)
+      {
+        chosen = ai;
+        break;
+      }
+      // CRITICAL FIX for SIP: Immediately handle connection refused for local
+      // connections This prevents hanging when connecting to non-existent
+      // local ports
+      if (errno == ECONNREFUSED || errno == ENETUNREACH || errno == EHOSTUNREACH)
       {
-        if (events & EPOLLOUT)
+        // Connection definitively failed - don't retry other addresses for
+        // same host
+        ::close(cfd);
+        cfd = -1;
+
+        // Clean up addrinfo before returning
+        if (isIPv4 || isIPv6)
         {
-          std::lock_guard<std::mutex> g(_cbMutex);
-          if (_cbs.onConnect)
+          if (res && res->ai_addr)
           {
-            _atomicStats.connected++;
-            _cbs.onConnect(s->id, IoResult::success());
+            delete res->ai_addr;
           }
-          s->connectPending = false;
-          s->lastWriteProgress = MonoClock::now();
-          cancelConnectTimeout(s);
-          updateInterest(s);
+          delete res;
+        }
+        else
+        {
+          ::freeaddrinfo(res);
+        }
+
+        // Report immediate failure
+        std::lock_guard<std::mutex> g(_cbMutex);
+        if (_cbs.onConnect)
+        {
+          std::string errMsg =
+            "Connection refused to " + cr.host + ":" + ps.c_str() + " - " + lastErr();
+          _cbs.onConnect(cr.sid, IoResult::failure(TransportError::Connect, errMsg, errno, 0));
         }
+        err(TransportError::Connect, "connect immediately failed: " + lastErr());
+        return false;
       }
+      ::close(cfd);
+      cfd = -1;
+    }
 
-      // Handle error conditions first (connection closed, etc.)
-      if (events & (EPOLLHUP | EPOLLERR))
+    // Custom cleanup for manually created addrinfo structure
+    if (isIPv4 || isIPv6)
+    {
+      if (res && res->ai_addr)
       {
-        core::Logger::debug(
-            "Transport: Detected EPOLLHUP/EPOLLERR for session " +
-            std::to_string(s->id) + ", events=0x" + std::to_string(events));
-        closeNow(s, TransportError::PeerClosed,
-                 "Connection closed by peer (EPOLLHUP/EPOLLERR)", 0);
-        return;
+        delete res->ai_addr;
       }
+      delete res;
+    }
+    else
+    {
+      ::freeaddrinfo(res);
+    }
 
-      if (events & EPOLLIN)
+    if (cfd < 0)
+    {
+      std::lock_guard<std::mutex> g(_cbMutex);
+      if (_cbs.onConnect)
       {
-        readAvail(s);
+        _cbs.onConnect(cr.sid, IoResult::failure(TransportError::Connect, lastErr(), errno, 0));
       }
-      if (events & EPOLLOUT)
+      err(TransportError::Connect, "connect: " + lastErr());
+      return false;
+    }
+
+    auto s = std::make_unique<Session>();
+    s->id = cr.sid;
+    s->fd = cfd;
+    s->created = MonoClock::now();
+    s->lastActivity = s->created;
+    s->lastWriteProgress = s->created;
+    s->connectPending = true;
+    s->connectStart = MonoClock::now();
+    scheduleConnectTimeout(s.get());
+
+    if (chosen)
+    {
+      sockaddr_storage peer{};
+      socklen_t pl = (socklen_t)chosen->ai_addrlen;
+      std::memcpy(&peer, chosen->ai_addr, pl);
+      s->peerLen = pl;
+      s->peerKey = keyFromSockaddr(peer);
+      std::memcpy(&s->peer, &peer, pl);
+    }
+
+    if (cr.tls == TlsMode::Client && _cliTls.enabled && _sslCli)
+    {
+      s->tlsMode = TlsMode::Client;
+      s->ssl = ::SSL_new(_sslCli);
+      if (!s->ssl)
       {
-        writePending(s);
+        err(TransportError::TLSHandshake, "SSL_new(client) failed");
+        ::close(cfd);
+        return false; // not inserted yet => no tags to clean
       }
+      ::SSL_set_fd(s->ssl, cfd);
+      ::SSL_set_connect_state(s->ssl);
+      s->tlsState = TlsState::Handshake;
+      s->tlsStart = MonoClock::now();
+      scheduleHandshakeTimeout(s.get());
+    }
+
+    _sessions.emplace(s->id, std::move(s));
+    bumpSess();
+
+    std::uint32_t ev = EPOLLIN | EPOLLOUT;
+    if (_cfg.useEdgeTriggered)
+      ev |= EPOLLET;
+    addEpoll(cfd, ev);
+    auto tg = std::make_unique<Tag>();
+    tg->isListener = false;
+    tg->sess = _sessions[cr.sid].get();
+    _fdTags.emplace(cfd, std::move(tg));
+    return true;
+  }
+
+  void onSession(Session *s, std::uint32_t events)
+  {
+    if (!s || s->closed)
+    {
+      return;
     }
 
-    bool driveHandshake(Session* s)
+    if (events & EPOLLOUT)
     {
-      // Only check timeout here if high-resolution timers are not available
-      if (!_timerService && _cfg.handshakeTimeout.count() > 0 &&
-          (MonoClock::now() - s->tlsStart) > std::chrono::duration_cast<std::chrono::seconds>(_cfg.handshakeTimeout))
+      int err = 0;
+      socklen_t el = sizeof(err);
+      if (::getsockopt(s->fd, SOL_SOCKET, SO_ERROR, &err, &el) == 0 && err != 0)
       {
-        closeNow(s, TransportError::TLSHandshake, "TLS handshake timeout", 0);
-        return false;
+        closeNow(s, TransportError::Connect, std::strerror(err), 0);
+        return;
       }
+    }
 
-      int rc = ::SSL_do_handshake(s->ssl);
-      if (rc == 1)
+    if (s->tlsMode != TlsMode::None && s->tlsState == TlsState::Handshake)
+    {
+      if (!driveHandshake(s))
       {
-        s->tlsState = TlsState::Open;
-        _atomicStats.tlsHandshakes++;
-        cancelHandshakeTimeout(s);
-
+        return;
+      } // progressed or closed; if still handshaking, return
+    }
+    else
+    {
+      if (events & EPOLLOUT)
+      {
+        std::lock_guard<std::mutex> g(_cbMutex);
+        if (_cbs.onConnect)
         {
-          std::lock_guard<std::mutex> g(_cbMutex);
-          if (_cbs.onConnect)
-          {
-            _atomicStats.connected++;
-            _cbs.onConnect(s->id, IoResult::success());
-          }
+          _atomicStats.connected++;
+          _cbs.onConnect(s->id, IoResult::success());
         }
         s->connectPending = false;
         s->lastWriteProgress = MonoClock::now();
         cancelConnectTimeout(s);
         updateInterest(s);
+      }
+    }
 
-        // BUGFIX: Immediately check for pending data after TLS handshake
-        // completion This fixes edge-triggered epoll missing initial data from
-        // server
-        readAvail(s);
+    // Handle error conditions first (connection closed, etc.)
+    if (events & (EPOLLHUP | EPOLLERR))
+    {
+      core::Logger::debug("Transport: Detected EPOLLHUP/EPOLLERR for session " +
+                          std::to_string(s->id) + ", events=0x" + std::to_string(events));
+      closeNow(s, TransportError::PeerClosed, "Connection closed by peer (EPOLLHUP/EPOLLERR)", 0);
+      return;
+    }
 
-        return true;
-      }
+    if (events & EPOLLIN)
+    {
+      readAvail(s);
+    }
+    if (events & EPOLLOUT)
+    {
+      writePending(s);
+    }
+  }
+
+  bool driveHandshake(Session *s)
+  {
+    // Only check timeout here if high-resolution timers are not available
+    if (!_timerService && _cfg.handshakeTimeout.count() > 0 &&
+        (MonoClock::now() - s->tlsStart) >
+          std::chrono::duration_cast<std::chrono::seconds>(_cfg.handshakeTimeout))
+    {
+      closeNow(s, TransportError::TLSHandshake, "TLS handshake timeout", 0);
+      return false;
+    }
+
+    int rc = ::SSL_do_handshake(s->ssl);
+    if (rc == 1)
+    {
+      s->tlsState = TlsState::Open;
+      _atomicStats.tlsHandshakes++;
+      cancelHandshakeTimeout(s);
 
-      int errc = ::SSL_get_error(s->ssl, rc);
-      if (errc == SSL_ERROR_WANT_READ || errc == SSL_ERROR_WANT_WRITE)
       {
-        updateInterest(s);
-        return false;
+        std::lock_guard<std::mutex> g(_cbMutex);
+        if (_cbs.onConnect)
+        {
+          _atomicStats.connected++;
+          _cbs.onConnect(s->id, IoResult::success());
+        }
       }
+      s->connectPending = false;
+      s->lastWriteProgress = MonoClock::now();
+      cancelConnectTimeout(s);
+      updateInterest(s);
+
+      // BUGFIX: Immediately check for pending data after TLS handshake
+      // completion This fixes edge-triggered epoll missing initial data from
+      // server
+      readAvail(s);
+
+      return true;
+    }
 
-      unsigned long e = ::ERR_get_error();
-      char msg[256];
-      ::ERR_error_string_n(e, msg, sizeof(msg));
-      closeNow(s, TransportError::TLSHandshake, msg, (int) e);
-      _atomicStats.tlsFailures++;
+    int errc = ::SSL_get_error(s->ssl, rc);
+    if (errc == SSL_ERROR_WANT_READ || errc == SSL_ERROR_WANT_WRITE)
+    {
+      updateInterest(s);
       return false;
     }
 
-    void readAvail(Session* s)
+    unsigned long e = ::ERR_get_error();
+    char msg[256];
+    ::ERR_error_string_n(e, msg, sizeof(msg));
+    closeNow(s, TransportError::TLSHandshake, msg, (int)e);
+    _atomicStats.tlsFailures++;
+    return false;
+  }
+
+  void readAvail(Session *s)
+  {
+    for (;;)
     {
-      for (;;)
+      std::vector<std::uint8_t> buf;
+      buf.resize(_cfg.ioReadChunk);
+      int n = 0;
+      if (s->tlsMode != TlsMode::None && s->tlsState == TlsState::Open)
       {
-        std::vector<std::uint8_t> buf;
-        buf.resize(_cfg.ioReadChunk);
-        int n = 0;
-        if (s->tlsMode != TlsMode::None && s->tlsState == TlsState::Open)
-        {
-          n = ::SSL_read(s->ssl, buf.data(), (int) buf.size());
-          if (n <= 0)
-          {
-            int ge = ::SSL_get_error(s->ssl, n);
-            if (ge == SSL_ERROR_WANT_READ || ge == SSL_ERROR_WANT_WRITE)
-            {
-              break;
-            }
-            if (ge == SSL_ERROR_ZERO_RETURN)
-            {
-              closeNow(s, TransportError::PeerClosed, "TLS peer closed", 0);
-              return;
-            }
-            unsigned long e = ::ERR_get_error();
-            char msg[256];
-            ::ERR_error_string_n(e, msg, sizeof(msg));
-            closeNow(s, TransportError::TLSIO, msg, (int) e);
-            return;
-          }
-        }
-        else
+        n = ::SSL_read(s->ssl, buf.data(), (int)buf.size());
+        if (n <= 0)
         {
-          n = ::recv(s->fd, buf.data(), (int) buf.size(), 0);
-          if (n < 0)
+          int ge = ::SSL_get_error(s->ssl, n);
+          if (ge == SSL_ERROR_WANT_READ || ge == SSL_ERROR_WANT_WRITE)
           {
-            if (errno == EAGAIN || errno == EWOULDBLOCK)
-            {
-              break;
-            }
-            closeNow(s, TransportError::Socket, lastErr(), 0);
-            return;
+            break;
           }
-          if (n == 0)
+          if (ge == SSL_ERROR_ZERO_RETURN)
           {
-            core::Logger::debug("Transport: recv() returned 0 for session " +
-                                std::to_string(s->id) +
-                                " - peer closed connection");
-            closeNow(s, TransportError::PeerClosed, "peer closed", 0);
+            closeNow(s, TransportError::PeerClosed, "TLS peer closed", 0);
             return;
           }
+          unsigned long e = ::ERR_get_error();
+          char msg[256];
+          ::ERR_error_string_n(e, msg, sizeof(msg));
+          closeNow(s, TransportError::TLSIO, msg, (int)e);
+          return;
         }
-
-        if (n > 0)
+      }
+      else
+      {
+        n = ::recv(s->fd, buf.data(), (int)buf.size(), 0);
+        if (n < 0)
         {
-          _atomicStats.bytesIn += n;
-          s->lastActivity = MonoClock::now();
-          std::lock_guard<std::mutex> g(_cbMutex);
-          if (_cbs.onData)
+          if (errno == EAGAIN || errno == EWOULDBLOCK)
           {
-            _cbs.onData(s->id, buf.data(), (std::size_t) n,
-                        IoResult::success());
+            break;
           }
+          closeNow(s, TransportError::Socket, lastErr(), 0);
+          return;
+        }
+        if (n == 0)
+        {
+          core::Logger::debug("Transport: recv() returned 0 for session " + std::to_string(s->id) +
+                              " - peer closed connection");
+          closeNow(s, TransportError::PeerClosed, "peer closed", 0);
+          return;
         }
-        else
+      }
+
+      if (n > 0)
+      {
+        _atomicStats.bytesIn += n;
+        s->lastActivity = MonoClock::now();
+        std::lock_guard<std::mutex> g(_cbMutex);
+        if (_cbs.onData)
         {
-          break;
+          _cbs.onData(s->id, buf.data(), (std::size_t)n, IoResult::success());
         }
       }
+      else
+      {
+        break;
+      }
     }
+  }
 
-    void writePending(Session* s)
+  void writePending(Session *s)
+  {
+    while (!s->wq.empty())
     {
-      while (!s->wq.empty())
+      ByteBuffer &d = s->wq.front();
+      int n = 0;
+      if (s->tlsMode != TlsMode::None && s->tlsState == TlsState::Open)
       {
-        ByteBuffer& d = s->wq.front();
-        int n = 0;
-        if (s->tlsMode != TlsMode::None && s->tlsState == TlsState::Open)
+        n = ::SSL_write(s->ssl, d.data(), (int)d.size());
+        if (n <= 0)
         {
-          n = ::SSL_write(s->ssl, d.data(), (int) d.size());
-          if (n <= 0)
+          int ge = ::SSL_get_error(s->ssl, n);
+          if (ge == SSL_ERROR_WANT_WRITE || ge == SSL_ERROR_WANT_READ)
           {
-            int ge = ::SSL_get_error(s->ssl, n);
-            if (ge == SSL_ERROR_WANT_WRITE || ge == SSL_ERROR_WANT_READ)
-            {
-              s->wantWrite = true;
-              updateInterest(s);
-              break;
-            }
-            unsigned long e = ::ERR_get_error();
-            char msg[256];
-            ::ERR_error_string_n(e, msg, sizeof(msg));
-            closeNow(s, TransportError::TLSIO, msg, (int) e);
-            return;
+            s->wantWrite = true;
+            updateInterest(s);
+            break;
           }
+          unsigned long e = ::ERR_get_error();
+          char msg[256];
+          ::ERR_error_string_n(e, msg, sizeof(msg));
+          closeNow(s, TransportError::TLSIO, msg, (int)e);
+          return;
         }
-        else
+      }
+      else
+      {
+        n = ::send(s->fd, d.data(), (int)d.size(), 0);
+        if (n < 0)
         {
-          n = ::send(s->fd, d.data(), (int) d.size(), 0);
-          if (n < 0)
+          if (errno == EAGAIN || errno == EWOULDBLOCK)
           {
-            if (errno == EAGAIN || errno == EWOULDBLOCK)
-            {
-              s->wantWrite = true;
-              updateInterest(s);
-              break;
-            }
-            closeNow(s, TransportError::Socket, lastErr(), 0);
-            return;
+            s->wantWrite = true;
+            updateInterest(s);
+            break;
           }
-        }
-
-        if (n >= 0)
-        {
-          _atomicStats.bytesOut += n;
-          s->lastWriteProgress = MonoClock::now();
-          s->wq.pop_front();
+          closeNow(s, TransportError::Socket, lastErr(), 0);
+          return;
         }
       }
 
-      if (s->wq.empty())
+      if (n >= 0)
       {
-        s->wantWrite = false;
-        cancelWriteStallTimeout(s);
-        updateInterest(s);
+        _atomicStats.bytesOut += n;
+        s->lastWriteProgress = MonoClock::now();
+        s->wq.pop_front();
       }
     }
 
-    void updateInterest(Session* s)
+    if (s->wq.empty())
     {
-      std::uint32_t ev = EPOLLIN;
-      if (_cfg.useEdgeTriggered)
-        ev |= EPOLLET;
-      if (s->wantWrite || !s->wq.empty() || s->tlsState == TlsState::Handshake)
-      {
-        ev |= EPOLLOUT;
-      }
-      modEpoll(s->fd, ev);
+      s->wantWrite = false;
+      cancelWriteStallTimeout(s);
+      updateInterest(s);
     }
+  }
 
-    void doSend(SendReq&& sr)
+  void updateInterest(Session *s)
+  {
+    std::uint32_t ev = EPOLLIN;
+    if (_cfg.useEdgeTriggered)
+      ev |= EPOLLET;
+    if (s->wantWrite || !s->wq.empty() || s->tlsState == TlsState::Handshake)
     {
-      auto it = _sessions.find(sr.sid);
-      if (it == _sessions.end())
-      {
-        return;
-      }
-      Session* s = it->second.get();
-      if (s->closed)
-      {
-        return;
-      }
+      ev |= EPOLLOUT;
+    }
+    modEpoll(s->fd, ev);
+  }
 
-      if (s->wq.empty())
+  void doSend(SendReq &&sr)
+  {
+    auto it = _sessions.find(sr.sid);
+    if (it == _sessions.end())
+    {
+      return;
+    }
+    Session *s = it->second.get();
+    if (s->closed)
+    {
+      return;
+    }
+
+    if (s->wq.empty())
+    {
+      int n = 0;
+      if (s->tlsMode != TlsMode::None && s->tlsState == TlsState::Open)
       {
-        int n = 0;
-        if (s->tlsMode != TlsMode::None && s->tlsState == TlsState::Open)
+        n = ::SSL_write(s->ssl, sr.payload.data(), (int)sr.payload.size());
+        if (n > 0)
         {
-          n = ::SSL_write(s->ssl, sr.payload.data(), (int) sr.payload.size());
-          if (n > 0)
-          {
-            _atomicStats.bytesOut += n;
-            s->lastActivity = MonoClock::now();
-            s->lastWriteProgress = MonoClock::now();
-            return;
-          }
-          int ge = ::SSL_get_error(s->ssl, n);
-          if (!(ge == SSL_ERROR_WANT_WRITE || ge == SSL_ERROR_WANT_READ))
-          {
-            unsigned long e = ::ERR_get_error();
-            char msg[256];
-            ::ERR_error_string_n(e, msg, sizeof(msg));
-            closeNow(s, TransportError::TLSIO, msg, (int) e);
-            return;
-          }
+          _atomicStats.bytesOut += n;
+          s->lastActivity = MonoClock::now();
+          s->lastWriteProgress = MonoClock::now();
+          return;
         }
-        else
+        int ge = ::SSL_get_error(s->ssl, n);
+        if (!(ge == SSL_ERROR_WANT_WRITE || ge == SSL_ERROR_WANT_READ))
         {
-          n = ::send(s->fd, sr.payload.data(), (int) sr.payload.size(), 0);
-          if (n >= 0)
-          {
-            _atomicStats.bytesOut += n;
-            s->lastActivity = MonoClock::now();
-            s->lastWriteProgress = MonoClock::now();
-            return;
-          }
-          if (!(errno == EAGAIN || errno == EWOULDBLOCK))
-          {
-            closeNow(s, TransportError::Socket, lastErr(), 0);
-            return;
-          }
+          unsigned long e = ::ERR_get_error();
+          char msg[256];
+          ::ERR_error_string_n(e, msg, sizeof(msg));
+          closeNow(s, TransportError::TLSIO, msg, (int)e);
+          return;
         }
       }
-
-      s->wq.emplace_back(std::move(sr.payload));
-      if (s->wq.size() == 1)
-      {
-        // First item in queue - schedule write stall timeout
-        scheduleWriteStallTimeout(s);
-      }
-      if (s->wq.size() > _cfg.maxWriteQueue)
+      else
       {
-        _atomicStats.backpressureCloses++;
-        if (_cfg.closeOnBackpressure)
+        n = ::send(s->fd, sr.payload.data(), (int)sr.payload.size(), 0);
+        if (n >= 0)
         {
-          closeNow(s, TransportError::WriteBackpressure, "write queue overflow",
-                   0);
+          _atomicStats.bytesOut += n;
+          s->lastActivity = MonoClock::now();
+          s->lastWriteProgress = MonoClock::now();
           return;
         }
-        else
+        if (!(errno == EAGAIN || errno == EWOULDBLOCK))
         {
-          s->wq.pop_front();
+          closeNow(s, TransportError::Socket, lastErr(), 0);
+          return;
         }
       }
-      s->wantWrite = true;
-      updateInterest(s);
     }
 
-    void closeNow(Session* s, TransportError why, const std::string& msg,
-                  int tlsErr)
+    s->wq.emplace_back(std::move(sr.payload));
+    if (s->wq.size() == 1)
     {
-      if (!s || s->closed)
+      // First item in queue - schedule write stall timeout
+      scheduleWriteStallTimeout(s);
+    }
+    if (s->wq.size() > _cfg.maxWriteQueue)
+    {
+      _atomicStats.backpressureCloses++;
+      if (_cfg.closeOnBackpressure)
       {
+        closeNow(s, TransportError::WriteBackpressure, "write queue overflow", 0);
         return;
       }
-      core::Logger::debug("Transport: closeNow called for session " +
-                          std::to_string(s->id) + ", reason: " + msg);
-      s->closed = true;
-      cancelAllTimers(s);
+      else
+      {
+        s->wq.pop_front();
+      }
+    }
+    s->wantWrite = true;
+    updateInterest(s);
+  }
 
-      delEpoll(s->fd);
-      ::close(s->fd);
+  void closeNow(Session *s, TransportError why, const std::string &msg, int tlsErr)
+  {
+    if (!s || s->closed)
+    {
+      return;
+    }
+    core::Logger::debug("Transport: closeNow called for session " + std::to_string(s->id) +
+                        ", reason: " + msg);
+    s->closed = true;
+    cancelAllTimers(s);
+
+    delEpoll(s->fd);
+    ::close(s->fd);
+
+    auto tagIt = _fdTags.find(s->fd);
+    if (tagIt != _fdTags.end())
+    {
+      _fdTags.erase(tagIt);
+    }
 
-      auto tagIt = _fdTags.find(s->fd);
-      if (tagIt != _fdTags.end())
+    if (s->ssl)
+    {
+      ::SSL_shutdown(s->ssl);
+      ::SSL_free(s->ssl);
+      s->ssl = nullptr;
+    }
+
+    _atomicStats.closed++;
+    _atomicStats.sessionsCurrent--;
+
+    {
+      std::lock_guard<std::mutex> g(_cbMutex);
+
+      // CRITICAL FIX: If connection was still pending, this is a failed
+      // connect, not a closed connection
+      if (s->connectPending && _cbs.onConnect)
       {
-        _fdTags.erase(tagIt);
+        // Failed connection - call onConnect with failure
+        IoResult r = IoResult::failure(why, msg, errno, tlsErr);
+        _cbs.onConnect(s->id, r);
       }
-
-      if (s->ssl)
+      else if (_cbs.onClosed)
       {
-        ::SSL_shutdown(s->ssl);
-        ::SSL_free(s->ssl);
-        s->ssl = nullptr;
+        // Established connection was closed - call onClosed
+        IoResult r = (why == TransportError::None && msg.empty())
+                       ? IoResult::success()
+                       : IoResult::failure(why, msg, errno, tlsErr);
+        _cbs.onClosed(s->id, r);
       }
+    }
 
-      _atomicStats.closed++;
-      _atomicStats.sessionsCurrent--;
+    _sessions.erase(s->id);
+  }
 
-      {
-        std::lock_guard<std::mutex> g(_cbMutex);
+  void closeListenerNow(Listener *lst)
+  {
+    delEpoll(lst->fd);
+    ::close(lst->fd);
+    auto it = _fdTags.find(lst->fd);
+    if (it != _fdTags.end())
+    {
+      _fdTags.erase(it);
+    }
+  }
 
-        // CRITICAL FIX: If connection was still pending, this is a failed
-        // connect, not a closed connection
-        if (s->connectPending && _cbs.onConnect)
-        {
-          // Failed connection - call onConnect with failure
-          IoResult r = IoResult::failure(why, msg, errno, tlsErr);
-          _cbs.onConnect(s->id, r);
-        }
-        else if (_cbs.onClosed)
-        {
-          // Established connection was closed - call onClosed
-          IoResult r = (why == TransportError::None && msg.empty())
-                           ? IoResult::success()
-                           : IoResult::failure(why, msg, errno, tlsErr);
-          _cbs.onClosed(s->id, r);
-        }
-      }
+  void runGc()
+  {
+    _atomicStats.gcRuns++;
+    const auto now = MonoClock::now();
+    const bool age = _cfg.maxConnAge.count() > 0;
 
-      _sessions.erase(s->id);
-    }
+    std::vector<SessionId> toClose;
+    toClose.reserve(_sessions.size());
 
-    void closeListenerNow(Listener* lst)
+    for (auto &kv : _sessions)
     {
-      delEpoll(lst->fd);
-      ::close(lst->fd);
-      auto it = _fdTags.find(lst->fd);
-      if (it != _fdTags.end())
+      Session *s = kv.second.get();
+      if (s->closed)
       {
-        _fdTags.erase(it);
+        continue;
       }
-    }
 
-    void runGc()
-    {
-      _atomicStats.gcRuns++;
-      const auto now = MonoClock::now();
-      const bool age = _cfg.maxConnAge.count() > 0;
+      if (_cfg.idleTimeout.count() > 0 && (now - s->lastActivity) > _cfg.idleTimeout)
+      {
+        toClose.push_back(s->id);
+        _atomicStats.gcClosedIdle++;
+        continue;
+      }
 
-      std::vector<SessionId> toClose;
-      toClose.reserve(_sessions.size());
+      if (age && (now - s->created) > _cfg.maxConnAge)
+      {
+        toClose.push_back(s->id);
+        _atomicStats.gcClosedAged++;
+        continue;
+      }
 
-      for (auto& kv : _sessions)
+      // Use high-resolution timers if available, otherwise fall back to GC-based timeout checking
+      if (!_timerService)
       {
-        Session* s = kv.second.get();
-        if (s->closed)
+        if (s->tlsMode != TlsMode::None && s->tlsState == TlsState::Handshake &&
+            _cfg.handshakeTimeout.count() > 0 &&
+            (now - s->tlsStart) >
+              std::chrono::duration_cast<std::chrono::seconds>(_cfg.handshakeTimeout))
         {
+          toClose.push_back(s->id);
           continue;
         }
 
-        if (_cfg.idleTimeout.count() > 0 &&
-            (now - s->lastActivity) > _cfg.idleTimeout)
+        // Safety-net: connect timeout
+        if (_cfg.connectTimeout.count() > 0 && s->connectPending &&
+            (now - s->connectStart) >
+              std::chrono::duration_cast<std::chrono::seconds>(_cfg.connectTimeout))
         {
           toClose.push_back(s->id);
-          _atomicStats.gcClosedIdle++;
           continue;
         }
 
-        if (age && (now - s->created) > _cfg.maxConnAge)
+        // Safety-net: write stall with queued data
+        if (_cfg.writeStallTimeout.count() > 0 && !s->wq.empty() &&
+            (now - s->lastWriteProgress) >
+              std::chrono::duration_cast<std::chrono::seconds>(_cfg.writeStallTimeout))
         {
           toClose.push_back(s->id);
-          _atomicStats.gcClosedAged++;
           continue;
         }
-
-        // Use high-resolution timers if available, otherwise fall back to GC-based timeout checking
-        if (!_timerService)
-        {
-          if (s->tlsMode != TlsMode::None && s->tlsState == TlsState::Handshake &&
-              _cfg.handshakeTimeout.count() > 0 &&
-              (now - s->tlsStart) > std::chrono::duration_cast<std::chrono::seconds>(_cfg.handshakeTimeout))
-          {
-            toClose.push_back(s->id);
-            continue;
-          }
-
-          // Safety-net: connect timeout
-          if (_cfg.connectTimeout.count() > 0 && s->connectPending &&
-              (now - s->connectStart) > std::chrono::duration_cast<std::chrono::seconds>(_cfg.connectTimeout))
-          {
-            toClose.push_back(s->id);
-            continue;
-          }
-
-          // Safety-net: write stall with queued data
-          if (_cfg.writeStallTimeout.count() > 0 && !s->wq.empty() &&
-              (now - s->lastWriteProgress) > std::chrono::duration_cast<std::chrono::seconds>(_cfg.writeStallTimeout))
-          {
-            toClose.push_back(s->id);
-            continue;
-          }
-        }
       }
+    }
 
-      for (auto sid : toClose)
+    for (auto sid : toClose)
+    {
+      auto it = _sessions.find(sid);
+      if (it != _sessions.end())
       {
-        auto it = _sessions.find(sid);
-        if (it != _sessions.end())
-        {
-          closeNow(it->second.get(), TransportError::GCClosed,
-                   "GC safety-net timeout", 0);
-        }
+        closeNow(it->second.get(), TransportError::GCClosed, "GC safety-net timeout", 0);
       }
     }
+  }
 
-    void bumpSess()
+  void bumpSess()
+  {
+    auto cur = _atomicStats.sessionsCurrent.fetch_add(1) + 1;
+    auto pk = _atomicStats.sessionsPeak.load();
+    while (cur > pk && !_atomicStats.sessionsPeak.compare_exchange_weak(pk, cur))
     {
-      auto cur = _atomicStats.sessionsCurrent.fetch_add(1) + 1;
-      auto pk = _atomicStats.sessionsPeak.load();
-      while (cur > pk &&
-             !_atomicStats.sessionsPeak.compare_exchange_weak(pk, cur))
-      {
-      }
     }
+  }
 
-    void applySockOpts(int fd)
+  void applySockOpts(int fd)
+  {
+    if (_cfg.enableTcpNoDelay)
     {
-      if (_cfg.enableTcpNoDelay)
-      {
-        int one = 1;
-        (void) ::setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &one, sizeof(one));
-      }
-      if (_cfg.soRcvBuf > 0)
-      {
-        (void) ::setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &_cfg.soRcvBuf,
-                            sizeof(int));
-      }
-      if (_cfg.soSndBuf > 0)
-      {
-        (void) ::setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &_cfg.soSndBuf,
-                            sizeof(int));
-      }
-      if (_cfg.tcpKeepalive.enable)
-      {
-        int one = 1;
-        (void) ::setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &one, sizeof(one));
-        (void) ::setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE,
-                            &_cfg.tcpKeepalive.idleSec, sizeof(int));
-        (void) ::setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL,
-                            &_cfg.tcpKeepalive.intvlSec, sizeof(int));
-        (void) ::setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT,
-                            &_cfg.tcpKeepalive.cnt, sizeof(int));
-      }
+      int one = 1;
+      (void)::setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &one, sizeof(one));
+    }
+    if (_cfg.soRcvBuf > 0)
+    {
+      (void)::setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &_cfg.soRcvBuf, sizeof(int));
+    }
+    if (_cfg.soSndBuf > 0)
+    {
+      (void)::setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &_cfg.soSndBuf, sizeof(int));
     }
+    if (_cfg.tcpKeepalive.enable)
+    {
+      int one = 1;
+      (void)::setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &one, sizeof(one));
+      (void)::setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &_cfg.tcpKeepalive.idleSec, sizeof(int));
+      (void)::setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &_cfg.tcpKeepalive.intvlSec, sizeof(int));
+      (void)::setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &_cfg.tcpKeepalive.cnt, sizeof(int));
+    }
+  }
 
-    // ===== TLS ctx =====
+  // ===== TLS ctx =====
 
-    static void buildAlpnWire(const std::string& list,
-                              std::vector<unsigned char>& out)
+  static void buildAlpnWire(const std::string &list, std::vector<unsigned char> &out)
+  {
+    out.clear();
+    std::size_t i = 0;
+    while (i < list.size())
     {
-      out.clear();
-      std::size_t i = 0;
-      while (i < list.size())
+      std::size_t j = list.find(';', i);
+      if (j == std::string::npos)
       {
-        std::size_t j = list.find(';', i);
-        if (j == std::string::npos)
-        {
-          j = list.size();
-        }
-        std::size_t len = j - i;
-        if (len > 0 && len <= 255)
-        {
-          out.push_back((unsigned char) len);
-          out.insert(out.end(), list.begin() + i, list.begin() + j);
-        }
-        i = j + 1;
+        j = list.size();
       }
+      std::size_t len = j - i;
+      if (len > 0 && len <= 255)
+      {
+        out.push_back((unsigned char)len);
+        out.insert(out.end(), list.begin() + i, list.begin() + j);
+      }
+      i = j + 1;
     }
+  }
 
-    bool initTls()
+  bool initTls()
+  {
+    // Server
+    if (_srvTls.enabled && _srvTls.defaultMode == TlsMode::Server)
     {
-      // Server
-      if (_srvTls.enabled && _srvTls.defaultMode == TlsMode::Server)
+      _sslSrv = ::SSL_CTX_new(TLS_server_method());
+      if (!_sslSrv)
+      {
+        setLastFatal(IoResult::failure(TransportError::Config, "SSL_CTX_new(server) failed"));
+        err(TransportError::Config, "SSL_CTX_new(server)");
+        return false;
+      }
+      if (!_srvTls.ciphers.empty())
+      {
+        ::SSL_CTX_set_cipher_list(_sslSrv, _srvTls.ciphers.c_str());
+      }
+      if (!_srvTls.certFile.empty() && !_srvTls.keyFile.empty())
       {
-        _sslSrv = ::SSL_CTX_new(TLS_server_method());
-        if (!_sslSrv)
+        if (::SSL_CTX_use_certificate_file(_sslSrv, _srvTls.certFile.c_str(), SSL_FILETYPE_PEM) !=
+              1 ||
+            ::SSL_CTX_use_PrivateKey_file(_sslSrv, _srvTls.keyFile.c_str(), SSL_FILETYPE_PEM) != 1)
         {
-          setLastFatal(IoResult::failure(TransportError::Config,
-                                         "SSL_CTX_new(server) failed"));
-          err(TransportError::Config, "SSL_CTX_new(server)");
+          setLastFatal(IoResult::failure(TransportError::Config, "load server cert/key failed"));
+          err(TransportError::Config, "load server cert/key");
           return false;
         }
-        if (!_srvTls.ciphers.empty())
-        {
-          ::SSL_CTX_set_cipher_list(_sslSrv, _srvTls.ciphers.c_str());
-        }
-        if (!_srvTls.certFile.empty() && !_srvTls.keyFile.empty())
+      }
+      if (_srvTls.verifyPeer)
+      {
+        ::SSL_CTX_set_verify(_sslSrv, SSL_VERIFY_PEER, nullptr);
+        if (!_srvTls.caFile.empty())
         {
-          if (::SSL_CTX_use_certificate_file(_sslSrv, _srvTls.certFile.c_str(),
-                                             SSL_FILETYPE_PEM) != 1 ||
-              ::SSL_CTX_use_PrivateKey_file(_sslSrv, _srvTls.keyFile.c_str(),
-                                            SSL_FILETYPE_PEM) != 1)
+          if (::SSL_CTX_load_verify_locations(_sslSrv, _srvTls.caFile.c_str(), nullptr) != 1)
           {
-            setLastFatal(IoResult::failure(TransportError::Config,
-                                           "load server cert/key failed"));
-            err(TransportError::Config, "load server cert/key");
+            setLastFatal(IoResult::failure(TransportError::Config, "server load CA failed"));
+            err(TransportError::Config, "server load CA");
             return false;
           }
         }
-        if (_srvTls.verifyPeer)
+        else
         {
-          ::SSL_CTX_set_verify(_sslSrv, SSL_VERIFY_PEER, nullptr);
-          if (!_srvTls.caFile.empty())
+          ::SSL_CTX_set_default_verify_paths(_sslSrv);
+        }
+      }
+      if (!_srvTls.alpn.empty())
+      {
+        _alpnPref.clear();
+        buildAlpnWire(_srvTls.alpn, _alpnPref);
+        (void)::SSL_CTX_set_alpn_select_cb(
+          _sslSrv,
+          [](SSL *, const unsigned char **out, unsigned char *outlen, const unsigned char *in,
+             unsigned int inlen, void *arg) -> int
           {
-            if (::SSL_CTX_load_verify_locations(_sslSrv, _srvTls.caFile.c_str(),
-                                                nullptr) != 1)
+            auto *pref = static_cast<std::vector<unsigned char> *>(arg);
+            if (pref && !pref->empty() && in && inlen > 0)
             {
-              setLastFatal(IoResult::failure(TransportError::Config,
-                                             "server load CA failed"));
-              err(TransportError::Config, "server load CA");
-              return false;
-            }
-          }
-          else
-          {
-            ::SSL_CTX_set_default_verify_paths(_sslSrv);
-          }
-        }
-        if (!_srvTls.alpn.empty())
-        {
-          _alpnPref.clear();
-          buildAlpnWire(_srvTls.alpn, _alpnPref);
-          (void) ::SSL_CTX_set_alpn_select_cb(
-              _sslSrv,
-              [](SSL*, const unsigned char** out, unsigned char* outlen,
-                 const unsigned char* in, unsigned int inlen, void* arg) -> int
+              // Minimal: pick the first protocol advertised by the client.
+              // (Replace with real preference matching if needed.)
+              const unsigned char *p = in;
+              unsigned int left = inlen;
+              while (left > 0)
               {
-                auto* pref = static_cast<std::vector<unsigned char>*>(arg);
-                if (pref && !pref->empty() && in && inlen > 0)
+                unsigned int l = *p++;
+                if (l > 0 && left >= (1 + l))
                 {
-                  // Minimal: pick the first protocol advertised by the client.
-                  // (Replace with real preference matching if needed.)
-                  const unsigned char* p = in;
-                  unsigned int left = inlen;
-                  while (left > 0)
-                  {
-                    unsigned int l = *p++;
-                    if (l > 0 && left >= (1 + l))
-                    {
-                      *out = p - 1;
-                      *outlen = (unsigned char) (l + 1);
-                      return SSL_TLSEXT_ERR_OK;
-                    }
-                    p += l;
-                    left -= (1 + l);
-                  }
+                  *out = p - 1;
+                  *outlen = (unsigned char)(l + 1);
+                  return SSL_TLSEXT_ERR_OK;
                 }
-                return SSL_TLSEXT_ERR_NOACK;
-              },
-              &_alpnPref);
-        }
+                p += l;
+                left -= (1 + l);
+              }
+            }
+            return SSL_TLSEXT_ERR_NOACK;
+          },
+          &_alpnPref);
       }
+    }
 
-      // Client
-      if (_cliTls.enabled && _cliTls.defaultMode == TlsMode::Client)
+    // Client
+    if (_cliTls.enabled && _cliTls.defaultMode == TlsMode::Client)
+    {
+      _sslCli = ::SSL_CTX_new(TLS_client_method());
+      if (!_sslCli)
       {
-        _sslCli = ::SSL_CTX_new(TLS_client_method());
-        if (!_sslCli)
-        {
-          setLastFatal(IoResult::failure(TransportError::Config,
-                                         "SSL_CTX_new(client) failed"));
-          err(TransportError::Config, "SSL_CTX_new(client)");
-          return false;
-        }
-        if (!_cliTls.ciphers.empty())
-        {
-          ::SSL_CTX_set_cipher_list(_sslCli, _cliTls.ciphers.c_str());
-        }
-        if (_cliTls.verifyPeer)
+        setLastFatal(IoResult::failure(TransportError::Config, "SSL_CTX_new(client) failed"));
+        err(TransportError::Config, "SSL_CTX_new(client)");
+        return false;
+      }
+      if (!_cliTls.ciphers.empty())
+      {
+        ::SSL_CTX_set_cipher_list(_sslCli, _cliTls.ciphers.c_str());
+      }
+      if (_cliTls.verifyPeer)
+      {
+        ::SSL_CTX_set_verify(_sslCli, SSL_VERIFY_PEER, nullptr);
+        if (!_cliTls.caFile.empty())
         {
-          ::SSL_CTX_set_verify(_sslCli, SSL_VERIFY_PEER, nullptr);
-          if (!_cliTls.caFile.empty())
-          {
-            if (::SSL_CTX_load_verify_locations(_sslCli, _cliTls.caFile.c_str(),
-                                                nullptr) != 1)
-            {
-              setLastFatal(IoResult::failure(TransportError::Config,
-                                             "client load CA failed"));
-              err(TransportError::Config, "client load CA");
-              return false;
-            }
-          }
-          else
+          if (::SSL_CTX_load_verify_locations(_sslCli, _cliTls.caFile.c_str(), nullptr) != 1)
           {
-            ::SSL_CTX_set_default_verify_paths(_sslCli);
+            setLastFatal(IoResult::failure(TransportError::Config, "client load CA failed"));
+            err(TransportError::Config, "client load CA");
+            return false;
           }
         }
-        if (!_cliTls.alpn.empty())
+        else
         {
-          std::vector<unsigned char> wire;
-          buildAlpnWire(_cliTls.alpn, wire);
-          (void) ::SSL_CTX_set_alpn_protos(_sslCli, wire.data(),
-                                           (unsigned int) wire.size());
+          ::SSL_CTX_set_default_verify_paths(_sslCli);
         }
       }
-
-      return true;
-    }
-
-    void freeTls()
-    {
-      if (_sslSrv)
-      {
-        ::SSL_CTX_free(_sslSrv);
-        _sslSrv = nullptr;
-      }
-      if (_sslCli)
+      if (!_cliTls.alpn.empty())
       {
-        ::SSL_CTX_free(_sslCli);
-        _sslCli = nullptr;
+        std::vector<unsigned char> wire;
+        buildAlpnWire(_cliTls.alpn, wire);
+        (void)::SSL_CTX_set_alpn_protos(_sslCli, wire.data(), (unsigned int)wire.size());
       }
     }
 
-  private:
-    struct AtomicStats
+    return true;
+  }
+
+  void freeTls()
+  {
+    if (_sslSrv)
+    {
+      ::SSL_CTX_free(_sslSrv);
+      _sslSrv = nullptr;
+    }
+    if (_sslCli)
     {
-      std::atomic<std::uint64_t> accepted{0}, connected{0}, closed{0},
-          errors{0}, tlsHandshakes{0}, tlsFailures{0}, bytesIn{0}, bytesOut{0},
-          epollWakeups{0}, commands{0}, gcRuns{0}, gcClosedIdle{0},
-          gcClosedAged{0}, backpressureCloses{0};
-      std::atomic<std::size_t> sessionsCurrent{0}, sessionsPeak{0};
-    };
+      ::SSL_CTX_free(_sslCli);
+      _sslCli = nullptr;
+    }
+  }
 
-    Config _cfg{};
-    TlsConfig _srvTls{}, _cliTls{};
-    mutable AtomicStats _atomicStats{};
+private:
+  struct AtomicStats
+  {
+    std::atomic<std::uint64_t> accepted{0}, connected{0}, closed{0}, errors{0}, tlsHandshakes{0},
+      tlsFailures{0}, bytesIn{0}, bytesOut{0}, epollWakeups{0}, commands{0}, gcRuns{0},
+      gcClosedIdle{0}, gcClosedAged{0}, backpressureCloses{0};
+    std::atomic<std::size_t> sessionsCurrent{0}, sessionsPeak{0};
+  };
 
-    std::atomic<bool> _running{false};
-    int _epollFd{-1}, _eventFd{-1}, _timerFd{-1};
-    std::thread _loop;
+  Config _cfg{};
+  TlsConfig _srvTls{}, _cliTls{};
+  mutable AtomicStats _atomicStats{};
 
-    std::mutex _cbMutex;
-    Callbacks _cbs{};
+  std::atomic<bool> _running{false};
+  int _epollFd{-1}, _eventFd{-1}, _timerFd{-1};
+  std::thread _loop;
 
-    std::mutex _cmdMutex;
-    std::deque<Command> _cmds;
+  std::mutex _cbMutex;
+  Callbacks _cbs{};
 
-    std::unordered_map<ListenerId, std::unique_ptr<Listener>> _listeners;
-    std::unordered_map<SessionId, std::unique_ptr<Session>> _sessions;
-    std::unordered_map<int, std::unique_ptr<Tag>> _fdTags;
+  std::mutex _cmdMutex;
+  std::deque<Command> _cmds;
 
-    std::atomic<SessionId> _nextSessionId{1};
-    std::atomic<ListenerId> _nextListenerId{1};
+  std::unordered_map<ListenerId, std::unique_ptr<Listener>> _listeners;
+  std::unordered_map<SessionId, std::unique_ptr<Session>> _sessions;
+  std::unordered_map<int, std::unique_ptr<Tag>> _fdTags;
 
-    // TLS contexts and per-instance ALPN preference
-    SSL_CTX* _sslSrv{nullptr};
-    SSL_CTX* _sslCli{nullptr};
-    std::vector<unsigned char> _alpnPref;
+  std::atomic<SessionId> _nextSessionId{1};
+  std::atomic<ListenerId> _nextListenerId{1};
 
-    // Sticky fatal (for start/init failures)
-    mutable std::mutex _fatalMx;
-    mutable IoResult _lastFatal{IoResult::success()};
+  // TLS contexts and per-instance ALPN preference
+  SSL_CTX *_sslSrv{nullptr};
+  SSL_CTX *_sslCli{nullptr};
+  std::vector<unsigned char> _alpnPref;
 
-    // High-resolution timer service
-    std::unique_ptr<iora::core::TimerService> _timerService;
-    iora::core::TimerServiceConfig _timerConfig;
+  // Sticky fatal (for start/init failures)
+  mutable std::mutex _fatalMx;
+  mutable IoResult _lastFatal{IoResult::success()};
 
-    // Static SSL initialization coordination
-    static std::once_flag _sslGlobalInitFlag;
-    static std::atomic<int> debugInstanceCount;
-    static void initSslGlobal();
-  };
+  // High-resolution timer service
+  std::unique_ptr<iora::core::TimerService> _timerService;
+  iora::core::TimerServiceConfig _timerConfig;
 
-  // Static member definitions
-  std::once_flag SharedTransport::_sslGlobalInitFlag;
-  std::atomic<int> SharedTransport::debugInstanceCount{0};
+  // Static SSL initialization coordination
+  static std::once_flag _sslGlobalInitFlag;
+  static std::atomic<int> debugInstanceCount;
+  static void initSslGlobal();
+};
 
-  void SharedTransport::initSslGlobal()
-  {
-    // Initialize OpenSSL library once per process
-    // This prevents deadlocks when multiple transports initialize
-    // simultaneously
+// Static member definitions
+std::once_flag SharedTransport::_sslGlobalInitFlag;
+std::atomic<int> SharedTransport::debugInstanceCount{0};
+
+void SharedTransport::initSslGlobal()
+{
+  // Initialize OpenSSL library once per process
+  // This prevents deadlocks when multiple transports initialize
+  // simultaneously
 #if OPENSSL_VERSION_NUMBER < 0x10100000L
-    // For OpenSSL < 1.1.0
-    SSL_load_error_strings();
-    SSL_library_init();
-    OpenSSL_add_all_algorithms();
+  // For OpenSSL < 1.1.0
+  SSL_load_error_strings();
+  SSL_library_init();
+  OpenSSL_add_all_algorithms();
 #else
-    // For OpenSSL >= 1.1.0, automatic initialization is handled by library
-    // But we can still call OPENSSL_init_ssl for explicit control
-    OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS |
-                         OPENSSL_INIT_LOAD_CRYPTO_STRINGS,
-                     nullptr);
+  // For OpenSSL >= 1.1.0, automatic initialization is handled by library
+  // But we can still call OPENSSL_init_ssl for explicit control
+  OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, nullptr);
 #endif
-  }
+}
 
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/shared_transport_udp.hpp b/include/iora/network/shared_transport_udp.hpp
old mode 100755
new mode 100644
index 3bdd18f..6e8be55
--- a/include/iora/network/shared_transport_udp.hpp
+++ b/include/iora/network/shared_transport_udp.hpp
@@ -10,115 +10,110 @@
 #error "Linux-only (epoll/eventfd/timerfd)"
 #endif
 
-#include "transport_types.hpp"
-#include "object_pool.hpp"
-#include "connection_health.hpp"
 #include "circuit_breaker.hpp"
+#include "connection_health.hpp"
+#include "object_pool.hpp"
+#include "transport_types.hpp"
+#include <arpa/inet.h>
 #include <atomic>
 #include <cerrno>
 #include <cstring>
 #include <deque>
+#include <fcntl.h>
 #include <functional>
 #include <memory>
 #include <mutex>
-#include <optional>
-#include <thread>
-#include <unordered_map>
-#include <utility>
-#include <arpa/inet.h>
-#include <fcntl.h>
 #include <netdb.h>
 #include <netinet/in.h>
+#include <optional>
 #include <signal.h>
 #include <sys/epoll.h>
 #include <sys/eventfd.h>
 #include <sys/socket.h>
 #include <sys/timerfd.h>
+#include <thread>
 #include <unistd.h>
+#include <unordered_map>
+#include <utility>
 
 namespace iora
 {
 namespace network
 {
 
-  class SharedUdpTransport
+class SharedUdpTransport
+{
+public:
+  /// \brief Returns the last error message from a failed operation.
+  std::string lastError() const
   {
-  public:
-    /// \brief Returns the last error message from a failed operation.
-    std::string lastError() const
-    {
-      std::lock_guard<std::mutex> lock(_errorMutex);
-      return _lastError;
-    }
+    std::lock_guard<std::mutex> lock(_errorMutex);
+    return _lastError;
+  }
 
-    struct Config
-    {
-      int epollMaxEvents = 128;
-      std::size_t ioReadChunk = 64 * 1024;
-      std::size_t maxWriteQueue = 256;
-      std::chrono::seconds idleTimeout{600};
-      std::chrono::seconds maxConnAge{std::chrono::seconds::zero()};
-      std::chrono::seconds handshakeTimeout{30}; // parity
-      std::chrono::seconds gcInterval{5};
-      int listenBacklog = 0;
-      std::size_t maxSessions = 0;
-      bool useEdgeTriggered = true;
-      bool closeOnBackpressure = true;
-      int soRcvBuf = 0, soSndBuf = 0;
-      // NEW: safety-net timers
-      std::chrono::seconds connectTimeout{30};
-      std::chrono::seconds writeStallTimeout{0};
-    };
-    struct TlsConfig
-    {
-      bool enabled = false;
-      TlsMode defaultMode = TlsMode::None;
-      std::string certFile, keyFile, caFile, ciphers, alpn;
-      bool verifyPeer = false;
-    };
-    struct Callbacks
-    {
-      std::function<void(SessionId, const std::string&, const IoResult&)>
-          onAccept;
-      std::function<void(SessionId, const IoResult&)> onConnect;
-      std::function<void(SessionId, const std::uint8_t*, std::size_t,
-                         const IoResult&)>
-          onData;
-      std::function<void(SessionId, const IoResult&)> onClosed;
-      std::function<void(TransportError, const std::string&)> onError;
-    };
-    struct Stats
-    {
-      std::uint64_t accepted{0}, connected{0}, closed{0}, errors{0},
-          tlsHandshakes{0}, tlsFailures{0}, bytesIn{0}, bytesOut{0},
-          epollWakeups{0}, commands{0}, gcRuns{0}, gcClosedIdle{0},
-          gcClosedAged{0}, backpressureCloses{0};
-      std::size_t sessionsCurrent{0}, sessionsPeak{0};
-    };
+  struct Config
+  {
+    int epollMaxEvents = 128;
+    std::size_t ioReadChunk = 64 * 1024;
+    std::size_t maxWriteQueue = 256;
+    std::chrono::seconds idleTimeout{600};
+    std::chrono::seconds maxConnAge{std::chrono::seconds::zero()};
+    std::chrono::seconds handshakeTimeout{30}; // parity
+    std::chrono::seconds gcInterval{5};
+    int listenBacklog = 0;
+    std::size_t maxSessions = 0;
+    bool useEdgeTriggered = true;
+    bool closeOnBackpressure = true;
+    int soRcvBuf = 0, soSndBuf = 0;
+    // NEW: safety-net timers
+    std::chrono::seconds connectTimeout{30};
+    std::chrono::seconds writeStallTimeout{0};
+  };
+  struct TlsConfig
+  {
+    bool enabled = false;
+    TlsMode defaultMode = TlsMode::None;
+    std::string certFile, keyFile, caFile, ciphers, alpn;
+    bool verifyPeer = false;
+  };
+  struct Callbacks
+  {
+    std::function<void(SessionId, const std::string &, const IoResult &)> onAccept;
+    std::function<void(SessionId, const IoResult &)> onConnect;
+    std::function<void(SessionId, const std::uint8_t *, std::size_t, const IoResult &)> onData;
+    std::function<void(SessionId, const IoResult &)> onClosed;
+    std::function<void(TransportError, const std::string &)> onError;
+  };
+  struct Stats
+  {
+    std::uint64_t accepted{0}, connected{0}, closed{0}, errors{0}, tlsHandshakes{0}, tlsFailures{0},
+      bytesIn{0}, bytesOut{0}, epollWakeups{0}, commands{0}, gcRuns{0}, gcClosedIdle{0},
+      gcClosedAged{0}, backpressureCloses{0};
+    std::size_t sessionsCurrent{0}, sessionsPeak{0};
+  };
 
-    SharedUdpTransport(const Config& cfg, const TlsConfig&, const TlsConfig&)
-      : _cfg(cfg),
-        _sessionPool([]() { return std::make_unique<Session>(); },
-                     [](Session* s)
-                     {
-                       if (s)
-                       {
-                         s->id = 0;
-                         s->role = Role::ServerPeer;
-                         s->fd = -1;
-                         s->owner = 0;
-                         s->pkey.clear();
-                         s->plen = 0;
-                         s->closed = false;
-                         s->connectPending = false;
-                         s->wantWrite = false;
-                         s->wq.clear();
-                       }
-                     },
-                     10) // Initial pool size
+  SharedUdpTransport(const Config &cfg, const TlsConfig &, const TlsConfig &)
+      : _cfg(cfg), _sessionPool([]() { return std::make_unique<Session>(); },
+                                [](Session *s)
+                                {
+                                  if (s)
+                                  {
+                                    s->id = 0;
+                                    s->role = Role::ServerPeer;
+                                    s->fd = -1;
+                                    s->owner = 0;
+                                    s->pkey.clear();
+                                    s->plen = 0;
+                                    s->closed = false;
+                                    s->connectPending = false;
+                                    s->wantWrite = false;
+                                    s->wq.clear();
+                                  }
+                                },
+                                10) // Initial pool size
         ,
         _listenerPool([]() { return std::make_unique<Listener>(); },
-                      [](Listener* l)
+                      [](Listener *l)
                       {
                         if (l)
                         {
@@ -130,952 +125,900 @@ namespace network
                         }
                       },
                       2) // Initial pool size
+  {
+  }
+
+  ~SharedUdpTransport() noexcept
+  {
+    try
     {
+      stop();
     }
-
-    ~SharedUdpTransport() noexcept
+    catch (...)
     {
-      try
-      {
-        stop();
-      }
-      catch (...)
-      {
-        // ignore exceptions in destructor
-      }
+      // ignore exceptions in destructor
     }
+  }
+
+  SharedUdpTransport(const SharedUdpTransport &) = delete;
+  SharedUdpTransport &operator=(const SharedUdpTransport &) = delete;
+  void setCallbacks(const Callbacks &c)
+  {
+    std::lock_guard<std::mutex> g(_cb);
+    _cbs = c;
+  }
 
-    SharedUdpTransport(const SharedUdpTransport&) = delete;
-    SharedUdpTransport& operator=(const SharedUdpTransport&) = delete;
-    void setCallbacks(const Callbacks& c)
+  bool start()
+  {
+    bool exp = false;
+    if (!_running.compare_exchange_strong(exp, true))
+      return false;
+    _epollFd = ::epoll_create1(EPOLL_CLOEXEC);
+    if (_epollFd < 0)
     {
-      std::lock_guard<std::mutex> g(_cb);
-      _cbs = c;
+      error(TransportError::Config, "epoll_create1: " + lastErr());
+      _running.store(false);
+      return false;
     }
-
-    bool start()
+    _eventFd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
+    if (_eventFd < 0)
     {
-      bool exp = false;
-      if (!_running.compare_exchange_strong(exp, true))
-        return false;
-      _epollFd = ::epoll_create1(EPOLL_CLOEXEC);
-      if (_epollFd < 0)
-      {
-        error(TransportError::Config, "epoll_create1: " + lastErr());
-        _running.store(false);
-        return false;
-      }
-      _eventFd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
-      if (_eventFd < 0)
-      {
-        error(TransportError::Config, "eventfd: " + lastErr());
-        cleanupFail();
-        return false;
-      }
-      addEpoll(_eventFd, EPOLLIN);
-      _timerFd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
-      if (_timerFd < 0)
-      {
-        error(TransportError::Config, "timerfd_create: " + lastErr());
-        cleanupFail();
-        return false;
-      }
-      addEpoll(_timerFd, EPOLLIN);
-      armGc(_cfg.gcInterval);
-      _loop = std::thread([this] { loop(); });
-      return true;
+      error(TransportError::Config, "eventfd: " + lastErr());
+      cleanupFail();
+      return false;
     }
-    void stop()
+    addEpoll(_eventFd, EPOLLIN);
+    _timerFd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
+    if (_timerFd < 0)
     {
-      bool exp = true;
-      if (!_running.compare_exchange_strong(exp, false))
-        return;
-      enqueue(Cmd::shutdown());
-      if (_loop.joinable())
-        _loop.join();
+      error(TransportError::Config, "timerfd_create: " + lastErr());
+      cleanupFail();
+      return false;
     }
+    addEpoll(_timerFd, EPOLLIN);
+    armGc(_cfg.gcInterval);
+    _loop = std::thread([this] { loop(); });
+    return true;
+  }
+  void stop()
+  {
+    bool exp = true;
+    if (!_running.compare_exchange_strong(exp, false))
+      return;
+    enqueue(Cmd::shutdown());
+    if (_loop.joinable())
+      _loop.join();
+  }
 
-    // Legacy async interface - returns ID immediately, validates later
-    ListenerId addListener(const std::string& bind, uint16_t port, TlsMode tls)
+  // Legacy async interface - returns ID immediately, validates later
+  ListenerId addListener(const std::string &bind, uint16_t port, TlsMode tls)
+  {
+    if (tls != TlsMode::None)
     {
-      if (tls != TlsMode::None)
-      {
-        error(TransportError::Config, "UDP does not support TLS/DTLS");
-        return 0;
-      }
-      ListenerCfg lc;
-      lc.id = _nextListenerId++;
-      lc.addr = bind;
-      lc.port = port;
-      enqueue(Cmd::addListener(lc));
-      return lc.id;
+      error(TransportError::Config, "UDP does not support TLS/DTLS");
+      return 0;
     }
+    ListenerCfg lc;
+    lc.id = _nextListenerId++;
+    lc.addr = bind;
+    lc.port = port;
+    enqueue(Cmd::addListener(lc));
+    return lc.id;
+  }
 
-    // New synchronous interface - validates immediately
-    ListenerResult addListenerSync(const std::string& bind, uint16_t port,
-                                   TlsMode tls)
+  // New synchronous interface - validates immediately
+  ListenerResult addListenerSync(const std::string &bind, uint16_t port, TlsMode tls)
+  {
+    if (tls != TlsMode::None)
     {
-      if (tls != TlsMode::None)
-      {
-        return ListenerResult::failure(TransportError::Config,
-                                       "UDP does not support TLS/DTLS");
-      }
+      return ListenerResult::failure(TransportError::Config, "UDP does not support TLS/DTLS");
+    }
 
-      // Immediate validation by attempting bind
-      auto result = validateBind(bind, port);
-      if (!result.result.ok)
-      {
-        return result;
-      }
+    // Immediate validation by attempting bind
+    auto result = validateBind(bind, port);
+    if (!result.result.ok)
+    {
+      return result;
+    }
 
-      // If validation passed, create listener normally
-      ListenerCfg lc;
-      lc.id = _nextListenerId++;
-      lc.addr = bind;
-      lc.port = port;
-      enqueue(Cmd::addListener(lc));
+    // If validation passed, create listener normally
+    ListenerCfg lc;
+    lc.id = _nextListenerId++;
+    lc.addr = bind;
+    lc.port = port;
+    enqueue(Cmd::addListener(lc));
 
-      return ListenerResult::success(lc.id, bind + ":" + std::to_string(port));
-    }
-    SessionId connect(const std::string& host, uint16_t port, TlsMode tls)
-    {
-      SessionId sid = _nextSessionId++;
-      ConnectReq cr;
-      cr.sid = sid;
-      cr.host = host;
-      cr.port = port;
-      cr.rejectTls = (tls != TlsMode::None);
-      enqueue(Cmd::connect(cr));
-      return sid;
-    }
-    SessionId connectViaListener(ListenerId lid, const std::string& host,
-                                 uint16_t port)
-    {
-      SessionId sid = _nextSessionId++;
-      ViaReq vr{sid, lid, host, port};
-      enqueue(Cmd::via(vr));
-      return sid;
-    }
-    bool send(SessionId sid, const void* p, std::size_t n)
-    {
-      if (n == 0)
-        return true;
-      ByteBuffer b(n);
-      std::memcpy(b.data(), p, n);
-      SendReq sr;
-      sr.sid = sid;
-      sr.payload = std::move(b);
-      return enqueue(Cmd::send(std::move(sr)));
-    }
-    bool close(SessionId sid) { return enqueue(Cmd::close(sid)); }
-    void reconfigure(const Config& cfg) { enqueue(Cmd::reconf(cfg)); }
-    Stats stats() const
-    {
-      Stats copy;
-      copy.accepted = _atomicStats.accepted.load();
-      copy.connected = _atomicStats.connected.load();
-      copy.closed = _atomicStats.closed.load();
-      copy.errors = _atomicStats.errors.load();
-      copy.tlsHandshakes = _atomicStats.tlsHandshakes.load();
-      copy.tlsFailures = _atomicStats.tlsFailures.load();
-      copy.bytesIn = _atomicStats.bytesIn.load();
-      copy.bytesOut = _atomicStats.bytesOut.load();
-      copy.epollWakeups = _atomicStats.epollWakeups.load();
-      copy.commands = _atomicStats.commands.load();
-      copy.gcRuns = _atomicStats.gcRuns.load();
-      copy.gcClosedIdle = _atomicStats.gcClosedIdle.load();
-      copy.gcClosedAged = _atomicStats.gcClosedAged.load();
-      copy.backpressureCloses = _atomicStats.backpressureCloses.load();
-      copy.sessionsCurrent = _atomicStats.sessionsCurrent.load();
-      copy.sessionsPeak = _atomicStats.sessionsPeak.load();
-      return copy;
-    }
+    return ListenerResult::success(lc.id, bind + ":" + std::to_string(port));
+  }
+  SessionId connect(const std::string &host, uint16_t port, TlsMode tls)
+  {
+    SessionId sid = _nextSessionId++;
+    ConnectReq cr;
+    cr.sid = sid;
+    cr.host = host;
+    cr.port = port;
+    cr.rejectTls = (tls != TlsMode::None);
+    enqueue(Cmd::connect(cr));
+    return sid;
+  }
+  SessionId connectViaListener(ListenerId lid, const std::string &host, uint16_t port)
+  {
+    SessionId sid = _nextSessionId++;
+    ViaReq vr{sid, lid, host, port};
+    enqueue(Cmd::via(vr));
+    return sid;
+  }
+  bool send(SessionId sid, const void *p, std::size_t n)
+  {
+    if (n == 0)
+      return true;
+    ByteBuffer b(n);
+    std::memcpy(b.data(), p, n);
+    SendReq sr;
+    sr.sid = sid;
+    sr.payload = std::move(b);
+    return enqueue(Cmd::send(std::move(sr)));
+  }
+  bool close(SessionId sid) { return enqueue(Cmd::close(sid)); }
+  void reconfigure(const Config &cfg) { enqueue(Cmd::reconf(cfg)); }
+  Stats stats() const
+  {
+    Stats copy;
+    copy.accepted = _atomicStats.accepted.load();
+    copy.connected = _atomicStats.connected.load();
+    copy.closed = _atomicStats.closed.load();
+    copy.errors = _atomicStats.errors.load();
+    copy.tlsHandshakes = _atomicStats.tlsHandshakes.load();
+    copy.tlsFailures = _atomicStats.tlsFailures.load();
+    copy.bytesIn = _atomicStats.bytesIn.load();
+    copy.bytesOut = _atomicStats.bytesOut.load();
+    copy.epollWakeups = _atomicStats.epollWakeups.load();
+    copy.commands = _atomicStats.commands.load();
+    copy.gcRuns = _atomicStats.gcRuns.load();
+    copy.gcClosedIdle = _atomicStats.gcClosedIdle.load();
+    copy.gcClosedAged = _atomicStats.gcClosedAged.load();
+    copy.backpressureCloses = _atomicStats.backpressureCloses.load();
+    copy.sessionsCurrent = _atomicStats.sessionsCurrent.load();
+    copy.sessionsPeak = _atomicStats.sessionsPeak.load();
+    return copy;
+  }
 
-  private:
-    static std::string lastErr()
-    {
-      int e = errno;
-      char buf[128];
+private:
+  static std::string lastErr()
+  {
+    int e = errno;
+    char buf[128];
 #if defined(__GLIBC__) && !defined(__APPLE__)
-      ::strerror_r(e, buf, sizeof(buf));
-      return std::string(buf);
+    ::strerror_r(e, buf, sizeof(buf));
+    return std::string(buf);
 #else
-      return std::string(std::strerror(e));
+    return std::string(std::strerror(e));
 #endif
+  }
+  bool addEpoll(int fd, uint32_t ev)
+  {
+    epoll_event e{};
+    e.events = ev;
+    e.data.fd = fd;
+    return ::epoll_ctl(_epollFd, EPOLL_CTL_ADD, fd, &e) == 0;
+  }
+  bool modEpoll(int fd, uint32_t ev)
+  {
+    epoll_event e{};
+    e.events = ev;
+    e.data.fd = fd;
+    return ::epoll_ctl(_epollFd, EPOLL_CTL_MOD, fd, &e) == 0;
+  }
+  void delEpoll(int fd) { ::epoll_ctl(_epollFd, EPOLL_CTL_DEL, fd, nullptr); }
+  void armGc(std::chrono::seconds s)
+  {
+    itimerspec its{};
+    its.it_interval.tv_sec = s.count();
+    its.it_value.tv_sec = s.count();
+    ::timerfd_settime(_timerFd, 0, &its, nullptr);
+  }
+  static std::string key(const sockaddr_storage &ss)
+  {
+    char h[NI_MAXHOST]{}, sv[NI_MAXSERV]{};
+    socklen_t sl = (ss.ss_family == AF_INET) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
+    if (getnameinfo(reinterpret_cast<const sockaddr *>(&ss), sl, h, sizeof(h), sv, sizeof(sv),
+                    NI_NUMERICHOST | NI_NUMERICSERV) == 0)
+    {
+      std::string o(h);
+      o.push_back(':');
+      o.append(sv);
+      return o;
     }
-    bool addEpoll(int fd, uint32_t ev)
+    return {};
+  }
+  int sockAf(int fd)
+  {
+    sockaddr_storage ss{};
+    socklen_t sl = sizeof(ss);
+    if (::getsockname(fd, reinterpret_cast<sockaddr *>(&ss), &sl) == 0)
+      return ss.ss_family;
+    return AF_UNSPEC;
+  }
+  void error(TransportError e, const std::string &m)
+  {
+    _atomicStats.errors++;
+    std::lock_guard<std::mutex> g(_cb);
+    if (_cbs.onError)
+      _cbs.onError(e, m);
+  }
+
+  enum class CmdType
+  {
+    Shutdown,
+    AddListener,
+    Connect,
+    Via,
+    Send,
+    Close,
+    Reconf
+  };
+  struct ListenerCfg
+  {
+    ListenerId id{};
+    std::string addr;
+    uint16_t port{};
+  };
+  struct ConnectReq
+  {
+    SessionId sid{};
+    std::string host;
+    uint16_t port{};
+    bool rejectTls{false};
+  };
+  struct ViaReq
+  {
+    SessionId sid{};
+    ListenerId lid{};
+    std::string host;
+    uint16_t port{};
+  };
+  struct SendReq
+  {
+    SessionId sid{};
+    ByteBuffer payload;
+  };
+  struct Cmd
+  {
+    CmdType t;
+    ListenerCfg l;
+    ConnectReq c;
+    ViaReq v;
+    SendReq s;
+    SessionId closeSid{};
+    Config cfg;
+    static Cmd shutdown()
     {
-      epoll_event e{};
-      e.events = ev;
-      e.data.fd = fd;
-      return ::epoll_ctl(_epollFd, EPOLL_CTL_ADD, fd, &e) == 0;
+      Cmd x;
+      x.t = CmdType::Shutdown;
+      return x;
     }
-    bool modEpoll(int fd, uint32_t ev)
+    static Cmd addListener(const ListenerCfg &lc)
     {
-      epoll_event e{};
-      e.events = ev;
-      e.data.fd = fd;
-      return ::epoll_ctl(_epollFd, EPOLL_CTL_MOD, fd, &e) == 0;
+      Cmd x;
+      x.t = CmdType::AddListener;
+      x.l = lc;
+      return x;
     }
-    void delEpoll(int fd)
+    static Cmd connect(const ConnectReq &cr)
     {
-      ::epoll_ctl(_epollFd, EPOLL_CTL_DEL, fd, nullptr);
+      Cmd x;
+      x.t = CmdType::Connect;
+      x.c = cr;
+      return x;
     }
-    void armGc(std::chrono::seconds s)
+    static Cmd via(const ViaReq &v)
     {
-      itimerspec its{};
-      its.it_interval.tv_sec = s.count();
-      its.it_value.tv_sec = s.count();
-      ::timerfd_settime(_timerFd, 0, &its, nullptr);
+      Cmd x;
+      x.t = CmdType::Via;
+      x.v = v;
+      return x;
     }
-    static std::string key(const sockaddr_storage& ss)
+    static Cmd send(SendReq &&sr)
     {
-      char h[NI_MAXHOST]{}, sv[NI_MAXSERV]{};
-      socklen_t sl = (ss.ss_family == AF_INET) ? sizeof(sockaddr_in)
-                                               : sizeof(sockaddr_in6);
-      if (getnameinfo(reinterpret_cast<const sockaddr*>(&ss), sl, h, sizeof(h),
-                      sv, sizeof(sv), NI_NUMERICHOST | NI_NUMERICSERV) == 0)
-      {
-        std::string o(h);
-        o.push_back(':');
-        o.append(sv);
-        return o;
-      }
-      return {};
+      Cmd x;
+      x.t = CmdType::Send;
+      x.s = std::move(sr);
+      return x;
     }
-    int sockAf(int fd)
+    static Cmd close(SessionId sid)
     {
-      sockaddr_storage ss{};
-      socklen_t sl = sizeof(ss);
-      if (::getsockname(fd, reinterpret_cast<sockaddr*>(&ss), &sl) == 0)
-        return ss.ss_family;
-      return AF_UNSPEC;
+      Cmd x;
+      x.t = CmdType::Close;
+      x.closeSid = sid;
+      return x;
     }
-    void error(TransportError e, const std::string& m)
+    static Cmd reconf(const Config &cfg)
     {
-      _atomicStats.errors++;
-      std::lock_guard<std::mutex> g(_cb);
-      if (_cbs.onError)
-        _cbs.onError(e, m);
+      Cmd x;
+      x.t = CmdType::Reconf;
+      x.cfg = cfg;
+      return x;
     }
-
-    enum class CmdType
-    {
-      Shutdown,
-      AddListener,
-      Connect,
-      Via,
-      Send,
-      Close,
-      Reconf
-    };
-    struct ListenerCfg
-    {
-      ListenerId id{};
-      std::string addr;
-      uint16_t port{};
-    };
-    struct ConnectReq
-    {
-      SessionId sid{};
-      std::string host;
-      uint16_t port{};
-      bool rejectTls{false};
-    };
-    struct ViaReq
-    {
-      SessionId sid{};
-      ListenerId lid{};
-      std::string host;
-      uint16_t port{};
-    };
-    struct SendReq
-    {
-      SessionId sid{};
-      ByteBuffer payload;
-    };
-    struct Cmd
-    {
-      CmdType t;
-      ListenerCfg l;
-      ConnectReq c;
-      ViaReq v;
-      SendReq s;
-      SessionId closeSid{};
-      Config cfg;
-      static Cmd shutdown()
-      {
-        Cmd x;
-        x.t = CmdType::Shutdown;
-        return x;
-      }
-      static Cmd addListener(const ListenerCfg& lc)
-      {
-        Cmd x;
-        x.t = CmdType::AddListener;
-        x.l = lc;
-        return x;
-      }
-      static Cmd connect(const ConnectReq& cr)
-      {
-        Cmd x;
-        x.t = CmdType::Connect;
-        x.c = cr;
-        return x;
-      }
-      static Cmd via(const ViaReq& v)
-      {
-        Cmd x;
-        x.t = CmdType::Via;
-        x.v = v;
-        return x;
-      }
-      static Cmd send(SendReq&& sr)
-      {
-        Cmd x;
-        x.t = CmdType::Send;
-        x.s = std::move(sr);
-        return x;
-      }
-      static Cmd close(SessionId sid)
-      {
-        Cmd x;
-        x.t = CmdType::Close;
-        x.closeSid = sid;
-        return x;
-      }
-      static Cmd reconf(const Config& cfg)
-      {
-        Cmd x;
-        x.t = CmdType::Reconf;
-        x.cfg = cfg;
-        return x;
-      }
-    };
-    bool enqueue(const Cmd& c)
+  };
+  bool enqueue(const Cmd &c)
+  {
     {
-      {
-        std::lock_guard<std::mutex> g(_qmx);
-        _q.push_back(c);
-        _atomicStats.commands++;
-      }
-      uint64_t one = 1;
-      (void) ::write(_eventFd, &one, sizeof(one));
-      return true;
+      std::lock_guard<std::mutex> g(_qmx);
+      _q.push_back(c);
+      _atomicStats.commands++;
     }
-    bool enqueue(Cmd&& c)
+    uint64_t one = 1;
+    (void)::write(_eventFd, &one, sizeof(one));
+    return true;
+  }
+  bool enqueue(Cmd &&c)
+  {
     {
-      {
-        std::lock_guard<std::mutex> g(_qmx);
-        _q.push_back(std::move(c));
-        _atomicStats.commands++;
-      }
-      uint64_t one = 1;
-      (void) ::write(_eventFd, &one, sizeof(one));
-      return true;
+      std::lock_guard<std::mutex> g(_qmx);
+      _q.push_back(std::move(c));
+      _atomicStats.commands++;
     }
-    void drainEvt()
+    uint64_t one = 1;
+    (void)::write(_eventFd, &one, sizeof(one));
+    return true;
+  }
+  void drainEvt()
+  {
+    uint64_t n = 0;
+    while (::read(_eventFd, &n, sizeof(n)) > 0)
     {
-      uint64_t n = 0;
-      while (::read(_eventFd, &n, sizeof(n)) > 0)
-      {
-      }
     }
-    void drainTim()
+  }
+  void drainTim()
+  {
+    uint64_t n = 0;
+    while (::read(_timerFd, &n, sizeof(n)) > 0)
     {
-      uint64_t n = 0;
-      while (::read(_timerFd, &n, sizeof(n)) > 0)
-      {
-      }
     }
+  }
 
-    struct OutDg
-    {
-      sockaddr_storage to{};
-      socklen_t toLen{0};
-      ByteBuffer payload;
-    };
-    struct Listener
-    {
-      ListenerId id{};
-      int fd{-1};
-      std::string bind;
-      std::deque<OutDg> wq;
-      bool wantWrite{false};
-    };
-    struct Session
-    {
-      SessionId id{};
-      Role role{Role::ServerPeer};
-      int fd{-1};
-      ListenerId owner{};
-      sockaddr_storage peer{};
-      socklen_t plen{0};
-      std::string pkey;
-      std::deque<ByteBuffer> wq;
-      bool wantWrite{false};
-      bool closed{false};
-      MonoTime created{}, lastActivity{};
-      // NEW: safety-net tracking
-      bool connectPending{false};
-      MonoTime connectStart{};
-      MonoTime lastWriteProgress{};
-    };
-    struct Tag
-    {
-      bool isListener{false};
-      Listener* lst{nullptr};
-      Session* sess{nullptr};
-    };
+  struct OutDg
+  {
+    sockaddr_storage to{};
+    socklen_t toLen{0};
+    ByteBuffer payload;
+  };
+  struct Listener
+  {
+    ListenerId id{};
+    int fd{-1};
+    std::string bind;
+    std::deque<OutDg> wq;
+    bool wantWrite{false};
+  };
+  struct Session
+  {
+    SessionId id{};
+    Role role{Role::ServerPeer};
+    int fd{-1};
+    ListenerId owner{};
+    sockaddr_storage peer{};
+    socklen_t plen{0};
+    std::string pkey;
+    std::deque<ByteBuffer> wq;
+    bool wantWrite{false};
+    bool closed{false};
+    MonoTime created{}, lastActivity{};
+    // NEW: safety-net tracking
+    bool connectPending{false};
+    MonoTime connectStart{};
+    MonoTime lastWriteProgress{};
+  };
+  struct Tag
+  {
+    bool isListener{false};
+    Listener *lst{nullptr};
+    Session *sess{nullptr};
+  };
 
-    void loop()
+  void loop()
+  {
+    std::vector<epoll_event> evs((size_t)_cfg.epollMaxEvents);
+    while (_running.load())
     {
-      std::vector<epoll_event> evs((size_t) _cfg.epollMaxEvents);
-      while (_running.load())
+      int n = ::epoll_wait(_epollFd, evs.data(), (int)evs.size(), -1);
+      if (n < 0)
       {
-        int n = ::epoll_wait(_epollFd, evs.data(), (int) evs.size(), -1);
-        if (n < 0)
-        {
-          if (errno == EINTR)
-            continue;
-          error(TransportError::Unknown, "epoll_wait: " + lastErr());
+        if (errno == EINTR)
           continue;
-        }
-        _atomicStats.epollWakeups++;
-        for (int i = 0; i < n; ++i)
-        {
-          int fd = evs[(size_t) i].data.fd;
-          uint32_t events = evs[(size_t) i].events;
-          if (fd == _eventFd)
-          {
-            drainEvt();
-            process();
-            continue;
-          }
-          if (fd == _timerFd)
-          {
-            drainTim();
-            runGc();
-            continue;
-          }
-          auto it = _tags.find(fd);
-          if (it == _tags.end())
-            continue;
-          Tag* t = it->second.get();
-          if (t->isListener)
-            onListener(t->lst, events);
-          else
-            onClient(t->sess, events);
-        }
+        error(TransportError::Unknown, "epoll_wait: " + lastErr());
+        continue;
       }
-      process();
-      // Collect sessions to close to avoid iterator invalidation
-      std::vector<Session*> toClose;
-      toClose.reserve(_sessions.size());
-      for (auto& kv : _sessions)
-        toClose.push_back(kv.second.get());
-
-      // Close all sessions safely (but don't erase from _sessions yet)
-      for (auto* s : toClose)
+      _atomicStats.epollWakeups++;
+      for (int i = 0; i < n; ++i)
       {
-        if (!s || s->closed)
-          continue;
-        s->closed = true;
-        if (s->role == Role::ClientConnected)
+        int fd = evs[(size_t)i].data.fd;
+        uint32_t events = evs[(size_t)i].events;
+        if (fd == _eventFd)
         {
-          delEpoll(s->fd);
-          ::close(s->fd);
-          _tags.erase(s->fd);
-        }
-        else
-        {
-          _peerIndex.erase(s->pkey);
+          drainEvt();
+          process();
+          continue;
         }
-        _atomicStats.closed++;
-        _atomicStats.sessionsCurrent--;
+        if (fd == _timerFd)
         {
-          std::lock_guard<std::mutex> g(_cb);
-          if (_cbs.onClosed)
-          {
-            IoResult r =
-                IoResult::failure(TransportError::Unknown, "shutdown", 0, 0);
-            _cbs.onClosed(s->id, r);
-          }
+          drainTim();
+          runGc();
+          continue;
         }
+        auto it = _tags.find(fd);
+        if (it == _tags.end())
+          continue;
+        Tag *t = it->second.get();
+        if (t->isListener)
+          onListener(t->lst, events);
+        else
+          onClient(t->sess, events);
       }
-      _sessions.clear();
-
-      // Close listeners
-      std::vector<Listener*> listenersToClose;
-      listenersToClose.reserve(_listeners.size());
-      for (auto& kv : _listeners)
-        listenersToClose.push_back(kv.second.get());
+    }
+    process();
+    // Collect sessions to close to avoid iterator invalidation
+    std::vector<Session *> toClose;
+    toClose.reserve(_sessions.size());
+    for (auto &kv : _sessions)
+      toClose.push_back(kv.second.get());
 
-      for (auto* lst : listenersToClose)
-        closeListenerNow(lst);
-      _listeners.clear();
-      if (_timerFd >= 0)
+    // Close all sessions safely (but don't erase from _sessions yet)
+    for (auto *s : toClose)
+    {
+      if (!s || s->closed)
+        continue;
+      s->closed = true;
+      if (s->role == Role::ClientConnected)
       {
-        delEpoll(_timerFd);
-        ::close(_timerFd);
-        _timerFd = -1;
+        delEpoll(s->fd);
+        ::close(s->fd);
+        _tags.erase(s->fd);
       }
-      if (_eventFd >= 0)
+      else
       {
-        delEpoll(_eventFd);
-        ::close(_eventFd);
-        _eventFd = -1;
+        _peerIndex.erase(s->pkey);
       }
-      if (_epollFd >= 0)
+      _atomicStats.closed++;
+      _atomicStats.sessionsCurrent--;
       {
-        ::close(_epollFd);
-        _epollFd = -1;
+        std::lock_guard<std::mutex> g(_cb);
+        if (_cbs.onClosed)
+        {
+          IoResult r = IoResult::failure(TransportError::Unknown, "shutdown", 0, 0);
+          _cbs.onClosed(s->id, r);
+        }
       }
     }
+    _sessions.clear();
 
-    void process()
+    // Close listeners
+    std::vector<Listener *> listenersToClose;
+    listenersToClose.reserve(_listeners.size());
+    for (auto &kv : _listeners)
+      listenersToClose.push_back(kv.second.get());
+
+    for (auto *lst : listenersToClose)
+      closeListenerNow(lst);
+    _listeners.clear();
+    if (_timerFd >= 0)
     {
-      std::deque<Cmd> l;
-      {
-        std::lock_guard<std::mutex> g(_qmx);
-        l.swap(_q);
-      }
-      for (auto& c : l)
+      delEpoll(_timerFd);
+      ::close(_timerFd);
+      _timerFd = -1;
+    }
+    if (_eventFd >= 0)
+    {
+      delEpoll(_eventFd);
+      ::close(_eventFd);
+      _eventFd = -1;
+    }
+    if (_epollFd >= 0)
+    {
+      ::close(_epollFd);
+      _epollFd = -1;
+    }
+  }
+
+  void process()
+  {
+    std::deque<Cmd> l;
+    {
+      std::lock_guard<std::mutex> g(_qmx);
+      l.swap(_q);
+    }
+    for (auto &c : l)
+    {
+      switch (c.t)
       {
-        switch (c.t)
-        {
-        case CmdType::Shutdown:
-          _running.store(false);
-          break;
-        case CmdType::AddListener:
-          if (!addListenerDo(c.l))
-          {
-            // Listener creation failed, the error was already reported
-            // The ListenerId was pre-allocated but the listener doesn't exist
-            // This is fine since subsequent operations on this ID will fail
-            // gracefully
-          }
-          break;
-        case CmdType::Connect:
-          connectDo(c.c);
-          break;
-        case CmdType::Via:
-          viaDo(c.v);
-          break;
-        case CmdType::Send:
-          sendDo(std::move(c.s));
-          break;
-        case CmdType::Close:
+      case CmdType::Shutdown:
+        _running.store(false);
+        break;
+      case CmdType::AddListener:
+        if (!addListenerDo(c.l))
         {
-          auto it = _sessions.find(c.closeSid);
-          if (it != _sessions.end())
-            closeNow(it->second.get(), TransportError::Unknown, "closed by app",
-                     0);
+          // Listener creation failed, the error was already reported
+          // The ListenerId was pre-allocated but the listener doesn't exist
+          // This is fine since subsequent operations on this ID will fail
+          // gracefully
         }
         break;
-        case CmdType::Reconf:
-          _cfg = c.cfg;
-          armGc(_cfg.gcInterval);
-          break;
-        }
+      case CmdType::Connect:
+        connectDo(c.c);
+        break;
+      case CmdType::Via:
+        viaDo(c.v);
+        break;
+      case CmdType::Send:
+        sendDo(std::move(c.s));
+        break;
+      case CmdType::Close:
+      {
+        auto it = _sessions.find(c.closeSid);
+        if (it != _sessions.end())
+          closeNow(it->second.get(), TransportError::Unknown, "closed by app", 0);
+      }
+      break;
+      case CmdType::Reconf:
+        _cfg = c.cfg;
+        armGc(_cfg.gcInterval);
+        break;
       }
     }
+  }
 
-    bool addListenerDo(const ListenerCfg& lc)
+  bool addListenerDo(const ListenerCfg &lc)
+  {
+    int sfd = -1;
+    sockaddr_storage ss{};
+    socklen_t sl = 0;
+    in6_addr t6{};
+    if (::inet_pton(AF_INET6, lc.addr.c_str(), &t6) == 1)
     {
-      int sfd = -1;
-      sockaddr_storage ss{};
-      socklen_t sl = 0;
-      in6_addr t6{};
-      if (::inet_pton(AF_INET6, lc.addr.c_str(), &t6) == 1)
+      sfd = ::socket(AF_INET6, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
+      if (sfd < 0)
       {
-        sfd = ::socket(AF_INET6, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
-        if (sfd < 0)
-        {
-          error(TransportError::Socket, "socket v6: " + lastErr());
-          return false;
-        }
-        int v6only = 0;
-        ::setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
-        sockaddr_in6 sa6{};
-        sa6.sin6_family = AF_INET6;
-        sa6.sin6_port = htons(lc.port);
-        sa6.sin6_addr = t6;
-        std::memcpy(&ss, &sa6, sizeof(sa6));
-        sl = sizeof(sa6);
+        error(TransportError::Socket, "socket v6: " + lastErr());
+        return false;
       }
-      else
+      int v6only = 0;
+      ::setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
+      sockaddr_in6 sa6{};
+      sa6.sin6_family = AF_INET6;
+      sa6.sin6_port = htons(lc.port);
+      sa6.sin6_addr = t6;
+      std::memcpy(&ss, &sa6, sizeof(sa6));
+      sl = sizeof(sa6);
+    }
+    else
+    {
+      in_addr t4{};
+      if (::inet_pton(AF_INET, lc.addr.c_str(), &t4) != 1)
       {
-        in_addr t4{};
-        if (::inet_pton(AF_INET, lc.addr.c_str(), &t4) != 1)
-        {
-          error(TransportError::Bind, "inet_pton failed");
-          return false;
-        }
-        sfd = ::socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
-        if (sfd < 0)
-        {
-          error(TransportError::Socket, "socket v4: " + lastErr());
-          return false;
-        }
-        sockaddr_in sa4{};
-        sa4.sin_family = AF_INET;
-        sa4.sin_port = htons(lc.port);
-        sa4.sin_addr = t4;
-        std::memcpy(&ss, &sa4, sizeof(sa4));
-        sl = sizeof(sa4);
+        error(TransportError::Bind, "inet_pton failed");
+        return false;
       }
-      if (_cfg.soRcvBuf > 0)
-        ::setsockopt(sfd, SOL_SOCKET, SO_RCVBUF, &_cfg.soRcvBuf, sizeof(int));
-      if (_cfg.soSndBuf > 0)
-        ::setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &_cfg.soSndBuf, sizeof(int));
-      if (::bind(sfd, reinterpret_cast<sockaddr*>(&ss), sl) < 0)
+      sfd = ::socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
+      if (sfd < 0)
       {
-        error(TransportError::Bind, "bind: " + lastErr());
-        ::close(sfd);
+        error(TransportError::Socket, "socket v4: " + lastErr());
         return false;
       }
-      auto lst = std::make_unique<Listener>();
-      lst->id = lc.id;
-      lst->fd = sfd;
-      lst->bind = lc.addr + ":" + std::to_string(lc.port);
-      uint32_t ev = EPOLLIN;
-      if (_cfg.useEdgeTriggered)
-        ev |= EPOLLET;
-      addEpoll(sfd, ev);
-      auto tag = std::make_unique<Tag>();
-      tag->isListener = true;
-      tag->lst = lst.get();
-      _tags.emplace(sfd, std::move(tag));
-      _listeners.emplace(lst->id, std::move(lst));
-      return true;
+      sockaddr_in sa4{};
+      sa4.sin_family = AF_INET;
+      sa4.sin_port = htons(lc.port);
+      sa4.sin_addr = t4;
+      std::memcpy(&ss, &sa4, sizeof(sa4));
+      sl = sizeof(sa4);
     }
-
-    void onListener(Listener* lst, uint32_t events)
+    if (_cfg.soRcvBuf > 0)
+      ::setsockopt(sfd, SOL_SOCKET, SO_RCVBUF, &_cfg.soRcvBuf, sizeof(int));
+    if (_cfg.soSndBuf > 0)
+      ::setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &_cfg.soSndBuf, sizeof(int));
+    if (::bind(sfd, reinterpret_cast<sockaddr *>(&ss), sl) < 0)
     {
-      if (events & EPOLLIN)
-        readFromListener(lst);
-      if (events & EPOLLOUT)
-        flushListener(lst);
+      error(TransportError::Bind, "bind: " + lastErr());
+      ::close(sfd);
+      return false;
     }
+    auto lst = std::make_unique<Listener>();
+    lst->id = lc.id;
+    lst->fd = sfd;
+    lst->bind = lc.addr + ":" + std::to_string(lc.port);
+    uint32_t ev = EPOLLIN;
+    if (_cfg.useEdgeTriggered)
+      ev |= EPOLLET;
+    addEpoll(sfd, ev);
+    auto tag = std::make_unique<Tag>();
+    tag->isListener = true;
+    tag->lst = lst.get();
+    _tags.emplace(sfd, std::move(tag));
+    _listeners.emplace(lst->id, std::move(lst));
+    return true;
+  }
+
+  void onListener(Listener *lst, uint32_t events)
+  {
+    if (events & EPOLLIN)
+      readFromListener(lst);
+    if (events & EPOLLOUT)
+      flushListener(lst);
+  }
 
-    void readFromListener(Listener* lst)
+  void readFromListener(Listener *lst)
+  {
+    for (;;)
     {
-      for (;;)
-      {
-        std::vector<std::uint8_t> buf;
-        buf.resize(_cfg.ioReadChunk);
-        sockaddr_storage from{};
-        socklen_t fl = sizeof(from);
-        int n = ::recvfrom(lst->fd, buf.data(), (int) buf.size(), 0,
-                           reinterpret_cast<sockaddr*>(&from), &fl);
-        if (n > 0)
+      std::vector<std::uint8_t> buf;
+      buf.resize(_cfg.ioReadChunk);
+      sockaddr_storage from{};
+      socklen_t fl = sizeof(from);
+      int n = ::recvfrom(lst->fd, buf.data(), (int)buf.size(), 0,
+                         reinterpret_cast<sockaddr *>(&from), &fl);
+      if (n > 0)
+      {
+        _atomicStats.bytesIn += n;
+        std::string k = key(from);
+        SessionId sid = 0;
+        auto it = _peerIndex.find(k);
+        if (it == _peerIndex.end())
         {
-          _atomicStats.bytesIn += n;
-          std::string k = key(from);
-          SessionId sid = 0;
-          auto it = _peerIndex.find(k);
-          if (it == _peerIndex.end())
-          {
-            if (_cfg.maxSessions &&
-                _atomicStats.sessionsCurrent.load() >= _cfg.maxSessions)
-              continue;
-            sid = _nextSessionId++;
-            auto s = std::make_unique<Session>();
-            s->id = sid;
-            s->role = Role::ServerPeer;
-            s->fd = lst->fd;
-            s->owner = lst->id;
-            std::memcpy(&s->peer, &from, fl);
-            s->plen = fl;
-            s->pkey = k;
-            s->created = MonoClock::now();
-            s->lastActivity = s->created;
-            s->lastWriteProgress = s->created;
-            _sessions.emplace(sid, std::move(s));
-            _peerIndex.emplace(k, sid);
-            _atomicStats.accepted++;
-            bumpSess();
-            {
-              std::lock_guard<std::mutex> g(_cb);
-              if (_cbs.onAccept)
-                _cbs.onAccept(sid, k, IoResult::success());
-            }
-          }
-          else
-          {
-            sid = it->second;
-          }
-          auto& sp = _sessions[sid];
-          sp->lastActivity = MonoClock::now();
+          if (_cfg.maxSessions && _atomicStats.sessionsCurrent.load() >= _cfg.maxSessions)
+            continue;
+          sid = _nextSessionId++;
+          auto s = std::make_unique<Session>();
+          s->id = sid;
+          s->role = Role::ServerPeer;
+          s->fd = lst->fd;
+          s->owner = lst->id;
+          std::memcpy(&s->peer, &from, fl);
+          s->plen = fl;
+          s->pkey = k;
+          s->created = MonoClock::now();
+          s->lastActivity = s->created;
+          s->lastWriteProgress = s->created;
+          _sessions.emplace(sid, std::move(s));
+          _peerIndex.emplace(k, sid);
+          _atomicStats.accepted++;
+          bumpSess();
           {
             std::lock_guard<std::mutex> g(_cb);
-            if (_cbs.onData)
-              _cbs.onData(sid, buf.data(), (size_t) n, IoResult::success());
+            if (_cbs.onAccept)
+              _cbs.onAccept(sid, k, IoResult::success());
           }
-          continue;
         }
-        if (n < 0)
+        else
         {
-          if (errno == EAGAIN || errno == EWOULDBLOCK)
-            break;
-          error(TransportError::Socket, "recvfrom: " + lastErr());
-          break;
+          sid = it->second;
         }
-        // n==0 acceptable
+        auto &sp = _sessions[sid];
+        sp->lastActivity = MonoClock::now();
+        {
+          std::lock_guard<std::mutex> g(_cb);
+          if (_cbs.onData)
+            _cbs.onData(sid, buf.data(), (size_t)n, IoResult::success());
+        }
+        continue;
+      }
+      if (n < 0)
+      {
+        if (errno == EAGAIN || errno == EWOULDBLOCK)
+          break;
+        error(TransportError::Socket, "recvfrom: " + lastErr());
+        break;
       }
+      // n==0 acceptable
     }
+  }
 
-    void flushListener(Listener* lst)
+  void flushListener(Listener *lst)
+  {
+    while (!lst->wq.empty())
     {
-      while (!lst->wq.empty())
+      auto &d = lst->wq.front();
+      int n = ::sendto(lst->fd, d.payload.data(), (int)d.payload.size(), 0,
+                       reinterpret_cast<sockaddr *>(&d.to), d.toLen);
+      if (n >= 0)
       {
-        auto& d = lst->wq.front();
-        int n = ::sendto(lst->fd, d.payload.data(), (int) d.payload.size(), 0,
-                         reinterpret_cast<sockaddr*>(&d.to), d.toLen);
-        if (n >= 0)
-        {
-          _atomicStats.bytesOut += n;
-          lst->wq.pop_front();
-          continue;
-        }
-        if (errno == EAGAIN || errno == EWOULDBLOCK)
-        {
-          lst->wantWrite = true;
-          updateListener(lst);
-          break;
-        }
-        error(TransportError::Socket, "sendto: " + lastErr());
+        _atomicStats.bytesOut += n;
         lst->wq.pop_front();
+        continue;
       }
-      if (lst->wq.empty())
+      if (errno == EAGAIN || errno == EWOULDBLOCK)
       {
-        lst->wantWrite = false;
+        lst->wantWrite = true;
         updateListener(lst);
+        break;
       }
+      error(TransportError::Socket, "sendto: " + lastErr());
+      lst->wq.pop_front();
     }
-
-    void updateListener(Listener* lst)
+    if (lst->wq.empty())
     {
-      uint32_t ev = EPOLLIN;
-      if (_cfg.useEdgeTriggered)
-        ev |= EPOLLET;
-      if (lst->wantWrite && !lst->wq.empty())
-        ev |= EPOLLOUT;
-      modEpoll(lst->fd, ev);
+      lst->wantWrite = false;
+      updateListener(lst);
     }
+  }
 
-    bool connectDo(const ConnectReq& cr)
+  void updateListener(Listener *lst)
+  {
+    uint32_t ev = EPOLLIN;
+    if (_cfg.useEdgeTriggered)
+      ev |= EPOLLET;
+    if (lst->wantWrite && !lst->wq.empty())
+      ev |= EPOLLOUT;
+    modEpoll(lst->fd, ev);
+  }
+
+  bool connectDo(const ConnectReq &cr)
+  {
+    if (cr.rejectTls)
     {
-      if (cr.rejectTls)
-      {
-        {
-          std::lock_guard<std::mutex> g(_cb);
-          if (_cbs.onConnect)
-            _cbs.onConnect(cr.sid,
-                           IoResult::failure(TransportError::Config,
-                                             "UDP: TLS/DTLS not supported"));
-        }
-        return false;
-      }
-      addrinfo* res = nullptr;
-      addrinfo hints{};
-      hints.ai_family = AF_UNSPEC;
-      hints.ai_socktype = SOCK_DGRAM;
-      hints.ai_protocol = IPPROTO_UDP;
-      std::string ps = std::to_string(cr.port);
-      int rc = ::getaddrinfo(cr.host.c_str(), ps.c_str(), &hints, &res);
-      if (rc != 0 || !res)
       {
-        {
-          std::lock_guard<std::mutex> g(_cb);
-          if (_cbs.onConnect)
-            _cbs.onConnect(cr.sid,
-                           IoResult::failure(TransportError::Resolve,
-                                             std::string("getaddrinfo: ") +
-                                                 gai_strerror(rc)));
-        }
-        error(TransportError::Resolve, "getaddrinfo failed");
-        return false;
+        std::lock_guard<std::mutex> g(_cb);
+        if (_cbs.onConnect)
+          _cbs.onConnect(cr.sid,
+                         IoResult::failure(TransportError::Config, "UDP: TLS/DTLS not supported"));
       }
-      int sfd = -1;
-      for (addrinfo* ai = res; ai; ai = ai->ai_next)
+      return false;
+    }
+    addrinfo *res = nullptr;
+    addrinfo hints{};
+    hints.ai_family = AF_UNSPEC;
+    hints.ai_socktype = SOCK_DGRAM;
+    hints.ai_protocol = IPPROTO_UDP;
+    std::string ps = std::to_string(cr.port);
+    int rc = ::getaddrinfo(cr.host.c_str(), ps.c_str(), &hints, &res);
+    if (rc != 0 || !res)
+    {
       {
-        sfd = ::socket(ai->ai_family, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
-                       0);
-        if (sfd < 0)
-          continue;
-        if (_cfg.soRcvBuf > 0)
-          ::setsockopt(sfd, SOL_SOCKET, SO_RCVBUF, &_cfg.soRcvBuf, sizeof(int));
-        if (_cfg.soSndBuf > 0)
-          ::setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &_cfg.soSndBuf, sizeof(int));
-        if (::connect(sfd, ai->ai_addr, ai->ai_addrlen) == 0)
-        {
-          break;
-        }
-        ::close(sfd);
-        sfd = -1;
+        std::lock_guard<std::mutex> g(_cb);
+        if (_cbs.onConnect)
+          _cbs.onConnect(cr.sid,
+                         IoResult::failure(TransportError::Resolve,
+                                           std::string("getaddrinfo: ") + gai_strerror(rc)));
       }
-      ::freeaddrinfo(res);
+      error(TransportError::Resolve, "getaddrinfo failed");
+      return false;
+    }
+    int sfd = -1;
+    for (addrinfo *ai = res; ai; ai = ai->ai_next)
+    {
+      sfd = ::socket(ai->ai_family, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
       if (sfd < 0)
+        continue;
+      if (_cfg.soRcvBuf > 0)
+        ::setsockopt(sfd, SOL_SOCKET, SO_RCVBUF, &_cfg.soRcvBuf, sizeof(int));
+      if (_cfg.soSndBuf > 0)
+        ::setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &_cfg.soSndBuf, sizeof(int));
+      if (::connect(sfd, ai->ai_addr, ai->ai_addrlen) == 0)
       {
-        {
-          std::lock_guard<std::mutex> g(_cb);
-          if (_cbs.onConnect)
-            _cbs.onConnect(cr.sid, IoResult::failure(TransportError::Connect,
-                                                     lastErr(), errno, 0));
-        }
-        error(TransportError::Connect, "UDP connect: " + lastErr());
-        return false;
+        break;
       }
-      auto s = std::make_unique<Session>();
-      s->id = cr.sid;
-      s->role = Role::ClientConnected;
-      s->fd = sfd;
-      s->created = MonoClock::now();
-      s->lastActivity = s->created;
-      s->lastWriteProgress = s->created;
-      s->connectPending = false; // UDP connect immediate
-      uint32_t ev = EPOLLIN;
-      if (_cfg.useEdgeTriggered)
-        ev |= EPOLLET;
-      addEpoll(sfd, ev);
-      auto tag = std::make_unique<Tag>();
-      tag->isListener = false;
-      tag->sess = s.get();
-      _tags.emplace(sfd, std::move(tag));
-      _sessions.emplace(s->id, std::move(s));
-      bumpSess();
+      ::close(sfd);
+      sfd = -1;
+    }
+    ::freeaddrinfo(res);
+    if (sfd < 0)
+    {
       {
         std::lock_guard<std::mutex> g(_cb);
         if (_cbs.onConnect)
-        {
-          _atomicStats.connected++;
-          _cbs.onConnect(cr.sid, IoResult::success());
-        }
+          _cbs.onConnect(cr.sid, IoResult::failure(TransportError::Connect, lastErr(), errno, 0));
       }
-      return true;
+      error(TransportError::Connect, "UDP connect: " + lastErr());
+      return false;
     }
-
-    bool viaDo(const ViaReq& vr)
+    auto s = std::make_unique<Session>();
+    s->id = cr.sid;
+    s->role = Role::ClientConnected;
+    s->fd = sfd;
+    s->created = MonoClock::now();
+    s->lastActivity = s->created;
+    s->lastWriteProgress = s->created;
+    s->connectPending = false; // UDP connect immediate
+    uint32_t ev = EPOLLIN;
+    if (_cfg.useEdgeTriggered)
+      ev |= EPOLLET;
+    addEpoll(sfd, ev);
+    auto tag = std::make_unique<Tag>();
+    tag->isListener = false;
+    tag->sess = s.get();
+    _tags.emplace(sfd, std::move(tag));
+    _sessions.emplace(s->id, std::move(s));
+    bumpSess();
     {
-      auto lit = _listeners.find(vr.lid);
-      if (lit == _listeners.end())
-      {
-        {
-          std::lock_guard<std::mutex> g(_cb);
-          if (_cbs.onConnect)
-            _cbs.onConnect(vr.sid, IoResult::failure(TransportError::Config,
-                                                     "listener not found"));
-        }
-        return false;
-      }
-      Listener* lst = lit->second.get();
-      int af = sockAf(lst->fd);
-      if (af != AF_INET && af != AF_INET6)
-      {
-        {
-          std::lock_guard<std::mutex> g(_cb);
-          if (_cbs.onConnect)
-            _cbs.onConnect(
-                vr.sid, IoResult::failure(TransportError::Config,
-                                          "listener AF unknown/unsupported"));
-        }
-        return false;
-      }
-      addrinfo hints{};
-      hints.ai_family = AF_UNSPEC;
-      hints.ai_socktype = SOCK_DGRAM;
-      hints.ai_protocol = IPPROTO_UDP;
-      addrinfo* res = nullptr;
-      std::string ps = std::to_string(vr.port);
-      int rc = ::getaddrinfo(vr.host.c_str(), ps.c_str(), &hints, &res);
-      if (rc != 0 || !res)
+      std::lock_guard<std::mutex> g(_cb);
+      if (_cbs.onConnect)
       {
-        {
-          std::lock_guard<std::mutex> g(_cb);
-          if (_cbs.onConnect)
-            _cbs.onConnect(vr.sid,
-                           IoResult::failure(TransportError::Resolve,
-                                             std::string("getaddrinfo: ") +
-                                                 gai_strerror(rc)));
-        }
-        error(TransportError::Resolve, "getaddrinfo failed");
-        return false;
+        _atomicStats.connected++;
+        _cbs.onConnect(cr.sid, IoResult::success());
       }
-      const addrinfo* chosen = nullptr;
-      for (const addrinfo* ai = res; ai; ai = ai->ai_next)
+    }
+    return true;
+  }
+
+  bool viaDo(const ViaReq &vr)
+  {
+    auto lit = _listeners.find(vr.lid);
+    if (lit == _listeners.end())
+    {
       {
-        if (ai->ai_family == af && ai->ai_socktype == SOCK_DGRAM)
-        {
-          chosen = ai;
-          break;
-        }
+        std::lock_guard<std::mutex> g(_cb);
+        if (_cbs.onConnect)
+          _cbs.onConnect(vr.sid, IoResult::failure(TransportError::Config, "listener not found"));
       }
-      if (!chosen)
+      return false;
+    }
+    Listener *lst = lit->second.get();
+    int af = sockAf(lst->fd);
+    if (af != AF_INET && af != AF_INET6)
+    {
       {
-        ::freeaddrinfo(res);
-        std::string m = (af == AF_INET)
-                            ? "AF mismatch: listener IPv4, remote IPv6 only"
-                            : "AF mismatch: listener IPv6, remote IPv4 only";
-        {
-          std::lock_guard<std::mutex> g(_cb);
-          if (_cbs.onConnect)
-            _cbs.onConnect(vr.sid,
-                           IoResult::failure(TransportError::Config, m));
-        }
-        return false;
+        std::lock_guard<std::mutex> g(_cb);
+        if (_cbs.onConnect)
+          _cbs.onConnect(
+            vr.sid, IoResult::failure(TransportError::Config, "listener AF unknown/unsupported"));
       }
-      sockaddr_storage to{};
-      socklen_t tl = 0;
-      if (chosen->ai_family == AF_INET6)
+      return false;
+    }
+    addrinfo hints{};
+    hints.ai_family = AF_UNSPEC;
+    hints.ai_socktype = SOCK_DGRAM;
+    hints.ai_protocol = IPPROTO_UDP;
+    addrinfo *res = nullptr;
+    std::string ps = std::to_string(vr.port);
+    int rc = ::getaddrinfo(vr.host.c_str(), ps.c_str(), &hints, &res);
+    if (rc != 0 || !res)
+    {
       {
-        std::memcpy(&to, chosen->ai_addr, sizeof(sockaddr_in6));
-        tl = sizeof(sockaddr_in6);
+        std::lock_guard<std::mutex> g(_cb);
+        if (_cbs.onConnect)
+          _cbs.onConnect(vr.sid,
+                         IoResult::failure(TransportError::Resolve,
+                                           std::string("getaddrinfo: ") + gai_strerror(rc)));
       }
-      else
+      error(TransportError::Resolve, "getaddrinfo failed");
+      return false;
+    }
+    const addrinfo *chosen = nullptr;
+    for (const addrinfo *ai = res; ai; ai = ai->ai_next)
+    {
+      if (ai->ai_family == af && ai->ai_socktype == SOCK_DGRAM)
       {
-        std::memcpy(&to, chosen->ai_addr, sizeof(sockaddr_in));
-        tl = sizeof(sockaddr_in);
+        chosen = ai;
+        break;
       }
+    }
+    if (!chosen)
+    {
       ::freeaddrinfo(res);
-      std::string k = key(to);
-      auto pit = _peerIndex.find(k);
-      if (pit != _peerIndex.end())
+      std::string m = (af == AF_INET) ? "AF mismatch: listener IPv4, remote IPv6 only"
+                                      : "AF mismatch: listener IPv6, remote IPv4 only";
       {
-        {
-          std::lock_guard<std::mutex> g(_cb);
-          if (_cbs.onConnect)
-            _cbs.onConnect(vr.sid, IoResult::success());
-        }
-        return true;
-      }
-      if (_cfg.maxSessions &&
-          _atomicStats.sessionsCurrent.load() >= _cfg.maxSessions)
-      {
-        {
-          std::lock_guard<std::mutex> g(_cb);
-          if (_cbs.onConnect)
-            _cbs.onConnect(vr.sid, IoResult::failure(TransportError::Config,
-                                                     "session cap reached"));
-        }
-        return false;
+        std::lock_guard<std::mutex> g(_cb);
+        if (_cbs.onConnect)
+          _cbs.onConnect(vr.sid, IoResult::failure(TransportError::Config, m));
       }
-      auto s = std::make_unique<Session>();
-      s->id = vr.sid;
-      s->role = Role::ServerPeer;
-      s->fd = lst->fd;
-      s->owner = lst->id;
-      std::memcpy(&s->peer, &to, tl);
-      s->plen = tl;
-      s->pkey = k;
-      s->created = MonoClock::now();
-      s->lastActivity = s->created;
-      s->lastWriteProgress = s->created;
-      s->connectPending = false;
-      _sessions.emplace(s->id, std::move(s));
-      _peerIndex.emplace(k, vr.sid);
-      bumpSess();
+      return false;
+    }
+    sockaddr_storage to{};
+    socklen_t tl = 0;
+    if (chosen->ai_family == AF_INET6)
+    {
+      std::memcpy(&to, chosen->ai_addr, sizeof(sockaddr_in6));
+      tl = sizeof(sockaddr_in6);
+    }
+    else
+    {
+      std::memcpy(&to, chosen->ai_addr, sizeof(sockaddr_in));
+      tl = sizeof(sockaddr_in);
+    }
+    ::freeaddrinfo(res);
+    std::string k = key(to);
+    auto pit = _peerIndex.find(k);
+    if (pit != _peerIndex.end())
+    {
       {
         std::lock_guard<std::mutex> g(_cb);
         if (_cbs.onConnect)
@@ -1083,135 +1026,126 @@ namespace network
       }
       return true;
     }
-
-    void onClient(Session* s, uint32_t events)
+    if (_cfg.maxSessions && _atomicStats.sessionsCurrent.load() >= _cfg.maxSessions)
     {
-      if (events & EPOLLIN)
       {
-        for (;;)
-        {
-          std::vector<std::uint8_t> buf;
-          buf.resize(_cfg.ioReadChunk);
-          int n = ::recv(s->fd, buf.data(), (int) buf.size(), 0);
-          if (n > 0)
-          {
-            _atomicStats.bytesIn += n;
-            s->lastActivity = MonoClock::now();
-            {
-              std::lock_guard<std::mutex> g(_cb);
-              if (_cbs.onData)
-                _cbs.onData(s->id, buf.data(), (size_t) n, IoResult::success());
-            }
-            continue;
-          }
-          if (n == 0)
-          {
-            {
-              std::lock_guard<std::mutex> g(_cb);
-              if (_cbs.onData)
-                _cbs.onData(s->id, nullptr, 0, IoResult::success());
-            }
-            break;
-          }
-          if (errno == EAGAIN || errno == EWOULDBLOCK)
-            break;
-          closeNow(s, TransportError::Socket, lastErr(), 0);
-          return;
-        }
+        std::lock_guard<std::mutex> g(_cb);
+        if (_cbs.onConnect)
+          _cbs.onConnect(vr.sid, IoResult::failure(TransportError::Config, "session cap reached"));
       }
-      if (events & EPOLLOUT)
-        writeClient(s);
+      return false;
     }
+    auto s = std::make_unique<Session>();
+    s->id = vr.sid;
+    s->role = Role::ServerPeer;
+    s->fd = lst->fd;
+    s->owner = lst->id;
+    std::memcpy(&s->peer, &to, tl);
+    s->plen = tl;
+    s->pkey = k;
+    s->created = MonoClock::now();
+    s->lastActivity = s->created;
+    s->lastWriteProgress = s->created;
+    s->connectPending = false;
+    _sessions.emplace(s->id, std::move(s));
+    _peerIndex.emplace(k, vr.sid);
+    bumpSess();
+    {
+      std::lock_guard<std::mutex> g(_cb);
+      if (_cbs.onConnect)
+        _cbs.onConnect(vr.sid, IoResult::success());
+    }
+    return true;
+  }
 
-    void writeClient(Session* s)
+  void onClient(Session *s, uint32_t events)
+  {
+    if (events & EPOLLIN)
     {
-      while (!s->wq.empty())
+      for (;;)
       {
-        ByteBuffer& d = s->wq.front();
-        int n = ::send(s->fd, d.data(), (int) d.size(), 0);
-        if (n >= 0)
+        std::vector<std::uint8_t> buf;
+        buf.resize(_cfg.ioReadChunk);
+        int n = ::recv(s->fd, buf.data(), (int)buf.size(), 0);
+        if (n > 0)
         {
-          _atomicStats.bytesOut += n;
-          s->lastWriteProgress = MonoClock::now();
-          s->wq.pop_front();
+          _atomicStats.bytesIn += n;
+          s->lastActivity = MonoClock::now();
+          {
+            std::lock_guard<std::mutex> g(_cb);
+            if (_cbs.onData)
+              _cbs.onData(s->id, buf.data(), (size_t)n, IoResult::success());
+          }
           continue;
         }
-        if (errno == EAGAIN || errno == EWOULDBLOCK)
+        if (n == 0)
         {
-          s->wantWrite = true;
-          updateClient(s);
+          {
+            std::lock_guard<std::mutex> g(_cb);
+            if (_cbs.onData)
+              _cbs.onData(s->id, nullptr, 0, IoResult::success());
+          }
           break;
         }
+        if (errno == EAGAIN || errno == EWOULDBLOCK)
+          break;
         closeNow(s, TransportError::Socket, lastErr(), 0);
         return;
       }
-      if (s->wq.empty())
+    }
+    if (events & EPOLLOUT)
+      writeClient(s);
+  }
+
+  void writeClient(Session *s)
+  {
+    while (!s->wq.empty())
+    {
+      ByteBuffer &d = s->wq.front();
+      int n = ::send(s->fd, d.data(), (int)d.size(), 0);
+      if (n >= 0)
       {
-        s->wantWrite = false;
+        _atomicStats.bytesOut += n;
+        s->lastWriteProgress = MonoClock::now();
+        s->wq.pop_front();
+        continue;
+      }
+      if (errno == EAGAIN || errno == EWOULDBLOCK)
+      {
+        s->wantWrite = true;
         updateClient(s);
+        break;
       }
+      closeNow(s, TransportError::Socket, lastErr(), 0);
+      return;
     }
-    void updateClient(Session* s)
+    if (s->wq.empty())
     {
-      uint32_t ev = EPOLLIN;
-      if (_cfg.useEdgeTriggered)
-        ev |= EPOLLET;
-      if (s->wantWrite && !s->wq.empty())
-        ev |= EPOLLOUT;
-      modEpoll(s->fd, ev);
+      s->wantWrite = false;
+      updateClient(s);
     }
+  }
+  void updateClient(Session *s)
+  {
+    uint32_t ev = EPOLLIN;
+    if (_cfg.useEdgeTriggered)
+      ev |= EPOLLET;
+    if (s->wantWrite && !s->wq.empty())
+      ev |= EPOLLOUT;
+    modEpoll(s->fd, ev);
+  }
 
-    void sendDo(SendReq&& sr)
+  void sendDo(SendReq &&sr)
+  {
+    auto it = _sessions.find(sr.sid);
+    if (it == _sessions.end())
+      return;
+    Session *s = it->second.get();
+    if (s->closed)
+      return;
+    if (s->role == Role::ClientConnected)
     {
-      auto it = _sessions.find(sr.sid);
-      if (it == _sessions.end())
-        return;
-      Session* s = it->second.get();
-      if (s->closed)
-        return;
-      if (s->role == Role::ClientConnected)
-      {
-        int n = ::send(s->fd, sr.payload.data(), (int) sr.payload.size(), 0);
-        if (n >= 0)
-        {
-          _atomicStats.bytesOut += n;
-          s->lastActivity = MonoClock::now();
-          s->lastWriteProgress = MonoClock::now();
-          return;
-        }
-        if (errno == EAGAIN || errno == EWOULDBLOCK)
-        {
-          s->wq.emplace_back(std::move(sr.payload));
-          if (s->wq.size() > _cfg.maxWriteQueue)
-          {
-            _atomicStats.backpressureCloses++;
-            if (_cfg.closeOnBackpressure)
-            {
-              closeNow(s, TransportError::WriteBackpressure,
-                       "client write queue overflow", 0);
-              return;
-            }
-            else
-            {
-              s->wq.pop_front();
-            }
-          }
-          s->wantWrite = true;
-          updateClient(s);
-          return;
-        }
-        closeNow(s, TransportError::Socket, lastErr(), 0);
-        return;
-      }
-      auto lit = _listeners.find(s->owner);
-      if (lit == _listeners.end())
-      {
-        closeNow(s, TransportError::Unknown, "listener gone", 0);
-        return;
-      }
-      Listener* lst = lit->second.get();
-      int n = ::sendto(lst->fd, sr.payload.data(), (int) sr.payload.size(), 0,
-                       reinterpret_cast<sockaddr*>(&s->peer), s->plen);
+      int n = ::send(s->fd, sr.payload.data(), (int)sr.payload.size(), 0);
       if (n >= 0)
       {
         _atomicStats.bytesOut += n;
@@ -1221,255 +1155,283 @@ namespace network
       }
       if (errno == EAGAIN || errno == EWOULDBLOCK)
       {
-        OutDg d{};
-        std::memcpy(&d.to, &s->peer, s->plen);
-        d.toLen = s->plen;
-        d.payload = std::move(sr.payload);
-        lst->wq.emplace_back(std::move(d));
-        if (lst->wq.size() > _cfg.maxWriteQueue)
+        s->wq.emplace_back(std::move(sr.payload));
+        if (s->wq.size() > _cfg.maxWriteQueue)
         {
           _atomicStats.backpressureCloses++;
           if (_cfg.closeOnBackpressure)
           {
-            closeNow(s, TransportError::WriteBackpressure,
-                     "listener write queue overflow", 0);
+            closeNow(s, TransportError::WriteBackpressure, "client write queue overflow", 0);
+            return;
           }
           else
           {
-            lst->wq.pop_front();
+            s->wq.pop_front();
           }
         }
-        lst->wantWrite = true;
-        updateListener(lst);
+        s->wantWrite = true;
+        updateClient(s);
         return;
       }
       closeNow(s, TransportError::Socket, lastErr(), 0);
+      return;
     }
-
-    void closeNow(Session* s, TransportError why, const std::string& m, int)
+    auto lit = _listeners.find(s->owner);
+    if (lit == _listeners.end())
     {
-      if (!s || s->closed)
-        return;
-      s->closed = true;
-      if (s->role == Role::ClientConnected)
-      {
-        delEpoll(s->fd);
-        ::close(s->fd);
-        _tags.erase(s->fd);
-      }
-      else
-      {
-        _peerIndex.erase(s->pkey);
-      }
-      _atomicStats.closed++;
-      _atomicStats.sessionsCurrent--;
-      {
-        std::lock_guard<std::mutex> g(_cb);
-        if (_cbs.onClosed)
-        {
-          IoResult r = (why == TransportError::None && m.empty())
-                           ? IoResult::success()
-                           : IoResult::failure(why, m, errno, 0);
-          _cbs.onClosed(s->id, r);
-        }
-      }
-      _sessions.erase(s->id);
+      closeNow(s, TransportError::Unknown, "listener gone", 0);
+      return;
     }
-    void closeListenerNow(Listener* lst)
+    Listener *lst = lit->second.get();
+    int n = ::sendto(lst->fd, sr.payload.data(), (int)sr.payload.size(), 0,
+                     reinterpret_cast<sockaddr *>(&s->peer), s->plen);
+    if (n >= 0)
     {
-      delEpoll(lst->fd);
-      ::close(lst->fd);
-      _tags.erase(lst->fd);
+      _atomicStats.bytesOut += n;
+      s->lastActivity = MonoClock::now();
+      s->lastWriteProgress = MonoClock::now();
+      return;
     }
-
-    void runGc()
-    {
-      _atomicStats.gcRuns++;
-      const auto now = MonoClock::now();
-      const bool age = _cfg.maxConnAge.count() > 0;
-      std::vector<SessionId> to;
-      to.reserve(_sessions.size());
-      for (auto& kv : _sessions)
-      {
-        Session* s = kv.second.get();
-        if (s->closed)
-          continue;
-        if (_cfg.idleTimeout.count() > 0 &&
-            (now - s->lastActivity) > _cfg.idleTimeout)
-        {
-          to.push_back(s->id);
-          _atomicStats.gcClosedIdle++;
-          continue;
-        }
-        if (age && (now - s->created) > _cfg.maxConnAge)
-        {
-          to.push_back(s->id);
-          _atomicStats.gcClosedAged++;
-          continue;
-        }
-        // NEW: safety-net connect timeout (mostly moot for UDP client)
-        if (_cfg.connectTimeout.count() > 0 && s->connectPending &&
-            (now - s->connectStart) > _cfg.connectTimeout)
+    if (errno == EAGAIN || errno == EWOULDBLOCK)
+    {
+      OutDg d{};
+      std::memcpy(&d.to, &s->peer, s->plen);
+      d.toLen = s->plen;
+      d.payload = std::move(sr.payload);
+      lst->wq.emplace_back(std::move(d));
+      if (lst->wq.size() > _cfg.maxWriteQueue)
+      {
+        _atomicStats.backpressureCloses++;
+        if (_cfg.closeOnBackpressure)
         {
-          to.push_back(s->id);
-          continue;
+          closeNow(s, TransportError::WriteBackpressure, "listener write queue overflow", 0);
         }
-        // NEW: safety-net write stall (applies to client-connected sessions)
-        if (_cfg.writeStallTimeout.count() > 0 && !s->wq.empty() &&
-            (now - s->lastWriteProgress) > _cfg.writeStallTimeout)
+        else
         {
-          to.push_back(s->id);
-          continue;
+          lst->wq.pop_front();
         }
       }
-      for (auto sid : to)
-      {
-        auto it = _sessions.find(sid);
-        if (it != _sessions.end())
-          closeNow(it->second.get(), TransportError::GCClosed,
-                   "GC safety-net timeout", 0);
-      }
+      lst->wantWrite = true;
+      updateListener(lst);
+      return;
     }
+    closeNow(s, TransportError::Socket, lastErr(), 0);
+  }
 
-    void bumpSess()
+  void closeNow(Session *s, TransportError why, const std::string &m, int)
+  {
+    if (!s || s->closed)
+      return;
+    s->closed = true;
+    if (s->role == Role::ClientConnected)
+    {
+      delEpoll(s->fd);
+      ::close(s->fd);
+      _tags.erase(s->fd);
+    }
+    else
     {
-      auto cur = _atomicStats.sessionsCurrent.fetch_add(1) + 1;
-      auto pk = _atomicStats.sessionsPeak.load();
-      while (cur > pk &&
-             !_atomicStats.sessionsPeak.compare_exchange_weak(pk, cur))
+      _peerIndex.erase(s->pkey);
+    }
+    _atomicStats.closed++;
+    _atomicStats.sessionsCurrent--;
+    {
+      std::lock_guard<std::mutex> g(_cb);
+      if (_cbs.onClosed)
       {
+        IoResult r = (why == TransportError::None && m.empty())
+                       ? IoResult::success()
+                       : IoResult::failure(why, m, errno, 0);
+        _cbs.onClosed(s->id, r);
       }
     }
+    _sessions.erase(s->id);
+  }
+  void closeListenerNow(Listener *lst)
+  {
+    delEpoll(lst->fd);
+    ::close(lst->fd);
+    _tags.erase(lst->fd);
+  }
 
-    void cleanupFail()
+  void runGc()
+  {
+    _atomicStats.gcRuns++;
+    const auto now = MonoClock::now();
+    const bool age = _cfg.maxConnAge.count() > 0;
+    std::vector<SessionId> to;
+    to.reserve(_sessions.size());
+    for (auto &kv : _sessions)
     {
-      if (_timerFd >= 0)
+      Session *s = kv.second.get();
+      if (s->closed)
+        continue;
+      if (_cfg.idleTimeout.count() > 0 && (now - s->lastActivity) > _cfg.idleTimeout)
       {
-        ::close(_timerFd);
-        _timerFd = -1;
+        to.push_back(s->id);
+        _atomicStats.gcClosedIdle++;
+        continue;
       }
-      if (_eventFd >= 0)
+      if (age && (now - s->created) > _cfg.maxConnAge)
       {
-        ::close(_eventFd);
-        _eventFd = -1;
+        to.push_back(s->id);
+        _atomicStats.gcClosedAged++;
+        continue;
       }
-      if (_epollFd >= 0)
+      // NEW: safety-net connect timeout (mostly moot for UDP client)
+      if (_cfg.connectTimeout.count() > 0 && s->connectPending &&
+          (now - s->connectStart) > _cfg.connectTimeout)
       {
-        ::close(_epollFd);
-        _epollFd = -1;
+        to.push_back(s->id);
+        continue;
       }
-      _running.store(false);
+      // NEW: safety-net write stall (applies to client-connected sessions)
+      if (_cfg.writeStallTimeout.count() > 0 && !s->wq.empty() &&
+          (now - s->lastWriteProgress) > _cfg.writeStallTimeout)
+      {
+        to.push_back(s->id);
+        continue;
+      }
+    }
+    for (auto sid : to)
+    {
+      auto it = _sessions.find(sid);
+      if (it != _sessions.end())
+        closeNow(it->second.get(), TransportError::GCClosed, "GC safety-net timeout", 0);
     }
+  }
 
-  private:
-    // Helper method for synchronous bind validation
-    ListenerResult validateBind(const std::string& addr, uint16_t port)
-    {
-      int sfd = -1;
-      sockaddr_storage ss{};
-      socklen_t sl = 0;
-      in6_addr t6{};
+  void bumpSess()
+  {
+    auto cur = _atomicStats.sessionsCurrent.fetch_add(1) + 1;
+    auto pk = _atomicStats.sessionsPeak.load();
+    while (cur > pk && !_atomicStats.sessionsPeak.compare_exchange_weak(pk, cur))
+    {
+    }
+  }
 
-      try
+  void cleanupFail()
+  {
+    if (_timerFd >= 0)
+    {
+      ::close(_timerFd);
+      _timerFd = -1;
+    }
+    if (_eventFd >= 0)
+    {
+      ::close(_eventFd);
+      _eventFd = -1;
+    }
+    if (_epollFd >= 0)
+    {
+      ::close(_epollFd);
+      _epollFd = -1;
+    }
+    _running.store(false);
+  }
+
+private:
+  // Helper method for synchronous bind validation
+  ListenerResult validateBind(const std::string &addr, uint16_t port)
+  {
+    int sfd = -1;
+    sockaddr_storage ss{};
+    socklen_t sl = 0;
+    in6_addr t6{};
+
+    try
+    {
+      if (::inet_pton(AF_INET6, addr.c_str(), &t6) == 1)
       {
-        if (::inet_pton(AF_INET6, addr.c_str(), &t6) == 1)
+        sfd = ::socket(AF_INET6, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
+        if (sfd < 0)
         {
-          sfd =
-              ::socket(AF_INET6, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
-          if (sfd < 0)
-          {
-            return ListenerResult::failure(TransportError::Socket,
-                                           "socket v6: " + lastErr(), errno);
-          }
-          auto* sa6 = reinterpret_cast<sockaddr_in6*>(&ss);
-          sa6->sin6_family = AF_INET6;
-          sa6->sin6_port = ::htons(port);
-          std::memcpy(&sa6->sin6_addr, &t6, sizeof(t6));
-          sl = sizeof(sockaddr_in6);
+          return ListenerResult::failure(TransportError::Socket, "socket v6: " + lastErr(), errno);
         }
-        else
+        auto *sa6 = reinterpret_cast<sockaddr_in6 *>(&ss);
+        sa6->sin6_family = AF_INET6;
+        sa6->sin6_port = ::htons(port);
+        std::memcpy(&sa6->sin6_addr, &t6, sizeof(t6));
+        sl = sizeof(sockaddr_in6);
+      }
+      else
+      {
+        sfd = ::socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
+        if (sfd < 0)
         {
-          sfd = ::socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
-          if (sfd < 0)
-          {
-            return ListenerResult::failure(TransportError::Socket,
-                                           "socket v4: " + lastErr(), errno);
-          }
-          auto* sa4 = reinterpret_cast<sockaddr_in*>(&ss);
-          sa4->sin_family = AF_INET;
-          sa4->sin_port = ::htons(port);
-          if (::inet_pton(AF_INET, addr.c_str(), &sa4->sin_addr) != 1)
-          {
-            ::close(sfd);
-            return ListenerResult::failure(TransportError::Config,
-                                           "invalid address: " + addr);
-          }
-          sl = sizeof(sockaddr_in);
+          return ListenerResult::failure(TransportError::Socket, "socket v4: " + lastErr(), errno);
         }
-
-        // Try to bind to validate the address/port
-        if (::bind(sfd, reinterpret_cast<sockaddr*>(&ss), sl) < 0)
+        auto *sa4 = reinterpret_cast<sockaddr_in *>(&ss);
+        sa4->sin_family = AF_INET;
+        sa4->sin_port = ::htons(port);
+        if (::inet_pton(AF_INET, addr.c_str(), &sa4->sin_addr) != 1)
         {
-          int bindError = errno;
           ::close(sfd);
-          return ListenerResult::failure(TransportError::Bind,
-                                         "bind validation failed: " + lastErr(),
-                                         bindError);
+          return ListenerResult::failure(TransportError::Config, "invalid address: " + addr);
         }
-
-        // Success - close the validation socket
-        ::close(sfd);
-        return ListenerResult::success(0, addr + ":" + std::to_string(port));
+        sl = sizeof(sockaddr_in);
       }
-      catch (...)
+
+      // Try to bind to validate the address/port
+      if (::bind(sfd, reinterpret_cast<sockaddr *>(&ss), sl) < 0)
       {
-        if (sfd >= 0)
-          ::close(sfd);
-        return ListenerResult::failure(TransportError::Unknown,
-                                       "bind validation exception");
+        int bindError = errno;
+        ::close(sfd);
+        return ListenerResult::failure(TransportError::Bind, "bind validation failed: " + lastErr(),
+                                       bindError);
       }
+
+      // Success - close the validation socket
+      ::close(sfd);
+      return ListenerResult::success(0, addr + ":" + std::to_string(port));
     }
+    catch (...)
+    {
+      if (sfd >= 0)
+        ::close(sfd);
+      return ListenerResult::failure(TransportError::Unknown, "bind validation exception");
+    }
+  }
 
-    struct AtomicStats
-    {
-      std::atomic<std::uint64_t> accepted{0}, connected{0}, closed{0},
-          errors{0}, tlsHandshakes{0}, tlsFailures{0}, bytesIn{0}, bytesOut{0},
-          epollWakeups{0}, commands{0}, gcRuns{0}, gcClosedIdle{0},
-          gcClosedAged{0}, backpressureCloses{0};
-      std::atomic<std::size_t> sessionsCurrent{0}, sessionsPeak{0};
-    };
+  struct AtomicStats
+  {
+    std::atomic<std::uint64_t> accepted{0}, connected{0}, closed{0}, errors{0}, tlsHandshakes{0},
+      tlsFailures{0}, bytesIn{0}, bytesOut{0}, epollWakeups{0}, commands{0}, gcRuns{0},
+      gcClosedIdle{0}, gcClosedAged{0}, backpressureCloses{0};
+    std::atomic<std::size_t> sessionsCurrent{0}, sessionsPeak{0};
+  };
 
-    Config _cfg{};
-    mutable AtomicStats _atomicStats{};
-    std::atomic<bool> _running{false};
-    int _epollFd{-1}, _eventFd{-1}, _timerFd{-1};
-    std::thread _loop;
-    std::mutex _cb;
-    Callbacks _cbs{};
-    std::mutex _qmx;
-    std::deque<Cmd> _q;
-    std::unordered_map<ListenerId, std::unique_ptr<Listener>> _listeners;
-    std::unordered_map<SessionId, std::unique_ptr<Session>> _sessions;
-    std::unordered_map<std::string, SessionId> _peerIndex;
-    std::unordered_map<int, std::unique_ptr<Tag>> _tags;
-    std::atomic<SessionId> _nextSessionId{1};
-    std::atomic<ListenerId> _nextListenerId{1};
+  Config _cfg{};
+  mutable AtomicStats _atomicStats{};
+  std::atomic<bool> _running{false};
+  int _epollFd{-1}, _eventFd{-1}, _timerFd{-1};
+  std::thread _loop;
+  std::mutex _cb;
+  Callbacks _cbs{};
+  std::mutex _qmx;
+  std::deque<Cmd> _q;
+  std::unordered_map<ListenerId, std::unique_ptr<Listener>> _listeners;
+  std::unordered_map<SessionId, std::unique_ptr<Session>> _sessions;
+  std::unordered_map<std::string, SessionId> _peerIndex;
+  std::unordered_map<int, std::unique_ptr<Tag>> _tags;
+  std::atomic<SessionId> _nextSessionId{1};
+  std::atomic<ListenerId> _nextListenerId{1};
 
-    // New improvements
-    ObjectPool<Session> _sessionPool;
-    ObjectPool<Listener> _listenerPool;
-    HealthMonitor _healthMonitor;
-    CircuitBreakerManager _circuitBreakers;
+  // New improvements
+  ObjectPool<Session> _sessionPool;
+  ObjectPool<Listener> _listenerPool;
+  HealthMonitor _healthMonitor;
+  CircuitBreakerManager _circuitBreakers;
 
-    mutable std::mutex _errorMutex;
-    std::string _lastError;
+  mutable std::mutex _errorMutex;
+  std::string _lastError;
 
-    void setLastError(const std::string& err)
-    {
-      std::lock_guard<std::mutex> lock(_errorMutex);
-      _lastError = err;
-    }
-  };
+  void setLastError(const std::string &err)
+  {
+    std::lock_guard<std::mutex> lock(_errorMutex);
+    _lastError = err;
+  }
+};
 
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/sync_async_transport.hpp b/include/iora/network/sync_async_transport.hpp
index ecfb5a7..4c76bde 100644
--- a/include/iora/network/sync_async_transport.hpp
+++ b/include/iora/network/sync_async_transport.hpp
@@ -37,1246 +37,1192 @@
 #include <unordered_map>
 #include <vector>
 
-#include "transport_types.hpp"
 #include "connection_health.hpp"
 #include "iora/core/logger.hpp"
+#include "transport_types.hpp"
 
 namespace iora
 {
 namespace network
 {
 
-  // Forward declarations
-  struct UnifiedStats;
+// Forward declarations
+struct UnifiedStats;
 
-  /// \brief Basic transport statistics (to avoid circular dependencies)
-  struct BasicTransportStats
-  {
-    std::uint64_t accepted{0};
-    std::uint64_t connected{0};
-    std::uint64_t closed{0};
-    std::uint64_t errors{0};
-    std::uint64_t bytesIn{0};
-    std::uint64_t bytesOut{0};
-    std::size_t sessionsCurrent{0};
-  };
+/// \brief Basic transport statistics (to avoid circular dependencies)
+struct BasicTransportStats
+{
+  std::uint64_t accepted{0};
+  std::uint64_t connected{0};
+  std::uint64_t closed{0};
+  std::uint64_t errors{0};
+  std::uint64_t bytesIn{0};
+  std::uint64_t bytesOut{0};
+  std::size_t sessionsCurrent{0};
+};
+
+/// \brief Base transport interface for SyncAsyncTransport
+/// \note Minimal interface to avoid circular dependencies
+class ITransportBase
+{
+public:
+  virtual ~ITransportBase() = default;
+  virtual bool start() = 0;
+  virtual void stop() = 0;
+  virtual ListenerId addListener(const std::string &bindIp, std::uint16_t port,
+                                 TlsMode tlsMode) = 0;
+  virtual SessionId connect(const std::string &host, std::uint16_t port, TlsMode tlsMode) = 0;
+  virtual bool send(SessionId sid, const void *data, std::size_t n) = 0;
+  virtual bool close(SessionId sid) = 0;
+
+  // Use basic callbacks to avoid dependency on UnifiedCallbacks
+  using DataCallback =
+    std::function<void(SessionId, const std::uint8_t *, std::size_t, const IoResult &)>;
+  using AcceptCallback = std::function<void(SessionId, const std::string &, const IoResult &)>;
+  using ConnectCallback = std::function<void(SessionId, const IoResult &)>;
+  using CloseCallback = std::function<void(SessionId, const IoResult &)>;
+  using ErrorCallback = std::function<void(TransportError, const std::string &)>;
+
+  virtual void setDataCallback(DataCallback cb) = 0;
+  virtual void setAcceptCallback(AcceptCallback cb) = 0;
+  virtual void setConnectCallback(ConnectCallback cb) = 0;
+  virtual void setCloseCallback(CloseCallback cb) = 0;
+  virtual void setErrorCallback(ErrorCallback cb) = 0;
+
+  virtual BasicTransportStats getBasicStats() const = 0;
+};
+
+/// \brief Token for cancelling synchronous operations
+/// \note Non-copyable to ensure clear ownership semantics
+class CancellationToken
+{
+public:
+  CancellationToken() : _cancelled(std::make_shared<std::atomic<bool>>(false)) {}
 
-  /// \brief Base transport interface for SyncAsyncTransport
-  /// \note Minimal interface to avoid circular dependencies
-  class ITransportBase
-  {
-  public:
-    virtual ~ITransportBase() = default;
-    virtual bool start() = 0;
-    virtual void stop() = 0;
-    virtual ListenerId addListener(const std::string& bindIp,
-                                   std::uint16_t port, TlsMode tlsMode) = 0;
-    virtual SessionId connect(const std::string& host, std::uint16_t port,
-                              TlsMode tlsMode) = 0;
-    virtual bool send(SessionId sid, const void* data, std::size_t n) = 0;
-    virtual bool close(SessionId sid) = 0;
-
-    // Use basic callbacks to avoid dependency on UnifiedCallbacks
-    using DataCallback = std::function<void(SessionId, const std::uint8_t*,
-                                            std::size_t, const IoResult&)>;
-    using AcceptCallback =
-        std::function<void(SessionId, const std::string&, const IoResult&)>;
-    using ConnectCallback = std::function<void(SessionId, const IoResult&)>;
-    using CloseCallback = std::function<void(SessionId, const IoResult&)>;
-    using ErrorCallback =
-        std::function<void(TransportError, const std::string&)>;
-
-    virtual void setDataCallback(DataCallback cb) = 0;
-    virtual void setAcceptCallback(AcceptCallback cb) = 0;
-    virtual void setConnectCallback(ConnectCallback cb) = 0;
-    virtual void setCloseCallback(CloseCallback cb) = 0;
-    virtual void setErrorCallback(ErrorCallback cb) = 0;
-
-    virtual BasicTransportStats getBasicStats() const = 0;
-  };
+  // Delete copy operations to prevent shared state confusion
+  CancellationToken(const CancellationToken &) = delete;
+  CancellationToken &operator=(const CancellationToken &) = delete;
+
+  // Allow move operations for transferring ownership
+  CancellationToken(CancellationToken &&) = default;
+  CancellationToken &operator=(CancellationToken &&) = default;
 
-  /// \brief Token for cancelling synchronous operations
-  /// \note Non-copyable to ensure clear ownership semantics
-  class CancellationToken
+  /// \brief Cancel any operations using this token
+  void cancel()
   {
-  public:
-    CancellationToken() : _cancelled(std::make_shared<std::atomic<bool>>(false))
+    _cancelled->store(true);
+    std::lock_guard<std::mutex> lock(_mutex);
+    for (auto &cv : _waiters)
     {
+      cv->notify_all();
     }
+  }
 
-    // Delete copy operations to prevent shared state confusion
-    CancellationToken(const CancellationToken&) = delete;
-    CancellationToken& operator=(const CancellationToken&) = delete;
+  /// \brief Check if token has been cancelled
+  bool isCancelled() const { return _cancelled->load(); }
 
-    // Allow move operations for transferring ownership
-    CancellationToken(CancellationToken&&) = default;
-    CancellationToken& operator=(CancellationToken&&) = default;
+  /// \brief Reset token for reuse
+  void reset()
+  {
+    _cancelled->store(false);
+    std::lock_guard<std::mutex> lock(_mutex);
+    _waiters.clear();
+  }
+
+  /// \brief Register a condition variable to be notified on cancellation
+  void registerWaiter(std::shared_ptr<std::condition_variable> cv)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    _waiters.push_back(cv);
+  }
 
-    /// \brief Cancel any operations using this token
-    void cancel()
+  /// \brief Unregister a condition variable
+  void unregisterWaiter(std::shared_ptr<std::condition_variable> cv)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    _waiters.erase(std::remove(_waiters.begin(), _waiters.end(), cv), _waiters.end());
+  }
+
+private:
+  std::shared_ptr<std::atomic<bool>> _cancelled;
+  mutable std::mutex _mutex;
+  std::vector<std::shared_ptr<std::condition_variable>> _waiters;
+};
+
+/// \brief Source for creating linked cancellation tokens
+/// \note Use this when you need hierarchical cancellation (cancel all
+/// children)
+class CancellationTokenSource
+{
+public:
+  CancellationTokenSource() = default;
+
+  // Non-copyable but movable
+  CancellationTokenSource(const CancellationTokenSource &) = delete;
+  CancellationTokenSource &operator=(const CancellationTokenSource &) = delete;
+  CancellationTokenSource(CancellationTokenSource &&) = default;
+  CancellationTokenSource &operator=(CancellationTokenSource &&) = default;
+
+  /// \brief Create a linked token that will be cancelled when source is
+  /// cancelled
+  std::shared_ptr<CancellationToken> createToken()
+  {
+    auto token = std::make_shared<CancellationToken>();
+    std::lock_guard<std::mutex> lock(_mutex);
+    _tokens.push_back(token);
+    return token;
+  }
+
+  /// \brief Cancel all tokens created from this source
+  void cancelAll()
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    for (auto &weakToken : _tokens)
     {
-      _cancelled->store(true);
-      std::lock_guard<std::mutex> lock(_mutex);
-      for (auto& cv : _waiters)
+      if (auto token = weakToken.lock())
       {
-        cv->notify_all();
+        token->cancel();
       }
     }
+    _tokens.clear();
+  }
 
-    /// \brief Check if token has been cancelled
-    bool isCancelled() const { return _cancelled->load(); }
-
-    /// \brief Reset token for reuse
-    void reset()
-    {
-      _cancelled->store(false);
-      std::lock_guard<std::mutex> lock(_mutex);
-      _waiters.clear();
-    }
-
-    /// \brief Register a condition variable to be notified on cancellation
-    void registerWaiter(std::shared_ptr<std::condition_variable> cv)
+  /// \brief Get the number of active tokens
+  size_t activeTokenCount() const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    size_t count = 0;
+    for (const auto &weakToken : _tokens)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      _waiters.push_back(cv);
+      if (weakToken.lock())
+      {
+        count++;
+      }
     }
+    return count;
+  }
 
-    /// \brief Unregister a condition variable
-    void unregisterWaiter(std::shared_ptr<std::condition_variable> cv)
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      _waiters.erase(std::remove(_waiters.begin(), _waiters.end(), cv),
-                     _waiters.end());
-    }
+private:
+  mutable std::mutex _mutex;
+  std::vector<std::weak_ptr<CancellationToken>> _tokens;
+};
 
-  private:
-    std::shared_ptr<std::atomic<bool>> _cancelled;
-    mutable std::mutex _mutex;
-    std::vector<std::shared_ptr<std::condition_variable>> _waiters;
-  };
+/// \brief Detailed connection health metrics for hybrid transport
+struct HybridConnectionHealth
+{
+  bool isHealthy{true};
+  std::chrono::steady_clock::time_point lastActivity;
+  std::chrono::steady_clock::time_point lastError;
+  std::uint32_t errorCount{0};
+  std::uint32_t successCount{0};
+  std::chrono::milliseconds averageRtt{0};
+  std::size_t pendingOperations{0};
+  std::size_t bytesIn{0};
+  std::size_t bytesOut{0};
+  TransportError lastErrorType{TransportError::None};
+  std::string lastErrorMessage;
+};
+
+/// \brief Read mode for exclusive access control
+enum class ReadMode
+{
+  Async,   ///< Callback-based reads (default)
+  Sync,    ///< Blocking reads via receiveSync()
+  Disabled ///< No reads allowed
+};
 
-  /// \brief Source for creating linked cancellation tokens
-  /// \note Use this when you need hierarchical cancellation (cancel all
-  /// children)
-  class CancellationTokenSource
+/// \brief Result of a sync operation with detailed error info
+struct SyncResult
+{
+  bool ok{false};
+  TransportError error{TransportError::None};
+  std::string errorMessage;
+  int sysError{0};
+  int tlsError{0};
+  std::size_t bytesTransferred{0};
+  std::chrono::milliseconds duration{0};
+
+  static SyncResult success(std::size_t bytes = 0)
   {
-  public:
-    CancellationTokenSource() = default;
-
-    // Non-copyable but movable
-    CancellationTokenSource(const CancellationTokenSource&) = delete;
-    CancellationTokenSource& operator=(const CancellationTokenSource&) = delete;
-    CancellationTokenSource(CancellationTokenSource&&) = default;
-    CancellationTokenSource& operator=(CancellationTokenSource&&) = default;
-
-    /// \brief Create a linked token that will be cancelled when source is
-    /// cancelled
-    std::shared_ptr<CancellationToken> createToken()
-    {
-      auto token = std::make_shared<CancellationToken>();
-      std::lock_guard<std::mutex> lock(_mutex);
-      _tokens.push_back(token);
-      return token;
-    }
+    SyncResult r;
+    r.ok = true;
+    r.bytesTransferred = bytes;
+    return r;
+  }
+
+  static SyncResult failure(TransportError err, const std::string &msg, int sysErr = 0,
+                            int tlsErr = 0)
+  {
+    SyncResult r;
+    r.ok = false;
+    r.error = err;
+    r.errorMessage = msg;
+    r.sysError = sysErr;
+    r.tlsError = tlsErr;
+    return r;
+  }
+
+  static SyncResult cancelled()
+  {
+    return failure(TransportError::Cancelled, "Operation cancelled");
+  }
 
-    /// \brief Cancel all tokens created from this source
-    void cancelAll()
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      for (auto& weakToken : _tokens)
-      {
-        if (auto token = weakToken.lock())
-        {
-          token->cancel();
-        }
-      }
-      _tokens.clear();
-    }
+  static SyncResult timeout() { return failure(TransportError::Timeout, "Operation timed out"); }
+};
 
-    /// \brief Get the number of active tokens
-    size_t activeTokenCount() const
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      size_t count = 0;
-      for (const auto& weakToken : _tokens)
-      {
-        if (weakToken.lock())
-        {
-          count++;
-        }
-      }
-      return count;
-    }
+/// \brief Synchronous/asynchronous transport providing both sync and async operations
+class SyncAsyncTransport
+{
+public:
+  using DataCallback =
+    std::function<void(SessionId, const std::uint8_t *, std::size_t, const IoResult &)>;
+  using ConnectCallback = std::function<void(SessionId, const IoResult &)>;
+  using CloseCallback = std::function<void(SessionId, const IoResult &)>;
+  using ErrorCallback = std::function<void(TransportError, const std::string &)>;
+  using SendCompleteCallback = std::function<void(SessionId, const SyncResult &)>;
+
+  /// \brief Configuration for sync/async transport
+  struct Config
+  {
+    std::size_t maxPendingSyncOps{32};               ///< Max queued sync operations per session
+    std::size_t maxSyncReceiveBuffer{1024 * 1024};   ///< Max buffer for sync receives
+    std::chrono::milliseconds defaultTimeout{30000}; ///< Default sync operation timeout
+    bool allowReadModeSwitch{true};                  ///< Allow switching between read modes
+    bool autoHealthMonitoring{true};                 ///< Automatically track connection health
+
+    /// \brief Default constructor
+    Config() = default;
 
-  private:
-    mutable std::mutex _mutex;
-    std::vector<std::weak_ptr<CancellationToken>> _tokens;
+    /// \brief Get default configuration
+    static Config defaultConfig() { return Config{}; }
   };
 
-  /// \brief Detailed connection health metrics for hybrid transport
-  struct HybridConnectionHealth
+  /// \brief Construct with underlying transport and default configuration
+  explicit SyncAsyncTransport(std::unique_ptr<ITransportBase> transport)
+      : _transport(std::move(transport)), _config(Config::defaultConfig())
   {
-    bool isHealthy{true};
-    std::chrono::steady_clock::time_point lastActivity;
-    std::chrono::steady_clock::time_point lastError;
-    std::uint32_t errorCount{0};
-    std::uint32_t successCount{0};
-    std::chrono::milliseconds averageRtt{0};
-    std::size_t pendingOperations{0};
-    std::size_t bytesIn{0};
-    std::size_t bytesOut{0};
-    TransportError lastErrorType{TransportError::None};
-    std::string lastErrorMessage;
-  };
+    setupInternalCallbacks();
+  }
 
-  /// \brief Read mode for exclusive access control
-  enum class ReadMode
+  /// \brief Construct with underlying transport and configuration
+  SyncAsyncTransport(std::unique_ptr<ITransportBase> transport, const Config &config)
+      : _transport(std::move(transport)), _config(config)
   {
-    Async,   ///< Callback-based reads (default)
-    Sync,    ///< Blocking reads via receiveSync()
-    Disabled ///< No reads allowed
-  };
+    setupInternalCallbacks();
+  }
+
+  ~SyncAsyncTransport() { stop(); }
+
+  // Disable copy/move
+  SyncAsyncTransport(const SyncAsyncTransport &) = delete;
+  SyncAsyncTransport &operator=(const SyncAsyncTransport &) = delete;
 
-  /// \brief Result of a sync operation with detailed error info
-  struct SyncResult
+  /// \brief Start the transport
+  bool start()
   {
-    bool ok{false};
-    TransportError error{TransportError::None};
-    std::string errorMessage;
-    int sysError{0};
-    int tlsError{0};
-    std::size_t bytesTransferred{0};
-    std::chrono::milliseconds duration{0};
-
-    static SyncResult success(std::size_t bytes = 0)
+    std::lock_guard<std::mutex> lock(_mutex);
+    if (_running)
     {
-      SyncResult r;
-      r.ok = true;
-      r.bytesTransferred = bytes;
-      return r;
+      return false;
     }
 
-    static SyncResult failure(TransportError err, const std::string& msg,
-                              int sysErr = 0, int tlsErr = 0)
+    if (!_transport->start())
     {
-      SyncResult r;
-      r.ok = false;
-      r.error = err;
-      r.errorMessage = msg;
-      r.sysError = sysErr;
-      r.tlsError = tlsErr;
-      return r;
+      return false;
     }
 
-    static SyncResult cancelled()
-    {
-      return failure(TransportError::Cancelled, "Operation cancelled");
-    }
+    _running = true;
+    _processingThread = std::thread([this] { processOperations(); });
+    return true;
+  }
 
-    static SyncResult timeout()
+  /// \brief Stop the transport
+  void stop()
+  {
+    iora::core::Logger::debug("SyncAsyncTransport::stop() - Starting");
     {
-      return failure(TransportError::Timeout, "Operation timed out");
+      std::lock_guard<std::mutex> lock(_mutex);
+      if (!_running)
+      {
+        iora::core::Logger::debug("SyncAsyncTransport::stop() - Already stopped");
+        return;
+      }
+      _running = false;
+      _stopCv.notify_all();
     }
-  };
 
-  /// \brief Synchronous/asynchronous transport providing both sync and async operations
-  class SyncAsyncTransport
-  {
-  public:
-    using DataCallback = std::function<void(SessionId, const std::uint8_t*,
-                                            std::size_t, const IoResult&)>;
-    using ConnectCallback = std::function<void(SessionId, const IoResult&)>;
-    using CloseCallback = std::function<void(SessionId, const IoResult&)>;
-    using ErrorCallback =
-        std::function<void(TransportError, const std::string&)>;
-    using SendCompleteCallback =
-        std::function<void(SessionId, const SyncResult&)>;
-
-    /// \brief Configuration for sync/async transport
-    struct Config
-    {
-      std::size_t maxPendingSyncOps{
-          32}; ///< Max queued sync operations per session
-      std::size_t maxSyncReceiveBuffer{1024 *
-                                       1024}; ///< Max buffer for sync receives
-      std::chrono::milliseconds defaultTimeout{
-          30000};                     ///< Default sync operation timeout
-      bool allowReadModeSwitch{true}; ///< Allow switching between read modes
-      bool autoHealthMonitoring{
-          true}; ///< Automatically track connection health
-
-      /// \brief Default constructor
-      Config() = default;
-
-      /// \brief Get default configuration
-      static Config defaultConfig() { return Config{}; }
-    };
+    iora::core::Logger::debug("SyncAsyncTransport::stop() - Cancelling all operations");
+    // Cancel all pending operations
+    cancelAllOperations();
 
-    /// \brief Construct with underlying transport and default configuration
-    explicit SyncAsyncTransport(std::unique_ptr<ITransportBase> transport)
-      : _transport(std::move(transport)), _config(Config::defaultConfig())
+    if (_processingThread.joinable())
     {
-      setupInternalCallbacks();
+      iora::core::Logger::debug("SyncAsyncTransport::stop() - Joining processing thread");
+      _processingThread.join();
+      iora::core::Logger::debug("SyncAsyncTransport::stop() - Processing thread joined");
     }
 
-    /// \brief Construct with underlying transport and configuration
-    SyncAsyncTransport(std::unique_ptr<ITransportBase> transport,
-                    const Config& config)
-      : _transport(std::move(transport)), _config(config)
-    {
-      setupInternalCallbacks();
-    }
+    iora::core::Logger::debug("SyncAsyncTransport::stop() - Stopping underlying transport");
+    _transport->stop();
+    iora::core::Logger::debug("SyncAsyncTransport::stop() - Completed");
+  }
 
-    ~SyncAsyncTransport() { stop(); }
+  // ===== Read Mode Management =====
 
-    // Disable copy/move
-    SyncAsyncTransport(const SyncAsyncTransport&) = delete;
-    SyncAsyncTransport& operator=(const SyncAsyncTransport&) = delete;
+  /// \brief Set the read mode for a session (exclusive access)
+  /// \return true if mode was successfully set, false if operation in
+  /// progress
+  bool setReadMode(SessionId sid, ReadMode mode)
+  {
+    std::lock_guard<std::mutex> lock(_sessionMutex);
+    auto &session = getOrCreateSession(sid);
 
-    /// \brief Start the transport
-    bool start()
+    // Check if there's an active operation preventing mode switch
+    if (session.syncReadActive || session.pendingSyncReads > 0)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      if (_running)
+      if (!_config.allowReadModeSwitch)
       {
         return false;
       }
+      // Wait for operations to complete if switching is allowed
+      waitForPendingReads(session);
+    }
 
-      if (!_transport->start())
-      {
-        return false;
-      }
+    ReadMode oldMode = session.readMode;
+    session.readMode = mode;
 
-      _running = true;
-      _processingThread = std::thread([this] { processOperations(); });
-      return true;
+    // Clear callback if switching away from async
+    if (oldMode == ReadMode::Async && mode != ReadMode::Async)
+    {
+      session.asyncDataCallback = nullptr;
     }
 
-    /// \brief Stop the transport
-    void stop()
+    return true;
+  }
+
+  /// \brief Get current read mode for a session
+  ReadMode getReadMode(SessionId sid) const
+  {
+    std::lock_guard<std::mutex> lock(_sessionMutex);
+    auto it = _sessions.find(sid);
+    if (it != _sessions.end())
     {
-      iora::core::Logger::debug("SyncAsyncTransport::stop() - Starting");
-      {
-        std::lock_guard<std::mutex> lock(_mutex);
-        if (!_running)
-        {
-          iora::core::Logger::debug(
-              "SyncAsyncTransport::stop() - Already stopped");
-          return;
-        }
-        _running = false;
-        _stopCv.notify_all();
-      }
+      return it->second.readMode;
+    }
+    return ReadMode::Async; // Default
+  }
 
-      iora::core::Logger::debug(
-          "SyncAsyncTransport::stop() - Cancelling all operations");
-      // Cancel all pending operations
-      cancelAllOperations();
+  // ===== Async Operations =====
 
-      if (_processingThread.joinable())
-      {
-        iora::core::Logger::debug(
-            "SyncAsyncTransport::stop() - Joining processing thread");
-        _processingThread.join();
-        iora::core::Logger::debug(
-            "SyncAsyncTransport::stop() - Processing thread joined");
-      }
+  /// \brief Set async data callback (only works in Async read mode)
+  bool setDataCallback(SessionId sid, DataCallback cb)
+  {
+    std::lock_guard<std::mutex> lock(_sessionMutex);
+    auto &session = getOrCreateSession(sid);
 
-      iora::core::Logger::debug(
-          "SyncAsyncTransport::stop() - Stopping underlying transport");
-      _transport->stop();
-      iora::core::Logger::debug("SyncAsyncTransport::stop() - Completed");
+    if (session.readMode != ReadMode::Async)
+    {
+      return false;
     }
 
-    // ===== Read Mode Management =====
-
-    /// \brief Set the read mode for a session (exclusive access)
-    /// \return true if mode was successfully set, false if operation in
-    /// progress
-    bool setReadMode(SessionId sid, ReadMode mode)
-    {
-      std::lock_guard<std::mutex> lock(_sessionMutex);
-      auto& session = getOrCreateSession(sid);
+    session.asyncDataCallback = cb;
+    return true;
+  }
 
-      // Check if there's an active operation preventing mode switch
-      if (session.syncReadActive || session.pendingSyncReads > 0)
-      {
-        if (!_config.allowReadModeSwitch)
-        {
-          return false;
-        }
-        // Wait for operations to complete if switching is allowed
-        waitForPendingReads(session);
-      }
+  /// \brief Set async connect callback
+  void setConnectCallback(ConnectCallback cb)
+  {
+    std::lock_guard<std::mutex> lock(_callbackMutex);
+    _connectCallback = cb;
+  }
 
-      ReadMode oldMode = session.readMode;
-      session.readMode = mode;
+  /// \brief Set async close callback
+  void setCloseCallback(CloseCallback cb)
+  {
+    std::lock_guard<std::mutex> lock(_callbackMutex);
+    _closeCallback = cb;
+  }
 
-      // Clear callback if switching away from async
-      if (oldMode == ReadMode::Async && mode != ReadMode::Async)
-      {
-        session.asyncDataCallback = nullptr;
-      }
+  /// \brief Set async error callback
+  void setErrorCallback(ErrorCallback cb)
+  {
+    std::lock_guard<std::mutex> lock(_callbackMutex);
+    _errorCallback = cb;
+  }
 
-      return true;
-    }
+  /// \brief Async send with completion callback
+  void sendAsync(SessionId sid, const void *data, std::size_t len,
+                 SendCompleteCallback cb = nullptr)
+  {
+    // Direct pass-through to underlying async transport
+    bool queued = _transport->send(sid, data, len);
 
-    /// \brief Get current read mode for a session
-    ReadMode getReadMode(SessionId sid) const
+    if (cb)
     {
-      std::lock_guard<std::mutex> lock(_sessionMutex);
-      auto it = _sessions.find(sid);
-      if (it != _sessions.end())
+      if (queued)
       {
-        return it->second.readMode;
+        // Track for completion notification if needed
+        std::lock_guard<std::mutex> lock(_sessionMutex);
+        auto &session = getOrCreateSession(sid);
+        session.pendingAsyncSends.push_back(cb);
       }
-      return ReadMode::Async; // Default
-    }
-
-    // ===== Async Operations =====
-
-    /// \brief Set async data callback (only works in Async read mode)
-    bool setDataCallback(SessionId sid, DataCallback cb)
-    {
-      std::lock_guard<std::mutex> lock(_sessionMutex);
-      auto& session = getOrCreateSession(sid);
-
-      if (session.readMode != ReadMode::Async)
+      else
       {
-        return false;
+        cb(sid, SyncResult::failure(TransportError::Unknown, "Failed to queue send"));
       }
-
-      session.asyncDataCallback = cb;
-      return true;
     }
 
-    /// \brief Set async connect callback
-    void setConnectCallback(ConnectCallback cb)
-    {
-      std::lock_guard<std::mutex> lock(_callbackMutex);
-      _connectCallback = cb;
-    }
+    updateHealth(sid, queued, len, true);
+  }
 
-    /// \brief Set async close callback
-    void setCloseCallback(CloseCallback cb)
-    {
-      std::lock_guard<std::mutex> lock(_callbackMutex);
-      _closeCallback = cb;
-    }
+  // ===== Sync Operations =====
 
-    /// \brief Set async error callback
-    void setErrorCallback(ErrorCallback cb)
+  /// \brief Synchronous send - blocks until complete or timeout
+  SyncResult sendSync(SessionId sid, const void *data, std::size_t len,
+                      std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+  {
+    if (timeout == std::chrono::milliseconds::max())
     {
-      std::lock_guard<std::mutex> lock(_callbackMutex);
-      _errorCallback = cb;
+      timeout = _config.defaultTimeout;
     }
 
-    /// \brief Async send with completion callback
-    void sendAsync(SessionId sid, const void* data, std::size_t len,
-                   SendCompleteCallback cb = nullptr)
+    core::Logger::debug("SyncAsyncTransport: sendSync starting for session " + std::to_string(sid) +
+                        ", len=" + std::to_string(len) +
+                        ", timeout=" + std::to_string(timeout.count()) + "ms");
+
+    auto operation = std::make_shared<SyncOperation>();
+    operation->type = SyncOperation::Type::Send;
+    operation->sessionId = sid;
+    operation->data.assign(static_cast<const std::uint8_t *>(data),
+                           static_cast<const std::uint8_t *>(data) + len);
+    operation->timeout = timeout;
+    operation->startTime = std::chrono::steady_clock::now();
+
+    // Queue the operation
     {
-      // Direct pass-through to underlying async transport
-      bool queued = _transport->send(sid, data, len);
+      std::lock_guard<std::mutex> lock(_sessionMutex);
+      auto &session = getOrCreateSession(sid);
 
-      if (cb)
+      if (session.pendingSyncOps.size() >= _config.maxPendingSyncOps)
       {
-        if (queued)
-        {
-          // Track for completion notification if needed
-          std::lock_guard<std::mutex> lock(_sessionMutex);
-          auto& session = getOrCreateSession(sid);
-          session.pendingAsyncSends.push_back(cb);
-        }
-        else
-        {
-          cb(sid, SyncResult::failure(TransportError::Unknown,
-                                      "Failed to queue send"));
-        }
+        return SyncResult::failure(TransportError::WriteBackpressure,
+                                   "Too many pending operations");
       }
 
-      updateHealth(sid, queued, len, true);
+      session.pendingSyncOps.push_back(operation);
+      _operationCv.notify_one();
     }
 
-    // ===== Sync Operations =====
+    // Wait for completion
+    std::unique_lock<std::mutex> lock(operation->mutex);
+    bool completed =
+      operation->cv.wait_for(lock, timeout, [operation] { return operation->completed.load(); });
 
-    /// \brief Synchronous send - blocks until complete or timeout
-    SyncResult sendSync(
-        SessionId sid, const void* data, std::size_t len,
-        std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+    if (!completed)
     {
-      if (timeout == std::chrono::milliseconds::max())
-      {
-        timeout = _config.defaultTimeout;
-      }
-
-      core::Logger::debug("SyncAsyncTransport: sendSync starting for session " +
-                          std::to_string(sid) + ", len=" + std::to_string(len) +
-                          ", timeout=" + std::to_string(timeout.count()) +
-                          "ms");
-
-      auto operation = std::make_shared<SyncOperation>();
-      operation->type = SyncOperation::Type::Send;
-      operation->sessionId = sid;
-      operation->data.assign(static_cast<const std::uint8_t*>(data),
-                             static_cast<const std::uint8_t*>(data) + len);
-      operation->timeout = timeout;
-      operation->startTime = std::chrono::steady_clock::now();
-
-      // Queue the operation
-      {
-        std::lock_guard<std::mutex> lock(_sessionMutex);
-        auto& session = getOrCreateSession(sid);
-
-        if (session.pendingSyncOps.size() >= _config.maxPendingSyncOps)
-        {
-          return SyncResult::failure(TransportError::WriteBackpressure,
-                                     "Too many pending operations");
-        }
+      operation->cancelled = true;
+      core::Logger::debug("SyncAsyncTransport: sendSync timed out for session " +
+                          std::to_string(sid));
+      return SyncResult::timeout();
+    }
 
-        session.pendingSyncOps.push_back(operation);
-        _operationCv.notify_one();
-      }
+    updateHealth(sid, operation->result.ok, len, true);
 
-      // Wait for completion
-      std::unique_lock<std::mutex> lock(operation->mutex);
-      bool completed = operation->cv.wait_for(
-          lock, timeout, [operation] { return operation->completed.load(); });
+    core::Logger::debug("SyncAsyncTransport: sendSync completed for session " +
+                        std::to_string(sid) +
+                        ", success=" + (operation->result.ok ? "true" : "false") +
+                        ", error=" + operation->result.errorMessage);
 
-      if (!completed)
-      {
-        operation->cancelled = true;
-        core::Logger::debug("SyncAsyncTransport: sendSync timed out for session " +
-                            std::to_string(sid));
-        return SyncResult::timeout();
-      }
+    return operation->result;
+  }
 
-      updateHealth(sid, operation->result.ok, len, true);
-
-      core::Logger::debug("SyncAsyncTransport: sendSync completed for session " +
-                          std::to_string(sid) + ", success=" +
-                          (operation->result.ok ? "true" : "false") +
-                          ", error=" + operation->result.errorMessage);
-
-      return operation->result;
+  /// \brief Cancellable synchronous send
+  SyncResult
+  sendSyncCancellable(SessionId sid, const void *data, std::size_t len, CancellationToken &token,
+                      std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+  {
+    if (timeout == std::chrono::milliseconds::max())
+    {
+      timeout = _config.defaultTimeout;
     }
 
-    /// \brief Cancellable synchronous send
-    SyncResult sendSyncCancellable(
-        SessionId sid, const void* data, std::size_t len,
-        CancellationToken& token,
-        std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+    auto operation = std::make_shared<SyncOperation>();
+    operation->type = SyncOperation::Type::Send;
+    operation->sessionId = sid;
+    operation->data.assign(static_cast<const std::uint8_t *>(data),
+                           static_cast<const std::uint8_t *>(data) + len);
+    operation->timeout = timeout;
+    operation->startTime = std::chrono::steady_clock::now();
+    operation->cancellationToken = &token;
+
+    // Register for cancellation
+    auto cvPtr =
+      std::shared_ptr<std::condition_variable>(&operation->cv, [](std::condition_variable *) {});
+    token.registerWaiter(cvPtr);
+
+    // Queue the operation
     {
-      if (timeout == std::chrono::milliseconds::max())
-      {
-        timeout = _config.defaultTimeout;
-      }
+      std::lock_guard<std::mutex> lock(_sessionMutex);
+      auto &session = getOrCreateSession(sid);
 
-      auto operation = std::make_shared<SyncOperation>();
-      operation->type = SyncOperation::Type::Send;
-      operation->sessionId = sid;
-      operation->data.assign(static_cast<const std::uint8_t*>(data),
-                             static_cast<const std::uint8_t*>(data) + len);
-      operation->timeout = timeout;
-      operation->startTime = std::chrono::steady_clock::now();
-      operation->cancellationToken = &token;
-
-      // Register for cancellation
-      auto cvPtr = std::shared_ptr<std::condition_variable>(
-          &operation->cv, [](std::condition_variable*) {});
-      token.registerWaiter(cvPtr);
-
-      // Queue the operation
+      if (session.pendingSyncOps.size() >= _config.maxPendingSyncOps)
       {
-        std::lock_guard<std::mutex> lock(_sessionMutex);
-        auto& session = getOrCreateSession(sid);
-
-        if (session.pendingSyncOps.size() >= _config.maxPendingSyncOps)
-        {
-          token.unregisterWaiter(cvPtr);
-          return SyncResult::failure(TransportError::WriteBackpressure,
-                                     "Too many pending operations");
-        }
-
-        session.pendingSyncOps.push_back(operation);
-        _operationCv.notify_one();
+        token.unregisterWaiter(cvPtr);
+        return SyncResult::failure(TransportError::WriteBackpressure,
+                                   "Too many pending operations");
       }
 
-      // Wait for completion or cancellation
-      std::unique_lock<std::mutex> lock(operation->mutex);
-      bool completed = operation->cv.wait_for(
-          lock, timeout,
-          [operation, &token]
-          { return operation->completed.load() || token.isCancelled(); });
-
-      token.unregisterWaiter(cvPtr);
+      session.pendingSyncOps.push_back(operation);
+      _operationCv.notify_one();
+    }
 
-      if (token.isCancelled())
-      {
-        operation->cancelled = true;
-        return SyncResult::cancelled();
-      }
+    // Wait for completion or cancellation
+    std::unique_lock<std::mutex> lock(operation->mutex);
+    bool completed =
+      operation->cv.wait_for(lock, timeout, [operation, &token]
+                             { return operation->completed.load() || token.isCancelled(); });
 
-      if (!completed)
-      {
-        operation->cancelled = true;
-        return SyncResult::timeout();
-      }
+    token.unregisterWaiter(cvPtr);
 
-      updateHealth(sid, operation->result.ok, len, true);
-      return operation->result;
+    if (token.isCancelled())
+    {
+      operation->cancelled = true;
+      return SyncResult::cancelled();
     }
 
-    /// \brief Synchronous receive - blocks until data available or timeout
-    /// \note Only works in Sync read mode
-    SyncResult receiveSync(
-        SessionId sid, void* buffer, std::size_t& len,
-        std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+    if (!completed)
     {
-      if (timeout == std::chrono::milliseconds::max())
-      {
-        timeout = _config.defaultTimeout;
-      }
+      operation->cancelled = true;
+      return SyncResult::timeout();
+    }
 
-      std::unique_lock<std::mutex> lock(_sessionMutex);
-      auto& session = getOrCreateSession(sid);
+    updateHealth(sid, operation->result.ok, len, true);
+    return operation->result;
+  }
 
-      // Check read mode
-      if (session.readMode != ReadMode::Sync)
-      {
-        return SyncResult::failure(TransportError::Config,
-                                   "Session not in Sync read mode");
-      }
+  /// \brief Synchronous receive - blocks until data available or timeout
+  /// \note Only works in Sync read mode
+  SyncResult receiveSync(SessionId sid, void *buffer, std::size_t &len,
+                         std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+  {
+    if (timeout == std::chrono::milliseconds::max())
+    {
+      timeout = _config.defaultTimeout;
+    }
 
-      // Mark sync read as active
-      session.syncReadActive = true;
-      session.pendingSyncReads++;
+    std::unique_lock<std::mutex> lock(_sessionMutex);
+    auto &session = getOrCreateSession(sid);
 
-      // Wait for data or session closure
-      bool hasData =
-          session.readCv.wait_for(lock, timeout,
-                                  [&] {
-                                    return !session.readBuffer.empty() ||
-                                           !_running || session.closed.load();
-                                  });
+    // Check read mode
+    if (session.readMode != ReadMode::Sync)
+    {
+      return SyncResult::failure(TransportError::Config, "Session not in Sync read mode");
+    }
 
-      session.syncReadActive = false;
-      session.pendingSyncReads--;
+    // Mark sync read as active
+    session.syncReadActive = true;
+    session.pendingSyncReads++;
 
-      if (!_running)
-      {
-        return SyncResult::failure(TransportError::Unknown,
-                                   "Transport stopped");
-      }
+    // Wait for data or session closure
+    bool hasData = session.readCv.wait_for(
+      lock, timeout,
+      [&] { return !session.readBuffer.empty() || !_running || session.closed.load(); });
 
-      if (session.closed.load())
-      {
-        core::Logger::debug(
-            "SyncAsyncTransport: receiveSync detected closed session " +
-            std::to_string(sid));
-        return SyncResult::failure(TransportError::PeerClosed,
-                                   "Session closed during receive");
-      }
+    session.syncReadActive = false;
+    session.pendingSyncReads--;
 
-      if (!hasData)
-      {
-        return SyncResult::timeout();
-      }
+    if (!_running)
+    {
+      return SyncResult::failure(TransportError::Unknown, "Transport stopped");
+    }
 
-      // Copy data to user buffer
-      auto& front = session.readBuffer.front();
-      std::size_t copyLen = std::min(len, front.size());
-      std::memcpy(buffer, front.data(), copyLen);
-      len = copyLen;
+    if (session.closed.load())
+    {
+      core::Logger::debug("SyncAsyncTransport: receiveSync detected closed session " +
+                          std::to_string(sid));
+      return SyncResult::failure(TransportError::PeerClosed, "Session closed during receive");
+    }
 
-      // Remove consumed data
-      if (copyLen >= front.size())
-      {
-        session.readBuffer.pop_front();
-      }
-      else
-      {
-        // Partial read - keep remaining data
-        front.erase(front.begin(), front.begin() + copyLen);
-      }
+    if (!hasData)
+    {
+      return SyncResult::timeout();
+    }
 
-      // Release the lock before calling updateHealth to avoid deadlock
-      lock.unlock();
+    // Copy data to user buffer
+    auto &front = session.readBuffer.front();
+    std::size_t copyLen = std::min(len, front.size());
+    std::memcpy(buffer, front.data(), copyLen);
+    len = copyLen;
 
-      updateHealth(sid, true, copyLen, false);
-      return SyncResult::success(copyLen);
+    // Remove consumed data
+    if (copyLen >= front.size())
+    {
+      session.readBuffer.pop_front();
     }
-
-    /// \brief Cancellable synchronous receive
-    SyncResult receiveSyncCancellable(
-        SessionId sid, void* buffer, std::size_t& len, CancellationToken& token,
-        std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+    else
     {
-      if (timeout == std::chrono::milliseconds::max())
-      {
-        timeout = _config.defaultTimeout;
-      }
+      // Partial read - keep remaining data
+      front.erase(front.begin(), front.begin() + copyLen);
+    }
 
-      std::unique_lock<std::mutex> lock(_sessionMutex);
-      auto& session = getOrCreateSession(sid);
+    // Release the lock before calling updateHealth to avoid deadlock
+    lock.unlock();
 
-      // Check read mode
-      if (session.readMode != ReadMode::Sync)
-      {
-        return SyncResult::failure(TransportError::Config,
-                                   "Session not in Sync read mode");
-      }
+    updateHealth(sid, true, copyLen, false);
+    return SyncResult::success(copyLen);
+  }
 
-      // Mark sync read as active
-      session.syncReadActive = true;
-      session.pendingSyncReads++;
+  /// \brief Cancellable synchronous receive
+  SyncResult
+  receiveSyncCancellable(SessionId sid, void *buffer, std::size_t &len, CancellationToken &token,
+                         std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+  {
+    if (timeout == std::chrono::milliseconds::max())
+    {
+      timeout = _config.defaultTimeout;
+    }
 
-      // Register for cancellation
-      auto cvPtr = std::shared_ptr<std::condition_variable>(
-          &session.readCv, [](std::condition_variable*) {});
-      token.registerWaiter(cvPtr);
+    std::unique_lock<std::mutex> lock(_sessionMutex);
+    auto &session = getOrCreateSession(sid);
 
-      // Wait for data or cancellation
-      bool hasData =
-          session.readCv.wait_for(lock, timeout,
-                                  [&] {
-                                    return !session.readBuffer.empty() ||
-                                           !_running || token.isCancelled();
-                                  });
+    // Check read mode
+    if (session.readMode != ReadMode::Sync)
+    {
+      return SyncResult::failure(TransportError::Config, "Session not in Sync read mode");
+    }
 
-      token.unregisterWaiter(cvPtr);
+    // Mark sync read as active
+    session.syncReadActive = true;
+    session.pendingSyncReads++;
 
-      session.syncReadActive = false;
-      session.pendingSyncReads--;
+    // Register for cancellation
+    auto cvPtr =
+      std::shared_ptr<std::condition_variable>(&session.readCv, [](std::condition_variable *) {});
+    token.registerWaiter(cvPtr);
 
-      if (token.isCancelled())
-      {
-        return SyncResult::cancelled();
-      }
+    // Wait for data or cancellation
+    bool hasData = session.readCv.wait_for(
+      lock, timeout,
+      [&] { return !session.readBuffer.empty() || !_running || token.isCancelled(); });
 
-      if (!_running)
-      {
-        return SyncResult::failure(TransportError::Unknown,
-                                   "Transport stopped");
-      }
+    token.unregisterWaiter(cvPtr);
 
-      if (!hasData)
-      {
-        return SyncResult::timeout();
-      }
+    session.syncReadActive = false;
+    session.pendingSyncReads--;
 
-      // Copy data to user buffer
-      auto& front = session.readBuffer.front();
-      std::size_t copyLen = std::min(len, front.size());
-      std::memcpy(buffer, front.data(), copyLen);
-      len = copyLen;
+    if (token.isCancelled())
+    {
+      return SyncResult::cancelled();
+    }
 
-      // Remove consumed data
-      if (copyLen >= front.size())
-      {
-        session.readBuffer.pop_front();
-      }
-      else
-      {
-        // Partial read - keep remaining data
-        front.erase(front.begin(), front.begin() + copyLen);
-      }
+    if (!_running)
+    {
+      return SyncResult::failure(TransportError::Unknown, "Transport stopped");
+    }
 
-      updateHealth(sid, true, copyLen, false);
-      return SyncResult::success(copyLen);
+    if (!hasData)
+    {
+      return SyncResult::timeout();
     }
 
-    // ===== Connection Management =====
+    // Copy data to user buffer
+    auto &front = session.readBuffer.front();
+    std::size_t copyLen = std::min(len, front.size());
+    std::memcpy(buffer, front.data(), copyLen);
+    len = copyLen;
 
-    /// \brief Add a listener
-    ListenerId addListener(const std::string& bind, std::uint16_t port,
-                           TlsMode tls = TlsMode::None)
+    // Remove consumed data
+    if (copyLen >= front.size())
     {
-      return _transport->addListener(bind, port, tls);
+      session.readBuffer.pop_front();
     }
-
-    /// \brief Connect to a remote host
-    SessionId connect(const std::string& host, std::uint16_t port,
-                      TlsMode tls = TlsMode::None)
+    else
     {
-      SessionId sid = _transport->connect(host, port, tls);
-      if (sid != 0)
-      {
-        std::lock_guard<std::mutex> lock(_sessionMutex);
-        getOrCreateSession(sid); // Initialize session state
-      }
-      return sid;
+      // Partial read - keep remaining data
+      front.erase(front.begin(), front.begin() + copyLen);
     }
 
-    /// \brief Close a session
-    bool close(SessionId sid)
-    {
-      // Clean up session state
-      {
-        std::lock_guard<std::mutex> lock(_sessionMutex);
-        auto it = _sessions.find(sid);
-        if (it != _sessions.end())
-        {
-          // Cancel pending operations
-          for (auto& op : it->second.pendingSyncOps)
-          {
-            op->cancelled = true;
-            op->result =
-                SyncResult::failure(TransportError::Unknown, "Session closed");
-            op->completed = true;
-            op->cv.notify_all();
-          }
-          it->second.pendingSyncOps.clear();
-          it->second.readCv.notify_all();
-        }
-      }
+    updateHealth(sid, true, copyLen, false);
+    return SyncResult::success(copyLen);
+  }
+
+  // ===== Connection Management =====
+
+  /// \brief Add a listener
+  ListenerId addListener(const std::string &bind, std::uint16_t port, TlsMode tls = TlsMode::None)
+  {
+    return _transport->addListener(bind, port, tls);
+  }
 
-      return _transport->close(sid);
+  /// \brief Connect to a remote host
+  SessionId connect(const std::string &host, std::uint16_t port, TlsMode tls = TlsMode::None)
+  {
+    SessionId sid = _transport->connect(host, port, tls);
+    if (sid != 0)
+    {
+      std::lock_guard<std::mutex> lock(_sessionMutex);
+      getOrCreateSession(sid); // Initialize session state
     }
+    return sid;
+  }
 
-    /// \brief Cancel all pending sync operations for a session
-    void cancelPendingOperations(SessionId sid)
+  /// \brief Close a session
+  bool close(SessionId sid)
+  {
+    // Clean up session state
     {
       std::lock_guard<std::mutex> lock(_sessionMutex);
       auto it = _sessions.find(sid);
       if (it != _sessions.end())
       {
-        for (auto& op : it->second.pendingSyncOps)
+        // Cancel pending operations
+        for (auto &op : it->second.pendingSyncOps)
         {
           op->cancelled = true;
-          op->result = SyncResult::cancelled();
+          op->result = SyncResult::failure(TransportError::Unknown, "Session closed");
           op->completed = true;
           op->cv.notify_all();
         }
         it->second.pendingSyncOps.clear();
+        it->second.readCv.notify_all();
       }
     }
 
-    /// \brief Get connection health metrics
-    HybridConnectionHealth getConnectionHealth(SessionId sid) const
+    return _transport->close(sid);
+  }
+
+  /// \brief Cancel all pending sync operations for a session
+  void cancelPendingOperations(SessionId sid)
+  {
+    std::lock_guard<std::mutex> lock(_sessionMutex);
+    auto it = _sessions.find(sid);
+    if (it != _sessions.end())
     {
-      std::lock_guard<std::mutex> lock(_sessionMutex);
-      auto it = _sessions.find(sid);
-      if (it != _sessions.end())
+      for (auto &op : it->second.pendingSyncOps)
       {
-        return it->second.health;
+        op->cancelled = true;
+        op->result = SyncResult::cancelled();
+        op->completed = true;
+        op->cv.notify_all();
       }
-      // Return health indicating session doesn't exist (closed/failed)
-      HybridConnectionHealth nonExistent{};
-      nonExistent.isHealthy = false;
-      nonExistent.errorCount = 1;
-      nonExistent.lastErrorType = TransportError::PeerClosed;
-      nonExistent.lastErrorMessage = "Session does not exist (closed)";
-      return nonExistent;
+      it->second.pendingSyncOps.clear();
     }
+  }
 
-    /// \brief Get access to underlying transport (for stats, etc.)
-    ITransportBase* getTransport() const { return _transport.get(); }
-
-    // Note: getStats() method moved to UnifiedSharedTransport to avoid circular
-    // dependencies
-
-  private:
-    struct SyncOperation
+  /// \brief Get connection health metrics
+  HybridConnectionHealth getConnectionHealth(SessionId sid) const
+  {
+    std::lock_guard<std::mutex> lock(_sessionMutex);
+    auto it = _sessions.find(sid);
+    if (it != _sessions.end())
     {
-      enum class Type
-      {
-        Send,
-        Receive
-      };
-
-      Type type;
-      SessionId sessionId;
-      std::vector<std::uint8_t> data;
-      std::chrono::milliseconds timeout;
-      std::chrono::steady_clock::time_point startTime;
-
-      std::mutex mutex;
-      std::condition_variable cv;
-      std::atomic<bool> completed{false};
-      std::atomic<bool> cancelled{false};
-      SyncResult result;
-
-      CancellationToken* cancellationToken{nullptr};
+      return it->second.health;
+    }
+    // Return health indicating session doesn't exist (closed/failed)
+    HybridConnectionHealth nonExistent{};
+    nonExistent.isHealthy = false;
+    nonExistent.errorCount = 1;
+    nonExistent.lastErrorType = TransportError::PeerClosed;
+    nonExistent.lastErrorMessage = "Session does not exist (closed)";
+    return nonExistent;
+  }
+
+  /// \brief Get access to underlying transport (for stats, etc.)
+  ITransportBase *getTransport() const { return _transport.get(); }
+
+  // Note: getStats() method moved to UnifiedSharedTransport to avoid circular
+  // dependencies
+
+private:
+  struct SyncOperation
+  {
+    enum class Type
+    {
+      Send,
+      Receive
     };
 
-    struct SessionState
-    {
-      ReadMode readMode{ReadMode::Async};
+    Type type;
+    SessionId sessionId;
+    std::vector<std::uint8_t> data;
+    std::chrono::milliseconds timeout;
+    std::chrono::steady_clock::time_point startTime;
 
-      // Async state
-      DataCallback asyncDataCallback;
-      std::vector<SendCompleteCallback> pendingAsyncSends;
+    std::mutex mutex;
+    std::condition_variable cv;
+    std::atomic<bool> completed{false};
+    std::atomic<bool> cancelled{false};
+    SyncResult result;
 
-      // Sync state
-      std::atomic<bool> syncReadActive{false};
-      std::atomic<std::uint32_t> pendingSyncReads{0};
-      std::deque<std::vector<std::uint8_t>> readBuffer;
-      std::condition_variable readCv;
-      std::deque<std::shared_ptr<SyncOperation>> pendingSyncOps;
-      std::atomic<bool> closed{false}; // Flag to indicate session is closed
+    CancellationToken *cancellationToken{nullptr};
+  };
 
-      // Health monitoring
-      HybridConnectionHealth health;
+  struct SessionState
+  {
+    ReadMode readMode{ReadMode::Async};
 
-      SessionState()
-      {
-        health.lastActivity = std::chrono::steady_clock::now();
-        health.isHealthy =
-            false; // Start as unhealthy until connection completes
-      }
+    // Async state
+    DataCallback asyncDataCallback;
+    std::vector<SendCompleteCallback> pendingAsyncSends;
 
-      // Non-copyable due to condition_variable
-      SessionState(const SessionState&) = delete;
-      SessionState& operator=(const SessionState&) = delete;
+    // Sync state
+    std::atomic<bool> syncReadActive{false};
+    std::atomic<std::uint32_t> pendingSyncReads{0};
+    std::deque<std::vector<std::uint8_t>> readBuffer;
+    std::condition_variable readCv;
+    std::deque<std::shared_ptr<SyncOperation>> pendingSyncOps;
+    std::atomic<bool> closed{false}; // Flag to indicate session is closed
 
-      // Non-movable due to condition_variable
-      SessionState(SessionState&&) = delete;
-      SessionState& operator=(SessionState&&) = delete;
-    };
+    // Health monitoring
+    HybridConnectionHealth health;
 
-    SessionState& getOrCreateSession(SessionId sid)
+    SessionState()
     {
-      auto it = _sessions.find(sid);
-      if (it == _sessions.end())
-      {
-        it = _sessions
-                 .emplace(std::piecewise_construct, std::forward_as_tuple(sid),
-                          std::forward_as_tuple())
-                 .first;
-      }
-      return it->second;
+      health.lastActivity = std::chrono::steady_clock::now();
+      health.isHealthy = false; // Start as unhealthy until connection completes
     }
 
-    void waitForPendingReads(SessionState& session)
+    // Non-copyable due to condition_variable
+    SessionState(const SessionState &) = delete;
+    SessionState &operator=(const SessionState &) = delete;
+
+    // Non-movable due to condition_variable
+    SessionState(SessionState &&) = delete;
+    SessionState &operator=(SessionState &&) = delete;
+  };
+
+  SessionState &getOrCreateSession(SessionId sid)
+  {
+    auto it = _sessions.find(sid);
+    if (it == _sessions.end())
     {
-      // Simple spin-wait for pending reads to complete
-      // In production, might want a more sophisticated approach
-      while (session.syncReadActive || session.pendingSyncReads > 0)
-      {
-        std::this_thread::sleep_for(std::chrono::milliseconds(1));
-      }
+      it = _sessions
+             .emplace(std::piecewise_construct, std::forward_as_tuple(sid), std::forward_as_tuple())
+             .first;
     }
+    return it->second;
+  }
 
-    void setupInternalCallbacks()
+  void waitForPendingReads(SessionState &session)
+  {
+    // Simple spin-wait for pending reads to complete
+    // In production, might want a more sophisticated approach
+    while (session.syncReadActive || session.pendingSyncReads > 0)
     {
-      // Data callback router
-      _transport->setDataCallback(
-          [this](SessionId sid, const std::uint8_t* data, std::size_t len,
-                 const IoResult& result)
-          { handleIncomingData(sid, data, len, result); });
-
-      // Accept callback pass-through
-      _transport->setAcceptCallback(
-          [this](SessionId sid, const std::string& peer, const IoResult& result)
-          {
-            if (result.ok)
-            {
-              std::lock_guard<std::mutex> lock(_sessionMutex);
-              getOrCreateSession(sid); // Initialize session state
-            }
-          });
-
-      // Connect callback pass-through
-      _transport->setConnectCallback(
-          [this](SessionId sid, const IoResult& result)
-          {
-            std::lock_guard<std::mutex> lock(_callbackMutex);
-            if (_connectCallback)
-            {
-              _connectCallback(sid, result);
-            }
-
-            // Update health
-            if (result.ok)
-            {
-              std::lock_guard<std::mutex> slock(_sessionMutex);
-              auto& session = getOrCreateSession(sid);
-              session.health.isHealthy = true;
-              session.health.lastActivity = std::chrono::steady_clock::now();
-            }
-          });
-
-      // Close callback pass-through
-      _transport->setCloseCallback(
-          [this](SessionId sid, const IoResult& result)
-          {
-            core::Logger::debug("SyncAsyncTransport: Close callback for session " +
-                                std::to_string(sid));
-            // Clean up session state
-            {
-              std::lock_guard<std::mutex> lock(_sessionMutex);
-              auto it = _sessions.find(sid);
-              if (it != _sessions.end())
-              {
-                core::Logger::debug(
-                    "SyncAsyncTransport: Waking " +
-                    std::to_string(it->second.pendingSyncOps.size()) +
-                    " pending sync operations");
-
-                // Mark session as closed before waking operations
-                it->second.closed = true;
-
-                // Wake any waiting sync operations
-                for (auto& op : it->second.pendingSyncOps)
-                {
-                  op->result = SyncResult::failure(TransportError::PeerClosed,
-                                                   "Connection closed");
-                  op->completed = true;
-                  op->cv.notify_all();
-                }
-                it->second.readCv.notify_all();
-                _sessions.erase(it);
-              }
-            }
-
-            std::lock_guard<std::mutex> lock(_callbackMutex);
-            if (_closeCallback)
-            {
-              _closeCallback(sid, result);
-            }
-          });
-
-      // Error callback pass-through
-      _transport->setErrorCallback(
-          [this](TransportError error, const std::string& msg)
-          {
-            std::lock_guard<std::mutex> lock(_callbackMutex);
-            if (_errorCallback)
-            {
-              _errorCallback(error, msg);
-            }
-          });
+      std::this_thread::sleep_for(std::chrono::milliseconds(1));
     }
+  }
 
-    void handleIncomingData(SessionId sid, const std::uint8_t* data,
-                            std::size_t len, const IoResult& result)
-    {
-      if (len > 0 && len < 200)
+  void setupInternalCallbacks()
+  {
+    // Data callback router
+    _transport->setDataCallback(
+      [this](SessionId sid, const std::uint8_t *data, std::size_t len, const IoResult &result)
+      { handleIncomingData(sid, data, len, result); });
+
+    // Accept callback pass-through
+    _transport->setAcceptCallback(
+      [this](SessionId sid, const std::string &peer, const IoResult &result)
       {
-        std::string dataStr(reinterpret_cast<const char*>(data), len);
-      }
-
-      DataCallback asyncCallback = nullptr;
+        if (result.ok)
+        {
+          std::lock_guard<std::mutex> lock(_sessionMutex);
+          getOrCreateSession(sid); // Initialize session state
+        }
+      });
 
-      // Critical section for session access
+    // Connect callback pass-through
+    _transport->setConnectCallback(
+      [this](SessionId sid, const IoResult &result)
       {
-        std::lock_guard<std::mutex> lock(_sessionMutex);
-        auto it = _sessions.find(sid);
-        if (it == _sessions.end())
+        std::lock_guard<std::mutex> lock(_callbackMutex);
+        if (_connectCallback)
         {
-          return; // Unknown session
+          _connectCallback(sid, result);
         }
 
-        auto& session = it->second;
-
-        // Update health metrics
-        if (_config.autoHealthMonitoring)
+        // Update health
+        if (result.ok)
         {
+          std::lock_guard<std::mutex> slock(_sessionMutex);
+          auto &session = getOrCreateSession(sid);
+          session.health.isHealthy = true;
           session.health.lastActivity = std::chrono::steady_clock::now();
-          session.health.bytesIn += len;
-          if (result.ok)
-          {
-            session.health.successCount++;
-          }
-          else
-          {
-            session.health.errorCount++;
-            session.health.lastError = std::chrono::steady_clock::now();
-            session.health.lastErrorType = result.code;
-            session.health.lastErrorMessage = result.message;
-          }
         }
+      });
 
-        // Route based on read mode
-        switch (session.readMode)
+    // Close callback pass-through
+    _transport->setCloseCallback(
+      [this](SessionId sid, const IoResult &result)
+      {
+        core::Logger::debug("SyncAsyncTransport: Close callback for session " +
+                            std::to_string(sid));
+        // Clean up session state
         {
-        case ReadMode::Async:
-          if (session.asyncDataCallback)
+          std::lock_guard<std::mutex> lock(_sessionMutex);
+          auto it = _sessions.find(sid);
+          if (it != _sessions.end())
           {
-            // Copy callback to call outside lock
-            asyncCallback = session.asyncDataCallback;
-          }
-          break;
+            core::Logger::debug("SyncAsyncTransport: Waking " +
+                                std::to_string(it->second.pendingSyncOps.size()) +
+                                " pending sync operations");
 
-        case ReadMode::Sync:
-          // Buffer data for sync reader
-          if (len > 0 && result.ok)
-          {
-            session.readBuffer.emplace_back(data, data + len);
-            session.readCv.notify_one();
+            // Mark session as closed before waking operations
+            it->second.closed = true;
+
+            // Wake any waiting sync operations
+            for (auto &op : it->second.pendingSyncOps)
+            {
+              op->result = SyncResult::failure(TransportError::PeerClosed, "Connection closed");
+              op->completed = true;
+              op->cv.notify_all();
+            }
+            it->second.readCv.notify_all();
+            _sessions.erase(it);
           }
-          break;
+        }
 
-        case ReadMode::Disabled:
-          // Drop data
-          break;
+        std::lock_guard<std::mutex> lock(_callbackMutex);
+        if (_closeCallback)
+        {
+          _closeCallback(sid, result);
         }
-      } // Lock released here
+      });
 
-      // Call async callback outside the lock to avoid deadlock
-      if (asyncCallback)
+    // Error callback pass-through
+    _transport->setErrorCallback(
+      [this](TransportError error, const std::string &msg)
       {
-        asyncCallback(sid, data, len, result);
-      }
+        std::lock_guard<std::mutex> lock(_callbackMutex);
+        if (_errorCallback)
+        {
+          _errorCallback(error, msg);
+        }
+      });
+  }
+
+  void handleIncomingData(SessionId sid, const std::uint8_t *data, std::size_t len,
+                          const IoResult &result)
+  {
+    if (len > 0 && len < 200)
+    {
+      std::string dataStr(reinterpret_cast<const char *>(data), len);
     }
 
-    void processOperations()
+    DataCallback asyncCallback = nullptr;
+
+    // Critical section for session access
     {
-      while (_running)
+      std::lock_guard<std::mutex> lock(_sessionMutex);
+      auto it = _sessions.find(sid);
+      if (it == _sessions.end())
       {
-        std::unique_lock<std::mutex> lock(_mutex);
-        _operationCv.wait_for(lock, std::chrono::milliseconds(100),
-                              [this]
-                              { return !_running || hasQueuedOperations(); });
+        return; // Unknown session
+      }
 
-        if (!_running)
+      auto &session = it->second;
+
+      // Update health metrics
+      if (_config.autoHealthMonitoring)
+      {
+        session.health.lastActivity = std::chrono::steady_clock::now();
+        session.health.bytesIn += len;
+        if (result.ok)
         {
-          break;
+          session.health.successCount++;
+        }
+        else
+        {
+          session.health.errorCount++;
+          session.health.lastError = std::chrono::steady_clock::now();
+          session.health.lastErrorType = result.code;
+          session.health.lastErrorMessage = result.message;
         }
-
-        // Process queued sync operations
-        processSyncOperations();
       }
-    }
 
-    bool hasQueuedOperations()
-    {
-      std::lock_guard<std::mutex> lock(_sessionMutex);
-      for (const auto& [sid, session] : _sessions)
+      // Route based on read mode
+      switch (session.readMode)
       {
-        if (!session.pendingSyncOps.empty())
+      case ReadMode::Async:
+        if (session.asyncDataCallback)
+        {
+          // Copy callback to call outside lock
+          asyncCallback = session.asyncDataCallback;
+        }
+        break;
+
+      case ReadMode::Sync:
+        // Buffer data for sync reader
+        if (len > 0 && result.ok)
         {
-          return true;
+          session.readBuffer.emplace_back(data, data + len);
+          session.readCv.notify_one();
         }
+        break;
+
+      case ReadMode::Disabled:
+        // Drop data
+        break;
       }
-      return false;
+    } // Lock released here
+
+    // Call async callback outside the lock to avoid deadlock
+    if (asyncCallback)
+    {
+      asyncCallback(sid, data, len, result);
     }
+  }
 
-    void processSyncOperations()
+  void processOperations()
+  {
+    while (_running)
     {
-      std::lock_guard<std::mutex> lock(_sessionMutex);
+      std::unique_lock<std::mutex> lock(_mutex);
+      _operationCv.wait_for(lock, std::chrono::milliseconds(100),
+                            [this] { return !_running || hasQueuedOperations(); });
 
-      for (auto& [sid, session] : _sessions)
+      if (!_running)
       {
-        while (!session.pendingSyncOps.empty())
-        {
-          auto op = session.pendingSyncOps.front();
+        break;
+      }
 
-          // Check if cancelled or timed out
-          if (op->cancelled ||
-              (std::chrono::steady_clock::now() - op->startTime) > op->timeout)
-          {
-            op->result =
-                op->cancelled ? SyncResult::cancelled() : SyncResult::timeout();
-            op->completed = true;
-            op->cv.notify_all();
-            session.pendingSyncOps.pop_front();
-            continue;
-          }
+      // Process queued sync operations
+      processSyncOperations();
+    }
+  }
 
-          // Process based on type
-          if (op->type == SyncOperation::Type::Send)
-          {
-            // Execute the send
-            bool sent = _transport->send(sid, op->data.data(), op->data.size());
-
-            auto elapsed = std::chrono::steady_clock::now() - op->startTime;
-            op->result = sent ? SyncResult::success(op->data.size())
-                              : SyncResult::failure(TransportError::Unknown,
-                                                    "Send failed");
-            op->result.duration =
-                std::chrono::duration_cast<std::chrono::milliseconds>(elapsed);
-
-            op->completed = true;
-            op->cv.notify_all();
-            session.pendingSyncOps.pop_front();
-          }
-        }
+  bool hasQueuedOperations()
+  {
+    std::lock_guard<std::mutex> lock(_sessionMutex);
+    for (const auto &[sid, session] : _sessions)
+    {
+      if (!session.pendingSyncOps.empty())
+      {
+        return true;
       }
     }
+    return false;
+  }
+
+  void processSyncOperations()
+  {
+    std::lock_guard<std::mutex> lock(_sessionMutex);
 
-    void cancelAllOperations()
+    for (auto &[sid, session] : _sessions)
     {
-      std::lock_guard<std::mutex> lock(_sessionMutex);
-      for (auto& [sid, session] : _sessions)
+      while (!session.pendingSyncOps.empty())
       {
-        for (auto& op : session.pendingSyncOps)
+        auto op = session.pendingSyncOps.front();
+
+        // Check if cancelled or timed out
+        if (op->cancelled || (std::chrono::steady_clock::now() - op->startTime) > op->timeout)
         {
-          op->cancelled = true;
-          op->result = SyncResult::cancelled();
+          op->result = op->cancelled ? SyncResult::cancelled() : SyncResult::timeout();
+          op->completed = true;
+          op->cv.notify_all();
+          session.pendingSyncOps.pop_front();
+          continue;
+        }
+
+        // Process based on type
+        if (op->type == SyncOperation::Type::Send)
+        {
+          // Execute the send
+          bool sent = _transport->send(sid, op->data.data(), op->data.size());
+
+          auto elapsed = std::chrono::steady_clock::now() - op->startTime;
+          op->result = sent ? SyncResult::success(op->data.size())
+                            : SyncResult::failure(TransportError::Unknown, "Send failed");
+          op->result.duration = std::chrono::duration_cast<std::chrono::milliseconds>(elapsed);
+
           op->completed = true;
           op->cv.notify_all();
+          session.pendingSyncOps.pop_front();
         }
-        session.pendingSyncOps.clear();
-        session.readCv.notify_all();
       }
     }
+  }
 
-    void updateHealth(SessionId sid, bool success, std::size_t bytes,
-                      bool isSend)
+  void cancelAllOperations()
+  {
+    std::lock_guard<std::mutex> lock(_sessionMutex);
+    for (auto &[sid, session] : _sessions)
     {
-      if (!_config.autoHealthMonitoring)
+      for (auto &op : session.pendingSyncOps)
       {
-        return;
+        op->cancelled = true;
+        op->result = SyncResult::cancelled();
+        op->completed = true;
+        op->cv.notify_all();
       }
+      session.pendingSyncOps.clear();
+      session.readCv.notify_all();
+    }
+  }
 
-      std::lock_guard<std::mutex> lock(_sessionMutex);
-      auto it = _sessions.find(sid);
-      if (it == _sessions.end())
-      {
-        return;
-      }
+  void updateHealth(SessionId sid, bool success, std::size_t bytes, bool isSend)
+  {
+    if (!_config.autoHealthMonitoring)
+    {
+      return;
+    }
 
-      auto& health = it->second.health;
-      health.lastActivity = std::chrono::steady_clock::now();
+    std::lock_guard<std::mutex> lock(_sessionMutex);
+    auto it = _sessions.find(sid);
+    if (it == _sessions.end())
+    {
+      return;
+    }
 
-      if (isSend)
-      {
-        health.bytesOut += bytes;
-      }
-      else
-      {
-        health.bytesIn += bytes;
-      }
+    auto &health = it->second.health;
+    health.lastActivity = std::chrono::steady_clock::now();
 
-      if (success)
-      {
-        health.successCount++;
-        // Simple health calculation
-        health.isHealthy = (health.errorCount == 0) ||
-                           (health.successCount > health.errorCount * 10);
-      }
-      else
-      {
-        health.errorCount++;
-        health.lastError = std::chrono::steady_clock::now();
-        health.isHealthy = false;
-      }
+    if (isSend)
+    {
+      health.bytesOut += bytes;
+    }
+    else
+    {
+      health.bytesIn += bytes;
+    }
 
-      health.pendingOperations = it->second.pendingSyncOps.size();
+    if (success)
+    {
+      health.successCount++;
+      // Simple health calculation
+      health.isHealthy = (health.errorCount == 0) || (health.successCount > health.errorCount * 10);
+    }
+    else
+    {
+      health.errorCount++;
+      health.lastError = std::chrono::steady_clock::now();
+      health.isHealthy = false;
     }
 
-  private:
-    std::unique_ptr<ITransportBase> _transport;
-    Config _config;
+    health.pendingOperations = it->second.pendingSyncOps.size();
+  }
 
-    std::atomic<bool> _running{false};
-    std::thread _processingThread;
+private:
+  std::unique_ptr<ITransportBase> _transport;
+  Config _config;
 
-    mutable std::mutex _mutex;
-    mutable std::mutex _sessionMutex;
-    mutable std::mutex _callbackMutex;
+  std::atomic<bool> _running{false};
+  std::thread _processingThread;
 
-    std::condition_variable _operationCv;
-    std::condition_variable _stopCv;
+  mutable std::mutex _mutex;
+  mutable std::mutex _sessionMutex;
+  mutable std::mutex _callbackMutex;
 
-    std::unordered_map<SessionId, SessionState> _sessions;
+  std::condition_variable _operationCv;
+  std::condition_variable _stopCv;
 
-    // User callbacks
-    ConnectCallback _connectCallback;
-    CloseCallback _closeCallback;
-    ErrorCallback _errorCallback;
-  };
+  std::unordered_map<SessionId, SessionState> _sessions;
+
+  // User callbacks
+  ConnectCallback _connectCallback;
+  CloseCallback _closeCallback;
+  ErrorCallback _errorCallback;
+};
 
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/transport_types.hpp b/include/iora/network/transport_types.hpp
index 1022765..ec5ba11 100644
--- a/include/iora/network/transport_types.hpp
+++ b/include/iora/network/transport_types.hpp
@@ -10,134 +10,128 @@
 #error "Linux-only (epoll/eventfd/timerfd)"
 #endif
 
+#include <chrono>
 #include <cstdint>
 #include <string>
 #include <vector>
-#include <chrono>
 
 namespace iora
 {
 namespace network
 {
 
-  using SessionId = std::uint64_t;
-  using ListenerId = std::uint64_t;
-  using ByteBuffer = std::vector<std::uint8_t>;
-  using MonoClock = std::chrono::steady_clock;
-  using MonoTime = std::chrono::time_point<MonoClock>;
+using SessionId = std::uint64_t;
+using ListenerId = std::uint64_t;
+using ByteBuffer = std::vector<std::uint8_t>;
+using MonoClock = std::chrono::steady_clock;
+using MonoTime = std::chrono::time_point<MonoClock>;
 
-  enum class Role
-  {
-    ServerPeer,
-    ClientConnected
-  };
+enum class Role
+{
+  ServerPeer,
+  ClientConnected
+};
+
+enum class TlsMode
+{
+  None,
+  Server,
+  Client
+};
+
+enum class TransportError
+{
+  None = 0,
+  Socket,
+  Resolve,
+  Bind,
+  Listen,
+  Accept,
+  Connect,
+  TLSHandshake,
+  TLSIO,
+  PeerClosed,
+  WriteBackpressure,
+  Config,
+  GCClosed,
+  Cancelled,
+  Timeout,
+  Unknown
+};
+
+struct IoResult
+{
+  bool ok{true};
+  TransportError code{TransportError::None};
+  std::string message;
+  int sysErrno{0};
+  int tlsError{0};
 
-  enum class TlsMode
+  static IoResult success() { return {true, TransportError::None, "", 0, 0}; }
+
+  static IoResult failure(TransportError c, const std::string &m, int se = 0, int te = 0)
   {
-    None,
-    Server,
-    Client
-  };
+    return {false, c, m, se, te};
+  }
+};
+
+// Enhanced error reporting with severity and context
+enum class ErrorSeverity
+{
+  Warning,
+  Recoverable,
+  Fatal
+};
 
-  enum class TransportError
+struct TransportEvent
+{
+  TransportError code{TransportError::None};
+  ErrorSeverity severity{ErrorSeverity::Warning};
+  std::string context;
+  std::string details;
+  SessionId sessionId{0};
+  std::chrono::system_clock::time_point timestamp{std::chrono::system_clock::now()};
+  int sysErrno{0};
+  int tlsError{0};
+
+  static TransportEvent warning(TransportError code, const std::string &ctx,
+                                const std::string &details = "")
   {
-    None = 0,
-    Socket,
-    Resolve,
-    Bind,
-    Listen,
-    Accept,
-    Connect,
-    TLSHandshake,
-    TLSIO,
-    PeerClosed,
-    WriteBackpressure,
-    Config,
-    GCClosed,
-    Cancelled,
-    Timeout,
-    Unknown
-  };
-
-  struct IoResult
+    return {code, ErrorSeverity::Warning, ctx, details, 0, std::chrono::system_clock::now(), 0, 0};
+  }
+
+  static TransportEvent error(TransportError code, const std::string &ctx,
+                              const std::string &details = "", int sysErr = 0)
   {
-    bool ok{true};
-    TransportError code{TransportError::None};
-    std::string message;
-    int sysErrno{0};
-    int tlsError{0};
-
-    static IoResult success() { return {true, TransportError::None, "", 0, 0}; }
-
-    static IoResult failure(TransportError c, const std::string& m, int se = 0,
-                            int te = 0)
-    {
-      return {false, c, m, se, te};
-    }
-  };
-
-  // Enhanced error reporting with severity and context
-  enum class ErrorSeverity
+    return {code, ErrorSeverity::Recoverable,       ctx,    details,
+            0,    std::chrono::system_clock::now(), sysErr, 0};
+  }
+
+  static TransportEvent fatal(TransportError code, const std::string &ctx,
+                              const std::string &details = "", int sysErr = 0)
   {
-    Warning,
-    Recoverable,
-    Fatal
-  };
+    return {code, ErrorSeverity::Fatal, ctx, details, 0, std::chrono::system_clock::now(), sysErr,
+            0};
+  }
+};
+
+// Synchronous result for listener operations
+struct ListenerResult
+{
+  ListenerId id{0};
+  IoResult result;
+  std::string bindAddress;
 
-  struct TransportEvent
+  static ListenerResult success(ListenerId lid, const std::string &addr)
   {
-    TransportError code{TransportError::None};
-    ErrorSeverity severity{ErrorSeverity::Warning};
-    std::string context;
-    std::string details;
-    SessionId sessionId{0};
-    std::chrono::system_clock::time_point timestamp{
-        std::chrono::system_clock::now()};
-    int sysErrno{0};
-    int tlsError{0};
-
-    static TransportEvent warning(TransportError code, const std::string& ctx,
-                                  const std::string& details = "")
-    {
-      return {code, ErrorSeverity::Warning,           ctx, details,
-              0,    std::chrono::system_clock::now(), 0,   0};
-    }
-
-    static TransportEvent error(TransportError code, const std::string& ctx,
-                                const std::string& details = "", int sysErr = 0)
-    {
-      return {code, ErrorSeverity::Recoverable,       ctx,    details,
-              0,    std::chrono::system_clock::now(), sysErr, 0};
-    }
-
-    static TransportEvent fatal(TransportError code, const std::string& ctx,
-                                const std::string& details = "", int sysErr = 0)
-    {
-      return {code,   ErrorSeverity::Fatal,
-              ctx,    details,
-              0,      std::chrono::system_clock::now(),
-              sysErr, 0};
-    }
-  };
-
-  // Synchronous result for listener operations
-  struct ListenerResult
+    return {lid, IoResult::success(), addr};
+  }
+
+  static ListenerResult failure(TransportError code, const std::string &msg, int sysErr = 0)
   {
-    ListenerId id{0};
-    IoResult result;
-    std::string bindAddress;
-
-    static ListenerResult success(ListenerId lid, const std::string& addr)
-    {
-      return {lid, IoResult::success(), addr};
-    }
-
-    static ListenerResult failure(TransportError code, const std::string& msg,
-                                  int sysErr = 0)
-    {
-      return {0, IoResult::failure(code, msg, sysErr), ""};
-    }
-  };
+    return {0, IoResult::failure(code, msg, sysErr), ""};
+  }
+};
 
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/transport_with_batching.hpp b/include/iora/network/transport_with_batching.hpp
index 0ba0eef..6781d50 100644
--- a/include/iora/network/transport_with_batching.hpp
+++ b/include/iora/network/transport_with_batching.hpp
@@ -17,147 +17,136 @@ namespace iora
 namespace network
 {
 
-  // Integration helper for adding batch processing to existing transports
-  template <typename BaseTransport> class BatchingTransportWrapper
-  {
-  public:
-    using EventHandler = std::function<void(int fd, uint32_t events)>;
+// Integration helper for adding batch processing to existing transports
+template <typename BaseTransport> class BatchingTransportWrapper
+{
+public:
+  using EventHandler = std::function<void(int fd, uint32_t events)>;
 
-    template <typename... Args>
-    explicit BatchingTransportWrapper(const BatchProcessingConfig& batchConfig,
-                                      Args&&... args)
+  template <typename... Args>
+  explicit BatchingTransportWrapper(const BatchProcessingConfig &batchConfig, Args &&...args)
       : baseTransport_(std::forward<Args>(args)...),
         batchProcessor_(std::make_unique<EventBatchProcessor>(batchConfig))
-    {
-    }
+  {
+  }
 
-    // Forward all BaseTransport methods
-    auto& getBase() { return baseTransport_; }
-    const auto& getBase() const { return baseTransport_; }
+  // Forward all BaseTransport methods
+  auto &getBase() { return baseTransport_; }
+  const auto &getBase() const { return baseTransport_; }
 
-    // Enhanced event loop with batching
-    template <typename SpecialHandler>
-    void runBatchingEventLoop(int epollFd, int eventFd, int timerFd,
-                              const EventHandler& sessionHandler,
-                              const SpecialHandler& specialHandler)
-    {
-      auto generalHandler = [&sessionHandler](int fd, uint32_t events)
-      { sessionHandler(fd, events); };
+  // Enhanced event loop with batching
+  template <typename SpecialHandler>
+  void runBatchingEventLoop(int epollFd, int eventFd, int timerFd,
+                            const EventHandler &sessionHandler,
+                            const SpecialHandler &specialHandler)
+  {
+    auto generalHandler = [&sessionHandler](int fd, uint32_t events)
+    { sessionHandler(fd, events); };
 
-      auto specialFdHandler = [eventFd, timerFd,
-                               &specialHandler](int fd, uint32_t events) -> bool
-      {
-        if (fd == eventFd || fd == timerFd)
-        {
-          return specialHandler(fd, events);
-        }
-        return false;
-      };
-
-      batchProcessor_->processBatch(
-          epollFd, generalHandler, specialFdHandler,
-          [this](std::size_t batchSize,
-                 std::chrono::microseconds processingTime)
-          { onBatchProcessed(batchSize, processingTime); });
-    }
-
-    // Convenience method for standard transport event loop integration
-    void runTransportEventLoop(int epollFd, int eventFd, int timerFd,
-                               const std::function<void()>& onEventFd,
-                               const std::function<void()>& onTimerFd,
-                               const EventHandler& sessionHandler)
-    {
-      batchProcessor_->processBatchWithSpecialFDs(
-          epollFd, eventFd, timerFd, sessionHandler, onEventFd, onTimerFd,
-          [this](std::size_t batchSize,
-                 std::chrono::microseconds processingTime)
-          { onBatchProcessed(batchSize, processingTime); });
-    }
-
-    // Batch processing statistics
-    BatchProcessingStats getBatchingStats() const
+    auto specialFdHandler = [eventFd, timerFd, &specialHandler](int fd, uint32_t events) -> bool
     {
-      return batchProcessor_->getStats();
-    }
+      if (fd == eventFd || fd == timerFd)
+      {
+        return specialHandler(fd, events);
+      }
+      return false;
+    };
+
+    batchProcessor_->processBatch(
+      epollFd, generalHandler, specialFdHandler,
+      [this](std::size_t batchSize, std::chrono::microseconds processingTime)
+      { onBatchProcessed(batchSize, processingTime); });
+  }
 
-    void resetBatchingStats() { batchProcessor_->resetStats(); }
+  // Convenience method for standard transport event loop integration
+  void runTransportEventLoop(int epollFd, int eventFd, int timerFd,
+                             const std::function<void()> &onEventFd,
+                             const std::function<void()> &onTimerFd,
+                             const EventHandler &sessionHandler)
+  {
+    batchProcessor_->processBatchWithSpecialFDs(
+      epollFd, eventFd, timerFd, sessionHandler, onEventFd, onTimerFd,
+      [this](std::size_t batchSize, std::chrono::microseconds processingTime)
+      { onBatchProcessed(batchSize, processingTime); });
+  }
 
-    void updateBatchingConfig(const BatchProcessingConfig& config)
-    {
-      batchProcessor_->updateConfig(config);
-    }
+  // Batch processing statistics
+  BatchProcessingStats getBatchingStats() const { return batchProcessor_->getStats(); }
 
-    BatchProcessingConfig getBatchingConfig() const
-    {
-      return batchProcessor_->getConfig();
-    }
+  void resetBatchingStats() { batchProcessor_->resetStats(); }
 
-  protected:
-    virtual void onBatchProcessed(std::size_t batchSize,
-                                  std::chrono::microseconds processingTime)
-    {
-      // Default implementation - derived classes can override for custom
-      // metrics
-      (void) batchSize;
-      (void) processingTime;
-    }
-
-  private:
-    BaseTransport baseTransport_;
-    std::unique_ptr<EventBatchProcessor> batchProcessor_;
-  };
-
-  // Specialization helper for common transport configurations
-  template <typename BaseTransport>
-  std::unique_ptr<BatchingTransportWrapper<BaseTransport>>
-  createOptimizedBatchingTransport(std::size_t expectedLoad = 32)
+  void updateBatchingConfig(const BatchProcessingConfig &config)
   {
-    auto config = BatchProcessingConfig{};
-    config.maxBatchSize = std::max(8UL, expectedLoad * 2);
-    config.maxBatchDelay = std::chrono::microseconds(50);
-    config.enableAdaptiveSizing = true;
-    config.loadFactor = 0.7;
-
-    return std::make_unique<BatchingTransportWrapper<BaseTransport>>(config);
+    batchProcessor_->updateConfig(config);
   }
 
-  // Example usage patterns for different scenarios
+  BatchProcessingConfig getBatchingConfig() const { return batchProcessor_->getConfig(); }
 
-  // High-throughput server configuration
-  inline BatchProcessingConfig createServerConfig()
+protected:
+  virtual void onBatchProcessed(std::size_t batchSize, std::chrono::microseconds processingTime)
   {
-    BatchProcessingConfig config;
-    config.maxBatchSize = 128;
-    config.maxBatchDelay = std::chrono::microseconds(200);
-    config.adaptiveThreshold = std::chrono::microseconds(100);
-    config.enableAdaptiveSizing = true;
-    config.loadFactor = 0.8;
-    return config;
+    // Default implementation - derived classes can override for custom
+    // metrics
+    (void)batchSize;
+    (void)processingTime;
   }
 
-  // Low-latency client configuration
-  inline BatchProcessingConfig createClientConfig()
-  {
-    BatchProcessingConfig config;
-    config.maxBatchSize = 16;
-    config.maxBatchDelay = std::chrono::microseconds(10);
-    config.adaptiveThreshold = std::chrono::microseconds(5);
-    config.enableAdaptiveSizing = true;
-    config.loadFactor = 0.5;
-    return config;
-  }
+private:
+  BaseTransport baseTransport_;
+  std::unique_ptr<EventBatchProcessor> batchProcessor_;
+};
 
-  // Balanced general-purpose configuration
-  inline BatchProcessingConfig createBalancedConfig()
-  {
-    BatchProcessingConfig config;
-    config.maxBatchSize = 32;
-    config.maxBatchDelay = std::chrono::microseconds(50);
-    config.adaptiveThreshold = std::chrono::microseconds(25);
-    config.enableAdaptiveSizing = true;
-    config.loadFactor = 0.7;
-    return config;
-  }
+// Specialization helper for common transport configurations
+template <typename BaseTransport>
+std::unique_ptr<BatchingTransportWrapper<BaseTransport>>
+createOptimizedBatchingTransport(std::size_t expectedLoad = 32)
+{
+  auto config = BatchProcessingConfig{};
+  config.maxBatchSize = std::max(8UL, expectedLoad * 2);
+  config.maxBatchDelay = std::chrono::microseconds(50);
+  config.enableAdaptiveSizing = true;
+  config.loadFactor = 0.7;
+
+  return std::make_unique<BatchingTransportWrapper<BaseTransport>>(config);
+}
+
+// Example usage patterns for different scenarios
+
+// High-throughput server configuration
+inline BatchProcessingConfig createServerConfig()
+{
+  BatchProcessingConfig config;
+  config.maxBatchSize = 128;
+  config.maxBatchDelay = std::chrono::microseconds(200);
+  config.adaptiveThreshold = std::chrono::microseconds(100);
+  config.enableAdaptiveSizing = true;
+  config.loadFactor = 0.8;
+  return config;
+}
+
+// Low-latency client configuration
+inline BatchProcessingConfig createClientConfig()
+{
+  BatchProcessingConfig config;
+  config.maxBatchSize = 16;
+  config.maxBatchDelay = std::chrono::microseconds(10);
+  config.adaptiveThreshold = std::chrono::microseconds(5);
+  config.enableAdaptiveSizing = true;
+  config.loadFactor = 0.5;
+  return config;
+}
+
+// Balanced general-purpose configuration
+inline BatchProcessingConfig createBalancedConfig()
+{
+  BatchProcessingConfig config;
+  config.maxBatchSize = 32;
+  config.maxBatchDelay = std::chrono::microseconds(50);
+  config.adaptiveThreshold = std::chrono::microseconds(25);
+  config.enableAdaptiveSizing = true;
+  config.loadFactor = 0.7;
+  return config;
+}
 
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/unified_shared_transport.hpp b/include/iora/network/unified_shared_transport.hpp
old mode 100755
new mode 100644
index 16f29a7..3fc0f69
--- a/include/iora/network/unified_shared_transport.hpp
+++ b/include/iora/network/unified_shared_transport.hpp
@@ -27,944 +27,863 @@
 #include <string>
 #include <variant>
 
-#include "sync_async_transport.hpp"
 #include "shared_transport.hpp"
 #include "shared_transport_udp.hpp"
+#include "sync_async_transport.hpp"
 
 namespace iora
 {
 namespace network
 {
 
-  /// \brief Exception thrown when an operation is not supported by the chosen
-  /// protocol
-  class UnsupportedOperation : public std::logic_error
-  {
-  public:
-    explicit UnsupportedOperation(const std::string& what)
-      : std::logic_error(what)
-    {
-    }
-  };
+/// \brief Exception thrown when an operation is not supported by the chosen
+/// protocol
+class UnsupportedOperation : public std::logic_error
+{
+public:
+  explicit UnsupportedOperation(const std::string &what) : std::logic_error(what) {}
+};
 
-  /// \brief Transport capabilities flags
-  enum class Capability : std::uint32_t
-  {
-    None = 0u,
-    HasTls = 1u << 0,
-    IsConnectionOriented = 1u << 1,
-    HasConnectViaListener = 1u << 2,
-    SupportsKeepalive = 1u << 3,
-    SupportsBatchSend = 1u << 4,
-    SupportsSyncOperations =
-        1u << 5, // All transports now support this via SyncAsyncTransport
-    SupportsReadModes =
-        1u << 6 // All transports now support this via SyncAsyncTransport
-  };
+/// \brief Transport capabilities flags
+enum class Capability : std::uint32_t
+{
+  None = 0u,
+  HasTls = 1u << 0,
+  IsConnectionOriented = 1u << 1,
+  HasConnectViaListener = 1u << 2,
+  SupportsKeepalive = 1u << 3,
+  SupportsBatchSend = 1u << 4,
+  SupportsSyncOperations = 1u << 5, // All transports now support this via SyncAsyncTransport
+  SupportsReadModes = 1u << 6       // All transports now support this via SyncAsyncTransport
+};
+
+inline constexpr Capability operator|(Capability a, Capability b)
+{
+  return static_cast<Capability>(static_cast<std::uint32_t>(a) | static_cast<std::uint32_t>(b));
+}
+
+inline constexpr Capability operator&(Capability a, Capability b)
+{
+  return static_cast<Capability>(static_cast<std::uint32_t>(a) & static_cast<std::uint32_t>(b));
+}
+
+inline constexpr bool any(Capability c) { return static_cast<std::uint32_t>(c) != 0u; }
+
+/// \brief Unified statistics structure
+struct UnifiedStats
+{
+  std::uint64_t accepted{0};
+  std::uint64_t connected{0};
+  std::uint64_t closed{0};
+  std::uint64_t errors{0};
+  std::uint64_t tlsHandshakes{0};
+  std::uint64_t tlsFailures{0};
+  std::uint64_t bytesIn{0};
+  std::uint64_t bytesOut{0};
+  std::uint64_t epollWakeups{0};
+  std::uint64_t commands{0};
+  std::uint64_t gcRuns{0};
+  std::uint64_t gcClosedIdle{0};
+  std::uint64_t gcClosedAged{0};
+  std::uint64_t backpressureCloses{0};
+  std::size_t sessionsCurrent{0};
+  std::size_t sessionsPeak{0};
+};
+
+/// \brief Unified configuration supporting both TCP and UDP
+using UnifiedConfig = std::variant<SharedTransport::Config, SharedUdpTransport::Config>;
+
+/// \brief Unified TLS configuration
+using UnifiedTlsConfig = std::variant<SharedTransport::TlsConfig, SharedUdpTransport::TlsConfig>;
+
+/// \brief Unified callbacks for transport events
+struct UnifiedCallbacks
+{
+  std::function<void(SessionId, const std::string &, const IoResult &)> onAccept;
+  std::function<void(SessionId, const IoResult &)> onConnect;
+  std::function<void(SessionId, const std::uint8_t *, std::size_t, const IoResult &)> onData;
+  std::function<void(SessionId, const IoResult &)> onClosed;
+  std::function<void(TransportError, const std::string &)> onError;
+};
+
+/// \brief Abstract transport interface
+class ITransport : public ITransportBase
+{
+public:
+  virtual ~ITransport() = default;
+  virtual void setCallbacks(const UnifiedCallbacks &cbs) = 0;
+  virtual SessionId connectViaListener(ListenerId lid, const std::string &host,
+                                       std::uint16_t port) = 0;
+  virtual void reconfigure(const UnifiedConfig &cfg) = 0;
+  virtual UnifiedStats stats() const = 0;
+  virtual Capability caps() const = 0;
+};
+
+/// \brief TCP/TLS transport adapter implementing ITransport interface
+class TcpTlsTransportAdapter final : public ITransport
+{
+public:
+  TcpTlsTransportAdapter(const SharedTransport::Config &cfg,
+                         const SharedTransport::TlsConfig &srvTls,
+                         const SharedTransport::TlsConfig &cliTls)
+      : _impl(cfg, srvTls, cliTls)
+  {
+  }
 
-  inline constexpr Capability operator|(Capability a, Capability b)
+  void setCallbacks(const UnifiedCallbacks &cbs) override
   {
-    return static_cast<Capability>(static_cast<std::uint32_t>(a) |
-                                   static_cast<std::uint32_t>(b));
+    SharedTransport::Callbacks t{};
+    t.onAccept = cbs.onAccept;
+    t.onConnect = cbs.onConnect;
+    t.onData = cbs.onData;
+    t.onClosed = cbs.onClosed;
+    t.onError = cbs.onError;
+    _impl.setCallbacks(t);
   }
 
-  inline constexpr Capability operator&(Capability a, Capability b)
+  bool start() override { return _impl.start(); }
+  void stop() override { _impl.stop(); }
+
+  ListenerId addListener(const std::string &bindIp, std::uint16_t port, TlsMode tlsMode) override
   {
-    return static_cast<Capability>(static_cast<std::uint32_t>(a) &
-                                   static_cast<std::uint32_t>(b));
+    return _impl.addListener(bindIp, port, tlsMode);
   }
 
-  inline constexpr bool any(Capability c)
+  SessionId connect(const std::string &host, std::uint16_t port, TlsMode tlsMode) override
   {
-    return static_cast<std::uint32_t>(c) != 0u;
+    return _impl.connect(host, port, tlsMode);
   }
 
-  /// \brief Unified statistics structure
-  struct UnifiedStats
+  SessionId connectViaListener(ListenerId, const std::string &, std::uint16_t) override
   {
-    std::uint64_t accepted{0};
-    std::uint64_t connected{0};
-    std::uint64_t closed{0};
-    std::uint64_t errors{0};
-    std::uint64_t tlsHandshakes{0};
-    std::uint64_t tlsFailures{0};
-    std::uint64_t bytesIn{0};
-    std::uint64_t bytesOut{0};
-    std::uint64_t epollWakeups{0};
-    std::uint64_t commands{0};
-    std::uint64_t gcRuns{0};
-    std::uint64_t gcClosedIdle{0};
-    std::uint64_t gcClosedAged{0};
-    std::uint64_t backpressureCloses{0};
-    std::size_t sessionsCurrent{0};
-    std::size_t sessionsPeak{0};
-  };
+    throw UnsupportedOperation("connectViaListener is not supported on TCP/TLS");
+  }
 
-  /// \brief Unified configuration supporting both TCP and UDP
-  using UnifiedConfig =
-      std::variant<SharedTransport::Config, SharedUdpTransport::Config>;
-
-  /// \brief Unified TLS configuration
-  using UnifiedTlsConfig =
-      std::variant<SharedTransport::TlsConfig, SharedUdpTransport::TlsConfig>;
-
-  /// \brief Unified callbacks for transport events
-  struct UnifiedCallbacks
-  {
-    std::function<void(SessionId, const std::string&, const IoResult&)>
-        onAccept;
-    std::function<void(SessionId, const IoResult&)> onConnect;
-    std::function<void(SessionId, const std::uint8_t*, std::size_t,
-                       const IoResult&)>
-        onData;
-    std::function<void(SessionId, const IoResult&)> onClosed;
-    std::function<void(TransportError, const std::string&)> onError;
-  };
+  bool send(SessionId sid, const void *data, std::size_t n) override
+  {
+    return _impl.send(sid, data, n);
+  }
 
-  /// \brief Abstract transport interface
-  class ITransport : public ITransportBase
-  {
-  public:
-    virtual ~ITransport() = default;
-    virtual void setCallbacks(const UnifiedCallbacks& cbs) = 0;
-    virtual SessionId connectViaListener(ListenerId lid,
-                                         const std::string& host,
-                                         std::uint16_t port) = 0;
-    virtual void reconfigure(const UnifiedConfig& cfg) = 0;
-    virtual UnifiedStats stats() const = 0;
-    virtual Capability caps() const = 0;
-  };
+  bool close(SessionId sid) override { return _impl.close(sid); }
 
-  /// \brief TCP/TLS transport adapter implementing ITransport interface
-  class TcpTlsTransportAdapter final : public ITransport
+  void reconfigure(const UnifiedConfig &cfg) override
   {
-  public:
-    TcpTlsTransportAdapter(const SharedTransport::Config& cfg,
-                           const SharedTransport::TlsConfig& srvTls,
-                           const SharedTransport::TlsConfig& cliTls)
-      : _impl(cfg, srvTls, cliTls)
+    if (auto p = std::get_if<SharedTransport::Config>(&cfg))
     {
+      _impl.reconfigure(*p);
+      return;
     }
+    throw UnsupportedOperation("Provided UDP config to TCP/TLS transport");
+  }
 
-    void setCallbacks(const UnifiedCallbacks& cbs) override
-    {
-      SharedTransport::Callbacks t{};
-      t.onAccept = cbs.onAccept;
-      t.onConnect = cbs.onConnect;
-      t.onData = cbs.onData;
-      t.onClosed = cbs.onClosed;
-      t.onError = cbs.onError;
-      _impl.setCallbacks(t);
-    }
+  UnifiedStats stats() const override
+  {
+    auto s = _impl.stats();
+    UnifiedStats u{};
+    u.accepted = s.accepted;
+    u.connected = s.connected;
+    u.closed = s.closed;
+    u.errors = s.errors;
+    u.tlsHandshakes = s.tlsHandshakes;
+    u.tlsFailures = s.tlsFailures;
+    u.bytesIn = s.bytesIn;
+    u.bytesOut = s.bytesOut;
+    u.epollWakeups = s.epollWakeups;
+    u.commands = s.commands;
+    u.gcRuns = s.gcRuns;
+    u.gcClosedIdle = s.gcClosedIdle;
+    u.gcClosedAged = s.gcClosedAged;
+    u.backpressureCloses = s.backpressureCloses;
+    u.sessionsCurrent = s.sessionsCurrent;
+    u.sessionsPeak = s.sessionsPeak;
+    return u;
+  }
 
-    bool start() override { return _impl.start(); }
-    void stop() override { _impl.stop(); }
+  Capability caps() const override
+  {
+    return Capability::HasTls | Capability::IsConnectionOriented | Capability::SupportsKeepalive;
+  }
 
-    ListenerId addListener(const std::string& bindIp, std::uint16_t port,
-                           TlsMode tlsMode) override
-    {
-      return _impl.addListener(bindIp, port, tlsMode);
-    }
+  // ITransportBase callback setters (delegate directly to SharedTransport to
+  // preserve existing callbacks)
+  void setDataCallback(DataCallback cb) override { _impl.setDataCallback(cb); }
 
-    SessionId connect(const std::string& host, std::uint16_t port,
-                      TlsMode tlsMode) override
-    {
-      return _impl.connect(host, port, tlsMode);
-    }
+  void setAcceptCallback(AcceptCallback cb) override { _impl.setAcceptCallback(cb); }
 
-    SessionId connectViaListener(ListenerId, const std::string&,
-                                 std::uint16_t) override
-    {
-      throw UnsupportedOperation(
-          "connectViaListener is not supported on TCP/TLS");
-    }
+  void setConnectCallback(ConnectCallback cb) override { _impl.setConnectCallback(cb); }
 
-    bool send(SessionId sid, const void* data, std::size_t n) override
-    {
-      return _impl.send(sid, data, n);
-    }
+  void setCloseCallback(CloseCallback cb) override { _impl.setCloseCallback(cb); }
 
-    bool close(SessionId sid) override { return _impl.close(sid); }
+  void setErrorCallback(ErrorCallback cb) override { _impl.setErrorCallback(cb); }
 
-    void reconfigure(const UnifiedConfig& cfg) override
-    {
-      if (auto p = std::get_if<SharedTransport::Config>(&cfg))
-      {
-        _impl.reconfigure(*p);
-        return;
-      }
-      throw UnsupportedOperation("Provided UDP config to TCP/TLS transport");
-    }
+  BasicTransportStats getBasicStats() const override
+  {
+    auto s = _impl.stats();
+    BasicTransportStats basic{};
+    basic.accepted = s.accepted;
+    basic.connected = s.connected;
+    basic.closed = s.closed;
+    basic.errors = s.errors;
+    basic.bytesIn = s.bytesIn;
+    basic.bytesOut = s.bytesOut;
+    basic.sessionsCurrent = s.sessionsCurrent;
+    return basic;
+  }
 
-    UnifiedStats stats() const override
-    {
-      auto s = _impl.stats();
-      UnifiedStats u{};
-      u.accepted = s.accepted;
-      u.connected = s.connected;
-      u.closed = s.closed;
-      u.errors = s.errors;
-      u.tlsHandshakes = s.tlsHandshakes;
-      u.tlsFailures = s.tlsFailures;
-      u.bytesIn = s.bytesIn;
-      u.bytesOut = s.bytesOut;
-      u.epollWakeups = s.epollWakeups;
-      u.commands = s.commands;
-      u.gcRuns = s.gcRuns;
-      u.gcClosedIdle = s.gcClosedIdle;
-      u.gcClosedAged = s.gcClosedAged;
-      u.backpressureCloses = s.backpressureCloses;
-      u.sessionsCurrent = s.sessionsCurrent;
-      u.sessionsPeak = s.sessionsPeak;
-      return u;
-    }
+  SharedTransport &impl() { return _impl; }
+  const SharedTransport &impl() const { return _impl; }
 
-    Capability caps() const override
-    {
-      return Capability::HasTls | Capability::IsConnectionOriented |
-             Capability::SupportsKeepalive;
-    }
+private:
+  SharedTransport _impl;
+};
 
-    // ITransportBase callback setters (delegate directly to SharedTransport to
-    // preserve existing callbacks)
-    void setDataCallback(DataCallback cb) override
-    {
-      _impl.setDataCallback(cb);
-    }
+/// \brief UDP transport adapter implementing ITransport interface
+class UdpTransportAdapter final : public ITransport
+{
+public:
+  explicit UdpTransportAdapter(const SharedUdpTransport::Config &cfg)
+      : _impl(cfg, _dummyTls, _dummyTls)
+  {
+  }
 
-    void setAcceptCallback(AcceptCallback cb) override
-    {
-      _impl.setAcceptCallback(cb);
-    }
+  void setCallbacks(const UnifiedCallbacks &cbs) override
+  {
+    SharedUdpTransport::Callbacks u{};
+    u.onAccept = cbs.onAccept;
+    u.onConnect = cbs.onConnect;
+    u.onData = cbs.onData;
+    u.onClosed = cbs.onClosed;
+    u.onError = cbs.onError;
+    _impl.setCallbacks(u);
+  }
 
-    void setConnectCallback(ConnectCallback cb) override
-    {
-      _impl.setConnectCallback(cb);
-    }
+  bool start() override { return _impl.start(); }
+  void stop() override { _impl.stop(); }
 
-    void setCloseCallback(CloseCallback cb) override
+  ListenerId addListener(const std::string &bindIp, std::uint16_t port, TlsMode tlsMode) override
+  {
+    if (tlsMode != TlsMode::None)
     {
-      _impl.setCloseCallback(cb);
+      throw UnsupportedOperation("TLS/DTLS is not supported on UDP");
     }
+    return _impl.addListener(bindIp, port, TlsMode::None);
+  }
 
-    void setErrorCallback(ErrorCallback cb) override
+  SessionId connect(const std::string &host, std::uint16_t port, TlsMode tlsMode) override
+  {
+    if (tlsMode != TlsMode::None)
     {
-      _impl.setErrorCallback(cb);
+      throw UnsupportedOperation("TLS/DTLS is not supported on UDP");
     }
+    return _impl.connect(host, port, TlsMode::None);
+  }
 
-    BasicTransportStats getBasicStats() const override
-    {
-      auto s = _impl.stats();
-      BasicTransportStats basic{};
-      basic.accepted = s.accepted;
-      basic.connected = s.connected;
-      basic.closed = s.closed;
-      basic.errors = s.errors;
-      basic.bytesIn = s.bytesIn;
-      basic.bytesOut = s.bytesOut;
-      basic.sessionsCurrent = s.sessionsCurrent;
-      return basic;
-    }
+  SessionId connectViaListener(ListenerId lid, const std::string &host, std::uint16_t port) override
+  {
+    return _impl.connectViaListener(lid, host, port);
+  }
 
-    SharedTransport& impl() { return _impl; }
-    const SharedTransport& impl() const { return _impl; }
+  bool send(SessionId sid, const void *data, std::size_t n) override
+  {
+    return _impl.send(sid, data, n);
+  }
 
-  private:
-    SharedTransport _impl;
-  };
+  bool close(SessionId sid) override { return _impl.close(sid); }
 
-  /// \brief UDP transport adapter implementing ITransport interface
-  class UdpTransportAdapter final : public ITransport
+  void reconfigure(const UnifiedConfig &cfg) override
   {
-  public:
-    explicit UdpTransportAdapter(const SharedUdpTransport::Config& cfg)
-      : _impl(cfg, _dummyTls, _dummyTls)
-    {
-    }
-
-    void setCallbacks(const UnifiedCallbacks& cbs) override
+    if (auto p = std::get_if<SharedUdpTransport::Config>(&cfg))
     {
-      SharedUdpTransport::Callbacks u{};
-      u.onAccept = cbs.onAccept;
-      u.onConnect = cbs.onConnect;
-      u.onData = cbs.onData;
-      u.onClosed = cbs.onClosed;
-      u.onError = cbs.onError;
-      _impl.setCallbacks(u);
+      _impl.reconfigure(*p);
+      return;
     }
+    throw UnsupportedOperation("Provided TCP/TLS config to UDP transport");
+  }
 
-    bool start() override { return _impl.start(); }
-    void stop() override { _impl.stop(); }
+  UnifiedStats stats() const override
+  {
+    auto s = _impl.stats();
+    UnifiedStats u{};
+    u.accepted = s.accepted;
+    u.connected = s.connected;
+    u.closed = s.closed;
+    u.errors = s.errors;
+    u.tlsHandshakes = s.tlsHandshakes;
+    u.tlsFailures = s.tlsFailures;
+    u.bytesIn = s.bytesIn;
+    u.bytesOut = s.bytesOut;
+    u.epollWakeups = s.epollWakeups;
+    u.commands = s.commands;
+    u.gcRuns = s.gcRuns;
+    u.gcClosedIdle = s.gcClosedIdle;
+    u.gcClosedAged = s.gcClosedAged;
+    u.backpressureCloses = s.backpressureCloses;
+    u.sessionsCurrent = s.sessionsCurrent;
+    u.sessionsPeak = s.sessionsPeak;
+    return u;
+  }
 
-    ListenerId addListener(const std::string& bindIp, std::uint16_t port,
-                           TlsMode tlsMode) override
-    {
-      if (tlsMode != TlsMode::None)
-      {
-        throw UnsupportedOperation("TLS/DTLS is not supported on UDP");
-      }
-      return _impl.addListener(bindIp, port, TlsMode::None);
-    }
+  Capability caps() const override
+  {
+    return Capability::HasConnectViaListener | Capability::SupportsBatchSend;
+  }
 
-    SessionId connect(const std::string& host, std::uint16_t port,
-                      TlsMode tlsMode) override
-    {
-      if (tlsMode != TlsMode::None)
-      {
-        throw UnsupportedOperation("TLS/DTLS is not supported on UDP");
-      }
-      return _impl.connect(host, port, TlsMode::None);
-    }
+  // ITransportBase callback setters (delegate to setCallbacks)
+  void setDataCallback(DataCallback cb) override
+  {
+    UnifiedCallbacks cbs;
+    cbs.onData = cb;
+    setCallbacks(cbs);
+  }
 
-    SessionId connectViaListener(ListenerId lid, const std::string& host,
-                                 std::uint16_t port) override
-    {
-      return _impl.connectViaListener(lid, host, port);
-    }
+  void setAcceptCallback(AcceptCallback cb) override
+  {
+    UnifiedCallbacks cbs;
+    cbs.onAccept = [cb](SessionId sid, const std::string &peer, const IoResult &result)
+    { cb(sid, peer, result); };
+    setCallbacks(cbs);
+  }
 
-    bool send(SessionId sid, const void* data, std::size_t n) override
-    {
-      return _impl.send(sid, data, n);
-    }
+  void setConnectCallback(ConnectCallback cb) override
+  {
+    UnifiedCallbacks cbs;
+    cbs.onConnect = cb;
+    setCallbacks(cbs);
+  }
 
-    bool close(SessionId sid) override { return _impl.close(sid); }
+  void setCloseCallback(CloseCallback cb) override
+  {
+    UnifiedCallbacks cbs;
+    cbs.onClosed = cb;
+    setCallbacks(cbs);
+  }
 
-    void reconfigure(const UnifiedConfig& cfg) override
-    {
-      if (auto p = std::get_if<SharedUdpTransport::Config>(&cfg))
-      {
-        _impl.reconfigure(*p);
-        return;
-      }
-      throw UnsupportedOperation("Provided TCP/TLS config to UDP transport");
-    }
+  void setErrorCallback(ErrorCallback cb) override
+  {
+    UnifiedCallbacks cbs;
+    cbs.onError = cb;
+    setCallbacks(cbs);
+  }
 
-    UnifiedStats stats() const override
-    {
-      auto s = _impl.stats();
-      UnifiedStats u{};
-      u.accepted = s.accepted;
-      u.connected = s.connected;
-      u.closed = s.closed;
-      u.errors = s.errors;
-      u.tlsHandshakes = s.tlsHandshakes;
-      u.tlsFailures = s.tlsFailures;
-      u.bytesIn = s.bytesIn;
-      u.bytesOut = s.bytesOut;
-      u.epollWakeups = s.epollWakeups;
-      u.commands = s.commands;
-      u.gcRuns = s.gcRuns;
-      u.gcClosedIdle = s.gcClosedIdle;
-      u.gcClosedAged = s.gcClosedAged;
-      u.backpressureCloses = s.backpressureCloses;
-      u.sessionsCurrent = s.sessionsCurrent;
-      u.sessionsPeak = s.sessionsPeak;
-      return u;
-    }
+  BasicTransportStats getBasicStats() const override
+  {
+    auto s = _impl.stats();
+    BasicTransportStats basic{};
+    basic.accepted = s.accepted;
+    basic.connected = s.connected;
+    basic.closed = s.closed;
+    basic.errors = s.errors;
+    basic.bytesIn = s.bytesIn;
+    basic.bytesOut = s.bytesOut;
+    basic.sessionsCurrent = s.sessionsCurrent;
+    return basic;
+  }
 
-    Capability caps() const override
-    {
-      return Capability::HasConnectViaListener | Capability::SupportsBatchSend;
-    }
+  SharedUdpTransport &impl() { return _impl; }
+  const SharedUdpTransport &impl() const { return _impl; }
 
-    // ITransportBase callback setters (delegate to setCallbacks)
-    void setDataCallback(DataCallback cb) override
-    {
-      UnifiedCallbacks cbs;
-      cbs.onData = cb;
-      setCallbacks(cbs);
-    }
+private:
+  SharedUdpTransport::TlsConfig _dummyTls{};
+  SharedUdpTransport _impl;
+};
 
-    void setAcceptCallback(AcceptCallback cb) override
-    {
-      UnifiedCallbacks cbs;
-      cbs.onAccept = [cb](SessionId sid, const std::string& peer,
-                          const IoResult& result) { cb(sid, peer, result); };
-      setCallbacks(cbs);
-    }
+/// \brief Unified transport providing sync/async operations for both TCP and
+/// UDP
+class UnifiedSharedTransport
+{
+public:
+  /// \brief Transport protocol type
+  enum class Protocol
+  {
+    TCP,
+    UDP
+  };
 
-    void setConnectCallback(ConnectCallback cb) override
-    {
-      UnifiedCallbacks cbs;
-      cbs.onConnect = cb;
-      setCallbacks(cbs);
-    }
+  /// \brief Unified configuration combining transport and hybrid settings
+  struct Config
+  {
+    Protocol protocol{Protocol::TCP};
+
+    // === Network Layer Settings ===
+    std::chrono::seconds idleTimeout{600};
+    std::chrono::seconds maxConnAge{std::chrono::seconds::zero()};
+    std::chrono::seconds connectTimeout{30};
+    std::chrono::seconds handshakeTimeout{30};
+    std::chrono::seconds writeStallTimeout{0};
+    std::chrono::seconds gcInterval{5};
+
+    // Socket options
+    bool enableTcpNoDelay{true};
+    int soRcvBuf{0};
+    int soSndBuf{0};
+    bool useEdgeTriggered{true};
+    bool closeOnBackpressure{true};
+
+    // TCP-specific options
+    struct TcpKeepalive
+    {
+      bool enable{false};
+      int idleSec{60};
+      int intvlSec{10};
+      int cnt{3};
+    } tcpKeepalive;
+
+    // UDP-specific options
+    std::size_t maxSessions{0}; // UDP only
+    int listenBacklog{0};       // UDP only
+
+    // === Sync/Async Layer Settings ===
+    std::size_t maxPendingSyncOps{32};
+    std::size_t maxSyncReceiveBuffer{1024 * 1024};
+    std::chrono::milliseconds defaultSyncTimeout{30000};
+    bool allowReadModeSwitch{true};
+    bool autoHealthMonitoring{true};
+
+    // === I/O Settings ===
+    int epollMaxEvents{256};
+    std::size_t ioReadChunk{64 * 1024};
+    std::size_t maxWriteQueue{1024};
+
+    // === TLS Settings ===
+    struct TlsConfig
+    {
+      bool enabled{false};
+      TlsMode defaultMode{TlsMode::None};
+      std::string certFile;
+      std::string keyFile;
+      std::string caFile;
+      std::string ciphers;
+      std::string alpn;
+      bool verifyPeer{false};
+    } serverTls, clientTls;
+
+    /// \brief Create config optimized for SIP over TCP
+    static Config forSipTcp(const std::string &bindAddr = "0.0.0.0", std::uint16_t port = 5060,
+                            bool enableTls = false)
+    {
+      Config config;
+      config.protocol = Protocol::TCP;
+      config.idleTimeout = std::chrono::seconds(3600);              // Long-lived SIP connections
+      config.enableTcpNoDelay = true;                               // Low latency
+      config.tcpKeepalive.enable = true;                            // Detect dead peers
+      config.tcpKeepalive.idleSec = 120;                            // SIP keepalive
+      config.maxPendingSyncOps = 64;                                // Many transactions
+      config.defaultSyncTimeout = std::chrono::milliseconds(32000); // Timer B
+      config.autoHealthMonitoring = true;
+
+      if (enableTls)
+      {
+        config.serverTls.enabled = true;
+        config.serverTls.defaultMode = TlsMode::Server;
+        config.clientTls.enabled = true;
+        config.clientTls.defaultMode = TlsMode::Client;
+      }
 
-    void setCloseCallback(CloseCallback cb) override
-    {
-      UnifiedCallbacks cbs;
-      cbs.onClosed = cb;
-      setCallbacks(cbs);
+      return config;
     }
 
-    void setErrorCallback(ErrorCallback cb) override
+    /// \brief Create config optimized for SIP over UDP
+    static Config forSipUdp(const std::string &bindAddr = "0.0.0.0", std::uint16_t port = 5060)
     {
-      UnifiedCallbacks cbs;
-      cbs.onError = cb;
-      setCallbacks(cbs);
+      Config config;
+      config.protocol = Protocol::UDP;
+      config.idleTimeout = std::chrono::seconds(32);              // Timer B
+      config.maxSessions = 10000;                                 // Many peers
+      config.maxPendingSyncOps = 64;                              // Many transactions
+      config.defaultSyncTimeout = std::chrono::milliseconds(500); // Faster for UDP
+      config.autoHealthMonitoring = true;
+      return config;
     }
 
-    BasicTransportStats getBasicStats() const override
+    /// \brief Create minimal config for testing
+    static Config minimal(Protocol protocol = Protocol::TCP)
     {
-      auto s = _impl.stats();
-      BasicTransportStats basic{};
-      basic.accepted = s.accepted;
-      basic.connected = s.connected;
-      basic.closed = s.closed;
-      basic.errors = s.errors;
-      basic.bytesIn = s.bytesIn;
-      basic.bytesOut = s.bytesOut;
-      basic.sessionsCurrent = s.sessionsCurrent;
-      return basic;
+      Config config;
+      config.protocol = protocol;
+      config.idleTimeout = std::chrono::seconds(60);
+      config.maxPendingSyncOps = 8;
+      config.defaultSyncTimeout = std::chrono::milliseconds(1000);
+      return config;
     }
-
-    SharedUdpTransport& impl() { return _impl; }
-    const SharedUdpTransport& impl() const { return _impl; }
-
-  private:
-    SharedUdpTransport::TlsConfig _dummyTls{};
-    SharedUdpTransport _impl;
   };
 
-  /// \brief Unified transport providing sync/async operations for both TCP and
-  /// UDP
-  class UnifiedSharedTransport
+  /// \brief Construct unified transport with specified configuration
+  explicit UnifiedSharedTransport(const Config &config)
+      : _protocol(config.protocol), _config(config)
+  {
+    initializeTransport();
+  }
+
+  /// \brief Create transport with unified configuration
+  static std::unique_ptr<UnifiedSharedTransport> create(const Config &config)
   {
-  public:
-    /// \brief Transport protocol type
-    enum class Protocol
-    {
-      TCP,
-      UDP
-    };
+    return std::make_unique<UnifiedSharedTransport>(config);
+  }
 
-    /// \brief Unified configuration combining transport and hybrid settings
-    struct Config
-    {
-      Protocol protocol{Protocol::TCP};
-
-      // === Network Layer Settings ===
-      std::chrono::seconds idleTimeout{600};
-      std::chrono::seconds maxConnAge{std::chrono::seconds::zero()};
-      std::chrono::seconds connectTimeout{30};
-      std::chrono::seconds handshakeTimeout{30};
-      std::chrono::seconds writeStallTimeout{0};
-      std::chrono::seconds gcInterval{5};
-
-      // Socket options
-      bool enableTcpNoDelay{true};
-      int soRcvBuf{0};
-      int soSndBuf{0};
-      bool useEdgeTriggered{true};
-      bool closeOnBackpressure{true};
-
-      // TCP-specific options
-      struct TcpKeepalive
-      {
-        bool enable{false};
-        int idleSec{60};
-        int intvlSec{10};
-        int cnt{3};
-      } tcpKeepalive;
-
-      // UDP-specific options
-      std::size_t maxSessions{0}; // UDP only
-      int listenBacklog{0};       // UDP only
-
-      // === Sync/Async Layer Settings ===
-      std::size_t maxPendingSyncOps{32};
-      std::size_t maxSyncReceiveBuffer{1024 * 1024};
-      std::chrono::milliseconds defaultSyncTimeout{30000};
-      bool allowReadModeSwitch{true};
-      bool autoHealthMonitoring{true};
-
-      // === I/O Settings ===
-      int epollMaxEvents{256};
-      std::size_t ioReadChunk{64 * 1024};
-      std::size_t maxWriteQueue{1024};
-
-      // === TLS Settings ===
-      struct TlsConfig
-      {
-        bool enabled{false};
-        TlsMode defaultMode{TlsMode::None};
-        std::string certFile;
-        std::string keyFile;
-        std::string caFile;
-        std::string ciphers;
-        std::string alpn;
-        bool verifyPeer{false};
-      } serverTls, clientTls;
-
-      /// \brief Create config optimized for SIP over TCP
-      static Config forSipTcp(const std::string& bindAddr = "0.0.0.0",
-                              std::uint16_t port = 5060, bool enableTls = false)
-      {
-        Config config;
-        config.protocol = Protocol::TCP;
-        config.idleTimeout =
-            std::chrono::seconds(3600);    // Long-lived SIP connections
-        config.enableTcpNoDelay = true;    // Low latency
-        config.tcpKeepalive.enable = true; // Detect dead peers
-        config.tcpKeepalive.idleSec = 120; // SIP keepalive
-        config.maxPendingSyncOps = 64;     // Many transactions
-        config.defaultSyncTimeout = std::chrono::milliseconds(32000); // Timer B
-        config.autoHealthMonitoring = true;
-
-        if (enableTls)
-        {
-          config.serverTls.enabled = true;
-          config.serverTls.defaultMode = TlsMode::Server;
-          config.clientTls.enabled = true;
-          config.clientTls.defaultMode = TlsMode::Client;
-        }
-
-        return config;
-      }
+  /// \brief Create TCP transport with minimal configuration
+  static std::unique_ptr<UnifiedSharedTransport> createTcp()
+  {
+    return std::make_unique<UnifiedSharedTransport>(Config::minimal(Protocol::TCP));
+  }
 
-      /// \brief Create config optimized for SIP over UDP
-      static Config forSipUdp(const std::string& bindAddr = "0.0.0.0",
-                              std::uint16_t port = 5060)
-      {
-        Config config;
-        config.protocol = Protocol::UDP;
-        config.idleTimeout = std::chrono::seconds(32); // Timer B
-        config.maxSessions = 10000;                    // Many peers
-        config.maxPendingSyncOps = 64;                 // Many transactions
-        config.defaultSyncTimeout =
-            std::chrono::milliseconds(500); // Faster for UDP
-        config.autoHealthMonitoring = true;
-        return config;
-      }
+  /// \brief Create UDP transport with minimal configuration
+  static std::unique_ptr<UnifiedSharedTransport> createUdp()
+  {
+    return std::make_unique<UnifiedSharedTransport>(Config::minimal(Protocol::UDP));
+  }
 
-      /// \brief Create minimal config for testing
-      static Config minimal(Protocol protocol = Protocol::TCP)
-      {
-        Config config;
-        config.protocol = protocol;
-        config.idleTimeout = std::chrono::seconds(60);
-        config.maxPendingSyncOps = 8;
-        config.defaultSyncTimeout = std::chrono::milliseconds(1000);
-        return config;
-      }
-    };
+  /// \brief Create SIP-optimized TCP transport
+  static std::unique_ptr<UnifiedSharedTransport>
+  createSipTcp(const std::string &bindAddr = "0.0.0.0", std::uint16_t port = 5060,
+               bool enableTls = false)
+  {
+    auto config = Config::forSipTcp(bindAddr, port, enableTls);
+    auto transport = std::make_unique<UnifiedSharedTransport>(config);
 
-    /// \brief Construct unified transport with specified configuration
-    explicit UnifiedSharedTransport(const Config& config)
-      : _protocol(config.protocol), _config(config)
+    if (port > 0)
     {
-      initializeTransport();
+      transport->start();
+      transport->addListener(bindAddr, port, enableTls ? TlsMode::Server : TlsMode::None);
     }
 
-    /// \brief Create transport with unified configuration
-    static std::unique_ptr<UnifiedSharedTransport> create(const Config& config)
-    {
-      return std::make_unique<UnifiedSharedTransport>(config);
-    }
+    return transport;
+  }
 
-    /// \brief Create TCP transport with minimal configuration
-    static std::unique_ptr<UnifiedSharedTransport> createTcp()
-    {
-      return std::make_unique<UnifiedSharedTransport>(
-          Config::minimal(Protocol::TCP));
-    }
+  /// \brief Create SIP-optimized UDP transport
+  static std::unique_ptr<UnifiedSharedTransport>
+  createSipUdp(const std::string &bindAddr = "0.0.0.0", std::uint16_t port = 5060)
+  {
+    auto config = Config::forSipUdp(bindAddr, port);
+    auto transport = std::make_unique<UnifiedSharedTransport>(config);
 
-    /// \brief Create UDP transport with minimal configuration
-    static std::unique_ptr<UnifiedSharedTransport> createUdp()
+    if (port > 0)
     {
-      return std::make_unique<UnifiedSharedTransport>(
-          Config::minimal(Protocol::UDP));
+      transport->start();
+      transport->addListener(bindAddr, port);
     }
 
-    /// \brief Create SIP-optimized TCP transport
-    static std::unique_ptr<UnifiedSharedTransport>
-    createSipTcp(const std::string& bindAddr = "0.0.0.0",
-                 std::uint16_t port = 5060, bool enableTls = false)
-    {
-      auto config = Config::forSipTcp(bindAddr, port, enableTls);
-      auto transport = std::make_unique<UnifiedSharedTransport>(config);
+    return transport;
+  }
 
-      if (port > 0)
-      {
-        transport->start();
-        transport->addListener(bindAddr, port,
-                               enableTls ? TlsMode::Server : TlsMode::None);
-      }
+  ~UnifiedSharedTransport() { stop(); }
 
-      return transport;
-    }
+  // Delete copy/move
+  UnifiedSharedTransport(const UnifiedSharedTransport &) = delete;
+  UnifiedSharedTransport &operator=(const UnifiedSharedTransport &) = delete;
 
-    /// \brief Create SIP-optimized UDP transport
-    static std::unique_ptr<UnifiedSharedTransport>
-    createSipUdp(const std::string& bindAddr = "0.0.0.0",
-                 std::uint16_t port = 5060)
-    {
-      auto config = Config::forSipUdp(bindAddr, port);
-      auto transport = std::make_unique<UnifiedSharedTransport>(config);
+  // ===== Lifecycle Management =====
 
-      if (port > 0)
-      {
-        transport->start();
-        transport->addListener(bindAddr, port);
-      }
+  /// \brief Start the transport
+  bool start()
+  {
+    if (!_hybrid)
+    {
+      return false;
+    }
+    return _hybrid->start();
+  }
 
-      return transport;
+  /// \brief Stop the transport
+  void stop()
+  {
+    iora::core::Logger::debug("UnifiedSharedTransport::stop() - Starting");
+    if (_hybrid)
+    {
+      iora::core::Logger::debug("UnifiedSharedTransport::stop() - Calling hybrid->stop()");
+      _hybrid->stop();
+      iora::core::Logger::debug("UnifiedSharedTransport::stop() - hybrid->stop() completed");
     }
+    iora::core::Logger::debug("UnifiedSharedTransport::stop() - Completed");
+  }
 
-    ~UnifiedSharedTransport() { stop(); }
+  /// \brief Check if transport is running
+  bool isRunning() const { return _hybrid != nullptr; }
 
-    // Delete copy/move
-    UnifiedSharedTransport(const UnifiedSharedTransport&) = delete;
-    UnifiedSharedTransport& operator=(const UnifiedSharedTransport&) = delete;
+  // ===== Read Mode Management (via SyncAsyncTransport) =====
 
-    // ===== Lifecycle Management =====
+  /// \brief Set the read mode for a session (exclusive access)
+  bool setReadMode(SessionId sid, ReadMode mode) { return _hybrid->setReadMode(sid, mode); }
 
-    /// \brief Start the transport
-    bool start()
-    {
-      if (!_hybrid)
-      {
-        return false;
-      }
-      return _hybrid->start();
-    }
+  /// \brief Get current read mode for a session
+  ReadMode getReadMode(SessionId sid) const { return _hybrid->getReadMode(sid); }
 
-    /// \brief Stop the transport
-    void stop()
-    {
-      iora::core::Logger::debug("UnifiedSharedTransport::stop() - Starting");
-      if (_hybrid)
-      {
-        iora::core::Logger::debug(
-            "UnifiedSharedTransport::stop() - Calling hybrid->stop()");
-        _hybrid->stop();
-        iora::core::Logger::debug(
-            "UnifiedSharedTransport::stop() - hybrid->stop() completed");
-      }
-      iora::core::Logger::debug("UnifiedSharedTransport::stop() - Completed");
-    }
+  // ===== Async Operations (via SyncAsyncTransport) =====
 
-    /// \brief Check if transport is running
-    bool isRunning() const { return _hybrid != nullptr; }
+  /// \brief Set async data callback (only works in Async read mode)
+  bool setDataCallback(SessionId sid, SyncAsyncTransport::DataCallback cb)
+  {
+    return _hybrid->setDataCallback(sid, cb);
+  }
 
-    // ===== Read Mode Management (via SyncAsyncTransport) =====
+  /// \brief Set async accept callback for incoming connections
+  void setAcceptCallback(std::function<void(SessionId, const std::string &, const IoResult &)> cb)
+  {
+    _hybrid->getTransport()->setAcceptCallback(cb);
+  }
 
-    /// \brief Set the read mode for a session (exclusive access)
-    bool setReadMode(SessionId sid, ReadMode mode)
-    {
-      return _hybrid->setReadMode(sid, mode);
-    }
+  /// \brief Set async connect callback
+  void setConnectCallback(SyncAsyncTransport::ConnectCallback cb)
+  {
+    _hybrid->setConnectCallback(cb);
+  }
 
-    /// \brief Get current read mode for a session
-    ReadMode getReadMode(SessionId sid) const
-    {
-      return _hybrid->getReadMode(sid);
-    }
+  /// \brief Set async close callback
+  void setCloseCallback(SyncAsyncTransport::CloseCallback cb) { _hybrid->setCloseCallback(cb); }
 
-    // ===== Async Operations (via SyncAsyncTransport) =====
+  /// \brief Set async error callback
+  void setErrorCallback(SyncAsyncTransport::ErrorCallback cb) { _hybrid->setErrorCallback(cb); }
 
-    /// \brief Set async data callback (only works in Async read mode)
-    bool setDataCallback(SessionId sid, SyncAsyncTransport::DataCallback cb)
-    {
-      return _hybrid->setDataCallback(sid, cb);
-    }
+  /// \brief Async send with optional completion callback
+  void sendAsync(SessionId sid, const void *data, std::size_t len,
+                 SyncAsyncTransport::SendCompleteCallback cb = nullptr)
+  {
+    _hybrid->sendAsync(sid, data, len, cb);
+  }
 
-    /// \brief Set async accept callback for incoming connections
-    void setAcceptCallback(
-        std::function<void(SessionId, const std::string&, const IoResult&)> cb)
-    {
-      _hybrid->getTransport()->setAcceptCallback(cb);
-    }
+  // ===== Sync Operations (via SyncAsyncTransport) =====
 
-    /// \brief Set async connect callback
-    void setConnectCallback(SyncAsyncTransport::ConnectCallback cb)
-    {
-      _hybrid->setConnectCallback(cb);
-    }
+  /// \brief Synchronous send - blocks until complete or timeout
+  SyncResult sendSync(SessionId sid, const void *data, std::size_t len,
+                      std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+  {
+    return _hybrid->sendSync(sid, data, len, timeout);
+  }
 
-    /// \brief Set async close callback
-    void setCloseCallback(SyncAsyncTransport::CloseCallback cb)
-    {
-      _hybrid->setCloseCallback(cb);
-    }
+  /// \brief Cancellable synchronous send
+  SyncResult
+  sendSyncCancellable(SessionId sid, const void *data, std::size_t len, CancellationToken &token,
+                      std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+  {
+    return _hybrid->sendSyncCancellable(sid, data, len, token, timeout);
+  }
 
-    /// \brief Set async error callback
-    void setErrorCallback(SyncAsyncTransport::ErrorCallback cb)
-    {
-      _hybrid->setErrorCallback(cb);
-    }
+  /// \brief Synchronous receive - blocks until data available or timeout
+  /// \note Only works in Sync read mode
+  SyncResult receiveSync(SessionId sid, void *buffer, std::size_t &len,
+                         std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+  {
+    return _hybrid->receiveSync(sid, buffer, len, timeout);
+  }
 
-    /// \brief Async send with optional completion callback
-    void sendAsync(SessionId sid, const void* data, std::size_t len,
-                   SyncAsyncTransport::SendCompleteCallback cb = nullptr)
-    {
-      _hybrid->sendAsync(sid, data, len, cb);
-    }
+  /// \brief Cancellable synchronous receive
+  SyncResult
+  receiveSyncCancellable(SessionId sid, void *buffer, std::size_t &len, CancellationToken &token,
+                         std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+  {
+    return _hybrid->receiveSyncCancellable(sid, buffer, len, token, timeout);
+  }
 
-    // ===== Sync Operations (via SyncAsyncTransport) =====
+  // ===== Connection Management =====
 
-    /// \brief Synchronous send - blocks until complete or timeout
-    SyncResult sendSync(
-        SessionId sid, const void* data, std::size_t len,
-        std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+  /// \brief Add a listener
+  ListenerId addListener(const std::string &bind, std::uint16_t port, TlsMode tls = TlsMode::None)
+  {
+    if (_protocol == Protocol::UDP && tls != TlsMode::None)
     {
-      return _hybrid->sendSync(sid, data, len, timeout);
+      throw UnsupportedOperation("TLS/DTLS is not supported on UDP");
     }
+    return _hybrid->addListener(bind, port, tls);
+  }
 
-    /// \brief Cancellable synchronous send
-    SyncResult sendSyncCancellable(
-        SessionId sid, const void* data, std::size_t len,
-        CancellationToken& token,
-        std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+  /// \brief Connect to a remote host
+  SessionId connect(const std::string &host, std::uint16_t port, TlsMode tls = TlsMode::None)
+  {
+    if (_protocol == Protocol::UDP && tls != TlsMode::None)
     {
-      return _hybrid->sendSyncCancellable(sid, data, len, token, timeout);
+      throw UnsupportedOperation("TLS/DTLS is not supported on UDP");
     }
+    return _hybrid->connect(host, port, tls);
+  }
 
-    /// \brief Synchronous receive - blocks until data available or timeout
-    /// \note Only works in Sync read mode
-    SyncResult receiveSync(
-        SessionId sid, void* buffer, std::size_t& len,
-        std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
+  /// \brief Connect via a specific listener (UDP only)
+  SessionId connectViaListener(ListenerId lid, const std::string &host, std::uint16_t port)
+  {
+    if (_protocol != Protocol::UDP)
     {
-      return _hybrid->receiveSync(sid, buffer, len, timeout);
+      throw UnsupportedOperation("connectViaListener is only supported on UDP");
     }
 
-    /// \brief Cancellable synchronous receive
-    SyncResult receiveSyncCancellable(
-        SessionId sid, void* buffer, std::size_t& len, CancellationToken& token,
-        std::chrono::milliseconds timeout = std::chrono::milliseconds::max())
-    {
-      return _hybrid->receiveSyncCancellable(sid, buffer, len, token, timeout);
-    }
+    // Need to access the underlying UDP transport
+    // This is a limitation - SyncAsyncTransport doesn't expose this method
+    // We'll need to add it to SyncAsyncTransport or use a workaround
+    throw UnsupportedOperation("connectViaListener not yet implemented in SyncAsyncTransport");
+  }
 
-    // ===== Connection Management =====
+  /// \brief Close a session
+  bool close(SessionId sid) { return _hybrid->close(sid); }
 
-    /// \brief Add a listener
-    ListenerId addListener(const std::string& bind, std::uint16_t port,
-                           TlsMode tls = TlsMode::None)
-    {
-      if (_protocol == Protocol::UDP && tls != TlsMode::None)
-      {
-        throw UnsupportedOperation("TLS/DTLS is not supported on UDP");
-      }
-      return _hybrid->addListener(bind, port, tls);
-    }
+  /// \brief Cancel all pending sync operations for a session
+  void cancelPendingOperations(SessionId sid) { _hybrid->cancelPendingOperations(sid); }
 
-    /// \brief Connect to a remote host
-    SessionId connect(const std::string& host, std::uint16_t port,
-                      TlsMode tls = TlsMode::None)
-    {
-      if (_protocol == Protocol::UDP && tls != TlsMode::None)
-      {
-        throw UnsupportedOperation("TLS/DTLS is not supported on UDP");
-      }
-      return _hybrid->connect(host, port, tls);
-    }
+  // ===== Health and Statistics =====
 
-    /// \brief Connect via a specific listener (UDP only)
-    SessionId connectViaListener(ListenerId lid, const std::string& host,
-                                 std::uint16_t port)
-    {
-      if (_protocol != Protocol::UDP)
-      {
-        throw UnsupportedOperation(
-            "connectViaListener is only supported on UDP");
-      }
+  /// \brief Get connection health metrics
+  HybridConnectionHealth getConnectionHealth(SessionId sid) const
+  {
+    return _hybrid->getConnectionHealth(sid);
+  }
 
-      // Need to access the underlying UDP transport
-      // This is a limitation - SyncAsyncTransport doesn't expose this method
-      // We'll need to add it to SyncAsyncTransport or use a workaround
-      throw UnsupportedOperation(
-          "connectViaListener not yet implemented in SyncAsyncTransport");
-    }
+  /// \brief Get transport statistics
+  UnifiedStats getStats() const
+  {
+    // Get basic stats from underlying transport and convert to UnifiedStats
+    auto basic = _hybrid->getTransport()->getBasicStats();
+
+    UnifiedStats unified{};
+    unified.accepted = basic.accepted;
+    unified.connected = basic.connected;
+    unified.closed = basic.closed;
+    unified.errors = basic.errors;
+    unified.bytesIn = basic.bytesIn;
+    unified.bytesOut = basic.bytesOut;
+    unified.sessionsCurrent = basic.sessionsCurrent;
+
+    return unified;
+  }
 
-    /// \brief Close a session
-    bool close(SessionId sid) { return _hybrid->close(sid); }
+  // ===== Protocol Information =====
 
-    /// \brief Cancel all pending sync operations for a session
-    void cancelPendingOperations(SessionId sid)
-    {
-      _hybrid->cancelPendingOperations(sid);
-    }
+  /// \brief Get the current protocol
+  Protocol getProtocol() const { return _protocol; }
 
-    // ===== Health and Statistics =====
+  /// \brief Get transport capabilities
+  Capability getCapabilities() const
+  {
+    Capability caps = Capability::SupportsSyncOperations | Capability::SupportsReadModes;
 
-    /// \brief Get connection health metrics
-    HybridConnectionHealth getConnectionHealth(SessionId sid) const
+    if (_protocol == Protocol::TCP)
     {
-      return _hybrid->getConnectionHealth(sid);
+      caps = caps | Capability::HasTls | Capability::IsConnectionOriented |
+             Capability::SupportsKeepalive;
     }
-
-    /// \brief Get transport statistics
-    UnifiedStats getStats() const
+    else // UDP
     {
-      // Get basic stats from underlying transport and convert to UnifiedStats
-      auto basic = _hybrid->getTransport()->getBasicStats();
-
-      UnifiedStats unified{};
-      unified.accepted = basic.accepted;
-      unified.connected = basic.connected;
-      unified.closed = basic.closed;
-      unified.errors = basic.errors;
-      unified.bytesIn = basic.bytesIn;
-      unified.bytesOut = basic.bytesOut;
-      unified.sessionsCurrent = basic.sessionsCurrent;
-
-      return unified;
+      caps = caps | Capability::HasConnectViaListener | Capability::SupportsBatchSend;
     }
 
-    // ===== Protocol Information =====
+    return caps;
+  }
 
-    /// \brief Get the current protocol
-    Protocol getProtocol() const { return _protocol; }
+  /// \brief Check if a specific capability is supported
+  bool hasCapability(Capability cap) const { return any(getCapabilities() & cap); }
 
-    /// \brief Get transport capabilities
-    Capability getCapabilities() const
+  /// \brief Reconfigure the transport at runtime
+  void reconfigure(const UnifiedConfig &config)
+  {
+    if (_protocol == Protocol::TCP)
     {
-      Capability caps =
-          Capability::SupportsSyncOperations | Capability::SupportsReadModes;
-
-      if (_protocol == Protocol::TCP)
-      {
-        caps = caps | Capability::HasTls | Capability::IsConnectionOriented |
-               Capability::SupportsKeepalive;
-      }
-      else // UDP
+      if (!std::holds_alternative<SharedTransport::Config>(config))
       {
-        caps = caps | Capability::HasConnectViaListener |
-               Capability::SupportsBatchSend;
+        throw UnsupportedOperation("Cannot reconfigure TCP transport with UDP config");
       }
-
-      return caps;
     }
-
-    /// \brief Check if a specific capability is supported
-    bool hasCapability(Capability cap) const
+    else // UDP
     {
-      return any(getCapabilities() & cap);
-    }
-
-    /// \brief Reconfigure the transport at runtime
-    void reconfigure(const UnifiedConfig& config)
-    {
-      if (_protocol == Protocol::TCP)
-      {
-        if (!std::holds_alternative<SharedTransport::Config>(config))
-        {
-          throw UnsupportedOperation(
-              "Cannot reconfigure TCP transport with UDP config");
-        }
-      }
-      else // UDP
+      if (!std::holds_alternative<SharedUdpTransport::Config>(config))
       {
-        if (!std::holds_alternative<SharedUdpTransport::Config>(config))
-        {
-          throw UnsupportedOperation(
-              "Cannot reconfigure UDP transport with TCP config");
-        }
+        throw UnsupportedOperation("Cannot reconfigure UDP transport with TCP config");
       }
-
-      // Update config - SyncAsyncTransport doesn't expose reconfigure yet
-      // This would need to be added to SyncAsyncTransport
     }
 
-  private:
-    void initializeTransport()
-    {
-      std::unique_ptr<ITransport> baseTransport;
-
-      if (_protocol == Protocol::TCP)
-      {
-        // Convert unified config to TCP-specific config
-        SharedTransport::Config tcpConfig;
-        tcpConfig.epollMaxEvents = _config.epollMaxEvents;
-        tcpConfig.ioReadChunk = _config.ioReadChunk;
-        tcpConfig.maxWriteQueue = _config.maxWriteQueue;
-        tcpConfig.closeOnBackpressure = _config.closeOnBackpressure;
-        tcpConfig.idleTimeout = _config.idleTimeout;
-        tcpConfig.maxConnAge = _config.maxConnAge;
-        tcpConfig.handshakeTimeout = _config.handshakeTimeout;
-        tcpConfig.gcInterval = _config.gcInterval;
-        tcpConfig.connectTimeout = _config.connectTimeout;
-        tcpConfig.writeStallTimeout = _config.writeStallTimeout;
-        tcpConfig.useEdgeTriggered = _config.useEdgeTriggered;
-        tcpConfig.enableTcpNoDelay = _config.enableTcpNoDelay;
-        tcpConfig.soRcvBuf = _config.soRcvBuf;
-        tcpConfig.soSndBuf = _config.soSndBuf;
-        tcpConfig.tcpKeepalive.enable = _config.tcpKeepalive.enable;
-        tcpConfig.tcpKeepalive.idleSec = _config.tcpKeepalive.idleSec;
-        tcpConfig.tcpKeepalive.intvlSec = _config.tcpKeepalive.intvlSec;
-        tcpConfig.tcpKeepalive.cnt = _config.tcpKeepalive.cnt;
-
-        // Convert TLS config
-        SharedTransport::TlsConfig serverTls;
-        serverTls.enabled = _config.serverTls.enabled;
-        serverTls.defaultMode = _config.serverTls.defaultMode;
-        serverTls.certFile = _config.serverTls.certFile;
-        serverTls.keyFile = _config.serverTls.keyFile;
-        serverTls.caFile = _config.serverTls.caFile;
-        serverTls.ciphers = _config.serverTls.ciphers;
-        serverTls.alpn = _config.serverTls.alpn;
-        serverTls.verifyPeer = _config.serverTls.verifyPeer;
-
-        SharedTransport::TlsConfig clientTls;
-        clientTls.enabled = _config.clientTls.enabled;
-        clientTls.defaultMode = _config.clientTls.defaultMode;
-        clientTls.certFile = _config.clientTls.certFile;
-        clientTls.keyFile = _config.clientTls.keyFile;
-        clientTls.caFile = _config.clientTls.caFile;
-        clientTls.ciphers = _config.clientTls.ciphers;
-        clientTls.alpn = _config.clientTls.alpn;
-        clientTls.verifyPeer = _config.clientTls.verifyPeer;
-
-        baseTransport = std::make_unique<TcpTlsTransportAdapter>(
-            tcpConfig, serverTls, clientTls);
-      }
-      else // UDP
-      {
-        // Convert unified config to UDP-specific config
-        SharedUdpTransport::Config udpConfig;
-        udpConfig.epollMaxEvents = _config.epollMaxEvents;
-        udpConfig.ioReadChunk = _config.ioReadChunk;
-        udpConfig.maxWriteQueue = _config.maxWriteQueue;
-        udpConfig.idleTimeout = _config.idleTimeout;
-        udpConfig.maxConnAge = _config.maxConnAge;
-        udpConfig.handshakeTimeout = _config.handshakeTimeout;
-        udpConfig.gcInterval = _config.gcInterval;
-        udpConfig.listenBacklog = _config.listenBacklog;
-        udpConfig.maxSessions = _config.maxSessions;
-        udpConfig.useEdgeTriggered = _config.useEdgeTriggered;
-        udpConfig.closeOnBackpressure = _config.closeOnBackpressure;
-        udpConfig.soRcvBuf = _config.soRcvBuf;
-        udpConfig.soSndBuf = _config.soSndBuf;
-        udpConfig.connectTimeout = _config.connectTimeout;
-        udpConfig.writeStallTimeout = _config.writeStallTimeout;
-
-        baseTransport = std::make_unique<UdpTransportAdapter>(udpConfig);
-      }
-
-      // Convert hybrid config
-      SyncAsyncTransport::Config hybridConfig;
-      hybridConfig.maxPendingSyncOps = _config.maxPendingSyncOps;
-      hybridConfig.maxSyncReceiveBuffer = _config.maxSyncReceiveBuffer;
-      hybridConfig.defaultTimeout = _config.defaultSyncTimeout;
-      hybridConfig.allowReadModeSwitch = _config.allowReadModeSwitch;
-      hybridConfig.autoHealthMonitoring = _config.autoHealthMonitoring;
+    // Update config - SyncAsyncTransport doesn't expose reconfigure yet
+    // This would need to be added to SyncAsyncTransport
+  }
 
-      _hybrid = std::make_unique<SyncAsyncTransport>(std::move(baseTransport),
-                                                  hybridConfig);
-    }
+private:
+  void initializeTransport()
+  {
+    std::unique_ptr<ITransport> baseTransport;
+
+    if (_protocol == Protocol::TCP)
+    {
+      // Convert unified config to TCP-specific config
+      SharedTransport::Config tcpConfig;
+      tcpConfig.epollMaxEvents = _config.epollMaxEvents;
+      tcpConfig.ioReadChunk = _config.ioReadChunk;
+      tcpConfig.maxWriteQueue = _config.maxWriteQueue;
+      tcpConfig.closeOnBackpressure = _config.closeOnBackpressure;
+      tcpConfig.idleTimeout = _config.idleTimeout;
+      tcpConfig.maxConnAge = _config.maxConnAge;
+      tcpConfig.handshakeTimeout = _config.handshakeTimeout;
+      tcpConfig.gcInterval = _config.gcInterval;
+      tcpConfig.connectTimeout = _config.connectTimeout;
+      tcpConfig.writeStallTimeout = _config.writeStallTimeout;
+      tcpConfig.useEdgeTriggered = _config.useEdgeTriggered;
+      tcpConfig.enableTcpNoDelay = _config.enableTcpNoDelay;
+      tcpConfig.soRcvBuf = _config.soRcvBuf;
+      tcpConfig.soSndBuf = _config.soSndBuf;
+      tcpConfig.tcpKeepalive.enable = _config.tcpKeepalive.enable;
+      tcpConfig.tcpKeepalive.idleSec = _config.tcpKeepalive.idleSec;
+      tcpConfig.tcpKeepalive.intvlSec = _config.tcpKeepalive.intvlSec;
+      tcpConfig.tcpKeepalive.cnt = _config.tcpKeepalive.cnt;
+
+      // Convert TLS config
+      SharedTransport::TlsConfig serverTls;
+      serverTls.enabled = _config.serverTls.enabled;
+      serverTls.defaultMode = _config.serverTls.defaultMode;
+      serverTls.certFile = _config.serverTls.certFile;
+      serverTls.keyFile = _config.serverTls.keyFile;
+      serverTls.caFile = _config.serverTls.caFile;
+      serverTls.ciphers = _config.serverTls.ciphers;
+      serverTls.alpn = _config.serverTls.alpn;
+      serverTls.verifyPeer = _config.serverTls.verifyPeer;
+
+      SharedTransport::TlsConfig clientTls;
+      clientTls.enabled = _config.clientTls.enabled;
+      clientTls.defaultMode = _config.clientTls.defaultMode;
+      clientTls.certFile = _config.clientTls.certFile;
+      clientTls.keyFile = _config.clientTls.keyFile;
+      clientTls.caFile = _config.clientTls.caFile;
+      clientTls.ciphers = _config.clientTls.ciphers;
+      clientTls.alpn = _config.clientTls.alpn;
+      clientTls.verifyPeer = _config.clientTls.verifyPeer;
+
+      baseTransport = std::make_unique<TcpTlsTransportAdapter>(tcpConfig, serverTls, clientTls);
+    }
+    else // UDP
+    {
+      // Convert unified config to UDP-specific config
+      SharedUdpTransport::Config udpConfig;
+      udpConfig.epollMaxEvents = _config.epollMaxEvents;
+      udpConfig.ioReadChunk = _config.ioReadChunk;
+      udpConfig.maxWriteQueue = _config.maxWriteQueue;
+      udpConfig.idleTimeout = _config.idleTimeout;
+      udpConfig.maxConnAge = _config.maxConnAge;
+      udpConfig.handshakeTimeout = _config.handshakeTimeout;
+      udpConfig.gcInterval = _config.gcInterval;
+      udpConfig.listenBacklog = _config.listenBacklog;
+      udpConfig.maxSessions = _config.maxSessions;
+      udpConfig.useEdgeTriggered = _config.useEdgeTriggered;
+      udpConfig.closeOnBackpressure = _config.closeOnBackpressure;
+      udpConfig.soRcvBuf = _config.soRcvBuf;
+      udpConfig.soSndBuf = _config.soSndBuf;
+      udpConfig.connectTimeout = _config.connectTimeout;
+      udpConfig.writeStallTimeout = _config.writeStallTimeout;
+
+      baseTransport = std::make_unique<UdpTransportAdapter>(udpConfig);
+    }
+
+    // Convert hybrid config
+    SyncAsyncTransport::Config hybridConfig;
+    hybridConfig.maxPendingSyncOps = _config.maxPendingSyncOps;
+    hybridConfig.maxSyncReceiveBuffer = _config.maxSyncReceiveBuffer;
+    hybridConfig.defaultTimeout = _config.defaultSyncTimeout;
+    hybridConfig.allowReadModeSwitch = _config.allowReadModeSwitch;
+    hybridConfig.autoHealthMonitoring = _config.autoHealthMonitoring;
+
+    _hybrid = std::make_unique<SyncAsyncTransport>(std::move(baseTransport), hybridConfig);
+  }
 
-  private:
-    Protocol _protocol;
-    Config _config;
-    std::unique_ptr<SyncAsyncTransport> _hybrid;
-  };
+private:
+  Protocol _protocol;
+  Config _config;
+  std::unique_ptr<SyncAsyncTransport> _hybrid;
+};
 
-  // Note: SIP convenience functions are now built into the class as static
-  // methods:
-  // - UnifiedSharedTransport::createSipTcp()
-  // - UnifiedSharedTransport::createSipUdp()
+// Note: SIP convenience functions are now built into the class as static
+// methods:
+// - UnifiedSharedTransport::createSipTcp()
+// - UnifiedSharedTransport::createSipUdp()
 
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/network/webhook_server.hpp b/include/iora/network/webhook_server.hpp
index 1ca126a..779fe00 100644
--- a/include/iora/network/webhook_server.hpp
+++ b/include/iora/network/webhook_server.hpp
@@ -6,982 +6,912 @@
 // details.
 
 #pragma once
+#include <algorithm>
+#include <atomic>
+#include <chrono>
+#include <fstream>
+#include <functional>
 #include <iostream>
-#include <stdexcept>
-#include <string>
 #include <mutex>
-#include <unordered_map>
 #include <optional>
-#include <chrono>
-#include <functional>
-#include <variant>
-#include <atomic>
 #include <sstream>
-#include <fstream>
+#include <stdexcept>
+#include <string>
 #include <thread>
-#include <algorithm>
+#include <unordered_map>
+#include <variant>
 
-#include "iora/parsers/json.hpp"
 #include "iora/core/logger.hpp"
 #include "iora/core/thread_pool.hpp"
 #include "iora/network/unified_shared_transport.hpp"
 #include "iora/parsers/http_message.hpp"
+#include "iora/parsers/json.hpp"
 
 namespace iora
 {
 namespace network
 {
 
-  /// \brief Lightweight, testable HTTP webhook server for handling REST and
-  /// JSON endpoints.
-  class WebhookServer
+/// \brief Lightweight, testable HTTP webhook server for handling REST and
+/// JSON endpoints.
+class WebhookServer
+{
+public:
+  /// \brief Configuration constants
+  static constexpr std::size_t MAX_PENDING_REQUESTS = 1000;              // Maximum queued requests
+  static constexpr std::size_t DEFAULT_MAX_JSON_SIZE = 10 * 1024 * 1024; // 10MB default
+
+  /// \brief Explicitly delete copy/move constructors and assignment operators
+  WebhookServer(const WebhookServer &) = delete;
+  WebhookServer &operator=(const WebhookServer &) = delete;
+  WebhookServer(WebhookServer &&) = delete;
+  WebhookServer &operator=(WebhookServer &&) = delete;
+
+  /// \brief TLS configuration for the server
+  struct TlsConfig
   {
-  public:
-    /// \brief Configuration constants
-    static constexpr std::size_t MAX_PENDING_REQUESTS =
-        1000; // Maximum queued requests
-    static constexpr std::size_t DEFAULT_MAX_JSON_SIZE = 10 * 1024 * 1024; // 10MB default
-
-    /// \brief Explicitly delete copy/move constructors and assignment operators
-    WebhookServer(const WebhookServer&) = delete;
-    WebhookServer& operator=(const WebhookServer&) = delete;
-    WebhookServer(WebhookServer&&) = delete;
-    WebhookServer& operator=(WebhookServer&&) = delete;
-
-    /// \brief TLS configuration for the server
-    struct TlsConfig
-    {
-      std::string certFile;
-      std::string keyFile;
-      std::string caFile;
-      bool requireClientCert = false;
-    };
-
-    /// \brief JSON parsing configuration
-    struct JsonConfig
-    {
-      std::size_t maxPayloadSize = DEFAULT_MAX_JSON_SIZE;  // Maximum JSON payload size in bytes
-      parsers::ParseLimits parseLimits;  // JSON parsing limits (depth, array size, etc.)
-    };
+    std::string certFile;
+    std::string keyFile;
+    std::string caFile;
+    bool requireClientCert = false;
+  };
+
+  /// \brief JSON parsing configuration
+  struct JsonConfig
+  {
+    std::size_t maxPayloadSize = DEFAULT_MAX_JSON_SIZE; // Maximum JSON payload size in bytes
+    parsers::ParseLimits parseLimits; // JSON parsing limits (depth, array size, etc.)
+  };
 
-    /// \brief HTTP request wrapper to maintain API compatibility
-    struct Request
+  /// \brief HTTP request wrapper to maintain API compatibility
+  struct Request
+  {
+    HttpMethod method;
+    std::string path;
+    HttpHeaders headers;
+    std::string body;
+    std::unordered_map<std::string, std::string> params;
+    std::string remote_addr;       // Peer IP address for httplib compatibility
+    std::uint16_t remote_port = 0; // Peer port for additional context
+
+    std::string get_header_value(const std::string &key) const
     {
-      HttpMethod method;
-      std::string path;
-      HttpHeaders headers;
-      std::string body;
-      std::unordered_map<std::string, std::string> params;
-      std::string remote_addr; // Peer IP address for httplib compatibility
-      std::uint16_t remote_port = 0; // Peer port for additional context
-
-      std::string get_header_value(const std::string& key) const
-      {
-        auto it = headers.find(key);
-        return it != headers.end() ? it->second : "";
-      }
+      auto it = headers.find(key);
+      return it != headers.end() ? it->second : "";
+    }
 
-      bool has_header(const std::string& key) const
-      {
-        return headers.find(key) != headers.end();
-      }
-    };
+    bool has_header(const std::string &key) const { return headers.find(key) != headers.end(); }
+  };
 
-    /// \brief HTTP response wrapper to maintain API compatibility
-    struct Response
+  /// \brief HTTP response wrapper to maintain API compatibility
+  struct Response
+  {
+    int status = 200;
+    HttpHeaders headers;
+    std::string body;
+
+    void set_content(const std::string &content, const std::string &contentType)
     {
-      int status = 200;
-      HttpHeaders headers;
-      std::string body;
+      body = content;
+      headers["Content-Type"] = contentType;
+      headers["Content-Length"] = std::to_string(content.size());
+    }
 
-      void set_content(const std::string& content,
-                       const std::string& contentType)
-      {
-        body = content;
-        headers["Content-Type"] = contentType;
-        headers["Content-Length"] = std::to_string(content.size());
-      }
+    void set_header(const std::string &key, const std::string &value) { headers[key] = value; }
+  };
 
-      void set_header(const std::string& key, const std::string& value)
-      {
-        headers[key] = value;
-      }
-    };
-
-    using Handler = std::function<void(const Request&, Response&)>;
-    using JsonHandler = std::function<parsers::Json(const parsers::Json&)>;
-
-    /// \brief Utility class for handlers to check if the server is shutting
-    /// down
-    ///
-    /// Handlers should use this to check for shutdown and exit gracefully:
-    /// ```cpp
-    /// server.onPost("/api", [&server](const Request& req, Response& res) {
-    ///   auto shutdown = server.getShutdownChecker();
-    ///
-    ///   for (int i = 0; i < 1000; ++i) {
-    ///     if (shutdown.isShuttingDown()) {
-    ///       res.set_status(503);
-    ///       res.set_content("Service shutting down", "text/plain");
-    ///       return;
-    ///     }
-    ///     // Do work...
-    ///   }
-    /// });
-    /// ```
-    class ShutdownChecker
-    {
-      const std::atomic<bool>& _shutdownFlag;
+  using Handler = std::function<void(const Request &, Response &)>;
+  using JsonHandler = std::function<parsers::Json(const parsers::Json &)>;
+
+  /// \brief Utility class for handlers to check if the server is shutting
+  /// down
+  ///
+  /// Handlers should use this to check for shutdown and exit gracefully:
+  /// ```cpp
+  /// server.onPost("/api", [&server](const Request& req, Response& res) {
+  ///   auto shutdown = server.getShutdownChecker();
+  ///
+  ///   for (int i = 0; i < 1000; ++i) {
+  ///     if (shutdown.isShuttingDown()) {
+  ///       res.set_status(503);
+  ///       res.set_content("Service shutting down", "text/plain");
+  ///       return;
+  ///     }
+  ///     // Do work...
+  ///   }
+  /// });
+  /// ```
+  class ShutdownChecker
+  {
+    const std::atomic<bool> &_shutdownFlag;
 
-    public:
-      explicit ShutdownChecker(const std::atomic<bool>& flag)
-        : _shutdownFlag(flag)
-      {
-      }
+  public:
+    explicit ShutdownChecker(const std::atomic<bool> &flag) : _shutdownFlag(flag) {}
 
-      /// \brief Check if the server is shutting down
-      /// \return true if shutdown has been initiated
-      bool isShuttingDown() const { return _shutdownFlag.load(); }
+    /// \brief Check if the server is shutting down
+    /// \return true if shutdown has been initiated
+    bool isShuttingDown() const { return _shutdownFlag.load(); }
 
-      /// \brief Throw if shutting down (for exception-based flow control)
-      void throwIfShuttingDown() const
+    /// \brief Throw if shutting down (for exception-based flow control)
+    void throwIfShuttingDown() const
+    {
+      if (isShuttingDown())
       {
-        if (isShuttingDown())
-        {
-          throw std::runtime_error("Server is shutting down");
-        }
+        throw std::runtime_error("Server is shutting down");
       }
-    };
+    }
+  };
 
-    static constexpr int DEFAULT_PORT = 8080;
+  static constexpr int DEFAULT_PORT = 8080;
 
-    /// \brief Constructs a WebhookServer with the default port.
-    WebhookServer()
-      : _port(DEFAULT_PORT),
-        _shutdown(false),
-        _jsonConfig{},
+  /// \brief Constructs a WebhookServer with the default port.
+  WebhookServer()
+      : _port(DEFAULT_PORT), _shutdown(false), _jsonConfig{},
         _threadPool(2, 8, std::chrono::seconds(30))
-    {
-    }
+  {
+  }
 
-    ~WebhookServer()
+  ~WebhookServer()
+  {
+    iora::core::Logger::debug("WebhookServer::~WebhookServer() - Destructor called");
+    try
     {
-      iora::core::Logger::debug(
-          "WebhookServer::~WebhookServer() - Destructor called");
-      try
-      {
-        stop();
-      }
-      catch (const std::exception& e)
-      {
-        // Log the error but don't throw from destructor
-        iora::core::Logger::error("WebhookServer destructor error: " +
-                                  std::string(e.what()));
-      }
-      catch (...)
-      {
-        // Handle any other exceptions
-        iora::core::Logger::error("WebhookServer destructor unknown error");
-      }
+      stop();
     }
-
-    /// \brief Sets the port for the server.
-    void setPort(int port)
+    catch (const std::exception &e)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      _port = port;
+      // Log the error but don't throw from destructor
+      iora::core::Logger::error("WebhookServer destructor error: " + std::string(e.what()));
     }
-
-    /// \brief Sets the JSON parsing configuration
-    void setJsonConfig(const JsonConfig& config)
+    catch (...)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      _jsonConfig = config;
+      // Handle any other exceptions
+      iora::core::Logger::error("WebhookServer destructor unknown error");
     }
+  }
 
-    /// \brief Gets the current JSON parsing configuration
-    JsonConfig getJsonConfig() const
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      return _jsonConfig;
-    }
+  /// \brief Sets the port for the server.
+  void setPort(int port)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    _port = port;
+  }
 
-    /// \brief Get a ShutdownChecker for use in handlers
-    /// \return ShutdownChecker that can be used to check if server is shutting
-    /// down
-    ShutdownChecker getShutdownChecker() const
+  /// \brief Sets the JSON parsing configuration
+  void setJsonConfig(const JsonConfig &config)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    _jsonConfig = config;
+  }
+
+  /// \brief Gets the current JSON parsing configuration
+  JsonConfig getJsonConfig() const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _jsonConfig;
+  }
+
+  /// \brief Get a ShutdownChecker for use in handlers
+  /// \return ShutdownChecker that can be used to check if server is shutting
+  /// down
+  ShutdownChecker getShutdownChecker() const { return ShutdownChecker(_shutdown); }
+
+  /// \brief Enables TLS with the given configuration. Throws if cert/key
+  /// files are missing or invalid.
+  void enableTls(const TlsConfig &config)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+
+    // Validate cert/key files exist
+    if (config.certFile.empty() || config.keyFile.empty())
     {
-      return ShutdownChecker(_shutdown);
+      throw std::runtime_error("TLS: certFile and keyFile must be set");
     }
 
-    /// \brief Enables TLS with the given configuration. Throws if cert/key
-    /// files are missing or invalid.
-    void enableTls(const TlsConfig& config)
+    // Validate certificate file
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-
-      // Validate cert/key files exist
-      if (config.certFile.empty() || config.keyFile.empty())
+      std::ifstream certTest(config.certFile, std::ios::binary);
+      if (!certTest.good())
       {
-        throw std::runtime_error("TLS: certFile and keyFile must be set");
+        throw std::runtime_error("TLS: certFile '" + config.certFile + "' not readable");
       }
 
-      // Validate certificate file
+      // Basic validation - check for PEM format
+      std::string firstLine;
+      std::getline(certTest, firstLine);
+      if (firstLine.find("-----BEGIN") == std::string::npos)
       {
-        std::ifstream certTest(config.certFile, std::ios::binary);
-        if (!certTest.good())
-        {
-          throw std::runtime_error("TLS: certFile '" + config.certFile +
-                                   "' not readable");
-        }
-
-        // Basic validation - check for PEM format
-        std::string firstLine;
-        std::getline(certTest, firstLine);
-        if (firstLine.find("-----BEGIN") == std::string::npos)
-        {
-          throw std::runtime_error("TLS: certFile '" + config.certFile +
-                                   "' does not appear to be in PEM format");
-        }
-
-        // Check file size is reasonable
-        certTest.seekg(0, std::ios::end);
-        auto certSize = certTest.tellg();
-        if (certSize <= 0 || certSize > 100 * 1024) // 100KB max
-        {
-          throw std::runtime_error(
-              "TLS: certFile '" + config.certFile +
-              "' has invalid size: " + std::to_string(certSize) + " bytes");
-        }
+        throw std::runtime_error("TLS: certFile '" + config.certFile +
+                                 "' does not appear to be in PEM format");
       }
 
-      // Validate key file
+      // Check file size is reasonable
+      certTest.seekg(0, std::ios::end);
+      auto certSize = certTest.tellg();
+      if (certSize <= 0 || certSize > 100 * 1024) // 100KB max
       {
-        std::ifstream keyTest(config.keyFile, std::ios::binary);
-        if (!keyTest.good())
-        {
-          throw std::runtime_error("TLS: keyFile '" + config.keyFile +
-                                   "' not readable");
-        }
+        throw std::runtime_error("TLS: certFile '" + config.certFile +
+                                 "' has invalid size: " + std::to_string(certSize) + " bytes");
+      }
+    }
 
-        // Basic validation - check for PEM format
-        std::string firstLine;
-        std::getline(keyTest, firstLine);
-        if (firstLine.find("-----BEGIN") == std::string::npos)
-        {
-          throw std::runtime_error("TLS: keyFile '" + config.keyFile +
-                                   "' does not appear to be in PEM format");
-        }
+    // Validate key file
+    {
+      std::ifstream keyTest(config.keyFile, std::ios::binary);
+      if (!keyTest.good())
+      {
+        throw std::runtime_error("TLS: keyFile '" + config.keyFile + "' not readable");
+      }
 
-        // Check file size is reasonable
-        keyTest.seekg(0, std::ios::end);
-        auto keySize = keyTest.tellg();
-        if (keySize <= 0 || keySize > 100 * 1024) // 100KB max
-        {
-          throw std::runtime_error(
-              "TLS: keyFile '" + config.keyFile +
-              "' has invalid size: " + std::to_string(keySize) + " bytes");
-        }
+      // Basic validation - check for PEM format
+      std::string firstLine;
+      std::getline(keyTest, firstLine);
+      if (firstLine.find("-----BEGIN") == std::string::npos)
+      {
+        throw std::runtime_error("TLS: keyFile '" + config.keyFile +
+                                 "' does not appear to be in PEM format");
       }
 
-      // Validate CA file if client certificates are required
-      if (config.requireClientCert)
+      // Check file size is reasonable
+      keyTest.seekg(0, std::ios::end);
+      auto keySize = keyTest.tellg();
+      if (keySize <= 0 || keySize > 100 * 1024) // 100KB max
       {
-        if (config.caFile.empty())
-        {
-          throw std::runtime_error(
-              "TLS: requireClientCert is true but caFile is not set");
-        }
+        throw std::runtime_error("TLS: keyFile '" + config.keyFile +
+                                 "' has invalid size: " + std::to_string(keySize) + " bytes");
+      }
+    }
 
-        std::ifstream caTest(config.caFile, std::ios::binary);
-        if (!caTest.good())
-        {
-          throw std::runtime_error("TLS: caFile '" + config.caFile +
-                                   "' not readable");
-        }
+    // Validate CA file if client certificates are required
+    if (config.requireClientCert)
+    {
+      if (config.caFile.empty())
+      {
+        throw std::runtime_error("TLS: requireClientCert is true but caFile is not set");
+      }
 
-        // Basic validation - check for PEM format
-        std::string firstLine;
-        std::getline(caTest, firstLine);
-        if (firstLine.find("-----BEGIN") == std::string::npos)
-        {
-          throw std::runtime_error("TLS: caFile '" + config.caFile +
-                                   "' does not appear to be in PEM format");
-        }
+      std::ifstream caTest(config.caFile, std::ios::binary);
+      if (!caTest.good())
+      {
+        throw std::runtime_error("TLS: caFile '" + config.caFile + "' not readable");
+      }
 
-        // Check file size is reasonable
-        caTest.seekg(0, std::ios::end);
-        auto caSize = caTest.tellg();
-        if (caSize <= 0 || caSize > 100 * 1024) // 100KB max
-        {
-          throw std::runtime_error(
-              "TLS: caFile '" + config.caFile +
-              "' has invalid size: " + std::to_string(caSize) + " bytes");
-        }
+      // Basic validation - check for PEM format
+      std::string firstLine;
+      std::getline(caTest, firstLine);
+      if (firstLine.find("-----BEGIN") == std::string::npos)
+      {
+        throw std::runtime_error("TLS: caFile '" + config.caFile +
+                                 "' does not appear to be in PEM format");
       }
 
-      _tlsConfig = config;
-      iora::core::Logger::info(
-          "WebhookServer: TLS configuration validated successfully");
+      // Check file size is reasonable
+      caTest.seekg(0, std::ios::end);
+      auto caSize = caTest.tellg();
+      if (caSize <= 0 || caSize > 100 * 1024) // 100KB max
+      {
+        throw std::runtime_error("TLS: caFile '" + config.caFile +
+                                 "' has invalid size: " + std::to_string(caSize) + " bytes");
+      }
     }
 
-    /// \brief Registers a GET handler for the given path.
-    void onGet(const std::string& path, Handler handler)
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      _handlers[HttpMethod::GET][path] = std::move(handler);
-    }
+    _tlsConfig = config;
+    iora::core::Logger::info("WebhookServer: TLS configuration validated successfully");
+  }
 
-    /// \brief Registers a GET handler for JSON endpoints.
-    void onJsonGet(const std::string& endpoint, JsonHandler handler)
-    {
-      onGet(endpoint,
-            [this, handler](const Request& req, Response& res)
+  /// \brief Registers a GET handler for the given path.
+  void onGet(const std::string &path, Handler handler)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    _handlers[HttpMethod::GET][path] = std::move(handler);
+  }
+
+  /// \brief Registers a GET handler for JSON endpoints.
+  void onJsonGet(const std::string &endpoint, JsonHandler handler)
+  {
+    onGet(endpoint,
+          [this, handler](const Request &req, Response &res)
+          {
+            try
             {
-              try
+              parsers::Json requestJson;
+              if (req.body.empty())
               {
-                parsers::Json requestJson;
-                if (req.body.empty()) {
-                  requestJson = parsers::Json::object();
-                } else {
-                  if (req.body.size() > _jsonConfig.maxPayloadSize) {
-                    throw std::runtime_error("JSON payload exceeds maximum size limit of " +
-                                           std::to_string(_jsonConfig.maxPayloadSize) + " bytes");
-                  }
-                  auto result = parsers::Json::parse(req.body, _jsonConfig.parseLimits);
-                  if (!result.ok) {
-                    throw std::runtime_error("JSON parse error: " + result.error.message);
-                  }
-                  requestJson = std::move(result.value);
-                }
-                parsers::Json responseJson = handler(requestJson);
-                res.set_content(responseJson.dump(), "application/json");
+                requestJson = parsers::Json::object();
               }
-              catch (const std::exception& ex)
+              else
               {
-                res.status = 500;
-                res.set_content(ex.what(), "text/plain");
-                iora::core::Logger::error(
-                    std::string("WebhookServer onJsonGet handler error: ") +
-                    ex.what());
+                if (req.body.size() > _jsonConfig.maxPayloadSize)
+                {
+                  throw std::runtime_error("JSON payload exceeds maximum size limit of " +
+                                           std::to_string(_jsonConfig.maxPayloadSize) + " bytes");
+                }
+                auto result = parsers::Json::parse(req.body, _jsonConfig.parseLimits);
+                if (!result.ok)
+                {
+                  throw std::runtime_error("JSON parse error: " + result.error.message);
+                }
+                requestJson = std::move(result.value);
               }
-            });
-    }
+              parsers::Json responseJson = handler(requestJson);
+              res.set_content(responseJson.dump(), "application/json");
+            }
+            catch (const std::exception &ex)
+            {
+              res.status = 500;
+              res.set_content(ex.what(), "text/plain");
+              iora::core::Logger::error(std::string("WebhookServer onJsonGet handler error: ") +
+                                        ex.what());
+            }
+          });
+  }
 
-    /// \brief Registers a POST handler for the given path.
-    void onPost(const std::string& path, Handler handler)
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      _handlers[HttpMethod::POST][path] = std::move(handler);
-    }
+  /// \brief Registers a POST handler for the given path.
+  void onPost(const std::string &path, Handler handler)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    _handlers[HttpMethod::POST][path] = std::move(handler);
+  }
 
-    /// \brief Registers a POST handler for JSON endpoints.
-    void onJsonPost(const std::string& endpoint, JsonHandler handler)
-    {
-      onPost(endpoint,
-             [this, handler](const Request& req, Response& res)
+  /// \brief Registers a POST handler for JSON endpoints.
+  void onJsonPost(const std::string &endpoint, JsonHandler handler)
+  {
+    onPost(endpoint,
+           [this, handler](const Request &req, Response &res)
+           {
+             try
              {
-               try
+               if (req.body.size() > _jsonConfig.maxPayloadSize)
                {
-                 if (req.body.size() > _jsonConfig.maxPayloadSize) {
-                   throw std::runtime_error("JSON payload exceeds maximum size limit of " +
+                 throw std::runtime_error("JSON payload exceeds maximum size limit of " +
                                           std::to_string(_jsonConfig.maxPayloadSize) + " bytes");
-                 }
-                 auto result = parsers::Json::parse(req.body, _jsonConfig.parseLimits);
-                 if (!result.ok) {
-                   throw std::runtime_error("JSON parse error: " + result.error.message);
-                 }
-                 parsers::Json requestJson = std::move(result.value);
-                 parsers::Json responseJson = handler(requestJson);
-                 res.set_content(responseJson.dump(), "application/json");
                }
-               catch (const std::exception& ex)
+               auto result = parsers::Json::parse(req.body, _jsonConfig.parseLimits);
+               if (!result.ok)
                {
-                 res.status = 500;
-                 res.set_content(ex.what(), "text/plain");
-                 iora::core::Logger::error(
-                     std::string("WebhookServer onJsonPost handler error: ") +
-                     ex.what());
+                 throw std::runtime_error("JSON parse error: " + result.error.message);
                }
-             });
-    }
-
-    /// \brief Registers a DELETE handler for the given path.
-    void onDelete(const std::string& path, Handler handler)
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      _handlers[HttpMethod::DELETE][path] = std::move(handler);
-    }
+               parsers::Json requestJson = std::move(result.value);
+               parsers::Json responseJson = handler(requestJson);
+               res.set_content(responseJson.dump(), "application/json");
+             }
+             catch (const std::exception &ex)
+             {
+               res.status = 500;
+               res.set_content(ex.what(), "text/plain");
+               iora::core::Logger::error(std::string("WebhookServer onJsonPost handler error: ") +
+                                         ex.what());
+             }
+           });
+  }
+
+  /// \brief Registers a DELETE handler for the given path.
+  void onDelete(const std::string &path, Handler handler)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    _handlers[HttpMethod::DELETE][path] = std::move(handler);
+  }
 
-    /// \brief Starts the server. Throws on error.
-    void start()
+  /// \brief Starts the server. Throws on error.
+  void start()
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    try
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      try
+      _shutdown = false;
+
+      // Configure transport
+      UnifiedSharedTransport::Config config;
+      config.protocol = UnifiedSharedTransport::Protocol::TCP;
+      config.idleTimeout = std::chrono::seconds(600);
+      config.maxPendingSyncOps = 32;
+      config.defaultSyncTimeout = std::chrono::milliseconds(30000);
+      config.enableTcpNoDelay = true;
+      config.tcpKeepalive.enable = true;
+      config.maxWriteQueue = 1024;
+
+      // Configure TLS if enabled
+      if (_tlsConfig.has_value())
       {
-        _shutdown = false;
-
-        // Configure transport
-        UnifiedSharedTransport::Config config;
-        config.protocol = UnifiedSharedTransport::Protocol::TCP;
-        config.idleTimeout = std::chrono::seconds(600);
-        config.maxPendingSyncOps = 32;
-        config.defaultSyncTimeout = std::chrono::milliseconds(30000);
-        config.enableTcpNoDelay = true;
-        config.tcpKeepalive.enable = true;
-        config.maxWriteQueue = 1024;
-
-        // Configure TLS if enabled
-        if (_tlsConfig.has_value())
-        {
-          const auto& tlsCfg = _tlsConfig.value();
-          config.serverTls.enabled = true;
-          config.serverTls.defaultMode = TlsMode::Server;
-          config.serverTls.certFile = tlsCfg.certFile;
-          config.serverTls.keyFile = tlsCfg.keyFile;
-          config.serverTls.caFile = tlsCfg.caFile;
-          config.serverTls.verifyPeer = tlsCfg.requireClientCert;
-        }
+        const auto &tlsCfg = _tlsConfig.value();
+        config.serverTls.enabled = true;
+        config.serverTls.defaultMode = TlsMode::Server;
+        config.serverTls.certFile = tlsCfg.certFile;
+        config.serverTls.keyFile = tlsCfg.keyFile;
+        config.serverTls.caFile = tlsCfg.caFile;
+        config.serverTls.verifyPeer = tlsCfg.requireClientCert;
+      }
 
-        _transport = std::make_unique<UnifiedSharedTransport>(config);
+      _transport = std::make_unique<UnifiedSharedTransport>(config);
 
-        // Set up callbacks before starting
+      // Set up callbacks before starting
 
-        // Accept callback - new connection accepted
-        _transport->setAcceptCallback(
-            [this](SessionId sid, const std::string& peer,
-                   const IoResult& result)
+      // Accept callback - new connection accepted
+      _transport->setAcceptCallback(
+        [this](SessionId sid, const std::string &peer, const IoResult &result)
+        {
+          if (result.ok)
+          {
+            // Initialize session state and parse peer address
             {
-              if (result.ok)
+              std::lock_guard<std::mutex> lock(_sessionMutex);
+              SessionInfo &info = _sessionInfo[sid];
+              info.buffer = "";
+
+              // Parse peer address from format "ip:port"
+              auto colonPos = peer.find(':');
+              if (colonPos != std::string::npos)
               {
-                // Initialize session state and parse peer address
+                info.peerAddress = peer.substr(0, colonPos);
+                try
                 {
-                  std::lock_guard<std::mutex> lock(_sessionMutex);
-                  SessionInfo& info = _sessionInfo[sid];
-                  info.buffer = "";
-
-                  // Parse peer address from format "ip:port"
-                  auto colonPos = peer.find(':');
-                  if (colonPos != std::string::npos)
-                  {
-                    info.peerAddress = peer.substr(0, colonPos);
-                    try
-                    {
-                      info.peerPort = static_cast<std::uint16_t>(
-                          std::stoi(peer.substr(colonPos + 1)));
-                    }
-                    catch (...)
-                    {
-                      info.peerPort = 0;
-                    }
-                  }
-                  else
-                  {
-                    info.peerAddress = peer;
-                    info.peerPort = 0;
-                  }
-
-                  // Log the accepted connection
-                  iora::core::Logger::info(
-                      "WebhookServer: Accepted HTTP connection from " +
-                      info.peerAddress + ":" + std::to_string(info.peerPort) +
-                      " (session " + std::to_string(sid) + ")");
+                  info.peerPort = static_cast<std::uint16_t>(std::stoi(peer.substr(colonPos + 1)));
+                }
+                catch (...)
+                {
+                  info.peerPort = 0;
                 }
-
-                // Set session to async mode for receiving data
-                _transport->setReadMode(sid, ReadMode::Async);
-
-                // Set up data callback for this session
-                _transport->setDataCallback(
-                    sid,
-                    [this](SessionId session, const std::uint8_t* data,
-                           std::size_t len, const IoResult& result)
-                    {
-                      if (result.ok)
-                      {
-                        handleIncomingData(session, data, len);
-                      }
-                    });
-              }
-            });
-
-        // Close callback - connection closed
-        _transport->setCloseCallback(
-            [this](SessionId sid, const IoResult& result)
-            {
-              std::lock_guard<std::mutex> lock(_sessionMutex);
-              auto it = _sessionInfo.find(sid);
-              if (it != _sessionInfo.end())
-              {
-                iora::core::Logger::info(
-                    "WebhookServer: HTTP connection closed from " +
-                    it->second.peerAddress + ":" +
-                    std::to_string(it->second.peerPort) + " (session " +
-                    std::to_string(sid) + ")");
-                _sessionInfo.erase(it);
               }
               else
               {
-                iora::core::Logger::debug(
-                    "WebhookServer: Connection closed (session " +
-                    std::to_string(sid) + ")");
+                info.peerAddress = peer;
+                info.peerPort = 0;
               }
-            });
 
-        // Error callback
-        _transport->setErrorCallback(
-            [this](TransportError error, const std::string& message) {
-              iora::core::Logger::error("WebhookServer transport error: " +
-                                        message);
-            });
+              // Log the accepted connection
+              iora::core::Logger::info("WebhookServer: Accepted HTTP connection from " +
+                                       info.peerAddress + ":" + std::to_string(info.peerPort) +
+                                       " (session " + std::to_string(sid) + ")");
+            }
+
+            // Set session to async mode for receiving data
+            _transport->setReadMode(sid, ReadMode::Async);
+
+            // Set up data callback for this session
+            _transport->setDataCallback(sid,
+                                        [this](SessionId session, const std::uint8_t *data,
+                                               std::size_t len, const IoResult &result)
+                                        {
+                                          if (result.ok)
+                                          {
+                                            handleIncomingData(session, data, len);
+                                          }
+                                        });
+          }
+        });
 
-        // Start transport
-        if (!_transport->start())
+      // Close callback - connection closed
+      _transport->setCloseCallback(
+        [this](SessionId sid, const IoResult &result)
         {
-          throw std::runtime_error("Failed to start transport");
-        }
+          std::lock_guard<std::mutex> lock(_sessionMutex);
+          auto it = _sessionInfo.find(sid);
+          if (it != _sessionInfo.end())
+          {
+            iora::core::Logger::info(
+              "WebhookServer: HTTP connection closed from " + it->second.peerAddress + ":" +
+              std::to_string(it->second.peerPort) + " (session " + std::to_string(sid) + ")");
+            _sessionInfo.erase(it);
+          }
+          else
+          {
+            iora::core::Logger::debug("WebhookServer: Connection closed (session " +
+                                      std::to_string(sid) + ")");
+          }
+        });
 
-        // Add listener
-        TlsMode tlsMode =
-            _tlsConfig.has_value() ? TlsMode::Server : TlsMode::None;
-        _listenerId = _transport->addListener("0.0.0.0", _port, tlsMode);
+      // Error callback
+      _transport->setErrorCallback(
+        [this](TransportError error, const std::string &message)
+        { iora::core::Logger::error("WebhookServer transport error: " + message); });
 
-        iora::core::Logger::info("WebhookServer started on port " +
-                                 std::to_string(_port));
-      }
-      catch (const std::exception& ex)
+      // Start transport
+      if (!_transport->start())
       {
-        iora::core::Logger::error(std::string("WebhookServer start error: ") +
-                                  ex.what());
-        throw;
+        throw std::runtime_error("Failed to start transport");
       }
+
+      // Add listener
+      TlsMode tlsMode = _tlsConfig.has_value() ? TlsMode::Server : TlsMode::None;
+      _listenerId = _transport->addListener("0.0.0.0", _port, tlsMode);
+
+      iora::core::Logger::info("WebhookServer started on port " + std::to_string(_port));
+    }
+    catch (const std::exception &ex)
+    {
+      iora::core::Logger::error(std::string("WebhookServer start error: ") + ex.what());
+      throw;
     }
+  }
 
-    /// \brief Stops the server gracefully.
-    void stop()
+  /// \brief Stops the server gracefully.
+  void stop()
+  {
+    iora::core::Logger::debug("WebhookServer::stop() - Starting graceful shutdown");
+
+    // Set shutdown flag atomically to stop new request processing
+    _shutdown.store(true);
+
+    // Give a brief moment for in-flight requests to see the shutdown flag
+    std::this_thread::sleep_for(std::chrono::milliseconds(50));
+
+    std::lock_guard<std::mutex> lock(_mutex);
+
+    iora::core::Logger::debug("WebhookServer::stop() - Stopping transport to "
+                              "prevent new connections");
+    // Stop transport first to prevent new connections and data
+    if (_transport)
     {
-      iora::core::Logger::debug(
-          "WebhookServer::stop() - Starting graceful shutdown");
+      _transport->stop();
+      iora::core::Logger::debug("WebhookServer::stop() - Transport stopped gracefully");
+    }
 
-      // Set shutdown flag atomically to stop new request processing
-      _shutdown.store(true);
+    // Clear session information
+    {
+      std::lock_guard<std::mutex> sessionLock(_sessionMutex);
+      _sessionInfo.clear();
+      iora::core::Logger::debug("WebhookServer::stop() - Cleared session information");
+    }
 
-      // Give a brief moment for in-flight requests to see the shutdown flag
-      std::this_thread::sleep_for(std::chrono::milliseconds(50));
+    // Wait for thread pool tasks to complete with a reasonable timeout
+    // Handlers should use getShutdownChecker() to detect shutdown and exit
+    // gracefully
+    auto startTime = std::chrono::steady_clock::now();
+    const auto maxWaitTime = std::chrono::seconds(2); // Reasonable timeout for production
 
-      std::lock_guard<std::mutex> lock(_mutex);
+    iora::core::Logger::debug("WebhookServer::stop() - Waiting for handlers to complete (max 2s)");
 
-      iora::core::Logger::debug("WebhookServer::stop() - Stopping transport to "
-                                "prevent new connections");
-      // Stop transport first to prevent new connections and data
-      if (_transport)
+    while (_threadPool.getPendingTaskCount() > 0 || _threadPool.getActiveThreadCount() > 0)
+    {
+      auto elapsed = std::chrono::steady_clock::now() - startTime;
+      if (elapsed > maxWaitTime)
       {
-        _transport->stop();
-        iora::core::Logger::debug(
-            "WebhookServer::stop() - Transport stopped gracefully");
+        auto pendingTasks = _threadPool.getPendingTaskCount();
+        auto activeTasks = _threadPool.getActiveThreadCount();
+        iora::core::Logger::warning(
+          std::string("WebhookServer::stop() - Timeout waiting for handlers. ") +
+          "Forcing shutdown with " + std::to_string(pendingTasks) + " pending and " +
+          std::to_string(activeTasks) + " active tasks. " +
+          "Handlers should use getShutdownChecker() to detect shutdown.");
+        break;
       }
+      std::this_thread::sleep_for(std::chrono::milliseconds(50));
+    }
 
-      // Clear session information
-      {
-        std::lock_guard<std::mutex> sessionLock(_sessionMutex);
-        _sessionInfo.clear();
-        iora::core::Logger::debug(
-            "WebhookServer::stop() - Cleared session information");
-      }
+    iora::core::Logger::debug("WebhookServer::stop() - Handler wait completed");
 
-      // Wait for thread pool tasks to complete with a reasonable timeout
-      // Handlers should use getShutdownChecker() to detect shutdown and exit
-      // gracefully
-      auto startTime = std::chrono::steady_clock::now();
-      const auto maxWaitTime =
-          std::chrono::seconds(2); // Reasonable timeout for production
+    // Now safe to reset the transport since no tasks are using it
+    if (_transport)
+    {
+      iora::core::Logger::debug("WebhookServer::stop() - Resetting transport");
+      _transport.reset();
+      iora::core::Logger::debug("WebhookServer::stop() - Transport reset complete");
+    }
 
-      iora::core::Logger::debug(
-          "WebhookServer::stop() - Waiting for handlers to complete (max 2s)");
+    iora::core::Logger::debug("WebhookServer::stop() - Graceful shutdown complete");
+  }
 
-      while (_threadPool.getPendingTaskCount() > 0 ||
-             _threadPool.getActiveThreadCount() > 0)
+private:
+  /// \brief Handle incoming data from a session
+  void handleIncomingData(SessionId sid, const std::uint8_t *data, std::size_t len)
+  {
+    std::string dataStr(reinterpret_cast<const char *>(data), len);
+
+    // Append to session buffer with size limits
+    {
+      std::lock_guard<std::mutex> lock(_sessionMutex);
+      auto it = _sessionInfo.find(sid);
+      if (it == _sessionInfo.end())
       {
-        auto elapsed = std::chrono::steady_clock::now() - startTime;
-        if (elapsed > maxWaitTime)
-        {
-          auto pendingTasks = _threadPool.getPendingTaskCount();
-          auto activeTasks = _threadPool.getActiveThreadCount();
-          iora::core::Logger::warning(
-              std::string(
-                  "WebhookServer::stop() - Timeout waiting for handlers. ") +
-              "Forcing shutdown with " + std::to_string(pendingTasks) +
-              " pending and " + std::to_string(activeTasks) +
-              " active tasks. " +
-              "Handlers should use getShutdownChecker() to detect shutdown.");
-          break;
-        }
-        std::this_thread::sleep_for(std::chrono::milliseconds(50));
+        return; // Session was closed
       }
 
-      iora::core::Logger::debug(
-          "WebhookServer::stop() - Handler wait completed");
-
-      // Now safe to reset the transport since no tasks are using it
-      if (_transport)
+      // Check buffer size limit to prevent DoS
+      if (it->second.buffer.size() + dataStr.size() > SessionInfo::MAX_BUFFER_SIZE)
       {
-        iora::core::Logger::debug(
-            "WebhookServer::stop() - Resetting transport");
-        _transport.reset();
-        iora::core::Logger::debug(
-            "WebhookServer::stop() - Transport reset complete");
+        iora::core::Logger::error("WebhookServer: Buffer size limit exceeded for session " +
+                                  std::to_string(sid) + " - closing connection");
+        _transport->close(sid);
+        return;
       }
 
-      iora::core::Logger::debug(
-          "WebhookServer::stop() - Graceful shutdown complete");
+      it->second.buffer += dataStr;
+      dataStr = it->second.buffer; // Work with complete buffer
     }
 
-  private:
-    /// \brief Handle incoming data from a session
-    void handleIncomingData(SessionId sid, const std::uint8_t* data,
-                            std::size_t len)
+    // Process all complete requests in the buffer (support pipelining)
+    while (true)
     {
-      std::string dataStr(reinterpret_cast<const char*>(data), len);
-
-      // Append to session buffer with size limits
+      auto headerEnd = dataStr.find("\r\n\r\n");
+      if (headerEnd == std::string::npos)
       {
-        std::lock_guard<std::mutex> lock(_sessionMutex);
-        auto it = _sessionInfo.find(sid);
-        if (it == _sessionInfo.end())
-        {
-          return; // Session was closed
-        }
-
-        // Check buffer size limit to prevent DoS
-        if (it->second.buffer.size() + dataStr.size() >
-            SessionInfo::MAX_BUFFER_SIZE)
-        {
-          iora::core::Logger::error(
-              "WebhookServer: Buffer size limit exceeded for session " +
-              std::to_string(sid) + " - closing connection");
-          _transport->close(sid);
-          return;
-        }
+        break; // Need more data for headers
+      }
 
-        it->second.buffer += dataStr;
-        dataStr = it->second.buffer; // Work with complete buffer
+      // Check header size limit
+      if (headerEnd > SessionInfo::MAX_HEADER_SIZE)
+      {
+        iora::core::Logger::error("WebhookServer: Header size limit exceeded for session " +
+                                  std::to_string(sid) + " - closing connection");
+        _transport->close(sid);
+        return;
       }
 
-      // Process all complete requests in the buffer (support pipelining)
-      while (true)
+      std::string headerSection = dataStr.substr(0, headerEnd);
+      std::size_t contentLength = 0;
+      bool isChunked = false;
+
+      // Parse headers
+      std::istringstream headerStream(headerSection);
+      std::string line;
+      while (std::getline(headerStream, line))
       {
-        auto headerEnd = dataStr.find("\r\n\r\n");
-        if (headerEnd == std::string::npos)
+        if (!line.empty() && line.back() == '\r')
         {
-          break; // Need more data for headers
+          line.pop_back();
         }
 
-        // Check header size limit
-        if (headerEnd > SessionInfo::MAX_HEADER_SIZE)
+        auto colonPos = line.find(':');
+        if (colonPos != std::string::npos)
         {
-          iora::core::Logger::error(
-              "WebhookServer: Header size limit exceeded for session " +
-              std::to_string(sid) + " - closing connection");
-          _transport->close(sid);
-          return;
-        }
+          std::string key = line.substr(0, colonPos);
+          std::string value = line.substr(colonPos + 1);
 
-        std::string headerSection = dataStr.substr(0, headerEnd);
-        std::size_t contentLength = 0;
-        bool isChunked = false;
+          // Trim whitespace
+          key.erase(0, key.find_first_not_of(" \t"));
+          key.erase(key.find_last_not_of(" \t") + 1);
+          value.erase(0, value.find_first_not_of(" \t"));
+          value.erase(value.find_last_not_of(" \t") + 1);
 
-        // Parse headers
-        std::istringstream headerStream(headerSection);
-        std::string line;
-        while (std::getline(headerStream, line))
-        {
-          if (!line.empty() && line.back() == '\r')
-          {
-            line.pop_back();
-          }
+          // Convert key to lowercase for comparison
+          std::transform(key.begin(), key.end(), key.begin(), ::tolower);
 
-          auto colonPos = line.find(':');
-          if (colonPos != std::string::npos)
+          if (key == "content-length")
           {
-            std::string key = line.substr(0, colonPos);
-            std::string value = line.substr(colonPos + 1);
-
-            // Trim whitespace
-            key.erase(0, key.find_first_not_of(" \t"));
-            key.erase(key.find_last_not_of(" \t") + 1);
-            value.erase(0, value.find_first_not_of(" \t"));
-            value.erase(value.find_last_not_of(" \t") + 1);
-
-            // Convert key to lowercase for comparison
-            std::transform(key.begin(), key.end(), key.begin(), ::tolower);
-
-            if (key == "content-length")
+            try
             {
-              try
+              contentLength = std::stoull(value);
+              if (contentLength > SessionInfo::MAX_BODY_SIZE)
               {
-                contentLength = std::stoull(value);
-                if (contentLength > SessionInfo::MAX_BODY_SIZE)
-                {
-                  iora::core::Logger::error(
-                      "WebhookServer: Body size limit exceeded for session " +
-                      std::to_string(sid) + " - closing connection");
-                  _transport->close(sid);
-                  return;
-                }
-              }
-              catch (...)
-              {
-                iora::core::Logger::error("WebhookServer: Invalid "
-                                          "content-length header for session " +
-                                          std::to_string(sid) +
-                                          " - closing connection");
+                iora::core::Logger::error("WebhookServer: Body size limit exceeded for session " +
+                                          std::to_string(sid) + " - closing connection");
                 _transport->close(sid);
                 return;
               }
             }
-            else if (key == "transfer-encoding")
+            catch (...)
             {
-              // Convert value to lowercase for comparison
-              std::transform(value.begin(), value.end(), value.begin(),
-                             ::tolower);
-              if (value.find("chunked") != std::string::npos)
-              {
-                isChunked = true;
-              }
+              iora::core::Logger::error("WebhookServer: Invalid "
+                                        "content-length header for session " +
+                                        std::to_string(sid) + " - closing connection");
+              _transport->close(sid);
+              return;
+            }
+          }
+          else if (key == "transfer-encoding")
+          {
+            // Convert value to lowercase for comparison
+            std::transform(value.begin(), value.end(), value.begin(), ::tolower);
+            if (value.find("chunked") != std::string::npos)
+            {
+              isChunked = true;
             }
           }
         }
+      }
 
-        std::size_t requestEndPos;
+      std::size_t requestEndPos;
 
-        if (isChunked)
+      if (isChunked)
+      {
+        // Handle chunked encoding
+        requestEndPos = findChunkedRequestEnd(dataStr, headerEnd + 4);
+        if (requestEndPos == std::string::npos)
         {
-          // Handle chunked encoding
-          requestEndPos = findChunkedRequestEnd(dataStr, headerEnd + 4);
-          if (requestEndPos == std::string::npos)
-          {
-            break; // Need more data for chunked body
-          }
+          break; // Need more data for chunked body
         }
-        else
+      }
+      else
+      {
+        // Handle content-length or no body
+        std::size_t totalExpectedLength = headerEnd + 4 + contentLength;
+        if (dataStr.length() < totalExpectedLength)
         {
-          // Handle content-length or no body
-          std::size_t totalExpectedLength = headerEnd + 4 + contentLength;
-          if (dataStr.length() < totalExpectedLength)
-          {
-            break; // Need more data for body
-          }
-          requestEndPos = totalExpectedLength;
+          break; // Need more data for body
         }
+        requestEndPos = totalExpectedLength;
+      }
 
-        // Extract complete request
-        std::string requestData = dataStr.substr(0, requestEndPos);
+      // Extract complete request
+      std::string requestData = dataStr.substr(0, requestEndPos);
 
-        // Remove processed data from buffer
-        dataStr = dataStr.substr(requestEndPos);
+      // Remove processed data from buffer
+      dataStr = dataStr.substr(requestEndPos);
+      {
+        std::lock_guard<std::mutex> lock(_sessionMutex);
+        auto it = _sessionInfo.find(sid);
+        if (it != _sessionInfo.end())
         {
-          std::lock_guard<std::mutex> lock(_sessionMutex);
-          auto it = _sessionInfo.find(sid);
-          if (it != _sessionInfo.end())
-          {
-            it->second.buffer = dataStr;
-          }
+          it->second.buffer = dataStr;
         }
+      }
 
-        // Process request in thread pool to avoid blocking transport
-        // Use tryEnqueue for backpressure - reject requests if queue is full
-        if (!_threadPool.tryEnqueue([this, sid, requestData]()
-                                    { processHttpRequest(sid, requestData); }))
-        {
-          // Thread pool is overloaded, send 503 Service Unavailable
-          iora::core::Logger::warning(
-              "WebhookServer: Rejecting request due to thread pool overload "
-              "(queue: " +
-              std::to_string(_threadPool.getPendingTaskCount()) + "/" +
-              std::to_string(1024) + ", utilization: " +
-              std::to_string(
-                  static_cast<int>(_threadPool.getQueueUtilization())) +
-              "%)");
-          sendErrorResponse(sid, 503, "Service Unavailable",
-                            "Server overloaded - please retry later");
-        }
-        else if (_threadPool.isUnderHighLoad())
-        {
-          // Log warning when approaching capacity
-          iora::core::Logger::warning(
-              "WebhookServer: High load detected (queue utilization: " +
-              std::to_string(
-                  static_cast<int>(_threadPool.getQueueUtilization())) +
-              "%, " + "active threads: " +
-              std::to_string(_threadPool.getActiveThreadCount()) + "/" +
-              std::to_string(_threadPool.getTotalThreadCount()) + ")");
-        }
+      // Process request in thread pool to avoid blocking transport
+      // Use tryEnqueue for backpressure - reject requests if queue is full
+      if (!_threadPool.tryEnqueue([this, sid, requestData]()
+                                  { processHttpRequest(sid, requestData); }))
+      {
+        // Thread pool is overloaded, send 503 Service Unavailable
+        iora::core::Logger::warning(
+          "WebhookServer: Rejecting request due to thread pool overload "
+          "(queue: " +
+          std::to_string(_threadPool.getPendingTaskCount()) + "/" + std::to_string(1024) +
+          ", utilization: " + std::to_string(static_cast<int>(_threadPool.getQueueUtilization())) +
+          "%)");
+        sendErrorResponse(sid, 503, "Service Unavailable",
+                          "Server overloaded - please retry later");
+      }
+      else if (_threadPool.isUnderHighLoad())
+      {
+        // Log warning when approaching capacity
+        iora::core::Logger::warning(
+          "WebhookServer: High load detected (queue utilization: " +
+          std::to_string(static_cast<int>(_threadPool.getQueueUtilization())) + "%, " +
+          "active threads: " + std::to_string(_threadPool.getActiveThreadCount()) + "/" +
+          std::to_string(_threadPool.getTotalThreadCount()) + ")");
       }
     }
+  }
 
-    /// \brief Process a complete HTTP request
-    void processHttpRequest(SessionId sid, const std::string& requestData)
+  /// \brief Process a complete HTTP request
+  void processHttpRequest(SessionId sid, const std::string &requestData)
+  {
+    iora::core::Logger::debug("WebhookServer::processHttpRequest() - "
+                              "Processing request for session " +
+                              std::to_string(sid));
+
+    // Check if we're shutting down - with atomic read to avoid lock
+    if (_shutdown.load())
     {
       iora::core::Logger::debug("WebhookServer::processHttpRequest() - "
-                                "Processing request for session " +
+                                "Aborting due to shutdown for session " +
                                 std::to_string(sid));
 
-      // Check if we're shutting down - with atomic read to avoid lock
-      if (_shutdown.load())
+      // Send 503 Service Unavailable during shutdown
+      HttpResponse shutdownRes(503, "Service Unavailable");
+      shutdownRes.setHeader("Content-Type", "text/plain");
+      shutdownRes.body = "Server Shutting Down";
+      shutdownRes.setHeader("Content-Length", std::to_string(shutdownRes.body.size()));
+      shutdownRes.setHeader("Connection", "close");
+
+      auto shutdownResponseData = std::make_shared<std::string>(shutdownRes.toWireFormat());
       {
-        iora::core::Logger::debug("WebhookServer::processHttpRequest() - "
-                                  "Aborting due to shutdown for session " +
-                                  std::to_string(sid));
-
-        // Send 503 Service Unavailable during shutdown
-        HttpResponse shutdownRes(503, "Service Unavailable");
-        shutdownRes.setHeader("Content-Type", "text/plain");
-        shutdownRes.body = "Server Shutting Down";
-        shutdownRes.setHeader("Content-Length",
-                              std::to_string(shutdownRes.body.size()));
-        shutdownRes.setHeader("Connection", "close");
-
-        auto shutdownResponseData =
-            std::make_shared<std::string>(shutdownRes.toWireFormat());
+        std::lock_guard<std::mutex> lock(_mutex);
+        if (_transport)
         {
-          std::lock_guard<std::mutex> lock(_mutex);
-          if (_transport)
-          {
-            _transport->sendAsync(
-                sid, shutdownResponseData->data(), shutdownResponseData->size(),
-                [this, sid](SessionId session, const SyncResult& result)
-                {
-                  // Always close connection during shutdown
-                  std::lock_guard<std::mutex> lock(_mutex);
-                  if (_transport)
-                  {
-                    _transport->close(session);
-                  }
-                });
-          }
+          _transport->sendAsync(sid, shutdownResponseData->data(), shutdownResponseData->size(),
+                                [this, sid](SessionId session, const SyncResult &result)
+                                {
+                                  // Always close connection during shutdown
+                                  std::lock_guard<std::mutex> lock(_mutex);
+                                  if (_transport)
+                                  {
+                                    _transport->close(session);
+                                  }
+                                });
         }
-        return;
       }
+      return;
+    }
 
-      try
-      {
-        // Parse HTTP request
-        HttpRequest httpReq = HttpRequest::fromWireFormat(requestData);
+    try
+    {
+      // Parse HTTP request
+      HttpRequest httpReq = HttpRequest::fromWireFormat(requestData);
 
-        // Convert to our Request format
-        Request req;
-        req.method = httpReq.method;
-        req.path = httpReq.uri;
-        req.headers = httpReq.headers;
-        req.body = httpReq.body;
+      // Convert to our Request format
+      Request req;
+      req.method = httpReq.method;
+      req.path = httpReq.uri;
+      req.headers = httpReq.headers;
+      req.body = httpReq.body;
 
-        // Populate peer address information
+      // Populate peer address information
+      {
+        std::lock_guard<std::mutex> lock(_sessionMutex);
+        auto it = _sessionInfo.find(sid);
+        if (it != _sessionInfo.end())
         {
-          std::lock_guard<std::mutex> lock(_sessionMutex);
-          auto it = _sessionInfo.find(sid);
-          if (it != _sessionInfo.end())
-          {
-            req.remote_addr = it->second.peerAddress;
-            req.remote_port = it->second.peerPort;
-          }
+          req.remote_addr = it->second.peerAddress;
+          req.remote_port = it->second.peerPort;
         }
+      }
 
-        // Log the incoming HTTP request with full context
-        std::string methodStr;
-        switch (req.method)
-        {
-        case HttpMethod::GET:
-          methodStr = "GET";
-          break;
-        case HttpMethod::POST:
-          methodStr = "POST";
-          break;
-        case HttpMethod::DELETE:
-          methodStr = "DELETE";
-          break;
-        default:
-          methodStr = "UNKNOWN";
-          break;
-        }
+      // Log the incoming HTTP request with full context
+      std::string methodStr;
+      switch (req.method)
+      {
+      case HttpMethod::GET:
+        methodStr = "GET";
+        break;
+      case HttpMethod::POST:
+        methodStr = "POST";
+        break;
+      case HttpMethod::DELETE:
+        methodStr = "DELETE";
+        break;
+      default:
+        methodStr = "UNKNOWN";
+        break;
+      }
 
-        iora::core::Logger::info(
-            "WebhookServer: " + methodStr + " " + req.path + " from " +
-            req.remote_addr + ":" + std::to_string(req.remote_port) +
-            " (session " + std::to_string(sid) +
-            ", body size: " + std::to_string(req.body.size()) + " bytes)");
+      iora::core::Logger::info("WebhookServer: " + methodStr + " " + req.path + " from " +
+                               req.remote_addr + ":" + std::to_string(req.remote_port) +
+                               " (session " + std::to_string(sid) +
+                               ", body size: " + std::to_string(req.body.size()) + " bytes)");
 
-        // Extract path without query parameters
-        auto queryPos = req.path.find('?');
-        if (queryPos != std::string::npos)
+      // Extract path without query parameters
+      auto queryPos = req.path.find('?');
+      if (queryPos != std::string::npos)
+      {
+        // Parse query parameters
+        std::string queryString = req.path.substr(queryPos + 1);
+        req.path = req.path.substr(0, queryPos);
+
+        // Simple query parameter parsing
+        std::istringstream queryStream(queryString);
+        std::string param;
+        while (std::getline(queryStream, param, '&'))
         {
-          // Parse query parameters
-          std::string queryString = req.path.substr(queryPos + 1);
-          req.path = req.path.substr(0, queryPos);
-
-          // Simple query parameter parsing
-          std::istringstream queryStream(queryString);
-          std::string param;
-          while (std::getline(queryStream, param, '&'))
+          auto eqPos = param.find('=');
+          if (eqPos != std::string::npos)
           {
-            auto eqPos = param.find('=');
-            if (eqPos != std::string::npos)
-            {
-              std::string key = param.substr(0, eqPos);
-              std::string value = param.substr(eqPos + 1);
-              req.params[key] = value;
-            }
+            std::string key = param.substr(0, eqPos);
+            std::string value = param.substr(eqPos + 1);
+            req.params[key] = value;
           }
         }
+      }
 
-        // Create response
-        Response res;
-        res.status = 404;
-        res.set_content("Not Found", "text/plain");
+      // Create response
+      Response res;
+      res.status = 404;
+      res.set_content("Not Found", "text/plain");
 
-        // Find handler with proper HTTP status codes
-        {
-          std::lock_guard<std::mutex> lock(_mutex);
+      // Find handler with proper HTTP status codes
+      {
+        std::lock_guard<std::mutex> lock(_mutex);
 
-          // Check if path exists for any method (for 405 Method Not Allowed)
-          bool pathExists = false;
-          for (const auto& [method, pathHandlers] : _handlers)
+        // Check if path exists for any method (for 405 Method Not Allowed)
+        bool pathExists = false;
+        for (const auto &[method, pathHandlers] : _handlers)
+        {
+          if (pathHandlers.find(req.path) != pathHandlers.end())
           {
-            if (pathHandlers.find(req.path) != pathHandlers.end())
-            {
-              pathExists = true;
-              break;
-            }
+            pathExists = true;
+            break;
           }
+        }
 
-          auto methodIt = _handlers.find(httpReq.method);
-          if (methodIt != _handlers.end())
+        auto methodIt = _handlers.find(httpReq.method);
+        if (methodIt != _handlers.end())
+        {
+          auto handlerIt = methodIt->second.find(req.path);
+          if (handlerIt != methodIt->second.end())
           {
-            auto handlerIt = methodIt->second.find(req.path);
-            if (handlerIt != methodIt->second.end())
+            // Handler found - execute it
+            res.status = 200;
+            try
             {
-              // Handler found - execute it
-              res.status = 200;
-              try
-              {
-                handlerIt->second(req, res);
-              }
-              catch (const std::exception& e)
-              {
-                iora::core::Logger::error(
-                    "WebhookServer: Handler exception for " + req.path + ": " +
-                    e.what());
-                res.status = 500;
-                res.set_content("Internal Server Error", "text/plain");
-              }
+              handlerIt->second(req, res);
             }
-            else if (pathExists)
+            catch (const std::exception &e)
             {
-              // Path exists but method not allowed
-              res.status = 405;
-              res.set_content("Method Not Allowed", "text/plain");
-              res.headers["Allow"] = getAllowedMethods(req.path);
+              iora::core::Logger::error("WebhookServer: Handler exception for " + req.path + ": " +
+                                        e.what());
+              res.status = 500;
+              res.set_content("Internal Server Error", "text/plain");
             }
-            // else: 404 Not Found (default)
           }
           else if (pathExists)
           {
@@ -992,428 +922,412 @@ namespace network
           }
           // else: 404 Not Found (default)
         }
+        else if (pathExists)
+        {
+          // Path exists but method not allowed
+          res.status = 405;
+          res.set_content("Method Not Allowed", "text/plain");
+          res.headers["Allow"] = getAllowedMethods(req.path);
+        }
+        // else: 404 Not Found (default)
+      }
 
-        // Determine connection behavior
-        bool shouldCloseConnection = false;
-        std::string connectionHeader = "keep-alive";
+      // Determine connection behavior
+      bool shouldCloseConnection = false;
+      std::string connectionHeader = "keep-alive";
 
-        // Check for HTTP/1.0 or Connection: close
+      // Check for HTTP/1.0 or Connection: close
+      {
+        std::lock_guard<std::mutex> lock(_sessionMutex);
+        auto it = _sessionInfo.find(sid);
+        if (it != _sessionInfo.end())
         {
-          std::lock_guard<std::mutex> lock(_sessionMutex);
-          auto it = _sessionInfo.find(sid);
-          if (it != _sessionInfo.end())
+          if (it->second.httpVersion == "1.0")
           {
-            if (it->second.httpVersion == "1.0")
-            {
-              shouldCloseConnection = true;
-              connectionHeader = "close";
-            }
-            else if (!it->second.connectionKeepAlive)
-            {
-              shouldCloseConnection = true;
-              connectionHeader = "close";
-            }
+            shouldCloseConnection = true;
+            connectionHeader = "close";
           }
-        }
-
-        // Check request headers for connection preference
-        auto connectionIt = req.headers.find("Connection");
-        if (connectionIt != req.headers.end())
-        {
-          std::string connValue = connectionIt->second;
-          std::transform(connValue.begin(), connValue.end(), connValue.begin(),
-                         ::tolower);
-          if (connValue == "close")
+          else if (!it->second.connectionKeepAlive)
           {
             shouldCloseConnection = true;
             connectionHeader = "close";
           }
         }
+      }
 
-        // Build HTTP response
-        HttpResponse httpRes;
-        httpRes.statusCode = res.status;
-        httpRes.statusText = getStatusText(res.status);
-        httpRes.headers = res.headers;
-        httpRes.body = res.body;
+      // Check request headers for connection preference
+      auto connectionIt = req.headers.find("Connection");
+      if (connectionIt != req.headers.end())
+      {
+        std::string connValue = connectionIt->second;
+        std::transform(connValue.begin(), connValue.end(), connValue.begin(), ::tolower);
+        if (connValue == "close")
+        {
+          shouldCloseConnection = true;
+          connectionHeader = "close";
+        }
+      }
+
+      // Build HTTP response
+      HttpResponse httpRes;
+      httpRes.statusCode = res.status;
+      httpRes.statusText = getStatusText(res.status);
+      httpRes.headers = res.headers;
+      httpRes.body = res.body;
 
-        // Add server headers
-        httpRes.setHeader("Server", "Iora/1.0");
-        httpRes.setHeader("Connection", connectionHeader);
+      // Add server headers
+      httpRes.setHeader("Server", "Iora/1.0");
+      httpRes.setHeader("Connection", connectionHeader);
 
-        // Send response asynchronously but ensure proper completion
-        std::string responseData = httpRes.toWireFormat();
+      // Send response asynchronously but ensure proper completion
+      std::string responseData = httpRes.toWireFormat();
 
-        // Create a shared string to keep the data alive during async send
-        auto sharedResponseData =
-            std::make_shared<std::string>(std::move(responseData));
+      // Create a shared string to keep the data alive during async send
+      auto sharedResponseData = std::make_shared<std::string>(std::move(responseData));
 
-        // Check if transport is still available before sending
+      // Check if transport is still available before sending
+      {
+        std::lock_guard<std::mutex> lock(_mutex);
+        if (_transport && !_shutdown)
         {
-          std::lock_guard<std::mutex> lock(_mutex);
-          if (_transport && !_shutdown)
-          {
-            iora::core::Logger::info(
-                "WebhookServer: Sending " + std::to_string(res.status) +
-                " response to " + req.remote_addr + ":" +
-                std::to_string(req.remote_port) + " (session " +
-                std::to_string(sid) + ", " +
-                std::to_string(sharedResponseData->size()) + " bytes)");
-            _transport->sendAsync(
-                sid, sharedResponseData->data(), sharedResponseData->size(),
-                [this, sid, shouldCloseConnection, sharedResponseData](
-                    SessionId session, const SyncResult& result)
-                {
-                  if (!result.ok)
-                  {
-                    iora::core::Logger::error("Failed to send HTTP response: " +
-                                              result.errorMessage);
-                    // Close connection on send failure
-                    std::lock_guard<std::mutex> lock(_mutex);
-                    if (_transport && !_shutdown)
-                    {
-                      _transport->close(session);
-                    }
-                  }
-                  else
-                  {
-                    iora::core::Logger::debug("WebhookServer - HTTP response "
-                                              "sent successfully for session " +
-                                              std::to_string(session));
-                    // Close connection if requested
-                    if (shouldCloseConnection)
-                    {
-                      std::lock_guard<std::mutex> lock(_mutex);
-                      if (_transport && !_shutdown)
-                      {
-                        _transport->close(session);
-                      }
-                    }
-                  }
-                });
-          }
-          else
-          {
-            iora::core::Logger::debug(
-                "WebhookServer::processHttpRequest() - Skipping response send "
-                "(shutdown=" +
-                std::to_string(_shutdown) +
-                ", transport=" + std::to_string(_transport != nullptr) +
-                ") for session " + std::to_string(sid));
-          }
+          iora::core::Logger::info(
+            "WebhookServer: Sending " + std::to_string(res.status) + " response to " +
+            req.remote_addr + ":" + std::to_string(req.remote_port) + " (session " +
+            std::to_string(sid) + ", " + std::to_string(sharedResponseData->size()) + " bytes)");
+          _transport->sendAsync(sid, sharedResponseData->data(), sharedResponseData->size(),
+                                [this, sid, shouldCloseConnection,
+                                 sharedResponseData](SessionId session, const SyncResult &result)
+                                {
+                                  if (!result.ok)
+                                  {
+                                    iora::core::Logger::error("Failed to send HTTP response: " +
+                                                              result.errorMessage);
+                                    // Close connection on send failure
+                                    std::lock_guard<std::mutex> lock(_mutex);
+                                    if (_transport && !_shutdown)
+                                    {
+                                      _transport->close(session);
+                                    }
+                                  }
+                                  else
+                                  {
+                                    iora::core::Logger::debug("WebhookServer - HTTP response "
+                                                              "sent successfully for session " +
+                                                              std::to_string(session));
+                                    // Close connection if requested
+                                    if (shouldCloseConnection)
+                                    {
+                                      std::lock_guard<std::mutex> lock(_mutex);
+                                      if (_transport && !_shutdown)
+                                      {
+                                        _transport->close(session);
+                                      }
+                                    }
+                                  }
+                                });
         }
-        iora::core::Logger::debug("WebhookServer::processHttpRequest() - "
-                                  "Completed successfully for session " +
-                                  std::to_string(sid));
-      }
-      catch (const std::exception& ex)
-      {
-        iora::core::Logger::error("Error processing HTTP request: " +
-                                  std::string(ex.what()));
-
-        // Check if transport is still available before sending error response
+        else
         {
-          std::lock_guard<std::mutex> lock(_mutex);
-          if (_transport && !_shutdown)
-          {
-            iora::core::Logger::debug("WebhookServer::processHttpRequest() - "
-                                      "Sending error response for session " +
-                                      std::to_string(sid));
-
-            // Send error response
-            HttpResponse errorRes(500, "Internal Server Error");
-            errorRes.setHeader("Content-Type", "text/plain");
-            errorRes.body = "Internal Server Error";
-            errorRes.setHeader("Content-Length",
-                               std::to_string(errorRes.body.size()));
-
-            auto errorResponseData =
-                std::make_shared<std::string>(errorRes.toWireFormat());
-            _transport->sendAsync(
-                sid, errorResponseData->data(), errorResponseData->size(),
-                [this, sid, errorResponseData](SessionId session,
-                                               const SyncResult& result)
-                {
-                  // Close connection after error response is sent
-                  std::lock_guard<std::mutex> lock(_mutex);
-                  if (_transport && !_shutdown)
-                  {
-                    _transport->close(session);
-                  }
-                });
-          }
-          else
-          {
-            iora::core::Logger::debug(
-                "WebhookServer::processHttpRequest() - Skipping error response "
-                "send (shutdown=" +
-                std::to_string(_shutdown) + ") for session " +
-                std::to_string(sid));
-          }
+          iora::core::Logger::debug("WebhookServer::processHttpRequest() - Skipping response send "
+                                    "(shutdown=" +
+                                    std::to_string(_shutdown) +
+                                    ", transport=" + std::to_string(_transport != nullptr) +
+                                    ") for session " + std::to_string(sid));
         }
       }
-
-      iora::core::Logger::debug(
-          "WebhookServer::processHttpRequest() - Exiting for session " +
-          std::to_string(sid));
+      iora::core::Logger::debug("WebhookServer::processHttpRequest() - "
+                                "Completed successfully for session " +
+                                std::to_string(sid));
     }
-
-    /// \brief Find the end of a chunked request body
-    std::size_t findChunkedRequestEnd(const std::string& data,
-                                      std::size_t bodyStart) const
+    catch (const std::exception &ex)
     {
-      std::size_t pos = bodyStart;
+      iora::core::Logger::error("Error processing HTTP request: " + std::string(ex.what()));
 
-      while (pos < data.length())
+      // Check if transport is still available before sending error response
       {
-        // Find chunk size line
-        auto chunkSizeLine = data.find("\r\n", pos);
-        if (chunkSizeLine == std::string::npos)
+        std::lock_guard<std::mutex> lock(_mutex);
+        if (_transport && !_shutdown)
         {
-          return std::string::npos; // Need more data
-        }
+          iora::core::Logger::debug("WebhookServer::processHttpRequest() - "
+                                    "Sending error response for session " +
+                                    std::to_string(sid));
 
-        // Parse chunk size (hex)
-        std::string chunkSizeStr = data.substr(pos, chunkSizeLine - pos);
-        std::size_t chunkSize;
-        try
-        {
-          chunkSize = std::stoul(chunkSizeStr, nullptr, 16);
+          // Send error response
+          HttpResponse errorRes(500, "Internal Server Error");
+          errorRes.setHeader("Content-Type", "text/plain");
+          errorRes.body = "Internal Server Error";
+          errorRes.setHeader("Content-Length", std::to_string(errorRes.body.size()));
+
+          auto errorResponseData = std::make_shared<std::string>(errorRes.toWireFormat());
+          _transport->sendAsync(
+            sid, errorResponseData->data(), errorResponseData->size(),
+            [this, sid, errorResponseData](SessionId session, const SyncResult &result)
+            {
+              // Close connection after error response is sent
+              std::lock_guard<std::mutex> lock(_mutex);
+              if (_transport && !_shutdown)
+              {
+                _transport->close(session);
+              }
+            });
         }
-        catch (...)
+        else
         {
-          iora::core::Logger::error(
-              "WebhookServer: Invalid chunk size in chunked encoding");
-          return std::string::npos;
+          iora::core::Logger::debug("WebhookServer::processHttpRequest() - Skipping error response "
+                                    "send (shutdown=" +
+                                    std::to_string(_shutdown) + ") for session " +
+                                    std::to_string(sid));
         }
+      }
+    }
 
-        pos = chunkSizeLine + 2; // Skip \r\n
+    iora::core::Logger::debug("WebhookServer::processHttpRequest() - Exiting for session " +
+                              std::to_string(sid));
+  }
 
-        if (chunkSize == 0)
-        {
-          // Final chunk, look for final \r\n
-          auto finalCRLF = data.find("\r\n", pos);
-          if (finalCRLF == std::string::npos)
-          {
-            return std::string::npos; // Need more data
-          }
-          return finalCRLF + 2;
-        }
+  /// \brief Find the end of a chunked request body
+  std::size_t findChunkedRequestEnd(const std::string &data, std::size_t bodyStart) const
+  {
+    std::size_t pos = bodyStart;
 
-        // Skip chunk data + trailing \r\n
-        pos += chunkSize + 2;
-        if (pos > data.length())
-        {
-          return std::string::npos; // Need more data
-        }
+    while (pos < data.length())
+    {
+      // Find chunk size line
+      auto chunkSizeLine = data.find("\r\n", pos);
+      if (chunkSizeLine == std::string::npos)
+      {
+        return std::string::npos; // Need more data
       }
 
-      return std::string::npos;
-    }
+      // Parse chunk size (hex)
+      std::string chunkSizeStr = data.substr(pos, chunkSizeLine - pos);
+      std::size_t chunkSize;
+      try
+      {
+        chunkSize = std::stoul(chunkSizeStr, nullptr, 16);
+      }
+      catch (...)
+      {
+        iora::core::Logger::error("WebhookServer: Invalid chunk size in chunked encoding");
+        return std::string::npos;
+      }
 
-    /// \brief Get allowed methods for a path (for 405 responses)
-    std::string getAllowedMethods(const std::string& path) const
-    {
-      std::vector<std::string> methods;
+      pos = chunkSizeLine + 2; // Skip \r\n
 
-      for (const auto& [method, pathHandlers] : _handlers)
+      if (chunkSize == 0)
       {
-        if (pathHandlers.find(path) != pathHandlers.end())
+        // Final chunk, look for final \r\n
+        auto finalCRLF = data.find("\r\n", pos);
+        if (finalCRLF == std::string::npos)
         {
-          switch (method)
-          {
-          case HttpMethod::GET:
-            methods.push_back("GET");
-            break;
-          case HttpMethod::POST:
-            methods.push_back("POST");
-            break;
-          case HttpMethod::DELETE:
-            methods.push_back("DELETE");
-            break;
-          case HttpMethod::PUT:
-            methods.push_back("PUT");
-            break;
-          case HttpMethod::HEAD:
-            methods.push_back("HEAD");
-            break;
-          case HttpMethod::OPTIONS:
-            methods.push_back("OPTIONS");
-            break;
-          case HttpMethod::PATCH:
-            methods.push_back("PATCH");
-            break;
-          case HttpMethod::CONNECT:
-            methods.push_back("CONNECT");
-            break;
-          case HttpMethod::TRACE:
-            methods.push_back("TRACE");
-            break;
-          }
+          return std::string::npos; // Need more data
         }
+        return finalCRLF + 2;
       }
 
-      std::string result;
-      for (std::size_t i = 0; i < methods.size(); ++i)
+      // Skip chunk data + trailing \r\n
+      pos += chunkSize + 2;
+      if (pos > data.length())
       {
-        if (i > 0)
-          result += ", ";
-        result += methods[i];
+        return std::string::npos; // Need more data
       }
-
-      return result;
     }
 
-    /// \brief Get status text for HTTP status code
-    static std::string getStatusText(int code)
+    return std::string::npos;
+  }
+
+  /// \brief Get allowed methods for a path (for 405 responses)
+  std::string getAllowedMethods(const std::string &path) const
+  {
+    std::vector<std::string> methods;
+
+    for (const auto &[method, pathHandlers] : _handlers)
     {
-      switch (code)
+      if (pathHandlers.find(path) != pathHandlers.end())
       {
-      case 200:
-        return "OK";
-      case 201:
-        return "Created";
-      case 204:
-        return "No Content";
-      case 400:
-        return "Bad Request";
-      case 401:
-        return "Unauthorized";
-      case 403:
-        return "Forbidden";
-      case 404:
-        return "Not Found";
-      case 405:
-        return "Method Not Allowed";
-      case 413:
-        return "Payload Too Large";
-      case 500:
-        return "Internal Server Error";
-      case 501:
-        return "Not Implemented";
-      case 502:
-        return "Bad Gateway";
-      case 503:
-        return "Service Unavailable";
-      default:
-        return "Unknown";
+        switch (method)
+        {
+        case HttpMethod::GET:
+          methods.push_back("GET");
+          break;
+        case HttpMethod::POST:
+          methods.push_back("POST");
+          break;
+        case HttpMethod::DELETE:
+          methods.push_back("DELETE");
+          break;
+        case HttpMethod::PUT:
+          methods.push_back("PUT");
+          break;
+        case HttpMethod::HEAD:
+          methods.push_back("HEAD");
+          break;
+        case HttpMethod::OPTIONS:
+          methods.push_back("OPTIONS");
+          break;
+        case HttpMethod::PATCH:
+          methods.push_back("PATCH");
+          break;
+        case HttpMethod::CONNECT:
+          methods.push_back("CONNECT");
+          break;
+        case HttpMethod::TRACE:
+          methods.push_back("TRACE");
+          break;
+        }
       }
     }
 
-    /// \brief Send an error response with specified status code and message
-    void sendErrorResponse(SessionId sid, int statusCode,
-                           const std::string& statusText,
-                           const std::string& body = "")
+    std::string result;
+    for (std::size_t i = 0; i < methods.size(); ++i)
     {
-      try
-      {
-        HttpResponse errorRes(statusCode, statusText);
-        std::string responseBody = body.empty() ? statusText : body;
-        errorRes.setHeader("Content-Type", "text/plain");
-        errorRes.body = responseBody;
-        errorRes.setHeader("Content-Length",
-                           std::to_string(responseBody.size()));
-        errorRes.setHeader("Connection", "close");
-        errorRes.setHeader("Server", "Iora WebhookServer");
-
-        auto errorResponseData =
-            std::make_shared<std::string>(errorRes.toWireFormat());
+      if (i > 0)
+        result += ", ";
+      result += methods[i];
+    }
 
-        std::lock_guard<std::mutex> lock(_mutex);
-        if (_transport && !_shutdown)
-        {
-          iora::core::Logger::info(
-              "WebhookServer: Sending " + std::to_string(statusCode) + " " +
-              statusText + " response (session " + std::to_string(sid) + ", " +
-              std::to_string(errorResponseData->size()) + " bytes)");
-          _transport->sendAsync(
-              sid, errorResponseData->data(), errorResponseData->size(),
-              [this, sid, errorResponseData](SessionId session,
-                                             const SyncResult& result)
-              {
-                // Close connection after error response is sent
-                if (result.ok)
-                {
-                  iora::core::Logger::debug("WebhookServer: Error response "
-                                            "sent successfully to session " +
-                                            std::to_string(session));
-                }
-                else
-                {
-                  iora::core::Logger::error("WebhookServer: Failed to send "
-                                            "error response to session " +
-                                            std::to_string(session) + ": " +
-                                            result.errorMessage);
-                }
+    return result;
+  }
 
-                // Always close the connection after sending error response
-                _transport->close(session);
+  /// \brief Get status text for HTTP status code
+  static std::string getStatusText(int code)
+  {
+    switch (code)
+    {
+    case 200:
+      return "OK";
+    case 201:
+      return "Created";
+    case 204:
+      return "No Content";
+    case 400:
+      return "Bad Request";
+    case 401:
+      return "Unauthorized";
+    case 403:
+      return "Forbidden";
+    case 404:
+      return "Not Found";
+    case 405:
+      return "Method Not Allowed";
+    case 413:
+      return "Payload Too Large";
+    case 500:
+      return "Internal Server Error";
+    case 501:
+      return "Not Implemented";
+    case 502:
+      return "Bad Gateway";
+    case 503:
+      return "Service Unavailable";
+    default:
+      return "Unknown";
+    }
+  }
 
-                // Clean up session info
-                std::lock_guard<std::mutex> sessionLock(_sessionMutex);
-                _sessionInfo.erase(session);
-              });
-        }
-        else
-        {
-          iora::core::Logger::warning(
-              "WebhookServer: Cannot send error response to session " +
-              std::to_string(sid) +
-              " - transport unavailable or shutting down");
-        }
+  /// \brief Send an error response with specified status code and message
+  void sendErrorResponse(SessionId sid, int statusCode, const std::string &statusText,
+                         const std::string &body = "")
+  {
+    try
+    {
+      HttpResponse errorRes(statusCode, statusText);
+      std::string responseBody = body.empty() ? statusText : body;
+      errorRes.setHeader("Content-Type", "text/plain");
+      errorRes.body = responseBody;
+      errorRes.setHeader("Content-Length", std::to_string(responseBody.size()));
+      errorRes.setHeader("Connection", "close");
+      errorRes.setHeader("Server", "Iora WebhookServer");
+
+      auto errorResponseData = std::make_shared<std::string>(errorRes.toWireFormat());
+
+      std::lock_guard<std::mutex> lock(_mutex);
+      if (_transport && !_shutdown)
+      {
+        iora::core::Logger::info("WebhookServer: Sending " + std::to_string(statusCode) + " " +
+                                 statusText + " response (session " + std::to_string(sid) + ", " +
+                                 std::to_string(errorResponseData->size()) + " bytes)");
+        _transport->sendAsync(
+          sid, errorResponseData->data(), errorResponseData->size(),
+          [this, sid, errorResponseData](SessionId session, const SyncResult &result)
+          {
+            // Close connection after error response is sent
+            if (result.ok)
+            {
+              iora::core::Logger::debug("WebhookServer: Error response "
+                                        "sent successfully to session " +
+                                        std::to_string(session));
+            }
+            else
+            {
+              iora::core::Logger::error("WebhookServer: Failed to send "
+                                        "error response to session " +
+                                        std::to_string(session) + ": " + result.errorMessage);
+            }
+
+            // Always close the connection after sending error response
+            _transport->close(session);
+
+            // Clean up session info
+            std::lock_guard<std::mutex> sessionLock(_sessionMutex);
+            _sessionInfo.erase(session);
+          });
       }
-      catch (const std::exception& e)
+      else
       {
-        iora::core::Logger::error("WebhookServer: Exception while sending "
-                                  "error response to session " +
-                                  std::to_string(sid) + ": " + e.what());
-        // Force close the connection if error response fails
-        std::lock_guard<std::mutex> lock(_mutex);
-        if (_transport)
-        {
-          _transport->close(sid);
-        }
+        iora::core::Logger::warning("WebhookServer: Cannot send error response to session " +
+                                    std::to_string(sid) +
+                                    " - transport unavailable or shutting down");
       }
     }
+    catch (const std::exception &e)
+    {
+      iora::core::Logger::error("WebhookServer: Exception while sending "
+                                "error response to session " +
+                                std::to_string(sid) + ": " + e.what());
+      // Force close the connection if error response fails
+      std::lock_guard<std::mutex> lock(_mutex);
+      if (_transport)
+      {
+        _transport->close(sid);
+      }
+    }
+  }
 
-    mutable std::mutex _mutex;
-    mutable std::mutex _sessionMutex;
+  mutable std::mutex _mutex;
+  mutable std::mutex _sessionMutex;
 
-    int _port;
-    std::optional<TlsConfig> _tlsConfig;
-    std::unique_ptr<UnifiedSharedTransport> _transport;
-    ListenerId _listenerId{0};
-    std::atomic<bool> _shutdown;
-    JsonConfig _jsonConfig;
+  int _port;
+  std::optional<TlsConfig> _tlsConfig;
+  std::unique_ptr<UnifiedSharedTransport> _transport;
+  ListenerId _listenerId{0};
+  std::atomic<bool> _shutdown;
+  JsonConfig _jsonConfig;
 
-    // Thread pool for processing requests
-    core::ThreadPool _threadPool;
+  // Thread pool for processing requests
+  core::ThreadPool _threadPool;
 
-    // Session information tracking
-    struct SessionInfo
-    {
-      std::string buffer;
-      std::string peerAddress;
-      std::uint16_t peerPort = 0;
-      bool connectionKeepAlive = true;
-      std::string httpVersion = "1.1"; // Default to HTTP/1.1
-
-      // Buffer management constants
-      static constexpr std::size_t MAX_BUFFER_SIZE =
-          1024 * 1024; // 1MB max per session
-      static constexpr std::size_t MAX_HEADER_SIZE =
-          64 * 1024; // 64KB max headers
-      static constexpr std::size_t MAX_BODY_SIZE =
-          10 * 1024 * 1024; // 10MB max body
-    };
-
-    // Session tracking for incomplete requests and peer info
-    std::unordered_map<SessionId, SessionInfo> _sessionInfo;
-
-    // Handler storage: method -> path -> handler
-    std::unordered_map<HttpMethod, std::unordered_map<std::string, Handler>>
-        _handlers;
+  // Session information tracking
+  struct SessionInfo
+  {
+    std::string buffer;
+    std::string peerAddress;
+    std::uint16_t peerPort = 0;
+    bool connectionKeepAlive = true;
+    std::string httpVersion = "1.1"; // Default to HTTP/1.1
+
+    // Buffer management constants
+    static constexpr std::size_t MAX_BUFFER_SIZE = 1024 * 1024;    // 1MB max per session
+    static constexpr std::size_t MAX_HEADER_SIZE = 64 * 1024;      // 64KB max headers
+    static constexpr std::size_t MAX_BODY_SIZE = 10 * 1024 * 1024; // 10MB max body
   };
 
+  // Session tracking for incomplete requests and peer info
+  std::unordered_map<SessionId, SessionInfo> _sessionInfo;
+
+  // Handler storage: method -> path -> handler
+  std::unordered_map<HttpMethod, std::unordered_map<std::string, Handler>> _handlers;
+};
+
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/parsers/http_message.hpp b/include/iora/parsers/http_message.hpp
index 294a496..6777ffd 100644
--- a/include/iora/parsers/http_message.hpp
+++ b/include/iora/parsers/http_message.hpp
@@ -15,702 +15,668 @@
 /// dependencies like cpr and cpp-httplib with homegrown, integrated solutions.
 ///
 
-#include <string>
-#include <map>
-#include <vector>
-#include <unordered_map>
-#include <sstream>
 #include <algorithm>
 #include <cctype>
-#include <stdexcept>
-#include <fstream>
 #include <ctime>
+#include <fstream>
+#include <map>
 #include <random>
+#include <sstream>
+#include <stdexcept>
+#include <string>
+#include <unordered_map>
+#include <vector>
 
 namespace iora
 {
 namespace network
 {
 
-  /// \brief HTTP method enumeration
-  enum class HttpMethod
-  {
-    GET,
-    POST,
-    PUT,
-    DELETE,
-    HEAD,
-    OPTIONS,
-    PATCH,
-    CONNECT,
-    TRACE
-  };
-
-  /// \brief Convert HttpMethod to string
-  inline std::string toString(HttpMethod method)
+/// \brief HTTP method enumeration
+enum class HttpMethod
+{
+  GET,
+  POST,
+  PUT,
+  DELETE,
+  HEAD,
+  OPTIONS,
+  PATCH,
+  CONNECT,
+  TRACE
+};
+
+/// \brief Convert HttpMethod to string
+inline std::string toString(HttpMethod method)
+{
+  switch (method)
   {
-    switch (method)
-    {
-    case HttpMethod::GET:
-      return "GET";
-    case HttpMethod::POST:
-      return "POST";
-    case HttpMethod::PUT:
-      return "PUT";
-    case HttpMethod::DELETE:
-      return "DELETE";
-    case HttpMethod::HEAD:
-      return "HEAD";
-    case HttpMethod::OPTIONS:
-      return "OPTIONS";
-    case HttpMethod::PATCH:
-      return "PATCH";
-    case HttpMethod::CONNECT:
-      return "CONNECT";
-    case HttpMethod::TRACE:
-      return "TRACE";
-    default:
-      return "GET";
-    }
+  case HttpMethod::GET:
+    return "GET";
+  case HttpMethod::POST:
+    return "POST";
+  case HttpMethod::PUT:
+    return "PUT";
+  case HttpMethod::DELETE:
+    return "DELETE";
+  case HttpMethod::HEAD:
+    return "HEAD";
+  case HttpMethod::OPTIONS:
+    return "OPTIONS";
+  case HttpMethod::PATCH:
+    return "PATCH";
+  case HttpMethod::CONNECT:
+    return "CONNECT";
+  case HttpMethod::TRACE:
+    return "TRACE";
+  default:
+    return "GET";
   }
+}
 
-  /// \brief Convert string to HttpMethod
-  inline HttpMethod parseMethod(const std::string& method)
-  {
-    std::string upperMethod = method;
-    std::transform(upperMethod.begin(), upperMethod.end(), upperMethod.begin(),
-                   ::toupper);
-
-    if (upperMethod == "GET")
-      return HttpMethod::GET;
-    if (upperMethod == "POST")
-      return HttpMethod::POST;
-    if (upperMethod == "PUT")
-      return HttpMethod::PUT;
-    if (upperMethod == "DELETE")
-      return HttpMethod::DELETE;
-    if (upperMethod == "HEAD")
-      return HttpMethod::HEAD;
-    if (upperMethod == "OPTIONS")
-      return HttpMethod::OPTIONS;
-    if (upperMethod == "PATCH")
-      return HttpMethod::PATCH;
-    if (upperMethod == "CONNECT")
-      return HttpMethod::CONNECT;
-    if (upperMethod == "TRACE")
-      return HttpMethod::TRACE;
-
-    throw std::invalid_argument("Unknown HTTP method: " + method);
-  }
+/// \brief Convert string to HttpMethod
+inline HttpMethod parseMethod(const std::string &method)
+{
+  std::string upperMethod = method;
+  std::transform(upperMethod.begin(), upperMethod.end(), upperMethod.begin(), ::toupper);
+
+  if (upperMethod == "GET")
+    return HttpMethod::GET;
+  if (upperMethod == "POST")
+    return HttpMethod::POST;
+  if (upperMethod == "PUT")
+    return HttpMethod::PUT;
+  if (upperMethod == "DELETE")
+    return HttpMethod::DELETE;
+  if (upperMethod == "HEAD")
+    return HttpMethod::HEAD;
+  if (upperMethod == "OPTIONS")
+    return HttpMethod::OPTIONS;
+  if (upperMethod == "PATCH")
+    return HttpMethod::PATCH;
+  if (upperMethod == "CONNECT")
+    return HttpMethod::CONNECT;
+  if (upperMethod == "TRACE")
+    return HttpMethod::TRACE;
+
+  throw std::invalid_argument("Unknown HTTP method: " + method);
+}
+
+/// \brief HTTP version representation
+struct HttpVersion
+{
+  int major{1};
+  int minor{1};
 
-  /// \brief HTTP version representation
-  struct HttpVersion
+  std::string toString() const
   {
-    int major{1};
-    int minor{1};
+    return "HTTP/" + std::to_string(major) + "." + std::to_string(minor);
+  }
 
-    std::string toString() const
+  static HttpVersion parse(const std::string &version)
+  {
+    if (version.substr(0, 5) != "HTTP/")
     {
-      return "HTTP/" + std::to_string(major) + "." + std::to_string(minor);
+      throw std::invalid_argument("Invalid HTTP version format");
     }
 
-    static HttpVersion parse(const std::string& version)
+    auto dotPos = version.find('.', 5);
+    if (dotPos == std::string::npos)
     {
-      if (version.substr(0, 5) != "HTTP/")
-      {
-        throw std::invalid_argument("Invalid HTTP version format");
-      }
+      throw std::invalid_argument("Invalid HTTP version format");
+    }
 
-      auto dotPos = version.find('.', 5);
-      if (dotPos == std::string::npos)
-      {
-        throw std::invalid_argument("Invalid HTTP version format");
-      }
+    HttpVersion result;
+    result.major = std::stoi(version.substr(5, dotPos - 5));
+    result.minor = std::stoi(version.substr(dotPos + 1));
+    return result;
+  }
+};
 
-      HttpVersion result;
-      result.major = std::stoi(version.substr(5, dotPos - 5));
-      result.minor = std::stoi(version.substr(dotPos + 1));
-      return result;
-    }
-  };
+/// \brief Case-insensitive string comparison for headers
+struct CaseInsensitiveCompare
+{
+  bool operator()(const std::string &a, const std::string &b) const
+  {
+    return std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end(), [](char a, char b)
+                                        { return std::tolower(a) < std::tolower(b); });
+  }
+};
+
+/// \brief HTTP headers with case-insensitive keys
+using HttpHeaders = std::map<std::string, std::string, CaseInsensitiveCompare>;
 
-  /// \brief Case-insensitive string comparison for headers
-  struct CaseInsensitiveCompare
+/// \brief URL parsing structure
+struct ParsedUrl
+{
+  std::string scheme; // http, https
+  std::string host;
+  std::uint16_t port{0}; // 0 means use default for scheme
+  std::string path;
+  std::string query;
+  std::string fragment;
+
+  bool isHttps() const { return scheme == "https"; }
+  std::uint16_t getDefaultPort() const { return isHttps() ? 443 : 80; }
+  std::uint16_t getEffectivePort() const { return port == 0 ? getDefaultPort() : port; }
+
+  std::string getPathWithQuery() const
   {
-    bool operator()(const std::string& a, const std::string& b) const
+    std::string result = path.empty() ? "/" : path;
+    if (!query.empty())
     {
-      return std::lexicographical_compare(
-          a.begin(), a.end(), b.begin(), b.end(),
-          [](char a, char b) { return std::tolower(a) < std::tolower(b); });
+      result += "?" + query;
     }
-  };
+    return result;
+  }
+};
 
-  /// \brief HTTP headers with case-insensitive keys
-  using HttpHeaders =
-      std::map<std::string, std::string, CaseInsensitiveCompare>;
+/// \brief Parse URL into components
+inline ParsedUrl parseUrl(const std::string &url)
+{
+  ParsedUrl result;
 
-  /// \brief URL parsing structure
-  struct ParsedUrl
+  if (url.empty())
   {
-    std::string scheme; // http, https
-    std::string host;
-    std::uint16_t port{0}; // 0 means use default for scheme
-    std::string path;
-    std::string query;
-    std::string fragment;
+    throw std::invalid_argument("Empty URL");
+  }
 
-    bool isHttps() const { return scheme == "https"; }
-    std::uint16_t getDefaultPort() const { return isHttps() ? 443 : 80; }
-    std::uint16_t getEffectivePort() const
-    {
-      return port == 0 ? getDefaultPort() : port;
-    }
+  std::string remaining = url;
 
-    std::string getPathWithQuery() const
-    {
-      std::string result = path.empty() ? "/" : path;
-      if (!query.empty())
-      {
-        result += "?" + query;
-      }
-      return result;
-    }
-  };
-
-  /// \brief Parse URL into components
-  inline ParsedUrl parseUrl(const std::string& url)
+  // Extract scheme
+  auto schemeEnd = remaining.find("://");
+  if (schemeEnd != std::string::npos)
+  {
+    result.scheme = remaining.substr(0, schemeEnd);
+    std::transform(result.scheme.begin(), result.scheme.end(), result.scheme.begin(), ::tolower);
+    remaining = remaining.substr(schemeEnd + 3);
+  }
+  else
   {
-    ParsedUrl result;
+    throw std::invalid_argument("URL missing scheme (http:// or https://)");
+  }
 
-    if (url.empty())
-    {
-      throw std::invalid_argument("Empty URL");
-    }
+  // Extract fragment first (after #)
+  auto fragmentPos = remaining.find('#');
+  if (fragmentPos != std::string::npos)
+  {
+    result.fragment = remaining.substr(fragmentPos + 1);
+    remaining = remaining.substr(0, fragmentPos);
+  }
 
-    std::string remaining = url;
+  // Extract path and query
+  auto pathStart = remaining.find('/');
+  std::string hostPart;
+  if (pathStart != std::string::npos)
+  {
+    hostPart = remaining.substr(0, pathStart);
+    std::string pathPart = remaining.substr(pathStart);
 
-    // Extract scheme
-    auto schemeEnd = remaining.find("://");
-    if (schemeEnd != std::string::npos)
+    // Separate path and query
+    auto queryStart = pathPart.find('?');
+    if (queryStart != std::string::npos)
     {
-      result.scheme = remaining.substr(0, schemeEnd);
-      std::transform(result.scheme.begin(), result.scheme.end(),
-                     result.scheme.begin(), ::tolower);
-      remaining = remaining.substr(schemeEnd + 3);
+      result.path = pathPart.substr(0, queryStart);
+      result.query = pathPart.substr(queryStart + 1);
     }
     else
     {
-      throw std::invalid_argument("URL missing scheme (http:// or https://)");
+      result.path = pathPart;
     }
+  }
+  else
+  {
+    hostPart = remaining;
+    result.path = "/";
+  }
 
-    // Extract fragment first (after #)
-    auto fragmentPos = remaining.find('#');
-    if (fragmentPos != std::string::npos)
+  // Parse host and port
+  auto portPos = hostPart.find(':');
+  if (portPos != std::string::npos)
+  {
+    result.host = hostPart.substr(0, portPos);
+    std::string portStr = hostPart.substr(portPos + 1);
+    if (!portStr.empty())
     {
-      result.fragment = remaining.substr(fragmentPos + 1);
-      remaining = remaining.substr(0, fragmentPos);
+      result.port = static_cast<std::uint16_t>(std::stoi(portStr));
     }
+  }
+  else
+  {
+    result.host = hostPart;
+  }
 
-    // Extract path and query
-    auto pathStart = remaining.find('/');
-    std::string hostPart;
-    if (pathStart != std::string::npos)
-    {
-      hostPart = remaining.substr(0, pathStart);
-      std::string pathPart = remaining.substr(pathStart);
+  return result;
+}
 
-      // Separate path and query
-      auto queryStart = pathPart.find('?');
-      if (queryStart != std::string::npos)
-      {
-        result.path = pathPart.substr(0, queryStart);
-        result.query = pathPart.substr(queryStart + 1);
-      }
-      else
-      {
-        result.path = pathPart;
-      }
-    }
-    else
-    {
-      hostPart = remaining;
-      result.path = "/";
-    }
+/// \brief HTTP request message
+class HttpRequest
+{
+public:
+  HttpMethod method{HttpMethod::GET};
+  std::string uri; // Path + query string
+  HttpVersion version{1, 1};
+  HttpHeaders headers;
+  std::string body;
 
-    // Parse host and port
-    auto portPos = hostPart.find(':');
-    if (portPos != std::string::npos)
-    {
-      result.host = hostPart.substr(0, portPos);
-      std::string portStr = hostPart.substr(portPos + 1);
-      if (!portStr.empty())
-      {
-        result.port = static_cast<std::uint16_t>(std::stoi(portStr));
-      }
-    }
-    else
-    {
-      result.host = hostPart;
-    }
+  /// \brief Construct empty request
+  HttpRequest() = default;
 
-    return result;
-  }
+  /// \brief Construct request with method and URI
+  HttpRequest(HttpMethod m, const std::string &u) : method(m), uri(u) {}
 
-  /// \brief HTTP request message
-  class HttpRequest
+  /// \brief Get header value (case-insensitive)
+  std::string getHeader(const std::string &name) const
   {
-  public:
-    HttpMethod method{HttpMethod::GET};
-    std::string uri; // Path + query string
-    HttpVersion version{1, 1};
-    HttpHeaders headers;
-    std::string body;
+    auto it = headers.find(name);
+    return it != headers.end() ? it->second : std::string{};
+  }
 
-    /// \brief Construct empty request
-    HttpRequest() = default;
+  /// \brief Set header value (case-insensitive)
+  void setHeader(const std::string &name, const std::string &value) { headers[name] = value; }
 
-    /// \brief Construct request with method and URI
-    HttpRequest(HttpMethod m, const std::string& u) : method(m), uri(u) {}
+  /// \brief Check if header exists
+  bool hasHeader(const std::string &name) const { return headers.find(name) != headers.end(); }
 
-    /// \brief Get header value (case-insensitive)
-    std::string getHeader(const std::string& name) const
-    {
-      auto it = headers.find(name);
-      return it != headers.end() ? it->second : std::string{};
-    }
+  /// \brief Set content type and body
+  void setJsonBody(const std::string &jsonContent)
+  {
+    body = jsonContent;
+    setHeader("Content-Type", "application/json");
+    setHeader("Content-Length", std::to_string(body.size()));
+  }
 
-    /// \brief Set header value (case-insensitive)
-    void setHeader(const std::string& name, const std::string& value)
-    {
-      headers[name] = value;
-    }
+  /// \brief Set form data body
+  void setFormBody(const std::string &formContent)
+  {
+    body = formContent;
+    setHeader("Content-Type", "application/x-www-form-urlencoded");
+    setHeader("Content-Length", std::to_string(body.size()));
+  }
 
-    /// \brief Check if header exists
-    bool hasHeader(const std::string& name) const
-    {
-      return headers.find(name) != headers.end();
-    }
+  /// \brief Convert to HTTP wire format
+  std::string toWireFormat() const
+  {
+    std::ostringstream ss;
 
-    /// \brief Set content type and body
-    void setJsonBody(const std::string& jsonContent)
-    {
-      body = jsonContent;
-      setHeader("Content-Type", "application/json");
-      setHeader("Content-Length", std::to_string(body.size()));
-    }
+    // Request line
+    ss << toString(method) << " " << uri << " " << version.toString() << "\r\n";
 
-    /// \brief Set form data body
-    void setFormBody(const std::string& formContent)
+    // Headers
+    for (const auto &[key, value] : headers)
     {
-      body = formContent;
-      setHeader("Content-Type", "application/x-www-form-urlencoded");
-      setHeader("Content-Length", std::to_string(body.size()));
+      ss << key << ": " << value << "\r\n";
     }
 
-    /// \brief Convert to HTTP wire format
-    std::string toWireFormat() const
-    {
-      std::ostringstream ss;
+    ss << "\r\n"; // End of headers
 
-      // Request line
-      ss << toString(method) << " " << uri << " " << version.toString()
-         << "\r\n";
+    // Body
+    ss << body;
 
-      // Headers
-      for (const auto& [key, value] : headers)
-      {
-        ss << key << ": " << value << "\r\n";
-      }
-
-      ss << "\r\n"; // End of headers
+    return ss.str();
+  }
 
-      // Body
-      ss << body;
+  /// \brief Parse request from wire format
+  static HttpRequest fromWireFormat(const std::string &data)
+  {
+    HttpRequest request;
 
-      return ss.str();
+    auto headerEnd = data.find("\r\n\r\n");
+    if (headerEnd == std::string::npos)
+    {
+      throw std::invalid_argument("Invalid HTTP request: missing header terminator");
     }
 
-    /// \brief Parse request from wire format
-    static HttpRequest fromWireFormat(const std::string& data)
-    {
-      HttpRequest request;
+    std::string headerSection = data.substr(0, headerEnd);
+    request.body = data.substr(headerEnd + 4);
+
+    std::istringstream headerStream(headerSection);
+    std::string line;
+    bool firstLine = true;
 
-      auto headerEnd = data.find("\r\n\r\n");
-      if (headerEnd == std::string::npos)
+    while (std::getline(headerStream, line))
+    {
+      // Remove \r if present
+      if (!line.empty() && line.back() == '\r')
       {
-        throw std::invalid_argument(
-            "Invalid HTTP request: missing header terminator");
+        line.pop_back();
       }
 
-      std::string headerSection = data.substr(0, headerEnd);
-      request.body = data.substr(headerEnd + 4);
-
-      std::istringstream headerStream(headerSection);
-      std::string line;
-      bool firstLine = true;
-
-      while (std::getline(headerStream, line))
+      if (firstLine)
       {
-        // Remove \r if present
-        if (!line.empty() && line.back() == '\r')
-        {
-          line.pop_back();
-        }
-
-        if (firstLine)
-        {
-          parseRequestLine(line, request);
-          firstLine = false;
-        }
-        else if (!line.empty())
-        {
-          parseHeaderLine(line, request.headers);
-        }
+        parseRequestLine(line, request);
+        firstLine = false;
+      }
+      else if (!line.empty())
+      {
+        parseHeaderLine(line, request.headers);
       }
-
-      return request;
     }
 
-  private:
-    static void parseRequestLine(const std::string& line, HttpRequest& request)
-    {
-      std::istringstream iss(line);
-      std::string methodStr, versionStr;
-      iss >> methodStr >> request.uri >> versionStr;
+    return request;
+  }
 
-      request.method = parseMethod(methodStr);
-      request.version = HttpVersion::parse(versionStr);
-    }
+private:
+  static void parseRequestLine(const std::string &line, HttpRequest &request)
+  {
+    std::istringstream iss(line);
+    std::string methodStr, versionStr;
+    iss >> methodStr >> request.uri >> versionStr;
+
+    request.method = parseMethod(methodStr);
+    request.version = HttpVersion::parse(versionStr);
+  }
 
-    static void parseHeaderLine(const std::string& line, HttpHeaders& headers)
+  static void parseHeaderLine(const std::string &line, HttpHeaders &headers)
+  {
+    auto colonPos = line.find(':');
+    if (colonPos != std::string::npos)
     {
-      auto colonPos = line.find(':');
-      if (colonPos != std::string::npos)
-      {
-        std::string key = line.substr(0, colonPos);
-        std::string value = line.substr(colonPos + 1);
+      std::string key = line.substr(0, colonPos);
+      std::string value = line.substr(colonPos + 1);
 
-        // Trim whitespace
-        key.erase(0, key.find_first_not_of(" \t"));
-        key.erase(key.find_last_not_of(" \t") + 1);
-        value.erase(0, value.find_first_not_of(" \t"));
-        value.erase(value.find_last_not_of(" \t") + 1);
+      // Trim whitespace
+      key.erase(0, key.find_first_not_of(" \t"));
+      key.erase(key.find_last_not_of(" \t") + 1);
+      value.erase(0, value.find_first_not_of(" \t"));
+      value.erase(value.find_last_not_of(" \t") + 1);
 
-        headers[key] = value;
-      }
+      headers[key] = value;
     }
-  };
+  }
+};
 
-  /// \brief HTTP response message
-  class HttpResponse
-  {
-  public:
-    HttpVersion version{1, 1};
-    int statusCode{200};
-    std::string statusText{"OK"};
-    HttpHeaders headers;
-    std::string body;
+/// \brief HTTP response message
+class HttpResponse
+{
+public:
+  HttpVersion version{1, 1};
+  int statusCode{200};
+  std::string statusText{"OK"};
+  HttpHeaders headers;
+  std::string body;
 
-    /// \brief Construct empty response
-    HttpResponse() = default;
+  /// \brief Construct empty response
+  HttpResponse() = default;
 
-    /// \brief Construct response with status
-    HttpResponse(int code, const std::string& text = "")
-      : statusCode(code), statusText(text)
-    {
-    }
+  /// \brief Construct response with status
+  HttpResponse(int code, const std::string &text = "") : statusCode(code), statusText(text) {}
 
-    /// \brief Check if response indicates success
-    bool isSuccess() const { return statusCode >= 200 && statusCode < 300; }
+  /// \brief Check if response indicates success
+  bool isSuccess() const { return statusCode >= 200 && statusCode < 300; }
 
-    /// \brief Check if response is informational
-    bool isInformational() const
-    {
-      return statusCode >= 100 && statusCode < 200;
-    }
+  /// \brief Check if response is informational
+  bool isInformational() const { return statusCode >= 100 && statusCode < 200; }
 
-    /// \brief Check if response is redirection
-    bool isRedirection() const { return statusCode >= 300 && statusCode < 400; }
+  /// \brief Check if response is redirection
+  bool isRedirection() const { return statusCode >= 300 && statusCode < 400; }
 
-    /// \brief Check if response is client error
-    bool isClientError() const { return statusCode >= 400 && statusCode < 500; }
+  /// \brief Check if response is client error
+  bool isClientError() const { return statusCode >= 400 && statusCode < 500; }
 
-    /// \brief Check if response is server error
-    bool isServerError() const { return statusCode >= 500 && statusCode < 600; }
+  /// \brief Check if response is server error
+  bool isServerError() const { return statusCode >= 500 && statusCode < 600; }
 
-    /// \brief Get header value (case-insensitive)
-    std::string getHeader(const std::string& name) const
-    {
-      auto it = headers.find(name);
-      return it != headers.end() ? it->second : std::string{};
-    }
+  /// \brief Get header value (case-insensitive)
+  std::string getHeader(const std::string &name) const
+  {
+    auto it = headers.find(name);
+    return it != headers.end() ? it->second : std::string{};
+  }
 
-    /// \brief Set header value
-    void setHeader(const std::string& name, const std::string& value)
-    {
-      headers[name] = value;
-    }
+  /// \brief Set header value
+  void setHeader(const std::string &name, const std::string &value) { headers[name] = value; }
 
-    /// \brief Check if header exists
-    bool hasHeader(const std::string& name) const
-    {
-      return headers.find(name) != headers.end();
-    }
+  /// \brief Check if header exists
+  bool hasHeader(const std::string &name) const { return headers.find(name) != headers.end(); }
+
+  /// \brief Set JSON response body
+  void setJsonBody(const std::string &jsonContent)
+  {
+    body = jsonContent;
+    setHeader("Content-Type", "application/json");
+    setHeader("Content-Length", std::to_string(body.size()));
+  }
+
+  /// \brief Convert to HTTP wire format
+  std::string toWireFormat() const
+  {
+    std::ostringstream ss;
 
-    /// \brief Set JSON response body
-    void setJsonBody(const std::string& jsonContent)
+    // Status line
+    ss << version.toString() << " " << statusCode << " " << statusText << "\r\n";
+
+    // Headers
+    for (const auto &[key, value] : headers)
     {
-      body = jsonContent;
-      setHeader("Content-Type", "application/json");
-      setHeader("Content-Length", std::to_string(body.size()));
+      ss << key << ": " << value << "\r\n";
     }
 
-    /// \brief Convert to HTTP wire format
-    std::string toWireFormat() const
-    {
-      std::ostringstream ss;
+    ss << "\r\n"; // End of headers
 
-      // Status line
-      ss << version.toString() << " " << statusCode << " " << statusText
-         << "\r\n";
+    // Body
+    ss << body;
 
-      // Headers
-      for (const auto& [key, value] : headers)
-      {
-        ss << key << ": " << value << "\r\n";
-      }
-
-      ss << "\r\n"; // End of headers
+    return ss.str();
+  }
 
-      // Body
-      ss << body;
+  /// \brief Parse response from wire format
+  static HttpResponse fromWireFormat(const std::string &data)
+  {
+    HttpResponse response;
 
-      return ss.str();
+    auto headerEnd = data.find("\r\n\r\n");
+    if (headerEnd == std::string::npos)
+    {
+      throw std::invalid_argument("Invalid HTTP response: missing header terminator");
     }
 
-    /// \brief Parse response from wire format
-    static HttpResponse fromWireFormat(const std::string& data)
-    {
-      HttpResponse response;
+    std::string headerSection = data.substr(0, headerEnd);
+    response.body = data.substr(headerEnd + 4);
+
+    std::istringstream headerStream(headerSection);
+    std::string line;
+    bool firstLine = true;
 
-      auto headerEnd = data.find("\r\n\r\n");
-      if (headerEnd == std::string::npos)
+    while (std::getline(headerStream, line))
+    {
+      // Remove \r if present
+      if (!line.empty() && line.back() == '\r')
       {
-        throw std::invalid_argument(
-            "Invalid HTTP response: missing header terminator");
+        line.pop_back();
       }
 
-      std::string headerSection = data.substr(0, headerEnd);
-      response.body = data.substr(headerEnd + 4);
-
-      std::istringstream headerStream(headerSection);
-      std::string line;
-      bool firstLine = true;
-
-      while (std::getline(headerStream, line))
+      if (firstLine)
       {
-        // Remove \r if present
-        if (!line.empty() && line.back() == '\r')
-        {
-          line.pop_back();
-        }
-
-        if (firstLine)
-        {
-          parseStatusLine(line, response);
-          firstLine = false;
-        }
-        else if (!line.empty())
-        {
-          parseHeaderLine(line, response.headers);
-        }
+        parseStatusLine(line, response);
+        firstLine = false;
       }
-
-      // Handle chunked transfer encoding
-      auto transferEncoding = response.getHeader("transfer-encoding");
-      if (transferEncoding.find("chunked") != std::string::npos)
+      else if (!line.empty())
       {
-        response.body = parseChunkedBody(response.body);
+        parseHeaderLine(line, response.headers);
       }
-
-      return response;
     }
 
-  private:
-    static void parseStatusLine(const std::string& line, HttpResponse& response)
+    // Handle chunked transfer encoding
+    auto transferEncoding = response.getHeader("transfer-encoding");
+    if (transferEncoding.find("chunked") != std::string::npos)
     {
-      std::istringstream iss(line);
-      std::string version;
-      iss >> version >> response.statusCode;
+      response.body = parseChunkedBody(response.body);
+    }
 
-      // Get rest of line as status text
-      std::string remaining;
-      std::getline(iss, remaining);
-      response.statusText =
-          remaining.empty() ? "" : remaining.substr(1); // Remove leading space
+    return response;
+  }
 
-      response.version = HttpVersion::parse(version);
-    }
+private:
+  static void parseStatusLine(const std::string &line, HttpResponse &response)
+  {
+    std::istringstream iss(line);
+    std::string version;
+    iss >> version >> response.statusCode;
+
+    // Get rest of line as status text
+    std::string remaining;
+    std::getline(iss, remaining);
+    response.statusText = remaining.empty() ? "" : remaining.substr(1); // Remove leading space
 
-    static void parseHeaderLine(const std::string& line, HttpHeaders& headers)
+    response.version = HttpVersion::parse(version);
+  }
+
+  static void parseHeaderLine(const std::string &line, HttpHeaders &headers)
+  {
+    auto colonPos = line.find(':');
+    if (colonPos != std::string::npos)
     {
-      auto colonPos = line.find(':');
-      if (colonPos != std::string::npos)
-      {
-        std::string key = line.substr(0, colonPos);
-        std::string value = line.substr(colonPos + 1);
+      std::string key = line.substr(0, colonPos);
+      std::string value = line.substr(colonPos + 1);
 
-        // Trim whitespace
-        key.erase(0, key.find_first_not_of(" \t"));
-        key.erase(key.find_last_not_of(" \t") + 1);
-        value.erase(0, value.find_first_not_of(" \t"));
-        value.erase(value.find_last_not_of(" \t") + 1);
+      // Trim whitespace
+      key.erase(0, key.find_first_not_of(" \t"));
+      key.erase(key.find_last_not_of(" \t") + 1);
+      value.erase(0, value.find_first_not_of(" \t"));
+      value.erase(value.find_last_not_of(" \t") + 1);
 
-        headers[key] = value;
-      }
+      headers[key] = value;
     }
+  }
 
-    static std::string parseChunkedBody(const std::string& chunkedData)
-    {
-      std::string result;
-      std::istringstream stream(chunkedData);
-      std::string line;
+  static std::string parseChunkedBody(const std::string &chunkedData)
+  {
+    std::string result;
+    std::istringstream stream(chunkedData);
+    std::string line;
 
-      while (std::getline(stream, line))
+    while (std::getline(stream, line))
+    {
+      // Remove \r if present
+      if (!line.empty() && line.back() == '\r')
       {
-        // Remove \r if present
-        if (!line.empty() && line.back() == '\r')
-        {
-          line.pop_back();
-        }
-
-        if (line.empty())
-          continue;
-
-        // Parse chunk size (hex)
-        std::size_t chunkSize;
-        try
-        {
-          chunkSize = std::stoull(line, nullptr, 16);
-        }
-        catch (...)
-        {
-          break; // Invalid chunk size
-        }
-
-        if (chunkSize == 0)
-        {
-          // End of chunks
-          break;
-        }
-
-        // Read chunk data
-        std::vector<char> chunkData(chunkSize);
-        stream.read(chunkData.data(), chunkSize);
-        std::streamsize bytesRead = stream.gcount();
-        result.append(chunkData.begin(), chunkData.begin() + bytesRead);
-
-        // Skip trailing CRLF after chunk data
-        std::getline(stream, line);
+        line.pop_back();
       }
 
-      return result;
-    }
-  };
+      if (line.empty())
+        continue;
 
-  /// \brief Multipart form data builder
-  class MultipartFormData
-  {
-  public:
-    struct Part
-    {
-      std::string name;
-      std::string filename;
-      std::string contentType;
-      std::string content;
-    };
-
-  private:
-    std::vector<Part> _parts;
-    std::string _boundary;
-
-  public:
-    MultipartFormData()
-    {
-      // Generate random boundary
-      std::random_device rd;
-      std::mt19937 gen(rd());
-      std::uniform_int_distribution<> dis(0, 15);
+      // Parse chunk size (hex)
+      std::size_t chunkSize;
+      try
+      {
+        chunkSize = std::stoull(line, nullptr, 16);
+      }
+      catch (...)
+      {
+        break; // Invalid chunk size
+      }
 
-      _boundary = "----IoraBoundary";
-      for (int i = 0; i < 16; ++i)
+      if (chunkSize == 0)
       {
-        _boundary += "0123456789abcdef"[dis(gen)];
+        // End of chunks
+        break;
       }
-    }
 
-    /// \brief Add text field
-    void addField(const std::string& name, const std::string& value)
-    {
-      Part part;
-      part.name = name;
-      part.content = value;
-      _parts.push_back(part);
-    }
+      // Read chunk data
+      std::vector<char> chunkData(chunkSize);
+      stream.read(chunkData.data(), chunkSize);
+      std::streamsize bytesRead = stream.gcount();
+      result.append(chunkData.begin(), chunkData.begin() + bytesRead);
 
-    /// \brief Add file field
-    void addFile(const std::string& name, const std::string& filename,
-                 const std::string& content,
-                 const std::string& contentType = "application/octet-stream")
-    {
-      Part part;
-      part.name = name;
-      part.filename = filename;
-      part.contentType = contentType;
-      part.content = content;
-      _parts.push_back(part);
+      // Skip trailing CRLF after chunk data
+      std::getline(stream, line);
     }
 
-    /// \brief Get boundary string
-    std::string getBoundary() const { return _boundary; }
+    return result;
+  }
+};
 
-    /// \brief Get content type header value
-    std::string getContentType() const
+/// \brief Multipart form data builder
+class MultipartFormData
+{
+public:
+  struct Part
+  {
+    std::string name;
+    std::string filename;
+    std::string contentType;
+    std::string content;
+  };
+
+private:
+  std::vector<Part> _parts;
+  std::string _boundary;
+
+public:
+  MultipartFormData()
+  {
+    // Generate random boundary
+    std::random_device rd;
+    std::mt19937 gen(rd());
+    std::uniform_int_distribution<> dis(0, 15);
+
+    _boundary = "----IoraBoundary";
+    for (int i = 0; i < 16; ++i)
     {
-      return "multipart/form-data; boundary=" + _boundary;
+      _boundary += "0123456789abcdef"[dis(gen)];
     }
+  }
 
-    /// \brief Build multipart body
-    std::string build() const
-    {
-      std::ostringstream body;
+  /// \brief Add text field
+  void addField(const std::string &name, const std::string &value)
+  {
+    Part part;
+    part.name = name;
+    part.content = value;
+    _parts.push_back(part);
+  }
 
-      for (const auto& part : _parts)
-      {
-        body << "--" << _boundary << "\r\n";
-        body << "Content-Disposition: form-data; name=\"" << part.name << "\"";
+  /// \brief Add file field
+  void addFile(const std::string &name, const std::string &filename, const std::string &content,
+               const std::string &contentType = "application/octet-stream")
+  {
+    Part part;
+    part.name = name;
+    part.filename = filename;
+    part.contentType = contentType;
+    part.content = content;
+    _parts.push_back(part);
+  }
 
-        if (!part.filename.empty())
-        {
-          body << "; filename=\"" << part.filename << "\"";
-        }
+  /// \brief Get boundary string
+  std::string getBoundary() const { return _boundary; }
 
-        body << "\r\n";
+  /// \brief Get content type header value
+  std::string getContentType() const { return "multipart/form-data; boundary=" + _boundary; }
 
-        if (!part.contentType.empty())
-        {
-          body << "Content-Type: " << part.contentType << "\r\n";
-        }
+  /// \brief Build multipart body
+  std::string build() const
+  {
+    std::ostringstream body;
 
-        body << "\r\n";
-        body << part.content << "\r\n";
+    for (const auto &part : _parts)
+    {
+      body << "--" << _boundary << "\r\n";
+      body << "Content-Disposition: form-data; name=\"" << part.name << "\"";
+
+      if (!part.filename.empty())
+      {
+        body << "; filename=\"" << part.filename << "\"";
       }
 
-      body << "--" << _boundary << "--\r\n";
+      body << "\r\n";
 
-      return body.str();
+      if (!part.contentType.empty())
+      {
+        body << "Content-Type: " << part.contentType << "\r\n";
+      }
+
+      body << "\r\n";
+      body << part.content << "\r\n";
     }
-  };
+
+    body << "--" << _boundary << "--\r\n";
+
+    return body.str();
+  }
+};
 
 } // namespace network
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/parsers/json.hpp b/include/iora/parsers/json.hpp
index 918bad9..3d5ee25 100644
--- a/include/iora/parsers/json.hpp
+++ b/include/iora/parsers/json.hpp
@@ -29,1735 +29,1567 @@
 ///   SerializeOptions::sortKeys for stable output order.
 ///
 
+#include <algorithm>
 #include <cctype>
+#include <cerrno>
+#include <charconv>
+#include <cmath>
 #include <cstdint>
 #include <cstdlib>
-#include <cmath>
 #include <cstring>
-#include <cerrno>
+#include <functional>
+#include <iostream>
 #include <limits>
+#include <new>
 #include <optional>
 #include <stdexcept>
 #include <string>
 #include <string_view>
+#include <type_traits>
 #include <unordered_map>
 #include <utility>
 #include <variant>
 #include <vector>
-#include <algorithm>
-#include <charconv>
-#include <type_traits>
-#include <new>
-#include <iostream>
-#include <functional>
 
 namespace iora
 {
 namespace parsers
 {
-  /// \brief JSON type tags.
-  enum class JsonType
-  {
-    Null,
-    Boolean,
-    Int,
-    Double,
-    String,
-    Array,
-    Object
-  };
+/// \brief JSON type tags.
+enum class JsonType
+{
+  Null,
+  Boolean,
+  Int,
+  Double,
+  String,
+  Array,
+  Object
+};
+
+/// \brief Location of a parse error in the source text.
+struct JsonLocation
+{
+  std::size_t offset{0};
+  std::size_t line{1};
+  std::size_t column{1};
+};
 
-  /// \brief Location of a parse error in the source text.
-  struct JsonLocation
-  {
-    std::size_t offset{0};
-    std::size_t line{1};
-    std::size_t column{1};
-  };
+/// \brief Error information produced by the parser.
+struct JsonError
+{
+  std::string message;
+  JsonLocation where;
+};
 
-  /// \brief Error information produced by the parser.
-  struct JsonError
-  {
-    std::string message;
-    JsonLocation where;
-  };
+/// \brief Parse limits to prevent resource exhaustion.
+struct ParseLimits
+{
+  std::size_t arrayItemsMax{10000};     ///< Maximum array elements
+  std::size_t membersMax{10000};        ///< Maximum object members
+  std::size_t depthMax{100};            ///< Maximum nesting depth
+  std::size_t stringLengthMax{1000000}; ///< Maximum string length
+};
+
+/// \brief Serialization options.
+struct SerializeOptions
+{
+  bool pretty{false};       ///< Pretty-print with indentation
+  bool sortKeys{false};     ///< Sort object keys alphabetically
+  std::string indent{"  "}; ///< Indentation string for pretty printing
+};
+
+class Json; // forward declaration
+
+// =============================================================
+// SmallVec: small-buffer vector for arrays
+// =============================================================
+/// \brief Small-vector with inline capacity to avoid heap allocs for small
+/// arrays.
+template <typename T, std::size_t InlineN> class SmallVec
+{
+public:
+  SmallVec() : _data(reinterpret_cast<T *>(_inline)), _capacity(InlineN) {}
 
-  /// \brief Parse limits to prevent resource exhaustion.
-  struct ParseLimits
+  SmallVec(const SmallVec &other) : _data(reinterpret_cast<T *>(_inline)), _capacity(InlineN)
   {
-    std::size_t arrayItemsMax{10000};     ///< Maximum array elements
-    std::size_t membersMax{10000};        ///< Maximum object members
-    std::size_t depthMax{100};            ///< Maximum nesting depth
-    std::size_t stringLengthMax{1000000}; ///< Maximum string length
-  };
+    _copyFrom(other);
+  }
 
-  /// \brief Serialization options.
-  struct SerializeOptions
+  SmallVec(SmallVec &&other) noexcept : _data(reinterpret_cast<T *>(_inline)), _capacity(InlineN)
   {
-    bool pretty{false};       ///< Pretty-print with indentation
-    bool sortKeys{false};     ///< Sort object keys alphabetically
-    std::string indent{"  "}; ///< Indentation string for pretty printing
-  };
-
-  class Json; // forward declaration
+    _moveFrom(std::move(other));
+  }
 
-  // =============================================================
-  // SmallVec: small-buffer vector for arrays
-  // =============================================================
-  /// \brief Small-vector with inline capacity to avoid heap allocs for small
-  /// arrays.
-  template <typename T, std::size_t InlineN> class SmallVec
+  ~SmallVec()
   {
-  public:
-    SmallVec() : _data(reinterpret_cast<T*>(_inline)), _capacity(InlineN) {}
-
-    SmallVec(const SmallVec& other)
-      : _data(reinterpret_cast<T*>(_inline)), _capacity(InlineN)
+    _clear();
+    if (_heap)
     {
-      _copyFrom(other);
+      delete[] _data;
     }
+  }
 
-    SmallVec(SmallVec&& other) noexcept
-      : _data(reinterpret_cast<T*>(_inline)), _capacity(InlineN)
+  SmallVec &operator=(const SmallVec &other)
+  {
+    if (this != &other)
     {
-      _moveFrom(std::move(other));
+      _clear();
+      _copyFrom(other);
     }
+    return *this;
+  }
 
-    ~SmallVec()
+  SmallVec &operator=(SmallVec &&other) noexcept
+  {
+    if (this != &other)
     {
       _clear();
       if (_heap)
       {
         delete[] _data;
       }
+      _data = reinterpret_cast<T *>(_inline);
+      _capacity = InlineN;
+      _heap = false;
+      _moveFrom(std::move(other));
     }
+    return *this;
+  }
 
-    SmallVec& operator=(const SmallVec& other)
-    {
-      if (this != &other)
-      {
-        _clear();
-        _copyFrom(other);
-      }
-      return *this;
-    }
+  void push_back(const T &value)
+  {
+    _ensureCapacity(_size + 1);
+    new (_data + _size) T(value);
+    ++_size;
+  }
 
-    SmallVec& operator=(SmallVec&& other) noexcept
-    {
-      if (this != &other)
-      {
-        _clear();
-        if (_heap)
-        {
-          delete[] _data;
-        }
-        _data = reinterpret_cast<T*>(_inline);
-        _capacity = InlineN;
-        _heap = false;
-        _moveFrom(std::move(other));
-      }
-      return *this;
-    }
+  void push_back(T &&value)
+  {
+    _ensureCapacity(_size + 1);
+    new (_data + _size) T(std::move(value));
+    ++_size;
+  }
+
+  template <typename... Args> void emplace_back(Args &&...args)
+  {
+    _ensureCapacity(_size + 1);
+    new (_data + _size) T(std::forward<Args>(args)...);
+    ++_size;
+  }
+
+  std::size_t size() const { return _size; }
+  bool empty() const { return _size == 0; }
+
+  T &operator[](std::size_t index) { return _data[index]; }
+  const T &operator[](std::size_t index) const { return _data[index]; }
+
+  T *begin() { return _data; }
+  T *end() { return _data + _size; }
+  const T *begin() const { return _data; }
+  const T *end() const { return _data + _size; }
 
-    void push_back(const T& value)
+private:
+  T *_data{nullptr};
+  std::size_t _size{0};
+  std::size_t _capacity{0};
+  bool _heap{false};
+  alignas(T) char _inline[sizeof(T) * InlineN];
+
+  void _clear()
+  {
+    for (std::size_t i = 0; i < _size; ++i)
     {
-      _ensureCapacity(_size + 1);
-      new (_data + _size) T(value);
-      ++_size;
+      _data[i].~T();
     }
+    _size = 0;
+  }
+
+  void _ensureCapacity(std::size_t newSize)
+  {
+    if (newSize <= _capacity)
+      return;
+
+    std::size_t newCapacity = std::max(newSize, _capacity * 2);
+    T *newData = new T[newCapacity];
 
-    void push_back(T&& value)
+    for (std::size_t i = 0; i < _size; ++i)
     {
-      _ensureCapacity(_size + 1);
-      new (_data + _size) T(std::move(value));
-      ++_size;
+      new (newData + i) T(std::move(_data[i]));
+      _data[i].~T();
     }
 
-    template <typename... Args> void emplace_back(Args&&... args)
+    if (_heap)
     {
-      _ensureCapacity(_size + 1);
-      new (_data + _size) T(std::forward<Args>(args)...);
-      ++_size;
+      delete[] _data;
     }
 
-    std::size_t size() const { return _size; }
-    bool empty() const { return _size == 0; }
-
-    T& operator[](std::size_t index) { return _data[index]; }
-    const T& operator[](std::size_t index) const { return _data[index]; }
-
-    T* begin() { return _data; }
-    T* end() { return _data + _size; }
-    const T* begin() const { return _data; }
-    const T* end() const { return _data + _size; }
-
-  private:
-    T* _data{nullptr};
-    std::size_t _size{0};
-    std::size_t _capacity{0};
-    bool _heap{false};
-    alignas(T) char _inline[sizeof(T) * InlineN];
+    _data = newData;
+    _capacity = newCapacity;
+    _heap = true;
+  }
 
-    void _clear()
+  void _copyFrom(const SmallVec &other)
+  {
+    if (other._size > InlineN)
     {
-      for (std::size_t i = 0; i < _size; ++i)
-      {
-        _data[i].~T();
-      }
-      _size = 0;
+      _ensureCapacity(other._size);
     }
 
-    void _ensureCapacity(std::size_t newSize)
+    for (std::size_t i = 0; i < other._size; ++i)
     {
-      if (newSize <= _capacity)
-        return;
-
-      std::size_t newCapacity = std::max(newSize, _capacity * 2);
-      T* newData = new T[newCapacity];
-
-      for (std::size_t i = 0; i < _size; ++i)
-      {
-        new (newData + i) T(std::move(_data[i]));
-        _data[i].~T();
-      }
+      new (_data + i) T(other._data[i]);
+    }
+    _size = other._size;
+  }
 
+  void _moveFrom(SmallVec &&other)
+  {
+    if (other._heap)
+    {
       if (_heap)
       {
         delete[] _data;
       }
-
-      _data = newData;
-      _capacity = newCapacity;
+      _data = other._data;
+      _capacity = other._capacity;
+      _size = other._size;
       _heap = true;
-    }
 
-    void _copyFrom(const SmallVec& other)
+      other._data = reinterpret_cast<T *>(other._inline);
+      other._capacity = InlineN;
+      other._size = 0;
+      other._heap = false;
+    }
+    else
     {
-      if (other._size > InlineN)
-      {
-        _ensureCapacity(other._size);
-      }
-
       for (std::size_t i = 0; i < other._size; ++i)
       {
-        new (_data + i) T(other._data[i]);
+        new (_data + i) T(std::move(other._data[i]));
+        other._data[i].~T();
       }
       _size = other._size;
+      other._size = 0;
     }
+  }
+};
 
-    void _moveFrom(SmallVec&& other)
-    {
-      if (other._heap)
-      {
-        if (_heap)
-        {
-          delete[] _data;
-        }
-        _data = other._data;
-        _capacity = other._capacity;
-        _size = other._size;
-        _heap = true;
-
-        other._data = reinterpret_cast<T*>(other._inline);
-        other._capacity = InlineN;
-        other._size = 0;
-        other._heap = false;
-      }
-      else
-      {
-        for (std::size_t i = 0; i < other._size; ++i)
-        {
-          new (_data + i) T(std::move(other._data[i]));
-          other._data[i].~T();
-        }
-        _size = other._size;
-        other._size = 0;
-      }
-    }
-  };
-
-  // =============================================================
-  // Json class - main JSON value representation
-  // =============================================================
-  class Json
-  {
-  public:
-    using Array = std::vector<Json>;
-    using Object = std::unordered_map<std::string, Json>;
+// =============================================================
+// Json class - main JSON value representation
+// =============================================================
+class Json
+{
+public:
+  using Array = std::vector<Json>;
+  using Object = std::unordered_map<std::string, Json>;
 
-  private:
-    // Suppress false positive warnings from GCC's aggressive optimization
-    // analysis
+private:
+  // Suppress false positive warnings from GCC's aggressive optimization
+  // analysis
 #ifdef __GNUC__
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 #endif
-    using Value = std::variant<std::nullptr_t, bool, std::int64_t, double,
-                               std::string, Array, Object>;
-    Value _value;
+  using Value =
+    std::variant<std::nullptr_t, bool, std::int64_t, double, std::string, Array, Object>;
+  Value _value;
 #ifdef __GNUC__
 #pragma GCC diagnostic pop
 #endif
 
-  public:
-    // Constructors
-    Json() : _value(nullptr)
-    {
-    }
-    Json(std::nullptr_t) : _value(nullptr)
-    {
-    }
-    Json(bool b) : _value(b)
-    {
-    }
-    // Unified integer constructor to avoid overload conflicts
-    template <typename T,
-              std::enable_if_t<
-                  std::is_integral_v<T> && !std::is_same_v<T, bool>, int> = 0>
-    Json(T i) : _value(static_cast<std::int64_t>(i))
-    {
-    }
-    Json(float f) : _value(static_cast<double>(f))
-    {
-    }
-    Json(double d) : _value(d)
-    {
-    }
-    Json(const char* s) : _value(std::string(s))
-    {
-    }
-    Json(const std::string& s) : _value(s)
-    {
-    }
-    Json(std::string&& s) : _value(std::move(s))
-    {
-    }
-    Json(const Array& a) : _value(a)
-    {
-    }
-    Json(Array&& a) : _value(std::move(a))
-    {
-    }
-    Json(const Object& o) : _value(o)
-    {
-    }
-    Json(Object&& o) : _value(std::move(o))
-    {
-    }
-
-    // Initializer list constructor for arrays
-    Json(std::initializer_list<Json> init) : _value(Array(init))
-    {
-    }
-
-    // Explicit copy and move constructors to help compiler optimization
+public:
+  // Constructors
+  Json() : _value(nullptr) {}
+  Json(std::nullptr_t) : _value(nullptr) {}
+  Json(bool b) : _value(b) {}
+  // Unified integer constructor to avoid overload conflicts
+  template <typename T,
+            std::enable_if_t<std::is_integral_v<T> && !std::is_same_v<T, bool>, int> = 0>
+  Json(T i) : _value(static_cast<std::int64_t>(i))
+  {
+  }
+  Json(float f) : _value(static_cast<double>(f)) {}
+  Json(double d) : _value(d) {}
+  Json(const char *s) : _value(std::string(s)) {}
+  Json(const std::string &s) : _value(s) {}
+  Json(std::string &&s) : _value(std::move(s)) {}
+  Json(const Array &a) : _value(a) {}
+  Json(Array &&a) : _value(std::move(a)) {}
+  Json(const Object &o) : _value(o) {}
+  Json(Object &&o) : _value(std::move(o)) {}
+
+  // Initializer list constructor for arrays
+  Json(std::initializer_list<Json> init) : _value(Array(init)) {}
+
+  // Explicit copy and move constructors to help compiler optimization
 #ifdef __GNUC__
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 #endif
-    Json(const Json& other) : _value(other._value)
-    {
-    }
-    Json(Json&& other) noexcept : _value(std::move(other._value))
-    {
-    }
+  Json(const Json &other) : _value(other._value) {}
+  Json(Json &&other) noexcept : _value(std::move(other._value)) {}
 #ifdef __GNUC__
 #pragma GCC diagnostic pop
 #endif
 
-    // Explicit copy and move assignment operators
+  // Explicit copy and move assignment operators
 #ifdef __GNUC__
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 #endif
-    Json& operator=(const Json& other)
+  Json &operator=(const Json &other)
+  {
+    if (this != &other)
     {
-      if (this != &other)
-      {
-        _value = other._value;
-      }
-      return *this;
+      _value = other._value;
     }
+    return *this;
+  }
 
-    Json& operator=(Json&& other) noexcept
+  Json &operator=(Json &&other) noexcept
+  {
+    if (this != &other)
     {
-      if (this != &other)
-      {
-        _value = std::move(other._value);
-      }
-      return *this;
+      _value = std::move(other._value);
     }
+    return *this;
+  }
 #ifdef __GNUC__
 #pragma GCC diagnostic pop
 #endif
 
-    // Enable implicit conversions
-    template <typename T,
-              std::enable_if_t<
-                  std::is_arithmetic_v<T> && !std::is_same_v<T, bool>, int> = 0>
-    operator T() const
-    {
-      return get<T>();
-    }
+  // Enable implicit conversions
+  template <typename T,
+            std::enable_if_t<std::is_arithmetic_v<T> && !std::is_same_v<T, bool>, int> = 0>
+  operator T() const
+  {
+    return get<T>();
+  }
 
-    operator bool() const
-    {
-      if (isBool())
-        return getBool();
-      return !isNull();
-    }
+  operator bool() const
+  {
+    if (isBool())
+      return getBool();
+    return !isNull();
+  }
 
-    operator std::string() const
-    {
-      if (isString())
-        return getString();
-      return dump();
-    }
+  operator std::string() const
+  {
+    if (isString())
+      return getString();
+    return dump();
+  }
 
-    // Type queries
-    JsonType type() const
-    {
-      return static_cast<JsonType>(_value.index());
+  // Type queries
+  JsonType type() const { return static_cast<JsonType>(_value.index()); }
+
+  bool isNull() const { return std::holds_alternative<std::nullptr_t>(_value); }
+  bool isBool() const { return std::holds_alternative<bool>(_value); }
+  bool isInt() const { return std::holds_alternative<std::int64_t>(_value); }
+  bool isDouble() const { return std::holds_alternative<double>(_value); }
+  bool isString() const { return std::holds_alternative<std::string>(_value); }
+  bool isArray() const { return std::holds_alternative<Array>(_value); }
+  bool isObject() const { return std::holds_alternative<Object>(_value); }
+
+  // Additional type checks
+  bool is_null() const { return isNull(); }
+  bool is_boolean() const { return isBool(); }
+  bool is_number_integer() const { return isInt(); }
+  bool is_number_unsigned() const { return isInt() && getInt() >= 0; }
+  bool is_number_float() const { return isDouble(); }
+  bool is_number() const { return isInt() || isDouble(); }
+  bool is_string() const { return isString(); }
+  bool is_array() const { return isArray(); }
+  bool is_object() const { return isObject(); }
+
+  // Value accessors
+  bool getBool() const { return std::get<bool>(_value); }
+  std::int64_t getInt() const { return std::get<std::int64_t>(_value); }
+  double getDouble() const { return std::get<double>(_value); }
+  const std::string &getString() const { return std::get<std::string>(_value); }
+  const Array &getArray() const { return std::get<Array>(_value); }
+  const Object &getObject() const { return std::get<Object>(_value); }
+
+  // Mutable accessors
+  std::string &getString() { return std::get<std::string>(_value); }
+  Array &getArray() { return std::get<Array>(_value); }
+  Object &getObject() { return std::get<Object>(_value); }
+
+  // Generic value getter template
+  template <typename T> T get() const
+  {
+    if constexpr (std::is_same_v<T, bool>)
+      return getBool();
+    else if constexpr (std::is_integral_v<T> && !std::is_same_v<T, bool>)
+      return static_cast<T>(getInt());
+    else if constexpr (std::is_floating_point_v<T>)
+    {
+      if (isDouble())
+        return static_cast<T>(getDouble());
+      else if (isInt())
+        return static_cast<T>(getInt());
+      else
+        throw std::runtime_error("type_error: cannot get numeric type");
     }
+    else if constexpr (std::is_same_v<T, std::string>)
+      return getString();
+    else if constexpr (std::is_same_v<T, Array>)
+      return getArray();
+    else if constexpr (std::is_same_v<T, Object>)
+      return getObject();
+    else
+      static_assert(sizeof(T) == 0, "Unsupported type for get<T>");
+  }
 
-    bool isNull() const
-    {
-      return std::holds_alternative<std::nullptr_t>(_value);
-    }
-    bool isBool() const
-    {
-      return std::holds_alternative<bool>(_value);
-    }
-    bool isInt() const
-    {
-      return std::holds_alternative<std::int64_t>(_value);
-    }
-    bool isDouble() const
-    {
-      return std::holds_alternative<double>(_value);
-    }
-    bool isString() const
-    {
-      return std::holds_alternative<std::string>(_value);
-    }
-    bool isArray() const
-    {
-      return std::holds_alternative<Array>(_value);
-    }
-    bool isObject() const
-    {
-      return std::holds_alternative<Object>(_value);
-    }
+  // Value accessor template (same as get)
+  template <typename T> T value() const { return get<T>(); }
 
-    // Additional type checks
-    bool is_null() const
-    {
-      return isNull();
-    }
-    bool is_boolean() const
-    {
-      return isBool();
-    }
-    bool is_number_integer() const
-    {
-      return isInt();
-    }
-    bool is_number_unsigned() const
-    {
-      return isInt() && getInt() >= 0;
-    }
-    bool is_number_float() const
-    {
-      return isDouble();
-    }
-    bool is_number() const
-    {
-      return isInt() || isDouble();
-    }
-    bool is_string() const
-    {
-      return isString();
-    }
-    bool is_array() const
+  // Array operations
+  Json &operator[](std::size_t index)
+  {
+    if (!isArray())
     {
-      return isArray();
+      _value = Array{};
     }
-    bool is_object() const
+    auto &arr = getArray();
+    while (arr.size() <= index)
     {
-      return isObject();
+      arr.push_back(Json());
     }
+    return arr[index];
+  }
 
-    // Value accessors
-    bool getBool() const
-    {
-      return std::get<bool>(_value);
-    }
-    std::int64_t getInt() const
-    {
-      return std::get<std::int64_t>(_value);
-    }
-    double getDouble() const
-    {
-      return std::get<double>(_value);
-    }
-    const std::string& getString() const
-    {
-      return std::get<std::string>(_value);
-    }
-    const Array& getArray() const
-    {
-      return std::get<Array>(_value);
-    }
-    const Object& getObject() const
+  const Json &operator[](std::size_t index) const
+  {
+    static Json null_json;
+    if (!isArray() || index >= getArray().size())
     {
-      return std::get<Object>(_value);
+      return null_json;
     }
+    return getArray()[index];
+  }
 
-    // Mutable accessors
-    std::string& getString()
-    {
-      return std::get<std::string>(_value);
-    }
-    Array& getArray()
-    {
-      return std::get<Array>(_value);
-    }
-    Object& getObject()
+  // Object operations - overloads for string literals and string objects
+  Json &operator[](const std::string &key)
+  {
+    if (!isObject())
     {
-      return std::get<Object>(_value);
+      _value = Object{};
     }
+    return getObject()[key];
+  }
 
-    // Generic value getter template
-    template <typename T> T get() const
-    {
-      if constexpr (std::is_same_v<T, bool>)
-        return getBool();
-      else if constexpr (std::is_integral_v<T> && !std::is_same_v<T, bool>)
-        return static_cast<T>(getInt());
-      else if constexpr (std::is_floating_point_v<T>)
-      {
-        if (isDouble())
-          return static_cast<T>(getDouble());
-        else if (isInt())
-          return static_cast<T>(getInt());
-        else
-          throw std::runtime_error("type_error: cannot get numeric type");
-      }
-      else if constexpr (std::is_same_v<T, std::string>)
-        return getString();
-      else if constexpr (std::is_same_v<T, Array>)
-        return getArray();
-      else if constexpr (std::is_same_v<T, Object>)
-        return getObject();
-      else
-        static_assert(sizeof(T) == 0, "Unsupported type for get<T>");
-    }
+  Json &operator[](const char *key) { return operator[](std::string(key)); }
 
-    // Value accessor template (same as get)
-    template <typename T> T value() const
+  const Json &operator[](const std::string &key) const
+  {
+    static Json null_json;
+    if (!isObject())
     {
-      return get<T>();
+      return null_json;
     }
+    auto it = getObject().find(key);
+    return (it != getObject().end()) ? it->second : null_json;
+  }
 
-    // Array operations
-    Json& operator[](std::size_t index)
-    {
-      if (!isArray())
-      {
-        _value = Array{};
-      }
-      auto& arr = getArray();
-      while (arr.size() <= index)
-      {
-        arr.push_back(Json());
-      }
-      return arr[index];
-    }
+  const Json &operator[](const char *key) const { return operator[](std::string(key)); }
 
-    const Json& operator[](std::size_t index) const
-    {
-      static Json null_json;
-      if (!isArray() || index >= getArray().size())
-      {
-        return null_json;
-      }
-      return getArray()[index];
-    }
+  // Check if object contains a key
+  bool contains(const std::string &key) const
+  {
+    if (!isObject())
+      return false;
+    const auto &obj = getObject();
+    return obj.find(key) != obj.end();
+  }
 
-    // Object operations - overloads for string literals and string objects
-    Json& operator[](const std::string& key)
-    {
-      if (!isObject())
-      {
-        _value = Object{};
-      }
-      return getObject()[key];
-    }
+  // Safe element access with exception throwing
+  Json &at(const std::string &key)
+  {
+    if (!isObject())
+      throw std::runtime_error("type_error: cannot use at() with non-object");
+    auto &obj = getObject();
+    auto it = obj.find(key);
+    if (it == obj.end())
+      throw std::out_of_range("key '" + key + "' not found");
+    return it->second;
+  }
 
-    Json& operator[](const char* key)
-    {
-      return operator[](std::string(key));
-    }
+  const Json &at(const std::string &key) const
+  {
+    if (!isObject())
+      throw std::runtime_error("type_error: cannot use at() with non-object");
+    const auto &obj = getObject();
+    auto it = obj.find(key);
+    if (it == obj.end())
+      throw std::out_of_range("key '" + key + "' not found");
+    return it->second;
+  }
 
-    const Json& operator[](const std::string& key) const
-    {
-      static Json null_json;
-      if (!isObject())
-      {
-        return null_json;
-      }
-      auto it = getObject().find(key);
-      return (it != getObject().end()) ? it->second : null_json;
-    }
+  Json &at(std::size_t index)
+  {
+    if (!isArray())
+      throw std::runtime_error("type_error: cannot use at() with non-array");
+    auto &arr = getArray();
+    if (index >= arr.size())
+      throw std::out_of_range("array index " + std::to_string(index) + " out of range");
+    return arr[index];
+  }
 
-    const Json& operator[](const char* key) const
-    {
-      return operator[](std::string(key));
-    }
+  const Json &at(std::size_t index) const
+  {
+    if (!isArray())
+      throw std::runtime_error("type_error: cannot use at() with non-array");
+    const auto &arr = getArray();
+    if (index >= arr.size())
+      throw std::out_of_range("array index " + std::to_string(index) + " out of range");
+    return arr[index];
+  }
 
-    // Check if object contains a key
-    bool contains(const std::string& key) const
-    {
-      if (!isObject())
-        return false;
-      const auto& obj = getObject();
-      return obj.find(key) != obj.end();
-    }
+  // Container size accessor
+  std::size_t size() const
+  {
+    if (isArray())
+      return getArray().size();
+    else if (isObject())
+      return getObject().size();
+    else if (isString())
+      return getString().size();
+    else if (isNull())
+      return 0;
+    else
+      throw std::runtime_error("type_error: cannot get size");
+  }
 
-    // Safe element access with exception throwing
-    Json& at(const std::string& key)
-    {
-      if (!isObject())
-        throw std::runtime_error("type_error: cannot use at() with non-object");
-      auto& obj = getObject();
-      auto it = obj.find(key);
-      if (it == obj.end())
-        throw std::out_of_range("key '" + key + "' not found");
-      return it->second;
-    }
+  // Check if container is empty
+  bool empty() const
+  {
+    if (isArray())
+      return getArray().empty();
+    else if (isObject())
+      return getObject().empty();
+    else if (isString())
+      return getString().empty();
+    else if (isNull())
+      return true;
+    return false;
+  }
 
-    const Json& at(const std::string& key) const
+  // Add element to array
+  void push_back(const Json &val)
+  {
+    if (!isArray())
     {
-      if (!isObject())
-        throw std::runtime_error("type_error: cannot use at() with non-object");
-      const auto& obj = getObject();
-      auto it = obj.find(key);
-      if (it == obj.end())
-        throw std::out_of_range("key '" + key + "' not found");
-      return it->second;
+      _value = Array{};
     }
+    getArray().push_back(val);
+  }
 
-    Json& at(std::size_t index)
+  void push_back(Json &&val)
+  {
+    if (!isArray())
     {
-      if (!isArray())
-        throw std::runtime_error("type_error: cannot use at() with non-array");
-      auto& arr = getArray();
-      if (index >= arr.size())
-        throw std::out_of_range("array index " + std::to_string(index) +
-                                " out of range");
-      return arr[index];
+      _value = Array{};
     }
+    getArray().push_back(std::move(val));
+  }
 
-    const Json& at(std::size_t index) const
+  // Construct element in-place at end of array
+  template <typename... Args> void emplace_back(Args &&...args)
+  {
+    if (!isArray())
     {
-      if (!isArray())
-        throw std::runtime_error("type_error: cannot use at() with non-array");
-      const auto& arr = getArray();
-      if (index >= arr.size())
-        throw std::out_of_range("array index " + std::to_string(index) +
-                                " out of range");
-      return arr[index];
+      _value = Array{};
     }
+    getArray().emplace_back(std::forward<Args>(args)...);
+  }
 
-    // Container size accessor
-    std::size_t size() const
-    {
-      if (isArray())
-        return getArray().size();
-      else if (isObject())
-        return getObject().size();
-      else if (isString())
-        return getString().size();
-      else if (isNull())
-        return 0;
-      else
-        throw std::runtime_error("type_error: cannot get size");
-    }
+  // Clear container contents
+  void clear()
+  {
+    if (isArray())
+      getArray().clear();
+    else if (isObject())
+      getObject().clear();
+    else
+      _value = nullptr;
+  }
 
-    // Check if container is empty
-    bool empty() const
-    {
-      if (isArray())
-        return getArray().empty();
-      else if (isObject())
-        return getObject().empty();
-      else if (isString())
-        return getString().empty();
-      else if (isNull())
-        return true;
-      return false;
-    }
+  // Remove object member by key
+  std::size_t erase(const std::string &key)
+  {
+    if (!isObject())
+      return 0;
+    return getObject().erase(key);
+  }
 
-    // Add element to array
-    void push_back(const Json& val)
-    {
-      if (!isArray())
-      {
-        _value = Array{};
-      }
-      getArray().push_back(val);
-    }
+  // Find object member by key
+  Object::iterator find(const std::string &key)
+  {
+    if (!isObject())
+      throw type_error("cannot use find() with non-object");
+    return getObject().find(key);
+  }
 
-    void push_back(Json&& val)
-    {
-      if (!isArray())
-      {
-        _value = Array{};
-      }
-      getArray().push_back(std::move(val));
-    }
+  Object::const_iterator find(const std::string &key) const
+  {
+    if (!isObject())
+      throw type_error("cannot use find() with non-object");
+    return getObject().find(key);
+  }
 
-    // Construct element in-place at end of array
-    template <typename... Args> void emplace_back(Args&&... args)
-    {
-      if (!isArray())
-      {
-        _value = Array{};
-      }
-      getArray().emplace_back(std::forward<Args>(args)...);
-    }
+  // Get object for range-based iteration
+  Object &items()
+  {
+    if (!isObject())
+      throw type_error("cannot use items() with non-object");
+    return getObject();
+  }
 
-    // Clear container contents
-    void clear()
-    {
-      if (isArray())
-        getArray().clear();
-      else if (isObject())
-        getObject().clear();
-      else
-        _value = nullptr;
-    }
+  const Object &items() const
+  {
+    if (!isObject())
+      throw type_error("cannot use items() with non-object");
+    return getObject();
+  }
 
-    // Remove object member by key
-    std::size_t erase(const std::string& key)
-    {
-      if (!isObject())
-        return 0;
-      return getObject().erase(key);
-    }
+  // Count occurrences of key in object
+  std::size_t count(const std::string &key) const
+  {
+    if (!isObject())
+      return 0;
+    return getObject().count(key);
+  }
 
-    // Find object member by key
-    Object::iterator find(const std::string& key)
-    {
-      if (!isObject())
-        throw type_error("cannot use find() with non-object");
-      return getObject().find(key);
-    }
+  // Erase method that returns iterator (object version)
+  Object::iterator erase(Object::const_iterator it)
+  {
+    if (!isObject())
+      throw type_error("cannot use erase(iterator) with non-object");
+    return getObject().erase(it);
+  }
 
-    Object::const_iterator find(const std::string& key) const
-    {
-      if (!isObject())
-        throw type_error("cannot use find() with non-object");
-      return getObject().find(key);
-    }
+  // Iterator methods for range-based loops (arrays)
+  Array::iterator begin()
+  {
+    if (!isArray())
+      throw type_error("cannot use begin() with non-array");
+    return getArray().begin();
+  }
 
-    // Get object for range-based iteration
-    Object& items()
-    {
-      if (!isObject())
-        throw type_error("cannot use items() with non-object");
-      return getObject();
-    }
+  Array::const_iterator begin() const
+  {
+    if (!isArray())
+      throw type_error("cannot use begin() with non-array");
+    return getArray().begin();
+  }
 
-    const Object& items() const
-    {
-      if (!isObject())
-        throw type_error("cannot use items() with non-object");
-      return getObject();
-    }
+  Array::iterator end()
+  {
+    if (!isArray())
+      throw type_error("cannot use end() with non-array");
+    return getArray().end();
+  }
 
-    // Count occurrences of key in object
-    std::size_t count(const std::string& key) const
-    {
-      if (!isObject())
-        return 0;
-      return getObject().count(key);
-    }
+  Array::const_iterator end() const
+  {
+    if (!isArray())
+      throw type_error("cannot use end() with non-array");
+    return getArray().end();
+  }
 
-    // Erase method that returns iterator (object version)
-    Object::iterator erase(Object::const_iterator it)
-    {
-      if (!isObject())
-        throw type_error("cannot use erase(iterator) with non-object");
-      return getObject().erase(it);
-    }
+  // Serialization
+  std::string serialize(const SerializeOptions &options = {}) const
+  {
+    return _serialize(options, 0);
+  }
 
-    // Iterator methods for range-based loops (arrays)
-    Array::iterator begin()
+  // Serialize to string with formatting options
+  std::string dump(int indent = -1, char indent_char = ' ', bool ensure_ascii = false,
+                   bool sort_keys = false) const
+  {
+    SerializeOptions opts;
+    if (indent >= 0)
     {
-      if (!isArray())
-        throw type_error("cannot use begin() with non-array");
-      return getArray().begin();
+      opts.pretty = true;
+      opts.indent = std::string(indent, indent_char);
     }
+    opts.sortKeys = sort_keys;
+    return serialize(opts);
+  }
 
-    Array::const_iterator begin() const
-    {
-      if (!isArray())
-        throw type_error("cannot use begin() with non-array");
-      return getArray().begin();
-    }
+  // Static parsing methods (defined after ParseResult)
+  static auto parse(std::string_view text, const ParseLimits &limits = ParseLimits{})
+    -> struct ParseResult;
+  static Json parseOrThrow(std::string_view text, const ParseLimits &limits = {});
 
-    Array::iterator end()
-    {
-      if (!isArray())
-        throw type_error("cannot use end() with non-array");
-      return getArray().end();
-    }
+  // Static factory methods for containers
+  static Json object() { return Json(Object{}); }
 
-    Array::const_iterator end() const
-    {
-      if (!isArray())
-        throw type_error("cannot use end() with non-array");
-      return getArray().end();
-    }
+  static Json array() { return Json(Array{}); }
 
-    // Serialization
-    std::string serialize(const SerializeOptions& options = {}) const
-    {
-      return _serialize(options, 0);
-    }
+  // Additional parse method overloads
+  static Json parse(const std::string &text) { return parseOrThrow(text); }
 
-    // Serialize to string with formatting options
-    std::string dump(int indent = -1, char indent_char = ' ',
-                     bool ensure_ascii = false, bool sort_keys = false) const
-    {
-      SerializeOptions opts;
-      if (indent >= 0)
-      {
-        opts.pretty = true;
-        opts.indent = std::string(indent, indent_char);
-      }
-      opts.sortKeys = sort_keys;
-      return serialize(opts);
-    }
+  static Json parse(const std::string &text, std::nullptr_t, bool allow_exceptions = true);
+  static Json parse(const std::string &text,
+                    std::function<bool(int, const ParseResult &)> = nullptr,
+                    bool allow_exceptions = true);
 
-    // Static parsing methods (defined after ParseResult)
-    static auto parse(std::string_view text,
-                      const ParseLimits& limits = ParseLimits{})
-        -> struct ParseResult;
-    static Json parseOrThrow(std::string_view text,
-                             const ParseLimits& limits = {});
+  // Disambiguate from ParseResult version
+  static Json parseString(const std::string &text) { return parseOrThrow(text); }
 
-    // Static factory methods for containers
-    static Json object()
-    {
-      return Json(Object{});
-    }
+  // Simple parse that returns empty Json on error
+  static Json safe_parse(const std::string &text);
 
-    static Json array()
-    {
-      return Json(Array{});
-    }
+  // Comparison operators for various types
+  bool operator==(const Json &other) const { return _value == other._value; }
 
-    // Additional parse method overloads
-    static Json parse(const std::string& text)
-    {
-      return parseOrThrow(text);
-    }
+  bool operator!=(const Json &other) const { return !(*this == other); }
 
-    static Json parse(const std::string& text, std::nullptr_t,
-                      bool allow_exceptions = true);
-    static Json parse(const std::string& text,
-                      std::function<bool(int, const ParseResult&)> = nullptr,
-                      bool allow_exceptions = true);
+  bool operator==(const std::string &str) const { return isString() && getString() == str; }
 
-    // Disambiguate from ParseResult version
-    static Json parseString(const std::string& text)
-    {
-      return parseOrThrow(text);
-    }
+  bool operator==(const char *str) const { return isString() && getString() == str; }
 
-    // Simple parse that returns empty Json on error
-    static Json safe_parse(const std::string& text);
+  bool operator==(int val) const { return isInt() && getInt() == val; }
 
-    // Comparison operators for various types
-    bool operator==(const Json& other) const
-    {
-      return _value == other._value;
-    }
+  bool operator==(bool val) const { return isBool() && getBool() == val; }
 
-    bool operator!=(const Json& other) const
-    {
-      return !(*this == other);
-    }
+  bool operator==(double val) const
+  {
+    return (isDouble() && getDouble() == val) || (isInt() && getInt() == val);
+  }
 
-    bool operator==(const std::string& str) const
-    {
-      return isString() && getString() == str;
-    }
+  // Stream operators for file I/O
+  friend std::istream &operator>>(std::istream &is, Json &j)
+  {
+    std::string content((std::istreambuf_iterator<char>(is)), std::istreambuf_iterator<char>());
+    j = Json::parseOrThrow(content);
+    return is;
+  }
 
-    bool operator==(const char* str) const
-    {
-      return isString() && getString() == str;
-    }
+  friend std::ostream &operator<<(std::ostream &os, const Json &j)
+  {
+    os << j.dump();
+    return os;
+  }
 
-    bool operator==(int val) const
-    {
-      return isInt() && getInt() == val;
-    }
+  // Array iteration methods
+  Array::iterator beginArray()
+  {
+    if (!isArray())
+      throw std::runtime_error("type_error: cannot iterate over non-array");
+    return getArray().begin();
+  }
+  Array::iterator endArray()
+  {
+    if (!isArray())
+      throw std::runtime_error("type_error: cannot iterate over non-array");
+    return getArray().end();
+  }
+  Array::const_iterator beginArray() const
+  {
+    if (!isArray())
+      throw std::runtime_error("type_error: cannot iterate over non-array");
+    return getArray().begin();
+  }
+  Array::const_iterator endArray() const
+  {
+    if (!isArray())
+      throw std::runtime_error("type_error: cannot iterate over non-array");
+    return getArray().end();
+  }
 
-    bool operator==(bool val) const
-    {
-      return isBool() && getBool() == val;
-    }
+  // Range-based for loop support using specific methods
+  // For arrays, use beginArray()/endArray()
+  // For objects, use find() with object-specific end methods below
 
-    bool operator==(double val) const
-    {
-      return (isDouble() && getDouble() == val) || (isInt() && getInt() == val);
-    }
+  // Object-specific end methods for compatibility with find()
+  Object::iterator endObject()
+  {
+    if (!isObject())
+      throw type_error("cannot use endObject() with non-object");
+    return getObject().end();
+  }
 
-    // Stream operators for file I/O
-    friend std::istream& operator>>(std::istream& is, Json& j)
-    {
-      std::string content((std::istreambuf_iterator<char>(is)),
-                          std::istreambuf_iterator<char>());
-      j = Json::parseOrThrow(content);
-      return is;
-    }
+  Object::const_iterator endObject() const
+  {
+    if (!isObject())
+      throw type_error("cannot use endObject() with non-object");
+    return getObject().end();
+  }
 
-    friend std::ostream& operator<<(std::ostream& os, const Json& j)
-    {
-      os << j.dump();
-      return os;
-    }
+  // Exception types for JSON operations
+  class parse_error : public std::runtime_error
+  {
+  public:
+    explicit parse_error(const std::string &msg) : std::runtime_error(msg) {}
+  };
 
-    // Array iteration methods
-    Array::iterator beginArray()
-    {
-      if (!isArray())
-        throw std::runtime_error("type_error: cannot iterate over non-array");
-      return getArray().begin();
-    }
-    Array::iterator endArray()
-    {
-      if (!isArray())
-        throw std::runtime_error("type_error: cannot iterate over non-array");
-      return getArray().end();
-    }
-    Array::const_iterator beginArray() const
-    {
-      if (!isArray())
-        throw std::runtime_error("type_error: cannot iterate over non-array");
-      return getArray().begin();
-    }
-    Array::const_iterator endArray() const
-    {
-      if (!isArray())
-        throw std::runtime_error("type_error: cannot iterate over non-array");
-      return getArray().end();
+  class type_error : public std::runtime_error
+  {
+  public:
+    explicit type_error(const std::string &msg) : std::runtime_error(msg) {}
+  };
+
+  class out_of_range : public std::out_of_range
+  {
+  public:
+    explicit out_of_range(const std::string &msg) : std::out_of_range(msg) {}
+  };
+
+private:
+  std::string _serialize(const SerializeOptions &options, int depth) const
+  {
+    switch (type())
+    {
+    case JsonType::Null:
+      return "null";
+    case JsonType::Boolean:
+      return getBool() ? "true" : "false";
+    case JsonType::Int:
+      return std::to_string(getInt());
+    case JsonType::Double:
+      return std::to_string(getDouble());
+    case JsonType::String:
+      return _escapeString(getString());
+    case JsonType::Array:
+      return _serializeArray(options, depth);
+    case JsonType::Object:
+      return _serializeObject(options, depth);
+    default:
+      return "null";
     }
+  }
 
-    // Range-based for loop support using specific methods
-    // For arrays, use beginArray()/endArray()
-    // For objects, use find() with object-specific end methods below
+  std::string _serializeArray(const SerializeOptions &options, int depth) const
+  {
+    const auto &arr = getArray();
+    if (arr.empty())
+      return "[]";
 
-    // Object-specific end methods for compatibility with find()
-    Object::iterator endObject()
+    std::string result = "[";
+    if (options.pretty)
     {
-      if (!isObject())
-        throw type_error("cannot use endObject() with non-object");
-      return getObject().end();
+      result += "\n";
     }
 
-    Object::const_iterator endObject() const
+    for (std::size_t i = 0; i < arr.size(); ++i)
     {
-      if (!isObject())
-        throw type_error("cannot use endObject() with non-object");
-      return getObject().end();
+      if (options.pretty)
+      {
+        for (int j = 0; j <= depth; ++j)
+        {
+          result += options.indent;
+        }
+      }
+      result += arr[i]._serialize(options, depth + 1);
+      if (i < arr.size() - 1)
+      {
+        result += ",";
+      }
+      if (options.pretty)
+      {
+        result += "\n";
+      }
     }
 
-    // Exception types for JSON operations
-    class parse_error : public std::runtime_error
+    if (options.pretty)
     {
-    public:
-      explicit parse_error(const std::string& msg) : std::runtime_error(msg) {}
-    };
+      for (int j = 0; j < depth; ++j)
+      {
+        result += options.indent;
+      }
+    }
+    result += "]";
+    return result;
+  }
 
-    class type_error : public std::runtime_error
-    {
-    public:
-      explicit type_error(const std::string& msg) : std::runtime_error(msg) {}
-    };
+  std::string _serializeObject(const SerializeOptions &options, int depth) const
+  {
+    const auto &obj = getObject();
+    if (obj.empty())
+      return "{}";
 
-    class out_of_range : public std::out_of_range
+    std::string result = "{";
+    if (options.pretty)
     {
-    public:
-      explicit out_of_range(const std::string& msg) : std::out_of_range(msg) {}
-    };
+      result += "\n";
+    }
 
-  private:
-    std::string _serialize(const SerializeOptions& options, int depth) const
+    std::vector<std::string> keys;
+    keys.reserve(obj.size());
+    for (const auto &pair : obj)
     {
-      switch (type())
-      {
-      case JsonType::Null:
-        return "null";
-      case JsonType::Boolean:
-        return getBool() ? "true" : "false";
-      case JsonType::Int:
-        return std::to_string(getInt());
-      case JsonType::Double:
-        return std::to_string(getDouble());
-      case JsonType::String:
-        return _escapeString(getString());
-      case JsonType::Array:
-        return _serializeArray(options, depth);
-      case JsonType::Object:
-        return _serializeObject(options, depth);
-      default:
-        return "null";
-      }
+      keys.push_back(pair.first);
     }
 
-    std::string _serializeArray(const SerializeOptions& options,
-                                int depth) const
+    if (options.sortKeys)
     {
-      const auto& arr = getArray();
-      if (arr.empty())
-        return "[]";
-
-      std::string result = "[";
-      if (options.pretty)
-      {
-        result += "\n";
-      }
-
-      for (std::size_t i = 0; i < arr.size(); ++i)
-      {
-        if (options.pretty)
-        {
-          for (int j = 0; j <= depth; ++j)
-          {
-            result += options.indent;
-          }
-        }
-        result += arr[i]._serialize(options, depth + 1);
-        if (i < arr.size() - 1)
-        {
-          result += ",";
-        }
-        if (options.pretty)
-        {
-          result += "\n";
-        }
-      }
+      std::sort(keys.begin(), keys.end());
+    }
 
+    for (std::size_t i = 0; i < keys.size(); ++i)
+    {
       if (options.pretty)
       {
-        for (int j = 0; j < depth; ++j)
+        for (int j = 0; j <= depth; ++j)
         {
           result += options.indent;
         }
       }
-      result += "]";
-      return result;
-    }
-
-    std::string _serializeObject(const SerializeOptions& options,
-                                 int depth) const
-    {
-      const auto& obj = getObject();
-      if (obj.empty())
-        return "{}";
-
-      std::string result = "{";
+      result += _escapeString(keys[i]);
+      result += ":";
       if (options.pretty)
       {
-        result += "\n";
+        result += " ";
       }
-
-      std::vector<std::string> keys;
-      keys.reserve(obj.size());
-      for (const auto& pair : obj)
+      result += obj.at(keys[i])._serialize(options, depth + 1);
+      if (i < keys.size() - 1)
       {
-        keys.push_back(pair.first);
+        result += ",";
       }
-
-      if (options.sortKeys)
+      if (options.pretty)
       {
-        std::sort(keys.begin(), keys.end());
+        result += "\n";
       }
+    }
 
-      for (std::size_t i = 0; i < keys.size(); ++i)
+    if (options.pretty)
+    {
+      for (int j = 0; j < depth; ++j)
       {
-        if (options.pretty)
-        {
-          for (int j = 0; j <= depth; ++j)
-          {
-            result += options.indent;
-          }
-        }
-        result += _escapeString(keys[i]);
-        result += ":";
-        if (options.pretty)
-        {
-          result += " ";
-        }
-        result += obj.at(keys[i])._serialize(options, depth + 1);
-        if (i < keys.size() - 1)
-        {
-          result += ",";
-        }
-        if (options.pretty)
-        {
-          result += "\n";
-        }
+        result += options.indent;
       }
-
-      if (options.pretty)
-      {
-        for (int j = 0; j < depth; ++j)
-        {
-          result += options.indent;
-        }
-      }
-      result += "}";
-      return result;
     }
+    result += "}";
+    return result;
+  }
 
-    std::string _escapeString(const std::string& str) const
+  std::string _escapeString(const std::string &str) const
+  {
+    std::string result = "\"";
+    for (char c : str)
     {
-      std::string result = "\"";
-      for (char c : str)
+      switch (c)
       {
-        switch (c)
+      case '"':
+        result += "\\\"";
+        break;
+      case '\\':
+        result += "\\\\";
+        break;
+      case '\b':
+        result += "\\b";
+        break;
+      case '\f':
+        result += "\\f";
+        break;
+      case '\n':
+        result += "\\n";
+        break;
+      case '\r':
+        result += "\\r";
+        break;
+      case '\t':
+        result += "\\t";
+        break;
+      default:
+        if (static_cast<unsigned char>(c) < 32)
         {
-        case '"':
-          result += "\\\"";
-          break;
-        case '\\':
-          result += "\\\\";
-          break;
-        case '\b':
-          result += "\\b";
-          break;
-        case '\f':
-          result += "\\f";
-          break;
-        case '\n':
-          result += "\\n";
-          break;
-        case '\r':
-          result += "\\r";
-          break;
-        case '\t':
-          result += "\\t";
-          break;
-        default:
-          if (static_cast<unsigned char>(c) < 32)
-          {
-            result += "\\u";
-            char buf[5];
-            std::snprintf(buf, sizeof(buf), "%04x",
-                          static_cast<unsigned char>(c));
-            result += buf;
-          }
-          else
-          {
-            result += c;
-          }
+          result += "\\u";
+          char buf[5];
+          std::snprintf(buf, sizeof(buf), "%04x", static_cast<unsigned char>(c));
+          result += buf;
+        }
+        else
+        {
+          result += c;
         }
       }
-      result += "\"";
-      return result;
     }
-  };
+    result += "\"";
+    return result;
+  }
+};
 
-  /// \brief Result of a non-throwing parse operation.
-  struct ParseResult
+/// \brief Result of a non-throwing parse operation.
+struct ParseResult
+{
+  Json value;      ///< Parsed JSON value (undefined if ok == false)
+  bool ok{false};  ///< True if parsing succeeded
+  JsonError error; ///< Error info when ok == false
+};
+
+// =============================================================
+// JSON Parser implementation
+// =============================================================
+class JsonParser
+{
+public:
+  explicit JsonParser(std::string_view text, const ParseLimits &limits)
+      : _text(text), _pos(0), _limits(limits)
   {
-    Json value;      ///< Parsed JSON value (undefined if ok == false)
-    bool ok{false};  ///< True if parsing succeeded
-    JsonError error; ///< Error info when ok == false
-  };
+  }
 
-  // =============================================================
-  // JSON Parser implementation
-  // =============================================================
-  class JsonParser
+  ParseResult parse()
   {
-  public:
-    explicit JsonParser(std::string_view text, const ParseLimits& limits)
-      : _text(text), _pos(0), _limits(limits)
+    ParseResult result;
+    _skipWhitespace();
+
+    if (_pos >= _text.size())
     {
+      result.error.message = "Unexpected end of input";
+      result.error.where = _getLocation();
+      return result;
     }
 
-    ParseResult parse()
+    if (_parseValue(result.value, 0U))
     {
-      ParseResult result;
       _skipWhitespace();
-
-      if (_pos >= _text.size())
+      if (_pos < _text.size())
       {
-        result.error.message = "Unexpected end of input";
+        result.error.message = "Extra characters after JSON value";
         result.error.where = _getLocation();
         return result;
       }
+      result.ok = true;
+    }
+    else
+    {
+      result.error.message = _error.empty() ? "Parse error" : _error;
+      result.error.where = _getLocation();
+    }
 
-      if (_parseValue(result.value, 0U))
+    return result;
+  }
+
+private:
+  std::string_view _text;
+  std::size_t _pos;
+  ParseLimits _limits;
+  std::string _error;
+
+  JsonLocation _getLocation() const
+  {
+    JsonLocation loc;
+    loc.offset = _pos;
+    loc.line = 1;
+    loc.column = 1;
+
+    for (std::size_t i = 0; i < _pos && i < _text.size(); ++i)
+    {
+      if (_text[i] == '\n')
       {
-        _skipWhitespace();
-        if (_pos < _text.size())
-        {
-          result.error.message = "Extra characters after JSON value";
-          result.error.where = _getLocation();
-          return result;
-        }
-        result.ok = true;
+        ++loc.line;
+        loc.column = 1;
       }
       else
       {
-        result.error.message = _error.empty() ? "Parse error" : _error;
-        result.error.where = _getLocation();
+        ++loc.column;
       }
+    }
+    return loc;
+  }
 
-      return result;
+  void _skipWhitespace()
+  {
+    while (_pos < _text.size() && std::isspace(_text[_pos]))
+    {
+      ++_pos;
     }
+  }
 
-  private:
-    std::string_view _text;
-    std::size_t _pos;
-    ParseLimits _limits;
-    std::string _error;
+  bool _parseValue(Json &out, std::size_t depth)
+  {
+    if (depth > _limits.depthMax)
+    {
+      _error = "Maximum nesting depth exceeded";
+      return false;
+    }
 
-    JsonLocation _getLocation() const
+    _skipWhitespace();
+    if (_pos >= _text.size())
     {
-      JsonLocation loc;
-      loc.offset = _pos;
-      loc.line = 1;
-      loc.column = 1;
+      _error = "Unexpected end of input";
+      return false;
+    }
 
-      for (std::size_t i = 0; i < _pos && i < _text.size(); ++i)
-      {
-        if (_text[i] == '\n')
-        {
-          ++loc.line;
-          loc.column = 1;
-        }
-        else
-        {
-          ++loc.column;
-        }
-      }
-      return loc;
+    char c = _text[_pos];
+    switch (c)
+    {
+    case 'n':
+      return _parseNull(out);
+    case 't':
+    case 'f':
+      return _parseBool(out);
+    case '"':
+      return _parseString(out);
+    case '[':
+      return _parseArray(out, depth);
+    case '{':
+      return _parseObject(out, depth);
+    case '-':
+    case '0':
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+    case '5':
+    case '6':
+    case '7':
+    case '8':
+    case '9':
+      return _parseNumber(out);
+    default:
+      _error = "Unexpected character";
+      return false;
     }
+  }
 
-    void _skipWhitespace()
+  bool _parseNull(Json &out)
+  {
+    if (_text.substr(_pos, 4) == "null")
     {
-      while (_pos < _text.size() && std::isspace(_text[_pos]))
-      {
-        ++_pos;
-      }
+      _pos += 4;
+      out = Json();
+      return true;
     }
+    _error = "Invalid null literal";
+    return false;
+  }
 
-    bool _parseValue(Json& out, std::size_t depth)
+  bool _parseBool(Json &out)
+  {
+    if (_text.substr(_pos, 4) == "true")
     {
-      if (depth > _limits.depthMax)
-      {
-        _error = "Maximum nesting depth exceeded";
-        return false;
-      }
-
-      _skipWhitespace();
-      if (_pos >= _text.size())
-      {
-        _error = "Unexpected end of input";
-        return false;
-      }
-
-      char c = _text[_pos];
-      switch (c)
-      {
-      case 'n':
-        return _parseNull(out);
-      case 't':
-      case 'f':
-        return _parseBool(out);
-      case '"':
-        return _parseString(out);
-      case '[':
-        return _parseArray(out, depth);
-      case '{':
-        return _parseObject(out, depth);
-      case '-':
-      case '0':
-      case '1':
-      case '2':
-      case '3':
-      case '4':
-      case '5':
-      case '6':
-      case '7':
-      case '8':
-      case '9':
-        return _parseNumber(out);
-      default:
-        _error = "Unexpected character";
-        return false;
-      }
+      _pos += 4;
+      out = Json(true);
+      return true;
+    }
+    else if (_text.substr(_pos, 5) == "false")
+    {
+      _pos += 5;
+      out = Json(false);
+      return true;
     }
+    _error = "Invalid boolean literal";
+    return false;
+  }
+
+  bool _parseNumber(Json &out)
+  {
+    std::size_t start = _pos;
+    if (_text[_pos] == '-')
+      ++_pos;
 
-    bool _parseNull(Json& out)
+    if (_pos >= _text.size() || !std::isdigit(_text[_pos]))
     {
-      if (_text.substr(_pos, 4) == "null")
-      {
-        _pos += 4;
-        out = Json();
-        return true;
-      }
-      _error = "Invalid null literal";
+      _error = "Invalid number format";
       return false;
     }
 
-    bool _parseBool(Json& out)
+    // Parse integer part
+    if (_text[_pos] == '0')
     {
-      if (_text.substr(_pos, 4) == "true")
-      {
-        _pos += 4;
-        out = Json(true);
-        return true;
-      }
-      else if (_text.substr(_pos, 5) == "false")
+      ++_pos;
+    }
+    else
+    {
+      while (_pos < _text.size() && std::isdigit(_text[_pos]))
       {
-        _pos += 5;
-        out = Json(false);
-        return true;
+        ++_pos;
       }
-      _error = "Invalid boolean literal";
-      return false;
     }
 
-    bool _parseNumber(Json& out)
+    // Check for decimal point
+    bool hasDecimal = false;
+    if (_pos < _text.size() && _text[_pos] == '.')
     {
-      std::size_t start = _pos;
-      if (_text[_pos] == '-')
-        ++_pos;
-
+      hasDecimal = true;
+      ++_pos;
       if (_pos >= _text.size() || !std::isdigit(_text[_pos]))
       {
         _error = "Invalid number format";
         return false;
       }
-
-      // Parse integer part
-      if (_text[_pos] == '0')
+      while (_pos < _text.size() && std::isdigit(_text[_pos]))
       {
         ++_pos;
       }
-      else
-      {
-        while (_pos < _text.size() && std::isdigit(_text[_pos]))
-        {
-          ++_pos;
-        }
-      }
+    }
 
-      // Check for decimal point
-      bool hasDecimal = false;
-      if (_pos < _text.size() && _text[_pos] == '.')
+    // Check for exponent
+    if (_pos < _text.size() && (_text[_pos] == 'e' || _text[_pos] == 'E'))
+    {
+      hasDecimal = true;
+      ++_pos;
+      if (_pos < _text.size() && (_text[_pos] == '+' || _text[_pos] == '-'))
       {
-        hasDecimal = true;
         ++_pos;
-        if (_pos >= _text.size() || !std::isdigit(_text[_pos]))
-        {
-          _error = "Invalid number format";
-          return false;
-        }
-        while (_pos < _text.size() && std::isdigit(_text[_pos]))
-        {
-          ++_pos;
-        }
       }
-
-      // Check for exponent
-      if (_pos < _text.size() && (_text[_pos] == 'e' || _text[_pos] == 'E'))
+      if (_pos >= _text.size() || !std::isdigit(_text[_pos]))
+      {
+        _error = "Invalid number format";
+        return false;
+      }
+      while (_pos < _text.size() && std::isdigit(_text[_pos]))
       {
-        hasDecimal = true;
         ++_pos;
-        if (_pos < _text.size() && (_text[_pos] == '+' || _text[_pos] == '-'))
-        {
-          ++_pos;
-        }
-        if (_pos >= _text.size() || !std::isdigit(_text[_pos]))
-        {
-          _error = "Invalid number format";
-          return false;
-        }
-        while (_pos < _text.size() && std::isdigit(_text[_pos]))
-        {
-          ++_pos;
-        }
       }
+    }
 
-      std::string_view numStr = _text.substr(start, _pos - start);
+    std::string_view numStr = _text.substr(start, _pos - start);
 
-      if (hasDecimal)
+    if (hasDecimal)
+    {
+      char *endPtr;
+      double d = std::strtod(std::string(numStr).c_str(), &endPtr);
+      out = Json(d);
+    }
+    else
+    {
+      std::int64_t i;
+      auto result = std::from_chars(numStr.data(), numStr.data() + numStr.size(), i);
+      if (result.ec == std::errc{})
       {
-        char* endPtr;
-        double d = std::strtod(std::string(numStr).c_str(), &endPtr);
-        out = Json(d);
+        out = Json(i);
       }
       else
       {
-        std::int64_t i;
-        auto result =
-            std::from_chars(numStr.data(), numStr.data() + numStr.size(), i);
-        if (result.ec == std::errc{})
-        {
-          out = Json(i);
-        }
-        else
-        {
-          char* endPtr;
-          double d = std::strtod(std::string(numStr).c_str(), &endPtr);
-          out = Json(d);
-        }
+        char *endPtr;
+        double d = std::strtod(std::string(numStr).c_str(), &endPtr);
+        out = Json(d);
       }
+    }
 
-      return true;
+    return true;
+  }
+
+  bool _parseString(Json &out)
+  {
+    if (_text[_pos] != '"')
+    {
+      _error = "Expected '\"'";
+      return false;
     }
+    ++_pos;
 
-    bool _parseString(Json& out)
+    std::string str;
+    while (_pos < _text.size() && _text[_pos] != '"')
     {
-      if (_text[_pos] != '"')
+      if (str.size() > _limits.stringLengthMax)
       {
-        _error = "Expected '\"'";
+        _error = "String length exceeds limit";
         return false;
       }
-      ++_pos;
 
-      std::string str;
-      while (_pos < _text.size() && _text[_pos] != '"')
+      if (_text[_pos] == '\\')
       {
-        if (str.size() > _limits.stringLengthMax)
+        ++_pos;
+        if (_pos >= _text.size())
         {
-          _error = "String length exceeds limit";
+          _error = "Unexpected end of string";
           return false;
         }
 
-        if (_text[_pos] == '\\')
-        {
-          ++_pos;
-          if (_pos >= _text.size())
-          {
-            _error = "Unexpected end of string";
-            return false;
-          }
-
-          char c = _text[_pos];
-          switch (c)
-          {
-          case '"':
-            str += '"';
-            break;
-          case '\\':
-            str += '\\';
-            break;
-          case '/':
-            str += '/';
-            break;
-          case 'b':
-            str += '\b';
-            break;
-          case 'f':
-            str += '\f';
-            break;
-          case 'n':
-            str += '\n';
-            break;
-          case 'r':
-            str += '\r';
-            break;
-          case 't':
-            str += '\t';
-            break;
-          case 'u':
-            // Unicode escape - simplified implementation
-            _pos += 4;  // Skip the 4 hex digits for now
-            str += '?'; // Placeholder
-            break;
-          default:
-            _error = "Invalid escape sequence";
-            return false;
-          }
-        }
-        else
+        char c = _text[_pos];
+        switch (c)
         {
-          str += _text[_pos];
+        case '"':
+          str += '"';
+          break;
+        case '\\':
+          str += '\\';
+          break;
+        case '/':
+          str += '/';
+          break;
+        case 'b':
+          str += '\b';
+          break;
+        case 'f':
+          str += '\f';
+          break;
+        case 'n':
+          str += '\n';
+          break;
+        case 'r':
+          str += '\r';
+          break;
+        case 't':
+          str += '\t';
+          break;
+        case 'u':
+          // Unicode escape - simplified implementation
+          _pos += 4;  // Skip the 4 hex digits for now
+          str += '?'; // Placeholder
+          break;
+        default:
+          _error = "Invalid escape sequence";
+          return false;
         }
-        ++_pos;
       }
-
-      if (_pos >= _text.size())
+      else
       {
-        _error = "Unterminated string";
-        return false;
+        str += _text[_pos];
       }
+      ++_pos;
+    }
+
+    if (_pos >= _text.size())
+    {
+      _error = "Unterminated string";
+      return false;
+    }
+
+    ++_pos; // Skip closing quote
+    out = Json(std::move(str));
+    return true;
+  }
+
+  bool _parseArray(Json &out, std::size_t depth)
+  {
+    if (_text[_pos] != '[')
+    {
+      _error = "Expected '['";
+      return false;
+    }
+    ++_pos;
 
-      ++_pos; // Skip closing quote
-      out = Json(std::move(str));
+    Json::Array arr;
+    _skipWhitespace();
+
+    if (_pos < _text.size() && _text[_pos] == ']')
+    {
+      ++_pos;
+      out = Json(std::move(arr));
       return true;
     }
 
-    bool _parseArray(Json& out, std::size_t depth)
+    while (true)
     {
-      if (_text[_pos] != '[')
+      if (arr.size() >= _limits.arrayItemsMax)
       {
-        _error = "Expected '['";
+        _error = "Array size exceeds limit";
         return false;
       }
-      ++_pos;
 
-      Json::Array arr;
+      Json element;
+      if (!_parseValue(element, depth + 1))
+      {
+        return false;
+      }
+      arr.push_back(std::move(element));
+
       _skipWhitespace();
+      if (_pos >= _text.size())
+      {
+        _error = "Unexpected end of array";
+        return false;
+      }
 
-      if (_pos < _text.size() && _text[_pos] == ']')
+      if (_text[_pos] == ']')
       {
         ++_pos;
-        out = Json(std::move(arr));
-        return true;
+        break;
       }
-
-      while (true)
+      else if (_text[_pos] == ',')
       {
-        if (arr.size() >= _limits.arrayItemsMax)
-        {
-          _error = "Array size exceeds limit";
-          return false;
-        }
+        ++_pos;
+        _skipWhitespace();
+      }
+      else
+      {
+        _error = "Expected ',' or ']'";
+        return false;
+      }
+    }
 
-        Json element;
-        if (!_parseValue(element, depth + 1))
-        {
-          return false;
-        }
-        arr.push_back(std::move(element));
+    out = Json(std::move(arr));
+    return true;
+  }
 
-        _skipWhitespace();
-        if (_pos >= _text.size())
-        {
-          _error = "Unexpected end of array";
-          return false;
-        }
+  bool _parseObject(Json &out, std::size_t depth)
+  {
+    if (_text[_pos] != '{')
+    {
+      _error = "Expected '{'";
+      return false;
+    }
+    ++_pos;
 
-        if (_text[_pos] == ']')
-        {
-          ++_pos;
-          break;
-        }
-        else if (_text[_pos] == ',')
-        {
-          ++_pos;
-          _skipWhitespace();
-        }
-        else
-        {
-          _error = "Expected ',' or ']'";
-          return false;
-        }
-      }
+    Json::Object obj;
+    _skipWhitespace();
 
-      out = Json(std::move(arr));
+    if (_pos < _text.size() && _text[_pos] == '}')
+    {
+      ++_pos;
+      out = Json(std::move(obj));
       return true;
     }
 
-    bool _parseObject(Json& out, std::size_t depth)
+    while (true)
     {
-      if (_text[_pos] != '{')
+      if (obj.size() >= _limits.membersMax)
       {
-        _error = "Expected '{'";
+        _error = "Object size exceeds limit";
         return false;
       }
-      ++_pos;
-
-      Json::Object obj;
-      _skipWhitespace();
 
-      if (_pos < _text.size() && _text[_pos] == '}')
+      // Parse key
+      Json key;
+      if (!_parseString(key))
       {
-        ++_pos;
-        out = Json(std::move(obj));
-        return true;
+        return false;
       }
 
-      while (true)
+      _skipWhitespace();
+      if (_pos >= _text.size() || _text[_pos] != ':')
       {
-        if (obj.size() >= _limits.membersMax)
-        {
-          _error = "Object size exceeds limit";
-          return false;
-        }
-
-        // Parse key
-        Json key;
-        if (!_parseString(key))
-        {
-          return false;
-        }
+        _error = "Expected ':'";
+        return false;
+      }
+      ++_pos;
 
-        _skipWhitespace();
-        if (_pos >= _text.size() || _text[_pos] != ':')
-        {
-          _error = "Expected ':'";
-          return false;
-        }
-        ++_pos;
+      // Parse value
+      Json value;
+      if (!_parseValue(value, depth + 1))
+      {
+        return false;
+      }
 
-        // Parse value
-        Json value;
-        if (!_parseValue(value, depth + 1))
-        {
-          return false;
-        }
+      obj[key.getString()] = std::move(value);
 
-        obj[key.getString()] = std::move(value);
+      _skipWhitespace();
+      if (_pos >= _text.size())
+      {
+        _error = "Unexpected end of object";
+        return false;
+      }
 
+      if (_text[_pos] == '}')
+      {
+        ++_pos;
+        break;
+      }
+      else if (_text[_pos] == ',')
+      {
+        ++_pos;
         _skipWhitespace();
-        if (_pos >= _text.size())
-        {
-          _error = "Unexpected end of object";
-          return false;
-        }
-
-        if (_text[_pos] == '}')
-        {
-          ++_pos;
-          break;
-        }
-        else if (_text[_pos] == ',')
-        {
-          ++_pos;
-          _skipWhitespace();
-        }
-        else
-        {
-          _error = "Expected ',' or '}'";
-          return false;
-        }
       }
-
-      out = Json(std::move(obj));
-      return true;
+      else
+      {
+        _error = "Expected ',' or '}'";
+        return false;
+      }
     }
-  };
 
-  // Static method implementations
-  inline ParseResult Json::parse(std::string_view text,
-                                 const ParseLimits& limits)
-  {
-    JsonParser parser(text, limits);
-    return parser.parse();
+    out = Json(std::move(obj));
+    return true;
   }
+};
 
-  inline Json Json::parseOrThrow(std::string_view text,
-                                 const ParseLimits& limits)
-  {
-    auto result = parse(text, limits);
-    if (!result.ok)
-    {
-      throw parse_error("JSON parse error at line " +
-                        std::to_string(result.error.where.line) + ", column " +
-                        std::to_string(result.error.where.column) + ": " +
-                        result.error.message);
-    }
-    return std::move(result.value);
-  }
+// Static method implementations
+inline ParseResult Json::parse(std::string_view text, const ParseLimits &limits)
+{
+  JsonParser parser(text, limits);
+  return parser.parse();
+}
 
-  inline Json Json::parse(const std::string& text, std::nullptr_t,
-                          bool allow_exceptions)
+inline Json Json::parseOrThrow(std::string_view text, const ParseLimits &limits)
+{
+  auto result = parse(text, limits);
+  if (!result.ok)
   {
-    if (allow_exceptions)
-    {
-      return parseOrThrow(text);
-    }
-    else
-    {
-      auto result = parse(std::string_view(text));
-      return result.ok ? std::move(result.value) : Json();
-    }
+    throw parse_error("JSON parse error at line " + std::to_string(result.error.where.line) +
+                      ", column " + std::to_string(result.error.where.column) + ": " +
+                      result.error.message);
   }
+  return std::move(result.value);
+}
 
-  inline Json Json::parse(const std::string& text,
-                          std::function<bool(int, const ParseResult&)>,
-                          bool allow_exceptions)
+inline Json Json::parse(const std::string &text, std::nullptr_t, bool allow_exceptions)
+{
+  if (allow_exceptions)
   {
-    return parse(text, nullptr, allow_exceptions);
+    return parseOrThrow(text);
   }
-
-  inline Json Json::safe_parse(const std::string& text)
+  else
   {
     auto result = parse(std::string_view(text));
     return result.ok ? std::move(result.value) : Json();
   }
+}
+
+inline Json Json::parse(const std::string &text, std::function<bool(int, const ParseResult &)>,
+                        bool allow_exceptions)
+{
+  return parse(text, nullptr, allow_exceptions);
+}
+
+inline Json Json::safe_parse(const std::string &text)
+{
+  auto result = parse(std::string_view(text));
+  return result.ok ? std::move(result.value) : Json();
+}
+
+/// \brief Incremental, DOM-building streaming parser.
+class JsonStreamParser
+{
+public:
+  explicit JsonStreamParser(const ParseLimits &limits = {}) : _limits(limits) {}
 
-  /// \brief Incremental, DOM-building streaming parser.
-  class JsonStreamParser
+  /// \brief Feed a chunk. Returns true if a full JSON value was parsed.
+  bool feed(std::string_view chunk)
   {
-  public:
-    explicit JsonStreamParser(const ParseLimits& limits = {}) : _limits(limits)
+    _buffer.append(chunk.data(), chunk.size());
+    auto result = Json::parse(_buffer, _limits);
+    if (result.ok)
     {
+      _value = std::move(result.value);
+      _complete = true;
+      _error = JsonError{};
+      return true;
     }
-
-    /// \brief Feed a chunk. Returns true if a full JSON value was parsed.
-    bool feed(std::string_view chunk)
+    else
     {
-      _buffer.append(chunk.data(), chunk.size());
-      auto result = Json::parse(_buffer, _limits);
-      if (result.ok)
-      {
-        _value = std::move(result.value);
-        _complete = true;
-        _error = JsonError{};
-        return true;
-      }
-      else
-      {
-        _error = result.error;
-        return false;
-      }
+      _error = result.error;
+      return false;
     }
+  }
 
-    /// \brief Finalize the stream; returns true if a complete value was
-    /// produced.
-    bool finish()
-    {
-      if (_complete)
-        return true;
-
-      auto result = Json::parse(_buffer, _limits);
-      if (result.ok)
-      {
-        _value = std::move(result.value);
-        _complete = true;
-        _error = JsonError{};
-        return true;
-      }
+  /// \brief Finalize the stream; returns true if a complete value was
+  /// produced.
+  bool finish()
+  {
+    if (_complete)
+      return true;
 
-      _error = result.error;
-      return false;
+    auto result = Json::parse(_buffer, _limits);
+    if (result.ok)
+    {
+      _value = std::move(result.value);
+      _complete = true;
+      _error = JsonError{};
+      return true;
     }
 
-    bool complete() const { return _complete; }
-    const Json& value() const { return _value; }
-    const JsonError& error() const { return _error; }
+    _error = result.error;
+    return false;
+  }
 
-  private:
-    std::string _buffer;
-    ParseLimits _limits;
-    Json _value;
-    bool _complete{false};
-    JsonError _error;
-  };
+  bool complete() const { return _complete; }
+  const Json &value() const { return _value; }
+  const JsonError &error() const { return _error; }
+
+private:
+  std::string _buffer;
+  ParseLimits _limits;
+  Json _value;
+  bool _complete{false};
+  JsonError _error;
+};
 
 } // namespace parsers
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/parsers/minimal_toml.hpp b/include/iora/parsers/minimal_toml.hpp
index 933ffac..eb3b3e5 100644
--- a/include/iora/parsers/minimal_toml.hpp
+++ b/include/iora/parsers/minimal_toml.hpp
@@ -7,672 +7,635 @@
 
 #pragma once
 
+#include <algorithm>
+#include <cstdint>
+#include <fstream>
+#include <iomanip>
+#include <memory>
+#include <optional>
+#include <sstream>
+#include <stdexcept>
 #include <string>
 #include <unordered_map>
 #include <variant>
 #include <vector>
-#include <optional>
-#include <memory>
-#include <fstream>
-#include <sstream>
-#include <stdexcept>
-#include <algorithm>
-#include <iomanip>
-#include <cstdint>
 
 namespace iora
 {
 namespace parsers
 {
-  namespace toml
-  {
+namespace toml
+{
 
-    class table;
-    class array;
-    class node;
+class table;
+class array;
+class node;
 
-    using value_type =
-        std::variant<std::monostate, int64_t, double, bool, std::string,
-                     std::shared_ptr<table>, std::shared_ptr<array>>;
+using value_type = std::variant<std::monostate, int64_t, double, bool, std::string,
+                                std::shared_ptr<table>, std::shared_ptr<array>>;
 
-    class array
-    {
-    public:
-      using container_type = std::vector<value_type>;
-      using iterator = container_type::iterator;
-      using const_iterator = container_type::const_iterator;
+class array
+{
+public:
+  using container_type = std::vector<value_type>;
+  using iterator = container_type::iterator;
+  using const_iterator = container_type::const_iterator;
 
-      void push_back(const value_type& val) { _values.push_back(val); }
-      void push_back(value_type&& val) { _values.push_back(std::move(val)); }
+  void push_back(const value_type &val) { _values.push_back(val); }
+  void push_back(value_type &&val) { _values.push_back(std::move(val)); }
 
-      size_t size() const { return _values.size(); }
-      bool empty() const { return _values.empty(); }
+  size_t size() const { return _values.size(); }
+  bool empty() const { return _values.empty(); }
 
-      iterator begin() { return _values.begin(); }
-      iterator end() { return _values.end(); }
-      const_iterator begin() const { return _values.begin(); }
-      const_iterator end() const { return _values.end(); }
+  iterator begin() { return _values.begin(); }
+  iterator end() { return _values.end(); }
+  const_iterator begin() const { return _values.begin(); }
+  const_iterator end() const { return _values.end(); }
 
-      const value_type& operator[](size_t idx) const { return _values[idx]; }
-      value_type& operator[](size_t idx) { return _values[idx]; }
+  const value_type &operator[](size_t idx) const { return _values[idx]; }
+  value_type &operator[](size_t idx) { return _values[idx]; }
 
-    private:
-      container_type _values;
-    };
+private:
+  container_type _values;
+};
 
-    class node
-    {
-    public:
-      node() = default;
-      node(const value_type& val) : _value(val) {}
-      node(value_type&& val) : _value(std::move(val)) {}
+class node
+{
+public:
+  node() = default;
+  node(const value_type &val) : _value(val) {}
+  node(value_type &&val) : _value(std::move(val)) {}
 
-      bool is_value() const
-      {
-        return !std::holds_alternative<std::monostate>(_value);
-      }
+  bool is_value() const { return !std::holds_alternative<std::monostate>(_value); }
 
-      bool is_string() const
-      {
-        return std::holds_alternative<std::string>(_value);
-      }
+  bool is_string() const { return std::holds_alternative<std::string>(_value); }
 
-      bool is_integer() const
-      {
-        return std::holds_alternative<int64_t>(_value);
-      }
+  bool is_integer() const { return std::holds_alternative<int64_t>(_value); }
 
-      bool is_floating_point() const
-      {
-        return std::holds_alternative<double>(_value);
-      }
+  bool is_floating_point() const { return std::holds_alternative<double>(_value); }
 
-      bool is_boolean() const { return std::holds_alternative<bool>(_value); }
+  bool is_boolean() const { return std::holds_alternative<bool>(_value); }
 
-      bool is_array() const
-      {
-        return std::holds_alternative<std::shared_ptr<array>>(_value);
-      }
+  bool is_array() const { return std::holds_alternative<std::shared_ptr<array>>(_value); }
 
-      bool is_table() const
-      {
-        return std::holds_alternative<std::shared_ptr<table>>(_value);
-      }
+  bool is_table() const { return std::holds_alternative<std::shared_ptr<table>>(_value); }
 
-      template <typename T> std::optional<T> as() const
-      {
-        if constexpr (std::is_same_v<T, int64_t>)
-        {
-          if (auto* val = std::get_if<int64_t>(&_value))
-            return *val;
-        }
-        else if constexpr (std::is_same_v<T, double>)
-        {
-          if (auto* val = std::get_if<double>(&_value))
-            return *val;
-          if (auto* val = std::get_if<int64_t>(&_value))
-            return static_cast<double>(*val);
-        }
-        else if constexpr (std::is_same_v<T, bool>)
-        {
-          if (auto* val = std::get_if<bool>(&_value))
-            return *val;
-        }
-        else if constexpr (std::is_same_v<T, std::string>)
-        {
-          if (auto* val = std::get_if<std::string>(&_value))
-            return *val;
-        }
-        return std::nullopt;
-      }
+  template <typename T> std::optional<T> as() const
+  {
+    if constexpr (std::is_same_v<T, int64_t>)
+    {
+      if (auto *val = std::get_if<int64_t>(&_value))
+        return *val;
+    }
+    else if constexpr (std::is_same_v<T, double>)
+    {
+      if (auto *val = std::get_if<double>(&_value))
+        return *val;
+      if (auto *val = std::get_if<int64_t>(&_value))
+        return static_cast<double>(*val);
+    }
+    else if constexpr (std::is_same_v<T, bool>)
+    {
+      if (auto *val = std::get_if<bool>(&_value))
+        return *val;
+    }
+    else if constexpr (std::is_same_v<T, std::string>)
+    {
+      if (auto *val = std::get_if<std::string>(&_value))
+        return *val;
+    }
+    return std::nullopt;
+  }
 
-      template <typename T> std::optional<T> value() const { return as<T>(); }
+  template <typename T> std::optional<T> value() const { return as<T>(); }
 
-      array* as_array()
-      {
-        if (auto* val = std::get_if<std::shared_ptr<array>>(&_value))
-          return val->get();
-        return nullptr;
-      }
+  array *as_array()
+  {
+    if (auto *val = std::get_if<std::shared_ptr<array>>(&_value))
+      return val->get();
+    return nullptr;
+  }
 
-      const array* as_array() const
-      {
-        if (auto* val = std::get_if<std::shared_ptr<array>>(&_value))
-          return val->get();
-        return nullptr;
-      }
+  const array *as_array() const
+  {
+    if (auto *val = std::get_if<std::shared_ptr<array>>(&_value))
+      return val->get();
+    return nullptr;
+  }
 
-      table* as_table()
-      {
-        if (auto* val = std::get_if<std::shared_ptr<table>>(&_value))
-          return val->get();
-        return nullptr;
-      }
+  table *as_table()
+  {
+    if (auto *val = std::get_if<std::shared_ptr<table>>(&_value))
+      return val->get();
+    return nullptr;
+  }
 
-      const table* as_table() const
-      {
-        if (auto* val = std::get_if<std::shared_ptr<table>>(&_value))
-          return val->get();
-        return nullptr;
-      }
+  const table *as_table() const
+  {
+    if (auto *val = std::get_if<std::shared_ptr<table>>(&_value))
+      return val->get();
+    return nullptr;
+  }
 
-      explicit operator bool() const
-      {
-        return !std::holds_alternative<std::monostate>(_value);
-      }
+  explicit operator bool() const { return !std::holds_alternative<std::monostate>(_value); }
 
-      const value_type& get_value() const { return _value; }
-      value_type& get_value() { return _value; }
+  const value_type &get_value() const { return _value; }
+  value_type &get_value() { return _value; }
 
-    private:
-      value_type _value;
-    };
+private:
+  value_type _value;
+};
 
-    class table
-    {
-    public:
-      using container_type = std::unordered_map<std::string, node>;
-      using iterator = container_type::iterator;
-      using const_iterator = container_type::const_iterator;
+class table
+{
+public:
+  using container_type = std::unordered_map<std::string, node>;
+  using iterator = container_type::iterator;
+  using const_iterator = container_type::const_iterator;
 
-      bool contains(const std::string& key) const
-      {
-        return _values.find(key) != _values.end();
-      }
+  bool contains(const std::string &key) const { return _values.find(key) != _values.end(); }
 
-      bool empty() const { return _values.empty(); }
+  bool empty() const { return _values.empty(); }
 
-      size_t size() const { return _values.size(); }
+  size_t size() const { return _values.size(); }
 
-      node& operator[](const std::string& key) { return _values[key]; }
+  node &operator[](const std::string &key) { return _values[key]; }
 
-      const node& at(const std::string& key) const
-      {
-        auto it = _values.find(key);
-        if (it == _values.end())
-          throw std::out_of_range("Key not found: " + key);
-        return it->second;
-      }
+  const node &at(const std::string &key) const
+  {
+    auto it = _values.find(key);
+    if (it == _values.end())
+      throw std::out_of_range("Key not found: " + key);
+    return it->second;
+  }
 
-      node at_path(const std::string& dottedPath) const
-      {
-        std::vector<std::string> parts;
-        std::stringstream ss(dottedPath);
-        std::string part;
-        while (std::getline(ss, part, '.'))
-          parts.push_back(part);
+  node at_path(const std::string &dottedPath) const
+  {
+    std::vector<std::string> parts;
+    std::stringstream ss(dottedPath);
+    std::string part;
+    while (std::getline(ss, part, '.'))
+      parts.push_back(part);
 
-        if (parts.empty())
-          return node();
+    if (parts.empty())
+      return node();
 
-        const table* current = this;
-        for (size_t i = 0; i < parts.size(); ++i)
-        {
-          auto it = current->_values.find(parts[i]);
-          if (it == current->_values.end())
-            return node();
+    const table *current = this;
+    for (size_t i = 0; i < parts.size(); ++i)
+    {
+      auto it = current->_values.find(parts[i]);
+      if (it == current->_values.end())
+        return node();
 
-          if (i == parts.size() - 1)
-            return it->second;
+      if (i == parts.size() - 1)
+        return it->second;
 
-          current = it->second.as_table();
-          if (!current)
-            return node();
-        }
+      current = it->second.as_table();
+      if (!current)
         return node();
-      }
+    }
+    return node();
+  }
 
-      iterator begin() { return _values.begin(); }
-      iterator end() { return _values.end(); }
-      const_iterator begin() const { return _values.begin(); }
-      const_iterator end() const { return _values.end(); }
+  iterator begin() { return _values.begin(); }
+  iterator end() { return _values.end(); }
+  const_iterator begin() const { return _values.begin(); }
+  const_iterator end() const { return _values.end(); }
 
-      void insert(const std::string& key, const node& value)
-      {
-        _values[key] = value;
-      }
+  void insert(const std::string &key, const node &value) { _values[key] = value; }
 
-      void insert(const std::string& key, node&& value)
-      {
-        _values[key] = std::move(value);
-      }
+  void insert(const std::string &key, node &&value) { _values[key] = std::move(value); }
 
-    private:
-      container_type _values;
-    };
-
-    class parser
-    {
-    public:
-      explicit parser(const std::string& input) : _input(input), _pos(0) {}
+private:
+  container_type _values;
+};
 
-      table parse()
-      {
-        table root;
-        table* currentTable = &root;
-        std::string currentSection;
+class parser
+{
+public:
+  explicit parser(const std::string &input) : _input(input), _pos(0) {}
 
-        while (!isEnd())
-        {
-          skipWhitespaceAndComments();
-          if (isEnd())
-            break;
-
-          if (peek() == '[')
-          {
-            currentSection = parseSection();
-            currentTable = ensureTable(&root, currentSection);
-          }
-          else
-          {
-            auto [key, value] = parseKeyValue();
-            if (!key.empty())
-              currentTable->insert(key, value);
-          }
-          skipWhitespaceAndComments();
-        }
-        return root;
-      }
+  table parse()
+  {
+    table root;
+    table *currentTable = &root;
+    std::string currentSection;
 
-    private:
-      std::string _input;
-      size_t _pos;
+    while (!isEnd())
+    {
+      skipWhitespaceAndComments();
+      if (isEnd())
+        break;
 
-      bool isEnd() const { return _pos >= _input.size(); }
-      char peek() const { return isEnd() ? '\0' : _input[_pos]; }
-      char peek(size_t offset) const
+      if (peek() == '[')
       {
-        size_t p = _pos + offset;
-        return p >= _input.size() ? '\0' : _input[p];
+        currentSection = parseSection();
+        currentTable = ensureTable(&root, currentSection);
       }
-      char advance() { return isEnd() ? '\0' : _input[_pos++]; }
-
-      void skipWhitespace()
+      else
       {
-        while (!isEnd() && std::isspace(peek()) && peek() != '\n')
-          advance();
+        auto [key, value] = parseKeyValue();
+        if (!key.empty())
+          currentTable->insert(key, value);
       }
+      skipWhitespaceAndComments();
+    }
+    return root;
+  }
+
+private:
+  std::string _input;
+  size_t _pos;
 
-      void skipWhitespaceAndNewlines()
+  bool isEnd() const { return _pos >= _input.size(); }
+  char peek() const { return isEnd() ? '\0' : _input[_pos]; }
+  char peek(size_t offset) const
+  {
+    size_t p = _pos + offset;
+    return p >= _input.size() ? '\0' : _input[p];
+  }
+  char advance() { return isEnd() ? '\0' : _input[_pos++]; }
+
+  void skipWhitespace()
+  {
+    while (!isEnd() && std::isspace(peek()) && peek() != '\n')
+      advance();
+  }
+
+  void skipWhitespaceAndNewlines()
+  {
+    while (!isEnd() && std::isspace(peek()))
+      advance();
+  }
+
+  void skipWhitespaceAndComments()
+  {
+    while (!isEnd())
+    {
+      skipWhitespaceAndNewlines();
+      if (peek() == '#')
       {
-        while (!isEnd() && std::isspace(peek()))
+        while (!isEnd() && peek() != '\n')
           advance();
       }
-
-      void skipWhitespaceAndComments()
+      else
       {
-        while (!isEnd())
-        {
-          skipWhitespaceAndNewlines();
-          if (peek() == '#')
-          {
-            while (!isEnd() && peek() != '\n')
-              advance();
-          }
-          else
-          {
-            break;
-          }
-        }
+        break;
       }
+    }
+  }
 
-      std::string parseSection()
-      {
-        advance(); // skip '['
-        std::string section;
-        while (!isEnd() && peek() != ']')
-        {
-          section += advance();
-        }
-        if (peek() != ']')
-          throw std::runtime_error("Unterminated section");
-        advance(); // skip ']'
-        return section;
-      }
+  std::string parseSection()
+  {
+    advance(); // skip '['
+    std::string section;
+    while (!isEnd() && peek() != ']')
+    {
+      section += advance();
+    }
+    if (peek() != ']')
+      throw std::runtime_error("Unterminated section");
+    advance(); // skip ']'
+    return section;
+  }
 
-      std::pair<std::string, node> parseKeyValue()
-      {
-        std::string key = parseKey();
-        if (key.empty())
-          return {"", node()};
+  std::pair<std::string, node> parseKeyValue()
+  {
+    std::string key = parseKey();
+    if (key.empty())
+      return {"", node()};
 
-        skipWhitespace();
-        if (peek() != '=')
-          throw std::runtime_error("Expected '=' after key");
-        advance();
-        skipWhitespace();
+    skipWhitespace();
+    if (peek() != '=')
+      throw std::runtime_error("Expected '=' after key");
+    advance();
+    skipWhitespace();
 
-        node value = parseValue();
-        return {key, value};
-      }
+    node value = parseValue();
+    return {key, value};
+  }
 
-      std::string parseKey()
+  std::string parseKey()
+  {
+    std::string key;
+    while (!isEnd() && (std::isalnum(peek()) || peek() == '_' || peek() == '-' || peek() == '.'))
+    {
+      key += advance();
+    }
+    return key;
+  }
+
+  node parseValue()
+  {
+    skipWhitespace();
+    char c = peek();
+
+    if (c == '"' || c == '\'')
+      return node(parseString());
+    else if (c == '[')
+      return node(parseArray());
+    else if (c == 't' || c == 'f')
+      return node(parseBool());
+    else if (c == '+' || c == '-' || std::isdigit(c))
+      return node(parseNumber());
+    else
+      throw std::runtime_error("Invalid value");
+  }
+
+  std::string parseString()
+  {
+    char quote = advance();
+    std::string str;
+    while (!isEnd() && peek() != quote)
+    {
+      if (peek() == '\\')
       {
-        std::string key;
-        while (!isEnd() && (std::isalnum(peek()) || peek() == '_' ||
-                            peek() == '-' || peek() == '.'))
+        advance();
+        char c = advance();
+        switch (c)
         {
-          key += advance();
+        case 'n':
+          str += '\n';
+          break;
+        case 't':
+          str += '\t';
+          break;
+        case 'r':
+          str += '\r';
+          break;
+        case '\\':
+          str += '\\';
+          break;
+        case '"':
+          str += '"';
+          break;
+        case '\'':
+          str += '\'';
+          break;
+        default:
+          str += c;
         }
-        return key;
       }
-
-      node parseValue()
+      else
       {
-        skipWhitespace();
-        char c = peek();
-
-        if (c == '"' || c == '\'')
-          return node(parseString());
-        else if (c == '[')
-          return node(parseArray());
-        else if (c == 't' || c == 'f')
-          return node(parseBool());
-        else if (c == '+' || c == '-' || std::isdigit(c))
-          return node(parseNumber());
-        else
-          throw std::runtime_error("Invalid value");
+        str += advance();
       }
+    }
+    if (peek() != quote)
+      throw std::runtime_error("Unterminated string");
+    advance();
+    return str;
+  }
 
-      std::string parseString()
-      {
-        char quote = advance();
-        std::string str;
-        while (!isEnd() && peek() != quote)
-        {
-          if (peek() == '\\')
-          {
-            advance();
-            char c = advance();
-            switch (c)
-            {
-            case 'n':
-              str += '\n';
-              break;
-            case 't':
-              str += '\t';
-              break;
-            case 'r':
-              str += '\r';
-              break;
-            case '\\':
-              str += '\\';
-              break;
-            case '"':
-              str += '"';
-              break;
-            case '\'':
-              str += '\'';
-              break;
-            default:
-              str += c;
-            }
-          }
-          else
-          {
-            str += advance();
-          }
-        }
-        if (peek() != quote)
-          throw std::runtime_error("Unterminated string");
-        advance();
-        return str;
-      }
+  value_type parseArray()
+  {
+    advance(); // skip '['
+    auto arr = std::make_shared<array>();
+    skipWhitespaceAndNewlines();
 
-      value_type parseArray()
+    while (!isEnd() && peek() != ']')
+    {
+      arr->push_back(parseValue().get_value());
+      skipWhitespaceAndNewlines();
+      if (peek() == ',')
       {
-        advance(); // skip '['
-        auto arr = std::make_shared<array>();
-        skipWhitespaceAndNewlines();
-
-        while (!isEnd() && peek() != ']')
-        {
-          arr->push_back(parseValue().get_value());
-          skipWhitespaceAndNewlines();
-          if (peek() == ',')
-          {
-            advance();
-            skipWhitespaceAndNewlines();
-          }
-        }
-
-        if (peek() != ']')
-          throw std::runtime_error("Unterminated array");
         advance();
-        return arr;
-      }
-
-      bool parseBool()
-      {
-        std::string word;
-        while (!isEnd() && std::isalpha(peek()))
-          word += advance();
-
-        if (word == "true")
-          return true;
-        if (word == "false")
-          return false;
-        throw std::runtime_error("Invalid boolean value: " + word);
+        skipWhitespaceAndNewlines();
       }
+    }
 
-      value_type parseNumber()
-      {
-        std::string num;
-        bool isFloat = false;
-
-        if (peek() == '+' || peek() == '-')
-          num += advance();
-
-        while (!isEnd() &&
-               (std::isdigit(peek()) || peek() == '.' || peek() == 'e' ||
-                peek() == 'E' || peek() == '+' || peek() == '-'))
-        {
-          if (peek() == '.' || peek() == 'e' || peek() == 'E')
-            isFloat = true;
-          num += advance();
-        }
+    if (peek() != ']')
+      throw std::runtime_error("Unterminated array");
+    advance();
+    return arr;
+  }
 
-        if (isFloat)
-        {
-          return std::stod(num);
-        }
-        else
-        {
-          return static_cast<int64_t>(std::stoll(num));
-        }
-      }
+  bool parseBool()
+  {
+    std::string word;
+    while (!isEnd() && std::isalpha(peek()))
+      word += advance();
+
+    if (word == "true")
+      return true;
+    if (word == "false")
+      return false;
+    throw std::runtime_error("Invalid boolean value: " + word);
+  }
+
+  value_type parseNumber()
+  {
+    std::string num;
+    bool isFloat = false;
 
-      table* ensureTable(table* root, const std::string& path)
-      {
-        std::vector<std::string> parts;
-        std::stringstream ss(path);
-        std::string part;
-        while (std::getline(ss, part, '.'))
-          parts.push_back(part);
-
-        table* current = root;
-        for (const auto& key : parts)
-        {
-          if (!current->contains(key))
-          {
-            current->insert(key, node(std::make_shared<table>()));
-          }
-          current = current->operator[](key).as_table();
-          if (!current)
-            throw std::runtime_error("Invalid table path: " + path);
-        }
-        return current;
-      }
-    };
+    if (peek() == '+' || peek() == '-')
+      num += advance();
 
-    inline table parse_file(const std::string& filename)
+    while (!isEnd() && (std::isdigit(peek()) || peek() == '.' || peek() == 'e' || peek() == 'E' ||
+                        peek() == '+' || peek() == '-'))
     {
-      std::ifstream file(filename);
-      if (!file.is_open())
-        throw std::runtime_error("Cannot open file: " + filename);
-
-      std::stringstream buffer;
-      buffer << file.rdbuf();
-
-      parser p(buffer.str());
-      return p.parse();
+      if (peek() == '.' || peek() == 'e' || peek() == 'E')
+        isFloat = true;
+      num += advance();
     }
 
-    inline table parse(const std::string& tomlString)
+    if (isFloat)
+    {
+      return std::stod(num);
+    }
+    else
     {
-      parser p(tomlString);
-      return p.parse();
+      return static_cast<int64_t>(std::stoll(num));
     }
+  }
 
-    class serializer
+  table *ensureTable(table *root, const std::string &path)
+  {
+    std::vector<std::string> parts;
+    std::stringstream ss(path);
+    std::string part;
+    while (std::getline(ss, part, '.'))
+      parts.push_back(part);
+
+    table *current = root;
+    for (const auto &key : parts)
     {
-    public:
-      static std::string serialize(const table& tbl)
+      if (!current->contains(key))
       {
-        std::ostringstream os;
-        serializeTable(os, tbl, "");
-        return os.str();
+        current->insert(key, node(std::make_shared<table>()));
       }
+      current = current->operator[](key).as_table();
+      if (!current)
+        throw std::runtime_error("Invalid table path: " + path);
+    }
+    return current;
+  }
+};
 
-      static void write_file(const std::string& filename, const table& tbl)
-      {
-        std::ofstream file(filename);
-        if (!file.is_open())
-          throw std::runtime_error("Cannot open file for writing: " + filename);
-        file << serialize(tbl);
-      }
+inline table parse_file(const std::string &filename)
+{
+  std::ifstream file(filename);
+  if (!file.is_open())
+    throw std::runtime_error("Cannot open file: " + filename);
 
-    private:
-      static void serializeTable(std::ostringstream& os, const table& tbl,
-                                 const std::string& prefix)
-      {
-        std::vector<std::pair<std::string, node>> simpleValues;
-        std::vector<std::pair<std::string, node>> tables;
+  std::stringstream buffer;
+  buffer << file.rdbuf();
 
-        for (const auto& [key, value] : tbl)
-        {
-          if (value.is_table())
-            tables.push_back({key, value});
-          else
-            simpleValues.push_back({key, value});
-        }
+  parser p(buffer.str());
+  return p.parse();
+}
 
-        std::sort(simpleValues.begin(), simpleValues.end(),
-                  [](const auto& a, const auto& b)
-                  { return a.first < b.first; });
-        std::sort(tables.begin(), tables.end(),
-                  [](const auto& a, const auto& b)
-                  { return a.first < b.first; });
+inline table parse(const std::string &tomlString)
+{
+  parser p(tomlString);
+  return p.parse();
+}
 
-        if (!prefix.empty() && !simpleValues.empty())
-        {
-          os << "[" << prefix << "]\n";
-        }
+class serializer
+{
+public:
+  static std::string serialize(const table &tbl)
+  {
+    std::ostringstream os;
+    serializeTable(os, tbl, "");
+    return os.str();
+  }
 
-        for (const auto& [key, value] : simpleValues)
-        {
-          os << key << " = ";
-          serializeValue(os, value);
-          os << "\n";
-        }
+  static void write_file(const std::string &filename, const table &tbl)
+  {
+    std::ofstream file(filename);
+    if (!file.is_open())
+      throw std::runtime_error("Cannot open file for writing: " + filename);
+    file << serialize(tbl);
+  }
+
+private:
+  static void serializeTable(std::ostringstream &os, const table &tbl, const std::string &prefix)
+  {
+    std::vector<std::pair<std::string, node>> simpleValues;
+    std::vector<std::pair<std::string, node>> tables;
+
+    for (const auto &[key, value] : tbl)
+    {
+      if (value.is_table())
+        tables.push_back({key, value});
+      else
+        simpleValues.push_back({key, value});
+    }
 
-        if (!simpleValues.empty() && !tables.empty())
-          os << "\n";
+    std::sort(simpleValues.begin(), simpleValues.end(),
+              [](const auto &a, const auto &b) { return a.first < b.first; });
+    std::sort(tables.begin(), tables.end(),
+              [](const auto &a, const auto &b) { return a.first < b.first; });
 
-        for (const auto& [key, value] : tables)
-        {
-          std::string newPrefix = prefix.empty() ? key : prefix + "." + key;
-          if (auto* tbl = value.as_table())
-          {
-            serializeTable(os, *tbl, newPrefix);
-          }
-        }
-      }
+    if (!prefix.empty() && !simpleValues.empty())
+    {
+      os << "[" << prefix << "]\n";
+    }
+
+    for (const auto &[key, value] : simpleValues)
+    {
+      os << key << " = ";
+      serializeValue(os, value);
+      os << "\n";
+    }
+
+    if (!simpleValues.empty() && !tables.empty())
+      os << "\n";
 
-      static void serializeValue(std::ostringstream& os, const node& n)
+    for (const auto &[key, value] : tables)
+    {
+      std::string newPrefix = prefix.empty() ? key : prefix + "." + key;
+      if (auto *tbl = value.as_table())
       {
-        if (n.is_string())
-        {
-          os << '"' << escapeString(*n.as<std::string>()) << '"';
-        }
-        else if (n.is_integer())
-        {
-          os << *n.as<int64_t>();
-        }
-        else if (n.is_floating_point())
-        {
-          os << std::setprecision(15) << *n.as<double>();
-        }
-        else if (n.is_boolean())
-        {
-          os << (*n.as<bool>() ? "true" : "false");
-        }
-        else if (n.is_array())
-        {
-          os << "[";
-          bool first = true;
-          for (const auto& elem : *n.as_array())
-          {
-            if (!first)
-              os << ", ";
-            first = false;
-            serializeValueType(os, elem);
-          }
-          os << "]";
-        }
+        serializeTable(os, *tbl, newPrefix);
       }
+    }
+  }
 
-      static void serializeValueType(std::ostringstream& os,
-                                     const value_type& val)
+  static void serializeValue(std::ostringstream &os, const node &n)
+  {
+    if (n.is_string())
+    {
+      os << '"' << escapeString(*n.as<std::string>()) << '"';
+    }
+    else if (n.is_integer())
+    {
+      os << *n.as<int64_t>();
+    }
+    else if (n.is_floating_point())
+    {
+      os << std::setprecision(15) << *n.as<double>();
+    }
+    else if (n.is_boolean())
+    {
+      os << (*n.as<bool>() ? "true" : "false");
+    }
+    else if (n.is_array())
+    {
+      os << "[";
+      bool first = true;
+      for (const auto &elem : *n.as_array())
       {
-        if (auto* s = std::get_if<std::string>(&val))
-        {
-          os << '"' << escapeString(*s) << '"';
-        }
-        else if (auto* i = std::get_if<int64_t>(&val))
-        {
-          os << *i;
-        }
-        else if (auto* d = std::get_if<double>(&val))
-        {
-          os << std::setprecision(15) << *d;
-        }
-        else if (auto* b = std::get_if<bool>(&val))
-        {
-          os << (*b ? "true" : "false");
-        }
+        if (!first)
+          os << ", ";
+        first = false;
+        serializeValueType(os, elem);
       }
+      os << "]";
+    }
+  }
 
-      static std::string escapeString(const std::string& str)
-      {
-        std::string result;
-        for (char c : str)
-        {
-          switch (c)
-          {
-          case '\n':
-            result += "\\n";
-            break;
-          case '\t':
-            result += "\\t";
-            break;
-          case '\r':
-            result += "\\r";
-            break;
-          case '\\':
-            result += "\\\\";
-            break;
-          case '"':
-            result += "\\\"";
-            break;
-          default:
-            result += c;
-          }
-        }
-        return result;
+  static void serializeValueType(std::ostringstream &os, const value_type &val)
+  {
+    if (auto *s = std::get_if<std::string>(&val))
+    {
+      os << '"' << escapeString(*s) << '"';
+    }
+    else if (auto *i = std::get_if<int64_t>(&val))
+    {
+      os << *i;
+    }
+    else if (auto *d = std::get_if<double>(&val))
+    {
+      os << std::setprecision(15) << *d;
+    }
+    else if (auto *b = std::get_if<bool>(&val))
+    {
+      os << (*b ? "true" : "false");
+    }
+  }
+
+  static std::string escapeString(const std::string &str)
+  {
+    std::string result;
+    for (char c : str)
+    {
+      switch (c)
+      {
+      case '\n':
+        result += "\\n";
+        break;
+      case '\t':
+        result += "\\t";
+        break;
+      case '\r':
+        result += "\\r";
+        break;
+      case '\\':
+        result += "\\\\";
+        break;
+      case '"':
+        result += "\\\"";
+        break;
+      default:
+        result += c;
       }
-    };
+    }
+    return result;
+  }
+};
 
-  } // namespace toml
+} // namespace toml
 } // namespace parsers
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/parsers/xml.hpp b/include/iora/parsers/xml.hpp
index 5a856a1..5d46089 100644
--- a/include/iora/parsers/xml.hpp
+++ b/include/iora/parsers/xml.hpp
@@ -1,13 +1,15 @@
 #pragma once
 /// \file xml.hpp
-/// \brief Single-header, non-validating XML 1.0 parser for C++17 with pull, SAX, and optional DOM APIs.
+/// \brief Single-header, non-validating XML 1.0 parser for C++17 with pull, SAX, and optional DOM
+/// APIs.
 ///
 /// Design goals:
 ///  - Header-only, zero external deps
 ///  - Non-validating (no DTD/XSD); safe-by-default (no external entity expansion)
 ///  - Efficient pull-token API; optional SAX callbacks; optional lightweight DOM builder
 ///  - UTF-8 primary encoding; predefined entities + numeric char refs
-///  - Iora style: 2-space indent, Allman braces, camelCase, PascalCase types, _member prefix, no using-namespace in headers
+///  - Iora style: 2-space indent, Allman braces, camelCase, PascalCase types, _member prefix, no
+///  using-namespace in headers
 ///
 /// Example (pull API):
 /// \code
@@ -25,17 +27,17 @@
 ///
 /// SPDX-License-Identifier: MPL-2.0
 
-#include <cstdint>
+#include <algorithm>
 #include <cstddef>
-#include <string>
-#include <string_view>
-#include <vector>
+#include <cstdint>
 #include <functional>
-#include <memory>
-#include <utility>
 #include <limits>
+#include <memory>
 #include <stdexcept>
-#include <algorithm>
+#include <string>
+#include <string_view>
+#include <utility>
+#include <vector>
 
 #ifndef IORA_XML_ENABLE_SAX
 #define IORA_XML_ENABLE_SAX 1
@@ -53,1165 +55,1262 @@ namespace parsers
 {
 namespace xml
 {
-  /// \brief Token kinds produced by the pull parser.
-  enum class TokenKind
-  {
-    Invalid,
-    Eof,
-    XmlDecl,
-    Doctype,
-    StartElement,
-    EndElement,
-    EmptyElement,
-    Text,
-    CData,
-    Comment,
-    ProcessingInstruction
-  };
+/// \brief Token kinds produced by the pull parser.
+enum class TokenKind
+{
+  Invalid,
+  Eof,
+  XmlDecl,
+  Doctype,
+  StartElement,
+  EndElement,
+  EmptyElement,
+  Text,
+  CData,
+  Comment,
+  ProcessingInstruction
+};
+
+/// \brief Error information for parse failures.
+struct Error
+{
+  std::size_t offset{0};
+  std::size_t line{1};
+  std::size_t column{1};
+  std::string message;
+};
+
+/// \brief Parser configuration options and safety limits.
+struct Options
+{
+  bool permissive{false};              ///< Best-effort recovery for minor issues
+  bool namespaceProcessing{true};      ///< Expose prefix/localName split; no URI resolution
+  std::size_t maxDepth{256};           ///< Max element nesting depth
+  std::size_t maxAttrsPerElement{256}; ///< Max attributes per element
+  std::size_t maxNameLength{1024};     ///< Max length of element or attribute names
+  std::size_t maxTextSpan{1u << 20};   ///< Max contiguous text span in bytes (1 MiB)
+  std::size_t maxTotalTokens{0};       ///< 0=unbounded; otherwise cap total tokens
+};
+
+/// \brief Attribute view (name/value) for tokens. Values are source slices; use decode*() for
+/// entity-decoded strings.
+struct Attribute
+{
+  std::string_view name;
+  std::string_view value;
+};
 
-  /// \brief Error information for parse failures.
-  struct Error
+/// \brief Token produced by the pull parser.
+struct Token
+{
+  TokenKind kind{TokenKind::Invalid};
+  std::string_view name;             ///< For elements/PI/decl/doctype: raw name or target
+  std::string_view text;             ///< For Text/Comment/CData/PI: raw text slice
+  std::vector<Attribute> attributes; ///< For StartElement/EmptyElement and XmlDecl
+  bool selfClosing{false};           ///< For EmptyElement convenience
+  std::size_t depth{0};              ///< Element depth at this token (root element has depth 1)
+  std::size_t offset{0};             ///< Byte offset of token start
+  std::size_t line{1};
+  std::size_t column{1};
+
+  /// \brief Returns the localName and prefix split from name (no URI resolution).
+  std::pair<std::string_view, std::string_view> splitQName() const
   {
-    std::size_t offset{0};
-    std::size_t line{1};
-    std::size_t column{1};
-    std::string message;
-  };
+    std::size_t pos = name.find(':');
+    if (pos == std::string_view::npos)
+    {
+      return {std::string_view{}, name};
+    }
+    return {name.substr(0, pos), name.substr(pos + 1)};
+  }
+};
 
-  /// \brief Parser configuration options and safety limits.
-  struct Options
-  {
-    bool permissive{false};              ///< Best-effort recovery for minor issues
-    bool namespaceProcessing{true};      ///< Expose prefix/localName split; no URI resolution
-    std::size_t maxDepth{256};           ///< Max element nesting depth
-    std::size_t maxAttrsPerElement{256}; ///< Max attributes per element
-    std::size_t maxNameLength{1024};     ///< Max length of element or attribute names
-    std::size_t maxTextSpan{1u << 20};   ///< Max contiguous text span in bytes (1 MiB)
-    std::size_t maxTotalTokens{0};       ///< 0=unbounded; otherwise cap total tokens
-  };
+/// \brief Minimal monotonic arena for optional DOM allocations.
+class MonotonicArena
+{
+public:
+  MonotonicArena() = default;
 
-  /// \brief Attribute view (name/value) for tokens. Values are source slices; use decode*() for entity-decoded strings.
-  struct Attribute
+  ~MonotonicArena()
   {
-    std::string_view name;
-    std::string_view value;
-  };
+    for (auto &b : _blocks)
+    {
+      delete[] b.ptr;
+    }
+  }
 
-  /// \brief Token produced by the pull parser.
-  struct Token
+  void *allocate(std::size_t n)
   {
-    TokenKind kind{TokenKind::Invalid};
-    std::string_view name;               ///< For elements/PI/decl/doctype: raw name or target
-    std::string_view text;               ///< For Text/Comment/CData/PI: raw text slice
-    std::vector<Attribute> attributes;   ///< For StartElement/EmptyElement and XmlDecl
-    bool selfClosing{false};             ///< For EmptyElement convenience
-    std::size_t depth{0};                ///< Element depth at this token (root element has depth 1)
-    std::size_t offset{0};               ///< Byte offset of token start
-    std::size_t line{1};
-    std::size_t column{1};
-
-    /// \brief Returns the localName and prefix split from name (no URI resolution).
-    std::pair<std::string_view, std::string_view> splitQName() const
-    {
-      std::size_t pos = name.find(':');
-      if (pos == std::string_view::npos)
+    n = (n + alignof(std::max_align_t) - 1) & ~(alignof(std::max_align_t) - 1);
+    if (_blocks.empty() || _blocks.back().used + n > _blocks.back().size)
+    {
+      std::size_t sz = std::max<std::size_t>(n, _nextGrowth);
+      Block b;
+      b.ptr = new char[sz];
+      b.size = sz;
+      b.used = 0;
+      _blocks.push_back(b);
+      if (_nextGrowth < (1u << 20))
       {
-        return {std::string_view{}, name};
+        _nextGrowth *= 2; // grow up to 1 MiB blocks
       }
-      return {name.substr(0, pos), name.substr(pos + 1)};
     }
-  };
+    Block &blk = _blocks.back();
+    void *p = blk.ptr + blk.used;
+    blk.used += n;
+    return p;
+  }
 
-  /// \brief Minimal monotonic arena for optional DOM allocations.
-  class MonotonicArena
+  template <class T> T *make()
   {
-  public:
-    MonotonicArena() = default;
+    void *p = allocate(sizeof(T));
+    return new (p) T();
+  }
 
-    ~MonotonicArena()
-    {
-      for (auto &b : _blocks)
-      {
-        delete[] b.ptr;
-      }
-    }
+  template <class T> T *makeArray(std::size_t count)
+  {
+    void *p = allocate(sizeof(T) * count);
+    return reinterpret_cast<T *>(p);
+  }
 
-    void *allocate(std::size_t n)
-    {
-      n = (n + alignof(std::max_align_t) - 1) & ~(alignof(std::max_align_t) - 1);
-      if (_blocks.empty() || _blocks.back().used + n > _blocks.back().size)
-      {
-        std::size_t sz = std::max<std::size_t>(n, _nextGrowth);
-        Block b;
-        b.ptr = new char[sz];
-        b.size = sz;
-        b.used = 0;
-        _blocks.push_back(b);
-        if (_nextGrowth < (1u << 20))
-        {
-          _nextGrowth *= 2; // grow up to 1 MiB blocks
-        }
-      }
-      Block &blk = _blocks.back();
-      void *p = blk.ptr + blk.used;
-      blk.used += n;
-      return p;
-    }
+private:
+  struct Block
+  {
+    char *ptr{nullptr};
+    std::size_t size{0};
+    std::size_t used{0};
+  };
 
-    template <class T>
-    T *make()
-    {
-      void *p = allocate(sizeof(T));
-      return new (p) T();
-    }
+  std::vector<Block> _blocks;
+  std::size_t _nextGrowth{4096};
+};
 
-    template <class T>
-    T *makeArray(std::size_t count)
-    {
-      void *p = allocate(sizeof(T) * count);
-      return reinterpret_cast<T *>(p);
-    }
+/// \brief Parser: non-validating XML tokenizer with pull API.
+class Parser
+{
+public:
+  /// \brief Construct a parser over a contiguous UTF-8 buffer.
+  Parser(std::string_view input, const Options &opt = Options{}) : _input(input), _opt(opt)
+  {
+    _cur = 0;
+    _line = 1;
+    _col = 1;
+    _depth = 0;
+    _token = Token{};
+    _producedTokens = 0;
+    _elementStack.clear();
+  }
 
-  private:
-    struct Block
-    {
-      char *ptr{nullptr};
-      std::size_t size{0};
-      std::size_t used{0};
-    };
+  /// \brief Returns the current token after a successful next().
+  const Token &current() const { return _token; }
 
-    std::vector<Block> _blocks;
-    std::size_t _nextGrowth{4096};
-  };
+  /// \brief Returns last error pointer if any (nullptr if none).
+  const Error *error() const { return _hasError ? &_error : nullptr; }
 
-  /// \brief Parser: non-validating XML tokenizer with pull API.
-  class Parser
+  /// \brief Advance to the next token. Returns false on error or when EOF has been emitted.
+  bool next()
   {
-  public:
-    /// \brief Construct a parser over a contiguous UTF-8 buffer.
-    Parser(std::string_view input, const Options &opt = Options{})
-      : _input(input), _opt(opt)
+    if (_hasError)
     {
-      _cur = 0;
-      _line = 1;
-      _col = 1;
-      _depth = 0;
-      _token = Token{};
-      _producedTokens = 0;
-      _elementStack.clear();
+      return false;
     }
-
-    /// \brief Returns the current token after a successful next().
-    const Token &current() const
+    if (_emittedEof)
+    {
+      return false;
+    }
+    if (_opt.maxTotalTokens != 0 && _producedTokens >= _opt.maxTotalTokens)
     {
-      return _token;
+      return fail("token limit exceeded");
     }
 
-    /// \brief Returns last error pointer if any (nullptr if none).
-    const Error *error() const
+    skipWhitespaceOutsideText();
+    if (eof())
     {
-      return _hasError ? &_error : nullptr;
+      emitEof();
+      return false;
     }
 
-    /// \brief Advance to the next token. Returns false on error or when EOF has been emitted.
-    bool next()
+    std::size_t startOffset = _cur;
+    std::size_t startLine = _line;
+    std::size_t startCol = _col;
+
+    char c = peek();
+    if (c == '<')
     {
-      if (_hasError)
-      {
-        return false;
-      }
-      if (_emittedEof)
-      {
-        return false;
-      }
-      if (_opt.maxTotalTokens != 0 && _producedTokens >= _opt.maxTotalTokens)
+      // Tag, comment, CDATA, PI, doctype
+      advance();
+      if (eof())
       {
-        return fail("token limit exceeded");
+        return fail("unexpected end after '<'");
       }
-
-      skipWhitespaceOutsideText();
-      if (eof())
+      char n = peek();
+      if (n == '?')
       {
-        emitEof();
-        return false;
+        advance();
+        return readProcessingInstruction(startOffset, startLine, startCol);
       }
-
-      std::size_t startOffset = _cur;
-      std::size_t startLine = _line;
-      std::size_t startCol = _col;
-
-      char c = peek();
-      if (c == '<')
+      else if (n == '!')
       {
-        // Tag, comment, CDATA, PI, doctype
         advance();
-        if (eof())
-        {
-          return fail("unexpected end after '<'");
-        }
-        char n = peek();
-        if (n == '?')
-        {
-          advance();
-          return readProcessingInstruction(startOffset, startLine, startCol);
-        }
-        else if (n == '!')
+        if (matchString("--"))
         {
-          advance();
-          if (matchString("--"))
-          {
-            return readComment(startOffset, startLine, startCol);
-          }
-          if (matchString("[CDATA["))
-          {
-            return readCData(startOffset, startLine, startCol);
-          }
-          if (matchWordCaseInsensitive("DOCTYPE"))
-          {
-            return readDoctype(startOffset, startLine, startCol);
-          }
-          return fail("unsupported markup declaration");
+          return readComment(startOffset, startLine, startCol);
         }
-        else if (n == '/')
+        if (matchString("[CDATA["))
         {
-          advance();
-          return readEndTag(startOffset, startLine, startCol);
+          return readCData(startOffset, startLine, startCol);
         }
-        else
+        if (matchWordCaseInsensitive("DOCTYPE"))
         {
-          return readStartOrEmptyTag(startOffset, startLine, startCol);
+          return readDoctype(startOffset, startLine, startCol);
         }
+        return fail("unsupported markup declaration");
+      }
+      else if (n == '/')
+      {
+        advance();
+        return readEndTag(startOffset, startLine, startCol);
       }
       else
       {
-        return readText(startOffset, startLine, startCol);
+        return readStartOrEmptyTag(startOffset, startLine, startCol);
       }
     }
+    else
+    {
+      return readText(startOffset, startLine, startCol);
+    }
+  }
 
-    /// \brief Decode predefined entities and numeric char refs in a slice.
-    static bool decodeEntities(std::string_view in, std::string &out, Error *err = nullptr)
+  /// \brief Decode predefined entities and numeric char refs in a slice.
+  static bool decodeEntities(std::string_view in, std::string &out, Error *err = nullptr)
+  {
+    out.clear();
+    out.reserve(in.size());
+    for (std::size_t i = 0; i < in.size();)
     {
-      out.clear();
-      out.reserve(in.size());
-      for (std::size_t i = 0; i < in.size(); )
+      char ch = in[i];
+      if (ch != '&')
       {
-        char ch = in[i];
-        if (ch != '&')
-        {
-          out.push_back(ch);
-          ++i;
-          continue;
-        }
-        // Entity
-        std::size_t semi = in.find(';', i + 1);
-        if (semi == std::string_view::npos)
+        out.push_back(ch);
+        ++i;
+        continue;
+      }
+      // Entity
+      std::size_t semi = in.find(';', i + 1);
+      if (semi == std::string_view::npos)
+      {
+        if (err)
         {
-          if (err) { *err = {i, 0, 0, "unterminated entity"}; }
-          return false;
+          *err = {i, 0, 0, "unterminated entity"};
         }
-        std::string_view ent = in.substr(i + 1, semi - (i + 1));
-        if (ent == "lt") out.push_back('<');
-        else if (ent == "gt") out.push_back('>');
-        else if (ent == "amp") out.push_back('&');
-        else if (ent == "apos") out.push_back('\'');
-        else if (ent == "quot") out.push_back('"');
-        else if (!ent.empty() && ent[0] == '#')
+        return false;
+      }
+      std::string_view ent = in.substr(i + 1, semi - (i + 1));
+      if (ent == "lt")
+        out.push_back('<');
+      else if (ent == "gt")
+        out.push_back('>');
+      else if (ent == "amp")
+        out.push_back('&');
+      else if (ent == "apos")
+        out.push_back('\'');
+      else if (ent == "quot")
+        out.push_back('"');
+      else if (!ent.empty() && ent[0] == '#')
+      {
+        bool ok = appendCharRef(ent, out);
+        if (!ok)
         {
-          bool ok = appendCharRef(ent, out);
-          if (!ok)
+          if (err)
           {
-            if (err) { *err = {i, 0, 0, "invalid character reference"}; }
-            return false;
+            *err = {i, 0, 0, "invalid character reference"};
           }
+          return false;
         }
-        else
+      }
+      else
+      {
+        if (err)
         {
-          if (err) { *err = {i, 0, 0, "unknown entity"}; }
-          return false; // external entities unsupported by design
+          *err = {i, 0, 0, "unknown entity"};
         }
-        i = semi + 1;
+        return false; // external entities unsupported by design
       }
-      return true;
+      i = semi + 1;
     }
+    return true;
+  }
+
+private:
+  // ===== Low-level cursor helpers =====
+  bool eof() const { return _cur >= _input.size(); }
 
-  private:
-    // ===== Low-level cursor helpers =====
-    bool eof() const
+  char peek() const { return _input[_cur]; }
+
+  char get()
+  {
+    char ch = _input[_cur++];
+    if (ch == '\n')
     {
-      return _cur >= _input.size();
+      ++_line;
+      _col = 1;
     }
-
-    char peek() const
+    else
     {
-      return _input[_cur];
+      ++_col;
     }
+    return ch;
+  }
+
+  void advance() { (void)get(); }
+
+  bool isNameStart(char ch) const
+  {
+    return (ch == ':' || ch == '_' || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'));
+  }
+
+  bool isNameChar(char ch) const
+  {
+    return isNameStart(ch) || (ch == '-' || ch == '.' || (ch >= '0' && ch <= '9'));
+  }
 
-    char get()
+  void skipSpaces()
+  {
+    while (!eof())
     {
-      char ch = _input[_cur++];
-      if (ch == '\n')
+      char ch = peek();
+      if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n')
       {
-        ++_line;
-        _col = 1;
+        advance();
       }
       else
       {
-        ++_col;
+        break;
       }
-      return ch;
-    }
-
-    void advance()
-    {
-      (void)get();
-    }
-
-    bool isNameStart(char ch) const
-    {
-      return (ch == ':' || ch == '_' || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'));
-    }
-
-    bool isNameChar(char ch) const
-    {
-      return isNameStart(ch) || (ch == '-' || ch == '.' || (ch >= '0' && ch <= '9'));
     }
+  }
 
-    void skipSpaces()
+  void skipWhitespaceOutsideText()
+  {
+    // Only skip if next thing is markup or beginning; do not consume text spaces.
+    while (!eof())
     {
-      while (!eof())
+      char ch = peek();
+      if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n')
       {
-        char ch = peek();
-        if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n')
-        {
-          advance();
-        }
-        else
-        {
-          break;
-        }
+        advance();
+        continue;
       }
-    }
-
-    void skipWhitespaceOutsideText()
-    {
-      // Only skip if next thing is markup or beginning; do not consume text spaces.
-      while (!eof())
+      if (ch == '<')
       {
-        char ch = peek();
-        if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n')
-        {
-          advance();
-          continue;
-        }
-        if (ch == '<')
-        {
-          // stop; next() will handle
-          return;
-        }
-        // Non-space text ahead; let readText handle
+        // stop; next() will handle
         return;
       }
+      // Non-space text ahead; let readText handle
+      return;
     }
+  }
 
-    bool matchString(const char *s)
+  bool matchString(const char *s)
+  {
+    std::size_t i = 0;
+    while (s[i] != '\0')
     {
-      std::size_t i = 0;
-      while (s[i] != '\0')
+      if (_cur + i >= _input.size())
       {
-        if (_cur + i >= _input.size())
-        {
-          return false;
-        }
-        if (_input[_cur + i] != s[i])
-        {
-          return false;
-        }
-        ++i;
+        return false;
+      }
+      if (_input[_cur + i] != s[i])
+      {
+        return false;
       }
-      // advance
-      for (std::size_t j = 0; j < i; ++j) { advance(); }
-      return true;
+      ++i;
     }
+    // advance
+    for (std::size_t j = 0; j < i; ++j)
+    {
+      advance();
+    }
+    return true;
+  }
 
-    bool matchWordCaseInsensitive(const char *s)
+  bool matchWordCaseInsensitive(const char *s)
+  {
+    // Matches a word ignoring ASCII case, requires a following whitespace or '>' or '['
+    std::size_t i = 0;
+    std::size_t pos = _cur;
+    while (s[i] != '\0')
     {
-      // Matches a word ignoring ASCII case, requires a following whitespace or '>' or '['
-      std::size_t i = 0;
-      std::size_t pos = _cur;
-      while (s[i] != '\0')
+      if (pos + i >= _input.size())
       {
-        if (pos + i >= _input.size())
-        {
-          return false;
-        }
-        char a = _input[pos + i];
-        char b = s[i];
-        if (a >= 'A' && a <= 'Z') { a = static_cast<char>(a - 'A' + 'a'); }
-        if (b >= 'A' && b <= 'Z') { b = static_cast<char>(b - 'A' + 'a'); }
-        if (a != b)
-        {
-          return false;
-        }
-        ++i;
+        return false;
+      }
+      char a = _input[pos + i];
+      char b = s[i];
+      if (a >= 'A' && a <= 'Z')
+      {
+        a = static_cast<char>(a - 'A' + 'a');
+      }
+      if (b >= 'A' && b <= 'Z')
+      {
+        b = static_cast<char>(b - 'A' + 'a');
       }
-      // Check word boundary
-      char next = (pos + i < _input.size() ? _input[pos + i] : '\0');
-      if (!(next == ' ' || next == '\t' || next == '\r' || next == '\n' || next == '>' || next == '['))
+      if (a != b)
       {
         return false;
       }
-      // advance
-      for (std::size_t j = 0; j < i; ++j) { advance(); }
-      return true;
+      ++i;
+    }
+    // Check word boundary
+    char next = (pos + i < _input.size() ? _input[pos + i] : '\0');
+    if (!(next == ' ' || next == '\t' || next == '\r' || next == '\n' || next == '>' ||
+          next == '['))
+    {
+      return false;
     }
+    // advance
+    for (std::size_t j = 0; j < i; ++j)
+    {
+      advance();
+    }
+    return true;
+  }
+
+  std::string_view readName()
+  {
+    std::size_t start = _cur;
+    if (eof() || !isNameStart(peek()))
+    {
+      return std::string_view{};
+    }
+    advance();
+    while (!eof() && isNameChar(peek()))
+    {
+      advance();
+    }
+    std::size_t len = _cur - start;
+    if (len > _opt.maxNameLength)
+    {
+      fail("name too long");
+      return std::string_view{};
+    }
+    return _input.substr(start, len);
+  }
 
-    std::string_view readName()
+  bool readUntil(std::string_view endSeq, std::size_t &startOut, std::size_t &lenOut)
+  {
+    // naive search; acceptable for typical sizes
+    std::size_t pos = _cur;
+    while (true)
     {
-      std::size_t start = _cur;
-      if (eof() || !isNameStart(peek()))
+      if (pos >= _input.size())
       {
-        return std::string_view{};
+        return false;
       }
-      advance();
-      while (!eof() && isNameChar(peek()))
+      if (_input.compare(pos, endSeq.size(), endSeq) == 0)
       {
-        advance();
+        startOut = _cur;
+        lenOut = pos - _cur;
+        // advance cursor to position after endSeq
+        while (_cur < pos + endSeq.size())
+        {
+          advance();
+        }
+        return true;
       }
-      std::size_t len = _cur - start;
-      if (len > _opt.maxNameLength)
+      // advance one char
+      char ch = _input[pos++];
+      if (ch == '\n')
       {
-        fail("name too long");
-        return std::string_view{};
+        // Maintain line/col if we step via get(); we are peeking here, so adjust counters on next
+        // get() calls only.
       }
-      return _input.substr(start, len);
     }
+  }
 
-    bool readUntil(std::string_view endSeq, std::size_t &startOut, std::size_t &lenOut)
+  bool readQuotedValue(std::string_view &out)
+  {
+    if (eof())
     {
-      // naive search; acceptable for typical sizes
-      std::size_t pos = _cur;
-      while (true)
-      {
-        if (pos >= _input.size())
-        {
-          return false;
-        }
-        if (_input.compare(pos, endSeq.size(), endSeq) == 0)
-        {
-          startOut = _cur;
-          lenOut = pos - _cur;
-          // advance cursor to position after endSeq
-          while (_cur < pos + endSeq.size()) { advance(); }
-          return true;
-        }
-        // advance one char
-        char ch = _input[pos++];
-        if (ch == '\n')
-        {
-          // Maintain line/col if we step via get(); we are peeking here, so adjust counters on next get() calls only.
-        }
-      }
+      return fail("expected quote");
+    }
+    char quote = peek();
+    if (quote != '"' && quote != '\'')
+    {
+      return fail("expected '\"' or '\'' for attribute value");
+    }
+    advance();
+    std::size_t start = _cur;
+    while (!eof() && peek() != quote)
+    {
+      advance();
+    }
+    if (eof())
+    {
+      return fail("unterminated attribute value");
+    }
+    std::size_t end = _cur;
+    advance(); // consume closing quote
+    out = _input.substr(start, end - start);
+    if (out.size() > _opt.maxTextSpan)
+    {
+      return fail("attribute value too long");
     }
+    return true;
+  }
 
-    bool readQuotedValue(std::string_view &out)
+  bool readAttributes(std::vector<Attribute> &attrs)
+  {
+    attrs.clear();
+    attrs.reserve(16); // Pre-allocate space for attributes to avoid reallocation issues
+    while (true)
     {
+      skipSpaces();
       if (eof())
       {
-        return fail("expected quote");
+        return fail("unexpected end in attributes");
       }
-      char quote = peek();
-      if (quote != '"' && quote != '\'')
+      char ch = peek();
+      if (ch == '/' || ch == '>')
       {
-        return fail("expected '\"' or '\'' for attribute value");
+        return true; // done
       }
-      advance();
-      std::size_t start = _cur;
-      while (!eof() && peek() != quote)
+      std::string_view name = readName();
+      if (name.empty())
       {
-        advance();
+        return fail("invalid attribute name");
       }
-      if (eof())
+      skipSpaces();
+      if (eof() || peek() != '=')
+      {
+        return fail("expected '=' after attribute name");
+      }
+      advance();
+      skipSpaces();
+      std::string_view value;
+      if (!readQuotedValue(value))
       {
-        return fail("unterminated attribute value");
+        return false;
       }
-      std::size_t end = _cur;
-      advance(); // consume closing quote
-      out = _input.substr(start, end - start);
-      if (out.size() > _opt.maxTextSpan)
+      attrs.push_back(Attribute{name, value});
+      if (attrs.size() > _opt.maxAttrsPerElement)
       {
-        return fail("attribute value too long");
+        return fail("too many attributes");
       }
-      return true;
     }
+  }
 
-    bool readAttributes(std::vector<Attribute> &attrs)
+  bool readProcessingInstruction(std::size_t startOffset, std::size_t startLine,
+                                 std::size_t startCol)
+  {
+    std::string_view target = readName();
+    if (target.empty())
     {
-      attrs.clear();
-      attrs.reserve(16); // Pre-allocate space for attributes to avoid reallocation issues
-      while (true)
-      {
-        skipSpaces();
-        if (eof())
-        {
-          return fail("unexpected end in attributes");
-        }
-        char ch = peek();
-        if (ch == '/' || ch == '>')
-        {
-          return true; // done
-        }
-        std::string_view name = readName();
-        if (name.empty())
-        {
-          return fail("invalid attribute name");
-        }
-        skipSpaces();
-        if (eof() || peek() != '=')
-        {
-          return fail("expected '=' after attribute name");
-        }
-        advance();
-        skipSpaces();
-        std::string_view value;
-        if (!readQuotedValue(value))
-        {
-          return false;
-        }
-        attrs.push_back(Attribute{name, value});
-        if (attrs.size() > _opt.maxAttrsPerElement)
-        {
-          return fail("too many attributes");
-        }
-      }
+      return fail("invalid PI target");
     }
-
-    bool readProcessingInstruction(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+    // Read until '?>'
+    // Consume optional whitespace after target
+    std::size_t contentStart = _cur;
+    // Find '?>'
+    std::size_t pos = _input.find("?>", _cur);
+    if (pos == std::string::npos)
     {
-      std::string_view target = readName();
-      if (target.empty())
-      {
-        return fail("invalid PI target");
-      }
-      // Read until '?>'
-      // Consume optional whitespace after target
-      std::size_t contentStart = _cur;
-      // Find '?>'
-      std::size_t pos = _input.find("?>", _cur);
-      if (pos == std::string::npos)
-      {
-        return fail("unterminated processing instruction");
-      }
-      std::string_view content = _input.substr(contentStart, pos - contentStart);
-      // Advance cursor to after '?>'
-      while (_cur < pos + 2) { advance(); }
-
-      _token = Token{};
-      _token.kind = TokenKind::ProcessingInstruction;
-      _token.name = target;
-      _token.text = content;
-      _token.depth = _depth;
-      _token.offset = startOffset;
-      _token.line = startLine;
-      _token.column = startCol;
-      return produced();
+      return fail("unterminated processing instruction");
+    }
+    std::string_view content = _input.substr(contentStart, pos - contentStart);
+    // Advance cursor to after '?>'
+    while (_cur < pos + 2)
+    {
+      advance();
     }
 
-    bool readComment(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+    _token = Token{};
+    _token.kind = TokenKind::ProcessingInstruction;
+    _token.name = target;
+    _token.text = content;
+    _token.depth = _depth;
+    _token.offset = startOffset;
+    _token.line = startLine;
+    _token.column = startCol;
+    return produced();
+  }
+
+  bool readComment(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+  {
+    // Expect until '-->'
+    std::size_t start, len;
+    if (!readUntil("-->", start, len))
     {
-      // Expect until '-->'
-      std::size_t start, len;
-      if (!readUntil("-->", start, len))
-      {
-        return fail("unterminated comment");
-      }
-      _token = Token{};
-      _token.kind = TokenKind::Comment;
-      _token.text = _input.substr(start, len);
-      _token.depth = _depth;
-      _token.offset = startOffset;
-      _token.line = startLine;
-      _token.column = startCol;
-      return produced();
+      return fail("unterminated comment");
     }
+    _token = Token{};
+    _token.kind = TokenKind::Comment;
+    _token.text = _input.substr(start, len);
+    _token.depth = _depth;
+    _token.offset = startOffset;
+    _token.line = startLine;
+    _token.column = startCol;
+    return produced();
+  }
 
-    bool readCData(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+  bool readCData(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+  {
+    std::size_t start, len;
+    if (!readUntil("]]>", start, len))
     {
-      std::size_t start, len;
-      if (!readUntil("]]>", start, len))
-      {
-        return fail("unterminated CDATA");
-      }
-      _token = Token{};
-      _token.kind = TokenKind::CData;
-      _token.text = _input.substr(start, len);
-      _token.depth = _depth;
-      _token.offset = startOffset;
-      _token.line = startLine;
-      _token.column = startCol;
-      return produced();
+      return fail("unterminated CDATA");
     }
+    _token = Token{};
+    _token.kind = TokenKind::CData;
+    _token.text = _input.substr(start, len);
+    _token.depth = _depth;
+    _token.offset = startOffset;
+    _token.line = startLine;
+    _token.column = startCol;
+    return produced();
+  }
 
-    bool readDoctype(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+  bool readDoctype(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+  {
+    // Tokenize the DOCTYPE up to the next '>' (naive; internal subset allowed within [])
+    std::size_t pos = _cur;
+    int bracket = 0;
+    while (pos < _input.size())
     {
-      // Tokenize the DOCTYPE up to the next '>' (naive; internal subset allowed within [])
-      std::size_t pos = _cur;
-      int bracket = 0;
-      while (pos < _input.size())
+      char ch = _input[pos];
+      if (ch == '[')
+      {
+        ++bracket;
+      }
+      else if (ch == ']')
       {
-        char ch = _input[pos];
-        if (ch == '[') { ++bracket; }
-        else if (ch == ']') { if (bracket > 0) { --bracket; } }
-        else if (ch == '>' && bracket == 0)
+        if (bracket > 0)
         {
-          break;
+          --bracket;
         }
-        ++pos;
       }
-      if (pos >= _input.size())
+      else if (ch == '>' && bracket == 0)
       {
-        return fail("unterminated doctype");
+        break;
       }
-      std::string_view nameAndIds = _input.substr(_cur, pos - _cur);
-      while (_cur <= pos) { advance(); }
-
-      _token = Token{};
-      _token.kind = TokenKind::Doctype;
-      _token.text = nameAndIds;
-      _token.depth = _depth;
-      _token.offset = startOffset;
-      _token.line = startLine;
-      _token.column = startCol;
-      return produced();
+      ++pos;
     }
-
-    bool readEndTag(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+    if (pos >= _input.size())
+    {
+      return fail("unterminated doctype");
+    }
+    std::string_view nameAndIds = _input.substr(_cur, pos - _cur);
+    while (_cur <= pos)
     {
-      std::string_view name = readName();
-      if (name.empty())
-      {
-        return fail("invalid end tag name");
-      }
-      skipSpaces();
-      if (eof() || peek() != '>')
-      {
-        return fail("expected '>' after end tag name");
-      }
       advance();
+    }
 
-      // Validate tag balance
-      if (_elementStack.empty())
-      {
-        return fail("end tag without matching start tag");
-      }
-      
-      // Check if the closing tag matches the most recent opening tag
-      if (_elementStack.back() != name)
-      {
-        std::string msg = "mismatched end tag - expected </" + _elementStack.back() + 
-                         "> but got </" + std::string(name) + ">";
-        return fail(msg.c_str());
-      }
-      
-      _elementStack.pop_back();
-      --_depth;
-      
-      _token = Token{};
-      _token.kind = TokenKind::EndElement;
-      _token.name = name;
-      _token.depth = _depth + 1; // depth at this token corresponds to the element being closed
-      _token.offset = startOffset;
-      _token.line = startLine;
-      _token.column = startCol;
-      return produced();
+    _token = Token{};
+    _token.kind = TokenKind::Doctype;
+    _token.text = nameAndIds;
+    _token.depth = _depth;
+    _token.offset = startOffset;
+    _token.line = startLine;
+    _token.column = startCol;
+    return produced();
+  }
+
+  bool readEndTag(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+  {
+    std::string_view name = readName();
+    if (name.empty())
+    {
+      return fail("invalid end tag name");
+    }
+    skipSpaces();
+    if (eof() || peek() != '>')
+    {
+      return fail("expected '>' after end tag name");
     }
+    advance();
 
-    bool readStartOrEmptyTag(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+    // Validate tag balance
+    if (_elementStack.empty())
     {
-      std::string_view name = readName();
-      if (name.empty())
-      {
-        return fail("invalid start tag name");
-      }
-      Token tok;
-      tok.kind = TokenKind::StartElement;
-      tok.name = name;
-      tok.offset = startOffset;
-      tok.line = startLine;
-      tok.column = startCol;
-
-      if (!readAttributes(tok.attributes))
-      {
-        return false;
-      }
+      return fail("end tag without matching start tag");
+    }
 
-      bool empty = false;
-      if (peek() == '/')
-      {
-        empty = true;
-        advance();
-      }
-      if (eof() || peek() != '>')
-      {
-        return fail("expected '>' to end start tag");
-      }
-      advance();
+    // Check if the closing tag matches the most recent opening tag
+    if (_elementStack.back() != name)
+    {
+      std::string msg = "mismatched end tag - expected </" + _elementStack.back() + "> but got </" +
+                        std::string(name) + ">";
+      return fail(msg.c_str());
+    }
 
-      if (_depth + 1 > _opt.maxDepth)
-      {
-        return fail("maximum element depth exceeded");
-      }
+    _elementStack.pop_back();
+    --_depth;
+
+    _token = Token{};
+    _token.kind = TokenKind::EndElement;
+    _token.name = name;
+    _token.depth = _depth + 1; // depth at this token corresponds to the element being closed
+    _token.offset = startOffset;
+    _token.line = startLine;
+    _token.column = startCol;
+    return produced();
+  }
 
-      ++_depth;
-      tok.depth = _depth;
+  bool readStartOrEmptyTag(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+  {
+    std::string_view name = readName();
+    if (name.empty())
+    {
+      return fail("invalid start tag name");
+    }
+    Token tok;
+    tok.kind = TokenKind::StartElement;
+    tok.name = name;
+    tok.offset = startOffset;
+    tok.line = startLine;
+    tok.column = startCol;
+
+    if (!readAttributes(tok.attributes))
+    {
+      return false;
+    }
 
-      if (empty)
-      {
-        // Emit EmptyElement token
-        tok.kind = TokenKind::EmptyElement;
-        tok.selfClosing = true;
-        _token = std::move(tok);
-        // Depth returns to previous because it's empty
-        --_depth;
-        // Don't push to stack since it's self-closing
-        return produced();
-      }
-      else
-      {
-        // Push element name to stack for validation
-        _elementStack.push_back(std::string(name));
-        _token = std::move(tok);
-        return produced();
-      }
+    bool empty = false;
+    if (peek() == '/')
+    {
+      empty = true;
+      advance();
+    }
+    if (eof() || peek() != '>')
+    {
+      return fail("expected '>' to end start tag");
     }
+    advance();
 
-    bool readText(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+    if (_depth + 1 > _opt.maxDepth)
     {
-      std::size_t start = _cur;
-      while (!eof() && peek() != '<')
-      {
-        // Limit contiguous span
-        if ((_cur - start) >= _opt.maxTextSpan)
-        {
-          return fail("text span too large");
-        }
-        advance();
-      }
-      std::string_view sv = _input.substr(start, _cur - start);
-      if (sv.empty())
-      {
-        // Should not happen; caller guards with '<' check
-        return next();
-      }
-      _token = Token{};
-      _token.kind = TokenKind::Text;
-      _token.text = sv;
-      _token.depth = _depth;
-      _token.offset = startOffset;
-      _token.line = startLine;
-      _token.column = startCol;
+      return fail("maximum element depth exceeded");
+    }
+
+    ++_depth;
+    tok.depth = _depth;
+
+    if (empty)
+    {
+      // Emit EmptyElement token
+      tok.kind = TokenKind::EmptyElement;
+      tok.selfClosing = true;
+      _token = std::move(tok);
+      // Depth returns to previous because it's empty
+      --_depth;
+      // Don't push to stack since it's self-closing
       return produced();
     }
+    else
+    {
+      // Push element name to stack for validation
+      _elementStack.push_back(std::string(name));
+      _token = std::move(tok);
+      return produced();
+    }
+  }
 
-    void emitEof()
+  bool readText(std::size_t startOffset, std::size_t startLine, std::size_t startCol)
+  {
+    std::size_t start = _cur;
+    while (!eof() && peek() != '<')
     {
-      // Check for unclosed elements
-      if (!_elementStack.empty())
+      // Limit contiguous span
+      if ((_cur - start) >= _opt.maxTextSpan)
       {
-        std::string unclosed = "unclosed elements at end of document: ";
-        for (const auto& elem : _elementStack)
-        {
-          unclosed += "<" + elem + "> ";
-        }
-        fail(unclosed.c_str());
-        return;
+        return fail("text span too large");
       }
-      _token = Token{};
-      _token.kind = TokenKind::Eof;
-      _token.depth = _depth;
-      _token.offset = _cur;
-      _token.line = _line;
-      _token.column = _col;
-      _emittedEof = true;
+      advance();
     }
-
-    bool produced()
+    std::string_view sv = _input.substr(start, _cur - start);
+    if (sv.empty())
     {
-      ++_producedTokens;
-      return true;
+      // Should not happen; caller guards with '<' check
+      return next();
     }
+    _token = Token{};
+    _token.kind = TokenKind::Text;
+    _token.text = sv;
+    _token.depth = _depth;
+    _token.offset = startOffset;
+    _token.line = startLine;
+    _token.column = startCol;
+    return produced();
+  }
 
-    bool fail(const char *msg)
+  void emitEof()
+  {
+    // Check for unclosed elements
+    if (!_elementStack.empty())
     {
-      _hasError = true;
-      _error.offset = _cur;
-      _error.line = _line;
-      _error.column = _col;
-      _error.message = msg;
+      std::string unclosed = "unclosed elements at end of document: ";
+      for (const auto &elem : _elementStack)
+      {
+        unclosed += "<" + elem + "> ";
+      }
+      fail(unclosed.c_str());
+      return;
+    }
+    _token = Token{};
+    _token.kind = TokenKind::Eof;
+    _token.depth = _depth;
+    _token.offset = _cur;
+    _token.line = _line;
+    _token.column = _col;
+    _emittedEof = true;
+  }
+
+  bool produced()
+  {
+    ++_producedTokens;
+    return true;
+  }
+
+  bool fail(const char *msg)
+  {
+    _hasError = true;
+    _error.offset = _cur;
+    _error.line = _line;
+    _error.column = _col;
+    _error.message = msg;
 #if IORA_XML_THROW_ON_ERROR
-      throw std::runtime_error(_error.message);
+    throw std::runtime_error(_error.message);
 #else
-      (void)msg;
+    (void)msg;
 #endif
+    return false;
+  }
+
+  // Append a numeric char ref (e.g. "#10" or "#x1F4A9") to out as UTF-8.
+  static bool appendCharRef(std::string_view entBody, std::string &out)
+  {
+    // entBody starts after '#'
+    if (entBody.size() < 2)
+    {
       return false;
     }
-
-    // Append a numeric char ref (e.g. "#10" or "#x1F4A9") to out as UTF-8.
-    static bool appendCharRef(std::string_view entBody, std::string &out)
+    uint32_t code = 0;
+    if (entBody[1] == 'x' || entBody[1] == 'X')
     {
-      // entBody starts after '#'
-      if (entBody.size() < 2) { return false; }
-      uint32_t code = 0;
-      if (entBody[1] == 'x' || entBody[1] == 'X')
+      // hex
+      for (std::size_t i = 2; i < entBody.size(); ++i)
       {
-        // hex
-        for (std::size_t i = 2; i < entBody.size(); ++i)
+        char c = entBody[i];
+        uint32_t v = 0;
+        if (c >= '0' && c <= '9')
+        {
+          v = static_cast<uint32_t>(c - '0');
+        }
+        else if (c >= 'a' && c <= 'f')
+        {
+          v = static_cast<uint32_t>(c - 'a' + 10);
+        }
+        else if (c >= 'A' && c <= 'F')
         {
-          char c = entBody[i];
-          uint32_t v = 0;
-          if (c >= '0' && c <= '9') { v = static_cast<uint32_t>(c - '0'); }
-          else if (c >= 'a' && c <= 'f') { v = static_cast<uint32_t>(c - 'a' + 10); }
-          else if (c >= 'A' && c <= 'F') { v = static_cast<uint32_t>(c - 'A' + 10); }
-          else { return false; }
-          code = (code << 4) | v;
+          v = static_cast<uint32_t>(c - 'A' + 10);
+        }
+        else
+        {
+          return false;
         }
+        code = (code << 4) | v;
       }
-      else
+    }
+    else
+    {
+      // decimal
+      for (std::size_t i = 1; i < entBody.size(); ++i)
       {
-        // decimal
-        for (std::size_t i = 1; i < entBody.size(); ++i)
+        char c = entBody[i];
+        if (c < '0' || c > '9')
         {
-          char c = entBody[i];
-          if (c < '0' || c > '9') { return false; }
-          code = code * 10u + static_cast<uint32_t>(c - '0');
+          return false;
         }
+        code = code * 10u + static_cast<uint32_t>(c - '0');
       }
-      if (!encodeUtf8(code, out))
+    }
+    if (!encodeUtf8(code, out))
+    {
+      return false;
+    }
+    return true;
+  }
+
+  static bool encodeUtf8(uint32_t cp, std::string &out)
+  {
+    if (cp <= 0x7Fu)
+    {
+      out.push_back(static_cast<char>(cp));
+    }
+    else if (cp <= 0x7FFu)
+    {
+      out.push_back(static_cast<char>(0xC0u | ((cp >> 6) & 0x1Fu)));
+      out.push_back(static_cast<char>(0x80u | (cp & 0x3Fu)));
+    }
+    else if (cp <= 0xFFFFu)
+    {
+      // Exclude UTF-16 surrogate halves
+      if (cp >= 0xD800u && cp <= 0xDFFFu)
       {
         return false;
       }
-      return true;
+      out.push_back(static_cast<char>(0xE0u | ((cp >> 12) & 0x0Fu)));
+      out.push_back(static_cast<char>(0x80u | ((cp >> 6) & 0x3Fu)));
+      out.push_back(static_cast<char>(0x80u | (cp & 0x3Fu)));
     }
+    else if (cp <= 0x10FFFFu)
+    {
+      out.push_back(static_cast<char>(0xF0u | ((cp >> 18) & 0x07u)));
+      out.push_back(static_cast<char>(0x80u | ((cp >> 12) & 0x3Fu)));
+      out.push_back(static_cast<char>(0x80u | ((cp >> 6) & 0x3Fu)));
+      out.push_back(static_cast<char>(0x80u | (cp & 0x3Fu)));
+    }
+    else
+    {
+      return false;
+    }
+    return true;
+  }
+
+private:
+  std::string_view _input;
+  Options _opt{};
+
+  std::size_t _cur{0};
+  std::size_t _line{1};
+  std::size_t _col{1};
+  std::size_t _depth{0};
+
+  Token _token{};
 
-    static bool encodeUtf8(uint32_t cp, std::string &out)
+  bool _hasError{false};
+  Error _error{};
+  bool _emittedEof{false};
+  std::size_t _producedTokens{0};
+  std::vector<std::string> _elementStack{}; // Track open element names for validation
+};
+
+#if IORA_XML_ENABLE_SAX
+/// \brief SAX-style callbacks (std::function). Register any subset; unregistered ones are skipped.
+struct SaxCallbacks
+{
+  std::function<void(const Token &)>
+    onXmlDecl; ///< kind=XmlDecl; attributes contain name/value pairs
+  std::function<void(const Token &)> onDoctype;      ///< kind=Doctype; text contains content
+  std::function<void(const Token &)> onStartElement; ///< kind=StartElement; attributes available
+  std::function<void(const Token &)> onEndElement;   ///< kind=EndElement
+  std::function<void(const Token &)> onEmptyElement; ///< kind=EmptyElement; attributes available
+  std::function<void(const Token &)> onText;    ///< kind=Text; use Parser::decodeEntities if needed
+  std::function<void(const Token &)> onCData;   ///< kind=CData
+  std::function<void(const Token &)> onComment; ///< kind=Comment
+  std::function<void(const Token &)> onPI;      ///< kind=ProcessingInstruction
+};
+
+/// \brief Run the parser and dispatch SAX callbacks.
+inline bool runSax(Parser &parser, const SaxCallbacks &cb)
+{
+  while (parser.next())
+  {
+    const Token &t = parser.current();
+    switch (t.kind)
     {
-      if (cp <= 0x7Fu)
+    case TokenKind::XmlDecl:
+      if (cb.onXmlDecl)
       {
-        out.push_back(static_cast<char>(cp));
+        cb.onXmlDecl(t);
       }
-      else if (cp <= 0x7FFu)
+      break;
+    case TokenKind::Doctype:
+      if (cb.onDoctype)
       {
-        out.push_back(static_cast<char>(0xC0u | ((cp >> 6) & 0x1Fu)));
-        out.push_back(static_cast<char>(0x80u | (cp & 0x3Fu)));
+        cb.onDoctype(t);
       }
-      else if (cp <= 0xFFFFu)
+      break;
+    case TokenKind::StartElement:
+      if (cb.onStartElement)
       {
-        // Exclude UTF-16 surrogate halves
-        if (cp >= 0xD800u && cp <= 0xDFFFu) { return false; }
-        out.push_back(static_cast<char>(0xE0u | ((cp >> 12) & 0x0Fu)));
-        out.push_back(static_cast<char>(0x80u | ((cp >> 6) & 0x3Fu)));
-        out.push_back(static_cast<char>(0x80u | (cp & 0x3Fu)));
+        cb.onStartElement(t);
       }
-      else if (cp <= 0x10FFFFu)
+      break;
+    case TokenKind::EndElement:
+      if (cb.onEndElement)
       {
-        out.push_back(static_cast<char>(0xF0u | ((cp >> 18) & 0x07u)));
-        out.push_back(static_cast<char>(0x80u | ((cp >> 12) & 0x3Fu)));
-        out.push_back(static_cast<char>(0x80u | ((cp >> 6) & 0x3Fu)));
-        out.push_back(static_cast<char>(0x80u | (cp & 0x3Fu)));
+        cb.onEndElement(t);
       }
-      else
+      break;
+    case TokenKind::EmptyElement:
+      if (cb.onEmptyElement)
       {
-        return false;
+        cb.onEmptyElement(t);
       }
-      return true;
-    }
-
-  private:
-    std::string_view _input;
-    Options _opt{};
-
-    std::size_t _cur{0};
-    std::size_t _line{1};
-    std::size_t _col{1};
-    std::size_t _depth{0};
-
-    Token _token{};
-
-    bool _hasError{false};
-    Error _error{};
-    bool _emittedEof{false};
-    std::size_t _producedTokens{0};
-    std::vector<std::string> _elementStack{}; // Track open element names for validation
-  };
-
-#if IORA_XML_ENABLE_SAX
-  /// \brief SAX-style callbacks (std::function). Register any subset; unregistered ones are skipped.
-  struct SaxCallbacks
-  {
-    std::function<void(const Token &)> onXmlDecl; ///< kind=XmlDecl; attributes contain name/value pairs
-    std::function<void(const Token &)> onDoctype; ///< kind=Doctype; text contains content
-    std::function<void(const Token &)> onStartElement; ///< kind=StartElement; attributes available
-    std::function<void(const Token &)> onEndElement;   ///< kind=EndElement
-    std::function<void(const Token &)> onEmptyElement; ///< kind=EmptyElement; attributes available
-    std::function<void(const Token &)> onText;   ///< kind=Text; use Parser::decodeEntities if needed
-    std::function<void(const Token &)> onCData;  ///< kind=CData
-    std::function<void(const Token &)> onComment;///< kind=Comment
-    std::function<void(const Token &)> onPI;     ///< kind=ProcessingInstruction
-  };
-
-  /// \brief Run the parser and dispatch SAX callbacks.
-  inline bool runSax(Parser &parser, const SaxCallbacks &cb)
-  {
-    while (parser.next())
-    {
-      const Token &t = parser.current();
-      switch (t.kind)
+      break;
+    case TokenKind::Text:
+      if (cb.onText)
+      {
+        cb.onText(t);
+      }
+      break;
+    case TokenKind::CData:
+      if (cb.onCData)
       {
-        case TokenKind::XmlDecl:
-          if (cb.onXmlDecl) { cb.onXmlDecl(t); }
-          break;
-        case TokenKind::Doctype:
-          if (cb.onDoctype) { cb.onDoctype(t); }
-          break;
-        case TokenKind::StartElement:
-          if (cb.onStartElement) { cb.onStartElement(t); }
-          break;
-        case TokenKind::EndElement:
-          if (cb.onEndElement) { cb.onEndElement(t); }
-          break;
-        case TokenKind::EmptyElement:
-          if (cb.onEmptyElement) { cb.onEmptyElement(t); }
-          break;
-        case TokenKind::Text:
-          if (cb.onText) { cb.onText(t); }
-          break;
-        case TokenKind::CData:
-          if (cb.onCData) { cb.onCData(t); }
-          break;
-        case TokenKind::Comment:
-          if (cb.onComment) { cb.onComment(t); }
-          break;
-        case TokenKind::ProcessingInstruction:
-          if (cb.onPI) { cb.onPI(t); }
-          break;
-        case TokenKind::Eof:
-        case TokenKind::Invalid:
-        default:
-          break;
+        cb.onCData(t);
       }
+      break;
+    case TokenKind::Comment:
+      if (cb.onComment)
+      {
+        cb.onComment(t);
+      }
+      break;
+    case TokenKind::ProcessingInstruction:
+      if (cb.onPI)
+      {
+        cb.onPI(t);
+      }
+      break;
+    case TokenKind::Eof:
+    case TokenKind::Invalid:
+    default:
+      break;
     }
-    return parser.error() == nullptr;
   }
+  return parser.error() == nullptr;
+}
 #endif // IORA_XML_ENABLE_SAX
 
 #if IORA_XML_ENABLE_DOM
-  /// \brief DOM node kinds built by DomBuilder.
-  enum class NodeType
-  {
-    Document,
-    Element,
-    Text,
-    CData,
-    Comment,
-    ProcessingInstruction
-  };
+/// \brief DOM node kinds built by DomBuilder.
+enum class NodeType
+{
+  Document,
+  Element,
+  Text,
+  CData,
+  Comment,
+  ProcessingInstruction
+};
+
+/// \brief DOM node (lightweight, immutable tree once built).
+class Node
+{
+public:
+  NodeType type{NodeType::Element};
+  std::string name;  ///< Element/PI name; empty for text/comment/cdata
+  std::string value; ///< Text content for Text/CData/Comment/PI; empty for Element/Document
 
-  /// \brief DOM node (lightweight, immutable tree once built).
-  class Node
+  struct Attr
   {
-  public:
-    NodeType type{NodeType::Element};
-    std::string name;  ///< Element/PI name; empty for text/comment/cdata
-    std::string value; ///< Text content for Text/CData/Comment/PI; empty for Element/Document
-
-    struct Attr
-    {
-      std::string name;
-      std::string value;
-    };
+    std::string name;
+    std::string value;
+  };
 
-    std::vector<Attr> attributes; ///< Attributes for Element
-    std::vector<std::unique_ptr<Node>> children; ///< Children for Element/Document
+  std::vector<Attr> attributes;                ///< Attributes for Element
+  std::vector<std::unique_ptr<Node>> children; ///< Children for Element/Document
 
-    /// \brief Find first direct child element by name; returns nullptr if none.
-    const Node *childByName(std::string_view n) const
+  /// \brief Find first direct child element by name; returns nullptr if none.
+  const Node *childByName(std::string_view n) const
+  {
+    for (const auto &c : children)
     {
-      for (const auto &c : children)
+      if (c->type == NodeType::Element && std::string_view(c->name) == n)
       {
-        if (c->type == NodeType::Element && std::string_view(c->name) == n)
-        {
-          return c.get();
-        }
+        return c.get();
       }
-      return nullptr;
     }
+    return nullptr;
+  }
 
-    /// \brief Find attribute by name; returns empty string_view if not found.
-    std::string_view getAttribute(std::string_view attrName) const
+  /// \brief Find attribute by name; returns empty string_view if not found.
+  std::string_view getAttribute(std::string_view attrName) const
+  {
+    for (const auto &attr : attributes)
     {
-      for (const auto &attr : attributes)
+      if (std::string_view(attr.name) == attrName)
       {
-        if (std::string_view(attr.name) == attrName)
-        {
-          return attr.value;
-        }
+        return attr.value;
       }
-      return std::string_view{};
     }
+    return std::string_view{};
+  }
 
-    /// \brief Get text content of all child text nodes concatenated.
-    std::string getTextContent() const
+  /// \brief Get text content of all child text nodes concatenated.
+  std::string getTextContent() const
+  {
+    std::string result;
+    for (const auto &child : children)
     {
-      std::string result;
-      for (const auto &child : children)
+      if (child->type == NodeType::Text || child->type == NodeType::CData)
       {
-        if (child->type == NodeType::Text || child->type == NodeType::CData)
-        {
-          result += child->value;
-        }
+        result += child->value;
       }
-      return result;
     }
-  };
+    return result;
+  }
+};
 
-  /// \brief Build a DOM tree from a pull parser.
-  class DomBuilder
+/// \brief Build a DOM tree from a pull parser.
+class DomBuilder
+{
+public:
+  /// \brief Build and return a unique_ptr to the Document node (root).
+  static std::unique_ptr<Node> build(Parser &parser, Error *errOut = nullptr)
   {
-  public:
-    /// \brief Build and return a unique_ptr to the Document node (root).
-    static std::unique_ptr<Node> build(Parser &parser, Error *errOut = nullptr)
-    {
-      std::unique_ptr<Node> doc = std::make_unique<Node>();
-      doc->type = NodeType::Document;
+    std::unique_ptr<Node> doc = std::make_unique<Node>();
+    doc->type = NodeType::Document;
 
-      std::vector<Node *> stack;
-      stack.push_back(doc.get());
+    std::vector<Node *> stack;
+    stack.push_back(doc.get());
 
-      while (parser.next())
+    while (parser.next())
+    {
+      const Token &t = parser.current();
+      switch (t.kind)
+      {
+      case TokenKind::StartElement:
       {
-        const Token &t = parser.current();
-        switch (t.kind)
+        auto elem = std::make_unique<Node>();
+        elem->type = NodeType::Element;
+        elem->name = std::string(t.name);
+        elem->attributes.reserve(t.attributes.size());
+        for (const auto &a : t.attributes)
         {
-          case TokenKind::StartElement:
-          {
-            auto elem = std::make_unique<Node>();
-            elem->type = NodeType::Element;
-            elem->name = std::string(t.name);
-            elem->attributes.reserve(t.attributes.size());
-            for (const auto &a : t.attributes)
-            {
-              std::string v;
-              Error tmp{};
-              if (!Parser::decodeEntities(a.value, v, &tmp))
-              {
-                if (errOut) { *errOut = tmp; }
-                return nullptr;
-              }
-              elem->attributes.push_back(Node::Attr{std::string(a.name), std::move(v)});
-            }
-            Node *parent = stack.back();
-            Node *raw = elem.get();
-            parent->children.push_back(std::move(elem));
-            stack.push_back(raw);
-            break;
-          }
-          case TokenKind::EmptyElement:
-          {
-            auto elem = std::make_unique<Node>();
-            elem->type = NodeType::Element;
-            elem->name = std::string(t.name);
-            elem->attributes.reserve(t.attributes.size());
-            for (const auto &a : t.attributes)
-            {
-              std::string v;
-              Error tmp{};
-              if (!Parser::decodeEntities(a.value, v, &tmp))
-              {
-                if (errOut) { *errOut = tmp; }
-                return nullptr;
-              }
-              elem->attributes.push_back(Node::Attr{std::string(a.name), std::move(v)});
-            }
-            Node *parent = stack.back();
-            parent->children.push_back(std::move(elem));
-            break;
-          }
-          case TokenKind::EndElement:
+          std::string v;
+          Error tmp{};
+          if (!Parser::decodeEntities(a.value, v, &tmp))
           {
-            if (stack.size() <= 1)
+            if (errOut)
             {
-              if (errOut) { *errOut = Error{t.offset, t.line, t.column, "unbalanced end element"}; }
-              return nullptr;
+              *errOut = tmp;
             }
-            Node *closed = stack.back();
-            (void)closed;
-            stack.pop_back();
-            break;
+            return nullptr;
           }
-          case TokenKind::Text:
+          elem->attributes.push_back(Node::Attr{std::string(a.name), std::move(v)});
+        }
+        Node *parent = stack.back();
+        Node *raw = elem.get();
+        parent->children.push_back(std::move(elem));
+        stack.push_back(raw);
+        break;
+      }
+      case TokenKind::EmptyElement:
+      {
+        auto elem = std::make_unique<Node>();
+        elem->type = NodeType::Element;
+        elem->name = std::string(t.name);
+        elem->attributes.reserve(t.attributes.size());
+        for (const auto &a : t.attributes)
+        {
+          std::string v;
+          Error tmp{};
+          if (!Parser::decodeEntities(a.value, v, &tmp))
           {
-            std::string v;
-            Error tmp{};
-            if (!Parser::decodeEntities(t.text, v, &tmp))
+            if (errOut)
             {
-              if (errOut) { *errOut = tmp; }
-              return nullptr;
+              *errOut = tmp;
             }
-            if (!v.empty())
-            {
-              auto n = std::make_unique<Node>();
-              n->type = NodeType::Text;
-              n->value = std::move(v);
-              stack.back()->children.push_back(std::move(n));
-            }
-            break;
-          }
-          case TokenKind::CData:
-          {
-            auto n = std::make_unique<Node>();
-            n->type = NodeType::CData;
-            n->value = std::string(t.text);
-            stack.back()->children.push_back(std::move(n));
-            break;
+            return nullptr;
           }
-          case TokenKind::Comment:
+          elem->attributes.push_back(Node::Attr{std::string(a.name), std::move(v)});
+        }
+        Node *parent = stack.back();
+        parent->children.push_back(std::move(elem));
+        break;
+      }
+      case TokenKind::EndElement:
+      {
+        if (stack.size() <= 1)
+        {
+          if (errOut)
           {
-            auto n = std::make_unique<Node>();
-            n->type = NodeType::Comment;
-            n->value = std::string(t.text);
-            stack.back()->children.push_back(std::move(n));
-            break;
+            *errOut = Error{t.offset, t.line, t.column, "unbalanced end element"};
           }
-          case TokenKind::ProcessingInstruction:
+          return nullptr;
+        }
+        Node *closed = stack.back();
+        (void)closed;
+        stack.pop_back();
+        break;
+      }
+      case TokenKind::Text:
+      {
+        std::string v;
+        Error tmp{};
+        if (!Parser::decodeEntities(t.text, v, &tmp))
+        {
+          if (errOut)
           {
-            auto n = std::make_unique<Node>();
-            n->type = NodeType::ProcessingInstruction;
-            n->name = std::string(t.name);
-            n->value = std::string(t.text);
-            stack.back()->children.push_back(std::move(n));
-            break;
+            *errOut = tmp;
           }
-          case TokenKind::XmlDecl:
-          case TokenKind::Doctype:
-          case TokenKind::Invalid:
-          case TokenKind::Eof:
-          default:
-            break;
+          return nullptr;
         }
+        if (!v.empty())
+        {
+          auto n = std::make_unique<Node>();
+          n->type = NodeType::Text;
+          n->value = std::move(v);
+          stack.back()->children.push_back(std::move(n));
+        }
+        break;
+      }
+      case TokenKind::CData:
+      {
+        auto n = std::make_unique<Node>();
+        n->type = NodeType::CData;
+        n->value = std::string(t.text);
+        stack.back()->children.push_back(std::move(n));
+        break;
+      }
+      case TokenKind::Comment:
+      {
+        auto n = std::make_unique<Node>();
+        n->type = NodeType::Comment;
+        n->value = std::string(t.text);
+        stack.back()->children.push_back(std::move(n));
+        break;
+      }
+      case TokenKind::ProcessingInstruction:
+      {
+        auto n = std::make_unique<Node>();
+        n->type = NodeType::ProcessingInstruction;
+        n->name = std::string(t.name);
+        n->value = std::string(t.text);
+        stack.back()->children.push_back(std::move(n));
+        break;
+      }
+      case TokenKind::XmlDecl:
+      case TokenKind::Doctype:
+      case TokenKind::Invalid:
+      case TokenKind::Eof:
+      default:
+        break;
       }
+    }
 
-      if (const Error *e = parser.error())
+    if (const Error *e = parser.error())
+    {
+      if (errOut)
       {
-        if (errOut) { *errOut = *e; }
-        return nullptr;
+        *errOut = *e;
       }
-      if (stack.size() != 1)
+      return nullptr;
+    }
+    if (stack.size() != 1)
+    {
+      if (errOut)
       {
-        if (errOut) { *errOut = Error{0, 0, 0, "unclosed elements at end of document"}; }
-        return nullptr;
+        *errOut = Error{0, 0, 0, "unclosed elements at end of document"};
       }
-      return doc;
+      return nullptr;
     }
-  };
+    return doc;
+  }
+};
 #endif // IORA_XML_ENABLE_DOM
 
 } // namespace xml
diff --git a/include/iora/storage/concrete_state_store.hpp b/include/iora/storage/concrete_state_store.hpp
index 39f6699..6129382 100644
--- a/include/iora/storage/concrete_state_store.hpp
+++ b/include/iora/storage/concrete_state_store.hpp
@@ -6,200 +6,186 @@
 // details.
 
 #pragma once
-#include <unordered_map>
-#include <string>
-#include <mutex>
-#include <vector>
+#include "iora/core/logger.hpp"
 #include <algorithm>
 #include <functional>
+#include <mutex>
 #include <optional>
-#include "iora/core/logger.hpp"
+#include <string>
+#include <unordered_map>
+#include <vector>
 
 namespace iora
 {
 namespace storage
 {
 
-  /// \brief In-memory key-value store for string data with basic get/set
-  /// operations.
-  struct CaseInsensitiveHash
+/// \brief In-memory key-value store for string data with basic get/set
+/// operations.
+struct CaseInsensitiveHash
+{
+  std::size_t operator()(const std::string &key) const
   {
-    std::size_t operator()(const std::string& key) const
-    {
-      std::string lowered = key;
-      std::transform(lowered.begin(), lowered.end(), lowered.begin(),
-                     ::tolower);
-      return std::hash<std::string>{}(lowered);
-    }
-  };
+    std::string lowered = key;
+    std::transform(lowered.begin(), lowered.end(), lowered.begin(), ::tolower);
+    return std::hash<std::string>{}(lowered);
+  }
+};
 
-  struct CaseInsensitiveEqual
+struct CaseInsensitiveEqual
+{
+  bool operator()(const std::string &lhs, const std::string &rhs) const
   {
-    bool operator()(const std::string& lhs, const std::string& rhs) const
-    {
-      return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(),
-                        [](char a, char b)
-                        { return std::tolower(a) == std::tolower(b); });
-    }
-  };
+    return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(),
+                      [](char a, char b) { return std::tolower(a) == std::tolower(b); });
+  }
+};
 
-  class ConcreteStateStore
+class ConcreteStateStore
+{
+public:
+  /// \brief Sets a key-value pair in the store.
+  void set(const std::string &key, const std::string &value)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    bool isUpdate = _store.find(key) != _store.end();
+    _store[key] = value;
+    iora::core::Logger::debug(std::string("ConcreteStateStore: ") +
+                              (isUpdate ? "Updated" : "Added") + " key '" + key +
+                              "' (total keys: " + std::to_string(_store.size()) + ")");
+  }
+
+  /// \brief Gets a value by key from the store.
+  std::optional<std::string> get(const std::string &key) const
   {
-  public:
-    /// \brief Sets a key-value pair in the store.
-    void set(const std::string& key, const std::string& value)
+    std::lock_guard<std::mutex> lock(_mutex);
+    auto it = _store.find(key);
+    if (it != _store.end())
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      bool isUpdate = _store.find(key) != _store.end();
-      _store[key] = value;
-      iora::core::Logger::debug(
-          std::string("ConcreteStateStore: ") +
-          (isUpdate ? "Updated" : "Added") + " key '" + key +
-          "' (total keys: " + std::to_string(_store.size()) + ")");
+      iora::core::Logger::debug("ConcreteStateStore: Retrieved value for key '" + key +
+                                "' (length: " + std::to_string(it->second.length()) + " chars)");
+      return it->second;
     }
+    iora::core::Logger::debug("ConcreteStateStore: Key '" + key + "' not found");
+    return std::nullopt;
+  }
 
-    /// \brief Gets a value by key from the store.
-    std::optional<std::string> get(const std::string& key) const
+  /// \brief Removes a key from the store.
+  bool remove(const std::string &key)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    auto result = _store.erase(key) > 0;
+    if (result)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      auto it = _store.find(key);
-      if (it != _store.end())
-      {
-        iora::core::Logger::debug(
-            "ConcreteStateStore: Retrieved value for key '" + key +
-            "' (length: " + std::to_string(it->second.length()) + " chars)");
-        return it->second;
-      }
-      iora::core::Logger::debug("ConcreteStateStore: Key '" + key +
-                                "' not found");
-      return std::nullopt;
+      iora::core::Logger::debug("ConcreteStateStore: Removed key '" + key +
+                                "' (remaining keys: " + std::to_string(_store.size()) + ")");
     }
-
-    /// \brief Removes a key from the store.
-    bool remove(const std::string& key)
+    else
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      auto result = _store.erase(key) > 0;
-      if (result)
-      {
-        iora::core::Logger::debug(
-            "ConcreteStateStore: Removed key '" + key +
-            "' (remaining keys: " + std::to_string(_store.size()) + ")");
-      }
-      else
-      {
-        iora::core::Logger::debug(
-            "ConcreteStateStore: Attempted to remove non-existent key '" + key +
-            "'");
-      }
-      return result;
+      iora::core::Logger::debug("ConcreteStateStore: Attempted to remove non-existent key '" + key +
+                                "'");
     }
+    return result;
+  }
 
-    /// \brief Checks if a key exists in the store.
-    bool contains(const std::string& key) const
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      return _store.find(key) != _store.end();
-    }
+  /// \brief Checks if a key exists in the store.
+  bool contains(const std::string &key) const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _store.find(key) != _store.end();
+  }
 
-    /// \brief Returns all keys in the store.
-    std::vector<std::string> keys() const
+  /// \brief Returns all keys in the store.
+  std::vector<std::string> keys() const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    std::vector<std::string> result;
+    result.reserve(_store.size());
+    for (const auto &[k, _] : _store)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      std::vector<std::string> result;
-      result.reserve(_store.size());
-      for (const auto& [k, _] : _store)
-      {
-        result.push_back(k);
-      }
-      return result;
+      result.push_back(k);
     }
+    return result;
+  }
 
-    /// \brief Returns the number of entries in the store.
-    std::size_t size() const
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      return _store.size();
-    }
+  /// \brief Returns the number of entries in the store.
+  std::size_t size() const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _store.size();
+  }
 
-    /// \brief Returns true if the store is empty.
-    bool empty() const
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      return _store.empty();
-    }
+  /// \brief Returns true if the store is empty.
+  bool empty() const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _store.empty();
+  }
 
-    /// \brief Finds all keys with the given prefix.
-    std::vector<std::string> findKeysWithPrefix(const std::string& prefix) const
+  /// \brief Finds all keys with the given prefix.
+  std::vector<std::string> findKeysWithPrefix(const std::string &prefix) const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    std::vector<std::string> result;
+    for (const auto &[key, _] : _store)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      std::vector<std::string> result;
-      for (const auto& [key, _] : _store)
+      if (key.rfind(prefix, 0) == 0) // key starts with prefix
       {
-        if (key.rfind(prefix, 0) == 0) // key starts with prefix
-        {
-          result.push_back(key);
-        }
+        result.push_back(key);
       }
-      iora::core::Logger::debug("ConcreteStateStore: Found " +
-                                std::to_string(result.size()) +
-                                " keys with prefix '" + prefix + "'");
-      return result;
     }
+    iora::core::Logger::debug("ConcreteStateStore: Found " + std::to_string(result.size()) +
+                              " keys with prefix '" + prefix + "'");
+    return result;
+  }
 
-    /// \brief Finds all keys whose values match the provided value.
-    std::vector<std::string> findKeysByValue(const std::string& value) const
+  /// \brief Finds all keys whose values match the provided value.
+  std::vector<std::string> findKeysByValue(const std::string &value) const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    std::vector<std::string> result;
+    for (const auto &[key, val] : _store)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      std::vector<std::string> result;
-      for (const auto& [key, val] : _store)
+      if (val == value)
       {
-        if (val == value)
-        {
-          result.push_back(key);
-        }
+        result.push_back(key);
       }
-      iora::core::Logger::debug("ConcreteStateStore: Found " +
-                                std::to_string(result.size()) +
-                                " keys with matching value (length: " +
-                                std::to_string(value.length()) + " chars)");
-      return result;
     }
-
-    /// \brief Finds all keys satisfying a custom matcher.
-    std::vector<std::string>
-    findKeysMatching(std::function<bool(const std::string&)> matcher) const
+    iora::core::Logger::debug(
+      "ConcreteStateStore: Found " + std::to_string(result.size()) +
+      " keys with matching value (length: " + std::to_string(value.length()) + " chars)");
+    return result;
+  }
+
+  /// \brief Finds all keys satisfying a custom matcher.
+  std::vector<std::string> findKeysMatching(std::function<bool(const std::string &)> matcher) const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    std::vector<std::string> result;
+    for (const auto &[key, _] : _store)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      std::vector<std::string> result;
-      for (const auto& [key, _] : _store)
+      try
       {
-        try
+        if (matcher(key))
         {
-          if (matcher(key))
-          {
-            result.push_back(key);
-          }
-        }
-        catch (const std::exception& e)
-        {
-          iora::core::Logger::error(
-              "ConcreteStateStore: Matcher function threw exception for key '" +
-              key + "': " + e.what());
+          result.push_back(key);
         }
       }
-      iora::core::Logger::debug("ConcreteStateStore: Found " +
-                                std::to_string(result.size()) +
-                                " keys matching custom criteria");
-      return result;
+      catch (const std::exception &e)
+      {
+        iora::core::Logger::error("ConcreteStateStore: Matcher function threw exception for key '" +
+                                  key + "': " + e.what());
+      }
     }
-
-  private:
-    mutable std::mutex _mutex;
-    std::unordered_map<std::string, std::string, CaseInsensitiveHash,
-                       CaseInsensitiveEqual>
-        _store;
-  };
+    iora::core::Logger::debug("ConcreteStateStore: Found " + std::to_string(result.size()) +
+                              " keys matching custom criteria");
+    return result;
+  }
+
+private:
+  mutable std::mutex _mutex;
+  std::unordered_map<std::string, std::string, CaseInsensitiveHash, CaseInsensitiveEqual> _store;
+};
 
 } // namespace storage
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/storage/json_file_store.hpp b/include/iora/storage/json_file_store.hpp
index f76f73d..679a910 100644
--- a/include/iora/storage/json_file_store.hpp
+++ b/include/iora/storage/json_file_store.hpp
@@ -6,353 +6,327 @@
 // details.
 
 #pragma once
+#include "iora/core/logger.hpp"
+#include "iora/parsers/json.hpp"
+#include <condition_variable>
 #include <fstream>
 #include <mutex>
 #include <set>
 #include <thread>
-#include <condition_variable>
-#include "iora/parsers/json.hpp"
-#include "iora/core/logger.hpp"
 
 namespace iora
 {
 namespace storage
 {
 
-  /// \brief Thread-safe key-value store backed by a JSON file with background
-  /// flushing and persistence.
-  class JsonFileStore
+/// \brief Thread-safe key-value store backed by a JSON file with background
+/// flushing and persistence.
+class JsonFileStore
+{
+public:
+  /// \brief Construct and load JSON file if it exists
+  explicit JsonFileStore(std::string filename) : _filename(std::move(filename)), _dirty(false)
   {
-  public:
-    /// \brief Construct and load JSON file if it exists
-    explicit JsonFileStore(std::string filename)
-      : _filename(std::move(filename)), _dirty(false)
+    iora::core::Logger::info("JsonFileStore: Initializing with file: " + _filename);
+    std::ifstream file(_filename);
+    if (file)
     {
-      iora::core::Logger::info("JsonFileStore: Initializing with file: " +
-                               _filename);
-      std::ifstream file(_filename);
-      if (file)
+      try
       {
-        try
-        {
-          file >> _store;
-          iora::core::Logger::info("JsonFileStore: Loaded existing data with " +
-                                   std::to_string(_store.size()) +
-                                   " keys from: " + _filename);
-        }
-        catch (const std::exception& e)
-        {
-          iora::core::Logger::error(
-              "JsonFileStore: Failed to parse JSON from " + _filename + ": " +
-              e.what() + " - starting with empty store");
-          _store = parsers::Json::object();
-        }
+        file >> _store;
+        iora::core::Logger::info("JsonFileStore: Loaded existing data with " +
+                                 std::to_string(_store.size()) + " keys from: " + _filename);
       }
-      else
+      catch (const std::exception &e)
       {
-        iora::core::Logger::info("JsonFileStore: File " + _filename +
-                                 " does not exist, starting with empty store");
+        iora::core::Logger::error("JsonFileStore: Failed to parse JSON from " + _filename + ": " +
+                                  e.what() + " - starting with empty store");
         _store = parsers::Json::object();
       }
-
-      registerStore();
     }
-
-    /// \brief Destructor unregisters the store
-    ~JsonFileStore()
+    else
     {
-      iora::core::Logger::debug("JsonFileStore: Destructor called for " +
-                                _filename);
-      unregisterStore();
-      flush();
-      iora::core::Logger::debug("JsonFileStore: Cleanup completed for " +
-                                _filename);
+      iora::core::Logger::info("JsonFileStore: File " + _filename +
+                               " does not exist, starting with empty store");
+      _store = parsers::Json::object();
     }
 
-    /// \brief Set a key to a value and mark store dirty
-    template <typename T> void set(const std::string& key, const T& value)
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      bool isUpdate = _store.contains(key);
-      _store[key] = value;
-      _dirty = true;
-      iora::core::Logger::debug(
-          std::string("JsonFileStore: ") + (isUpdate ? "Updated" : "Added") +
-          " key '" + key + "' in " + _filename +
-          " (total keys: " + std::to_string(_store.size()) + ")");
-    }
+    registerStore();
+  }
 
-    /// \brief Specialization for std::string
-    void set(const std::string& key, const std::string& value)
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      bool isUpdate = _store.contains(key);
-      _store[key] = value;
-      _dirty = true;
-      iora::core::Logger::debug(
-          std::string("JsonFileStore: ") + (isUpdate ? "Updated" : "Added") +
-          " string key '" + key + "' in " + _filename +
-          " (value length: " + std::to_string(value.length()) +
-          " chars, total keys: " + std::to_string(_store.size()) + ")");
-    }
+  /// \brief Destructor unregisters the store
+  ~JsonFileStore()
+  {
+    iora::core::Logger::debug("JsonFileStore: Destructor called for " + _filename);
+    unregisterStore();
+    flush();
+    iora::core::Logger::debug("JsonFileStore: Cleanup completed for " + _filename);
+  }
 
-    /// \brief Get a value from the store
-    template <typename T> std::optional<T> get(const std::string& key) const
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      if (_store.contains(key))
-      {
-        try
-        {
-          auto val = _store[key].get<T>();
-          iora::core::Logger::debug("JsonFileStore: Retrieved value for key '" +
-                                    key + "' from " + _filename);
-          return val;
-        }
-        catch (const std::exception& e)
-        {
-          iora::core::Logger::error(
-              "JsonFileStore: Type conversion failed for key '" + key +
-              "' in " + _filename + ": " + e.what());
-          return std::nullopt;
-        }
-      }
-      iora::core::Logger::debug("JsonFileStore: Key '" + key +
-                                "' not found in " + _filename);
-      return std::nullopt;
-    }
+  /// \brief Set a key to a value and mark store dirty
+  template <typename T> void set(const std::string &key, const T &value)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    bool isUpdate = _store.contains(key);
+    _store[key] = value;
+    _dirty = true;
+    iora::core::Logger::debug(std::string("JsonFileStore: ") + (isUpdate ? "Updated" : "Added") +
+                              " key '" + key + "' in " + _filename +
+                              " (total keys: " + std::to_string(_store.size()) + ")");
+  }
 
-    /// \brief Specialization for std::string
-    std::optional<std::string> get(const std::string& key) const
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      if (_store.contains(key))
-      {
-        try
-        {
-          auto val = _store[key].get<std::string>();
-          iora::core::Logger::debug(
-              "JsonFileStore: Retrieved string value for key '" + key +
-              "' from " + _filename +
-              " (length: " + std::to_string(val.length()) + " chars)");
-          return val;
-        }
-        catch (const std::exception& e)
-        {
-          iora::core::Logger::error(
-              "JsonFileStore: String conversion failed for key '" + key +
-              "' in " + _filename + ": " + e.what());
-          return std::nullopt;
-        }
-      }
-      iora::core::Logger::debug("JsonFileStore: String key '" + key +
-                                "' not found in " + _filename);
-      return std::nullopt;
-    }
+  /// \brief Specialization for std::string
+  void set(const std::string &key, const std::string &value)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    bool isUpdate = _store.contains(key);
+    _store[key] = value;
+    _dirty = true;
+    iora::core::Logger::debug(std::string("JsonFileStore: ") + (isUpdate ? "Updated" : "Added") +
+                              " string key '" + key + "' in " + _filename +
+                              " (value length: " + std::to_string(value.length()) +
+                              " chars, total keys: " + std::to_string(_store.size()) + ")");
+  }
 
-    /// \brief Remove a key from the store and mark dirty
-    void remove(const std::string& key)
+  /// \brief Get a value from the store
+  template <typename T> std::optional<T> get(const std::string &key) const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    if (_store.contains(key))
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      auto it = _store.find(key);
-      if (it != _store.endObject())
+      try
       {
-        _store.erase(it);
-        _dirty = true;
-        iora::core::Logger::debug(
-            "JsonFileStore: Removed key '" + key + "' from " + _filename +
-            " (remaining keys: " + std::to_string(_store.size()) + ")");
+        auto val = _store[key].get<T>();
+        iora::core::Logger::debug("JsonFileStore: Retrieved value for key '" + key + "' from " +
+                                  _filename);
+        return val;
       }
-      else
+      catch (const std::exception &e)
       {
-        iora::core::Logger::debug(
-            "JsonFileStore: Attempted to remove non-existent key '" + key +
-            "' from " + _filename);
+        iora::core::Logger::error("JsonFileStore: Type conversion failed for key '" + key +
+                                  "' in " + _filename + ": " + e.what());
+        return std::nullopt;
       }
     }
+    iora::core::Logger::debug("JsonFileStore: Key '" + key + "' not found in " + _filename);
+    return std::nullopt;
+  }
 
-    /// \brief Immediately write the store to disk
-    void flush()
+  /// \brief Specialization for std::string
+  std::optional<std::string> get(const std::string &key) const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    if (_store.contains(key))
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      if (_dirty)
+      try
       {
-        iora::core::Logger::debug("JsonFileStore: Flushing " +
-                                  std::to_string(_store.size()) + " keys to " +
-                                  _filename);
-        saveToFile();
-        _dirty = false;
-        iora::core::Logger::debug("JsonFileStore: Flush completed for " +
-                                  _filename);
+        auto val = _store[key].get<std::string>();
+        iora::core::Logger::debug("JsonFileStore: Retrieved string value for key '" + key +
+                                  "' from " + _filename +
+                                  " (length: " + std::to_string(val.length()) + " chars)");
+        return val;
       }
-      else
+      catch (const std::exception &e)
       {
-        iora::core::Logger::debug("JsonFileStore: No changes to flush for " +
-                                  _filename);
+        iora::core::Logger::error("JsonFileStore: String conversion failed for key '" + key +
+                                  "' in " + _filename + ": " + e.what());
+        return std::nullopt;
       }
     }
+    iora::core::Logger::debug("JsonFileStore: String key '" + key + "' not found in " + _filename);
+    return std::nullopt;
+  }
 
-    /// \brief Configure the background flush interval (in milliseconds)
-    static std::set<JsonFileStore*>& registry()
-    {
-      static std::set<JsonFileStore*> s;
-      return s;
-    }
-    static std::mutex& registryMutex()
-    {
-      static std::mutex m;
-      return m;
-    }
-    static std::thread& flushThread()
-    {
-      static std::thread t;
-      return t;
-    }
-    static std::chrono::milliseconds& flushInterval()
-    {
-      static std::chrono::milliseconds ms{2000};
-      return ms;
-    }
-    static std::condition_variable& terminationCv()
+  /// \brief Remove a key from the store and mark dirty
+  void remove(const std::string &key)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    auto it = _store.find(key);
+    if (it != _store.endObject())
     {
-      static std::condition_variable cv;
-      return cv;
+      _store.erase(it);
+      _dirty = true;
+      iora::core::Logger::debug("JsonFileStore: Removed key '" + key + "' from " + _filename +
+                                " (remaining keys: " + std::to_string(_store.size()) + ")");
     }
-    static std::mutex& terminateCvMutex()
+    else
     {
-      static std::mutex m;
-      return m;
+      iora::core::Logger::debug("JsonFileStore: Attempted to remove non-existent key '" + key +
+                                "' from " + _filename);
     }
-    static std::atomic<bool>& shouldExit()
+  }
+
+  /// \brief Immediately write the store to disk
+  void flush()
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    if (_dirty)
     {
-      static std::atomic<bool> flag{false};
-      return flag;
+      iora::core::Logger::debug("JsonFileStore: Flushing " + std::to_string(_store.size()) +
+                                " keys to " + _filename);
+      saveToFile();
+      _dirty = false;
+      iora::core::Logger::debug("JsonFileStore: Flush completed for " + _filename);
     }
-    static void setFlushInterval(std::chrono::milliseconds interval)
+    else
     {
-      flushInterval() = interval;
+      iora::core::Logger::debug("JsonFileStore: No changes to flush for " + _filename);
     }
+  }
 
-  private:
-    void saveToFile() const
+  /// \brief Configure the background flush interval (in milliseconds)
+  static std::set<JsonFileStore *> &registry()
+  {
+    static std::set<JsonFileStore *> s;
+    return s;
+  }
+  static std::mutex &registryMutex()
+  {
+    static std::mutex m;
+    return m;
+  }
+  static std::thread &flushThread()
+  {
+    static std::thread t;
+    return t;
+  }
+  static std::chrono::milliseconds &flushInterval()
+  {
+    static std::chrono::milliseconds ms{2000};
+    return ms;
+  }
+  static std::condition_variable &terminationCv()
+  {
+    static std::condition_variable cv;
+    return cv;
+  }
+  static std::mutex &terminateCvMutex()
+  {
+    static std::mutex m;
+    return m;
+  }
+  static std::atomic<bool> &shouldExit()
+  {
+    static std::atomic<bool> flag{false};
+    return flag;
+  }
+  static void setFlushInterval(std::chrono::milliseconds interval) { flushInterval() = interval; }
+
+private:
+  void saveToFile() const
+  {
+    try
     {
-      try
+      std::ofstream file(_filename);
+      if (file)
       {
-        std::ofstream file(_filename);
-        if (file)
-        {
-          std::string jsonData = _store.dump(2);
-          file << jsonData;
-          iora::core::Logger::debug("JsonFileStore: Wrote " +
-                                    std::to_string(jsonData.length()) +
-                                    " bytes to " + _filename);
-        }
-        else
-        {
-          iora::core::Logger::error("JsonFileStore: Failed to open " +
-                                    _filename + " for writing");
-        }
+        std::string jsonData = _store.dump(2);
+        file << jsonData;
+        iora::core::Logger::debug("JsonFileStore: Wrote " + std::to_string(jsonData.length()) +
+                                  " bytes to " + _filename);
       }
-      catch (const std::exception& e)
+      else
       {
-        iora::core::Logger::error("JsonFileStore: Failed to write to " +
-                                  _filename + ": " + e.what());
+        iora::core::Logger::error("JsonFileStore: Failed to open " + _filename + " for writing");
       }
     }
+    catch (const std::exception &e)
+    {
+      iora::core::Logger::error("JsonFileStore: Failed to write to " + _filename + ": " + e.what());
+    }
+  }
 
-    void tryFlushIfDirty()
+  void tryFlushIfDirty()
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    if (_dirty)
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      if (_dirty)
-      {
-        iora::core::Logger::debug(
-            "JsonFileStore: Background flush triggered for " + _filename);
-        saveToFile();
-        _dirty = false;
-      }
+      iora::core::Logger::debug("JsonFileStore: Background flush triggered for " + _filename);
+      saveToFile();
+      _dirty = false;
     }
+  }
 
-    void registerStore()
+  void registerStore()
+  {
+    std::lock_guard<std::mutex> lock(registryMutex());
+    registry().insert(this);
+    if (registry().size() == 1)
     {
-      std::lock_guard<std::mutex> lock(registryMutex());
-      registry().insert(this);
-      if (registry().size() == 1)
-      {
-        shouldExit() = false;
-        flushThread() = std::thread(flushThreadFunc);
-      }
+      shouldExit() = false;
+      flushThread() = std::thread(flushThreadFunc);
     }
+  }
 
-    void unregisterStore()
+  void unregisterStore()
+  {
+    std::lock_guard<std::mutex> lock(registryMutex());
+    registry().erase(this);
+    if (registry().empty())
     {
-      std::lock_guard<std::mutex> lock(registryMutex());
-      registry().erase(this);
-      if (registry().empty())
+      IORA_LOG_INFO("No more stores registered, stopping flush thread");
+      shouldExit() = true;
+      terminationCv().notify_all();
+      if (flushThread().joinable())
       {
-        IORA_LOG_INFO("No more stores registered, stopping flush thread");
-        shouldExit() = true;
-        terminationCv().notify_all();
-        if (flushThread().joinable())
-        {
-          flushThread().join();
-        }
-        flushThread() = std::thread(); // Reset thread
-        IORA_LOG_INFO("Flush thread stopped");
+        flushThread().join();
       }
+      flushThread() = std::thread(); // Reset thread
+      IORA_LOG_INFO("Flush thread stopped");
     }
+  }
 
-    static void flushThreadFunc()
+  static void flushThreadFunc()
+  {
+    while (!shouldExit())
     {
-      while (!shouldExit())
       {
+        std::unique_lock<std::mutex> lock(terminateCvMutex());
+        if (terminationCv().wait_for(lock, flushInterval()) != std::cv_status::timeout)
         {
-          std::unique_lock<std::mutex> lock(terminateCvMutex());
-          if (terminationCv().wait_for(lock, flushInterval()) !=
-              std::cv_status::timeout)
+          // Notified - check if we should exit
+          if (shouldExit())
           {
-            // Notified - check if we should exit
-            if (shouldExit())
-            {
-              break;
-            }
+            break;
           }
         }
-        
-        // Check again after waking up
+      }
+
+      // Check again after waking up
+      if (shouldExit())
+      {
+        break;
+      }
+
+      // Copy the registry under lock to avoid race conditions
+      std::set<JsonFileStore *> storesToFlush;
+      {
+        std::lock_guard<std::mutex> lock(registryMutex());
         if (shouldExit())
         {
           break;
         }
-        
-        // Copy the registry under lock to avoid race conditions
-        std::set<JsonFileStore*> storesToFlush;
-        {
-          std::lock_guard<std::mutex> lock(registryMutex());
-          if (shouldExit())
-          {
-            break;
-          }
-          storesToFlush = registry();
-        }
-        
-        // Now iterate over the copy without holding the registry lock
-        for (auto* store : storesToFlush)
+        storesToFlush = registry();
+      }
+
+      // Now iterate over the copy without holding the registry lock
+      for (auto *store : storesToFlush)
+      {
+        if (shouldExit())
         {
-          if (shouldExit())
-          {
-            break;
-          }
-          store->tryFlushIfDirty();
+          break;
         }
+        store->tryFlushIfDirty();
       }
     }
+  }
 
-    const std::string _filename;
-    mutable std::mutex _mutex;
-    parsers::Json _store;
-    bool _dirty;
-    // All statics are now function-local for safe destruction order
-  };
+  const std::string _filename;
+  mutable std::mutex _mutex;
+  parsers::Json _store;
+  bool _dirty;
+  // All statics are now function-local for safe destruction order
+};
 
 } // namespace storage
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/system/shell_runner.hpp b/include/iora/system/shell_runner.hpp
index 175a464..dbc3c18 100644
--- a/include/iora/system/shell_runner.hpp
+++ b/include/iora/system/shell_runner.hpp
@@ -7,270 +7,255 @@
 
 #pragma once
 
-#include <string>
-#include <stdexcept>
-#include <memory>
 #include <array>
-#include <vector>
-#include <unordered_map>
-#include <ostream>
 #include <chrono>
 #include <cstdio>
-#include <unistd.h>
-#include <sys/wait.h>
-#include <signal.h>
 #include <fcntl.h>
+#include <memory>
+#include <ostream>
+#include <signal.h>
+#include <stdexcept>
+#include <string>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <unordered_map>
+#include <vector>
 
 namespace iora
 {
 namespace system
 {
 
-  /// \brief Result of command execution with detailed information.
-  struct ExecutionResult
-  {
-    int exitCode = 0;
-    std::string stdout;
-    std::string stderr;
-    bool timedOut = false;
-    std::chrono::milliseconds duration{0};
-  };
-
-  /// \brief Options for command execution.
-  struct ExecutionOptions
-  {
-    std::unordered_map<std::string, std::string> environment;
-    std::string workingDirectory;
-    std::string input;
-    std::chrono::milliseconds timeout{0}; // 0 = no timeout
-    bool captureStderr = false;
-    bool throwOnError = true;
-  };
-
-  /// \brief Executes shell commands and captures their output.
-  class ShellRunner
+/// \brief Result of command execution with detailed information.
+struct ExecutionResult
+{
+  int exitCode = 0;
+  std::string stdout;
+  std::string stderr;
+  bool timedOut = false;
+  std::chrono::milliseconds duration{0};
+};
+
+/// \brief Options for command execution.
+struct ExecutionOptions
+{
+  std::unordered_map<std::string, std::string> environment;
+  std::string workingDirectory;
+  std::string input;
+  std::chrono::milliseconds timeout{0}; // 0 = no timeout
+  bool captureStderr = false;
+  bool throwOnError = true;
+};
+
+/// \brief Executes shell commands and captures their output.
+class ShellRunner
+{
+public:
+  /// \brief Executes a shell command and returns output as string.
+  /// \param command The shell command to execute.
+  /// \return The output of the command.
+  static std::string execute(const std::string &command)
   {
-  public:
-    /// \brief Executes a shell command and returns output as string.
-    /// \param command The shell command to execute.
-    /// \return The output of the command.
-    static std::string execute(const std::string& command)
+    std::array<char, 128> buffer;
+    std::string result;
+
+    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(command.c_str(), "r"), pclose);
+
+    if (!pipe)
     {
-      std::array<char, 128> buffer;
-      std::string result;
+      throw std::runtime_error("ShellRunner error: Failed to open pipe for command execution");
+    }
 
-      std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(command.c_str(), "r"),
-                                                    pclose);
+    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr)
+    {
+      result += buffer.data();
+    }
 
-      if (!pipe)
-      {
-        throw std::runtime_error(
-            "ShellRunner error: Failed to open pipe for command execution");
-      }
+    int exit_code = pclose(pipe.release());
 
-      while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr)
-      {
-        result += buffer.data();
-      }
+    if (exit_code != 0)
+    {
+      throw std::runtime_error("ShellRunner error: Command failed with exit code " +
+                               std::to_string(WEXITSTATUS(exit_code)));
+    }
 
-      int exit_code = pclose(pipe.release());
+    return result;
+  }
 
-      if (exit_code != 0)
-      {
-        throw std::runtime_error(
-            "ShellRunner error: Command failed with exit code " +
-            std::to_string(WEXITSTATUS(exit_code)));
-      }
+  /// \brief Executes a shell command and streams output to provided stream.
+  /// \param command The shell command to execute.
+  /// \param output Stream to write command output to.
+  /// \return Exit code of the command.
+  static int execute(const std::string &command, std::ostream &output)
+  {
+    std::array<char, 128> buffer;
 
-      return result;
+    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(command.c_str(), "r"), pclose);
+
+    if (!pipe)
+    {
+      throw std::runtime_error("ShellRunner error: Failed to open pipe for command execution");
     }
 
-    /// \brief Executes a shell command and streams output to provided stream.
-    /// \param command The shell command to execute.
-    /// \param output Stream to write command output to.
-    /// \return Exit code of the command.
-    static int execute(const std::string& command, std::ostream& output)
+    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr)
     {
-      std::array<char, 128> buffer;
+      output << buffer.data();
+      output.flush(); // Ensure real-time streaming
+    }
+
+    int exit_code = pclose(pipe.release());
+    return WEXITSTATUS(exit_code);
+  }
+
+  /// \brief Executes a shell command with advanced options.
+  /// \param command The shell command to execute.
+  /// \param options Execution options (timeout, environment, etc.).
+  /// \return Detailed execution result.
+  static ExecutionResult executeWithOptions(const std::string &command,
+                                            const ExecutionOptions &options = {})
+  {
+    auto start_time = std::chrono::steady_clock::now();
+    ExecutionResult result;
+
+    // Build command with environment and working directory
+    std::string full_command = buildCommand(command, options);
 
-      std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(command.c_str(), "r"),
-                                                    pclose);
+    // Execute command
+    std::array<char, 128> buffer;
+    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(full_command.c_str(), "r"), pclose);
 
-      if (!pipe)
+    if (!pipe)
+    {
+      if (options.throwOnError)
       {
-        throw std::runtime_error(
-            "ShellRunner error: Failed to open pipe for command execution");
+        throw std::runtime_error("ShellRunner error: Failed to open pipe for command execution");
       }
+      result.exitCode = -1;
+      return result;
+    }
 
+    // Read output with optional timeout
+    if (options.timeout.count() > 0)
+    {
+      result = readWithTimeout(pipe.get(), options.timeout);
+    }
+    else
+    {
       while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr)
       {
-        output << buffer.data();
-        output.flush(); // Ensure real-time streaming
+        result.stdout += buffer.data();
       }
-
-      int exit_code = pclose(pipe.release());
-      return WEXITSTATUS(exit_code);
     }
 
-    /// \brief Executes a shell command with advanced options.
-    /// \param command The shell command to execute.
-    /// \param options Execution options (timeout, environment, etc.).
-    /// \return Detailed execution result.
-    static ExecutionResult
-    executeWithOptions(const std::string& command,
-                       const ExecutionOptions& options = {})
+    int exit_code = pclose(pipe.release());
+    result.exitCode = WEXITSTATUS(exit_code);
+
+    auto end_time = std::chrono::steady_clock::now();
+    result.duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
+
+    if (options.throwOnError && result.exitCode != 0 && !result.timedOut)
     {
-      auto start_time = std::chrono::steady_clock::now();
-      ExecutionResult result;
+      throw std::runtime_error("ShellRunner error: Command failed with exit code " +
+                               std::to_string(result.exitCode));
+    }
 
-      // Build command with environment and working directory
-      std::string full_command = buildCommand(command, options);
+    return result;
+  }
 
-      // Execute command
-      std::array<char, 128> buffer;
-      std::unique_ptr<FILE, decltype(&pclose)> pipe(
-          popen(full_command.c_str(), "r"), pclose);
+  /// \brief Executes a command with input provided via stdin.
+  /// \param command The shell command to execute.
+  /// \param input Input to provide to the command via stdin.
+  /// \return The output of the command.
+  static std::string executeWithInput(const std::string &command, const std::string &input)
+  {
+    // Create temporary file for input
+    std::string temp_file = "/tmp/iora_shell_input_" + std::to_string(getpid());
 
-      if (!pipe)
-      {
-        if (options.throwOnError)
-        {
-          throw std::runtime_error(
-              "ShellRunner error: Failed to open pipe for command execution");
-        }
-        result.exitCode = -1;
-        return result;
-      }
+    // Write input to temporary file
+    FILE *temp = fopen(temp_file.c_str(), "w");
+    if (!temp)
+    {
+      throw std::runtime_error("ShellRunner error: Failed to create temporary input file");
+    }
 
-      // Read output with optional timeout
-      if (options.timeout.count() > 0)
-      {
-        result = readWithTimeout(pipe.get(), options.timeout);
-      }
-      else
-      {
-        while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr)
-        {
-          result.stdout += buffer.data();
-        }
-      }
+    fwrite(input.c_str(), 1, input.size(), temp);
+    fclose(temp);
 
-      int exit_code = pclose(pipe.release());
-      result.exitCode = WEXITSTATUS(exit_code);
+    // Execute command with input redirection
+    std::string full_command = command + " < " + temp_file;
+    std::string result = execute(full_command);
 
-      auto end_time = std::chrono::steady_clock::now();
-      result.duration = std::chrono::duration_cast<std::chrono::milliseconds>(
-          end_time - start_time);
+    // Clean up temporary file
+    unlink(temp_file.c_str());
 
-      if (options.throwOnError && result.exitCode != 0 && !result.timedOut)
-      {
-        throw std::runtime_error(
-            "ShellRunner error: Command failed with exit code " +
-            std::to_string(result.exitCode));
-      }
+    return result;
+  }
 
-      return result;
+private:
+  static std::string buildCommand(const std::string &command, const ExecutionOptions &options)
+  {
+    std::string full_command;
+
+    // Add environment variables
+    for (const auto &env : options.environment)
+    {
+      full_command += env.first + "=" + env.second + " ";
     }
 
-    /// \brief Executes a command with input provided via stdin.
-    /// \param command The shell command to execute.
-    /// \param input Input to provide to the command via stdin.
-    /// \return The output of the command.
-    static std::string executeWithInput(const std::string& command,
-                                        const std::string& input)
+    // Add working directory change
+    if (!options.workingDirectory.empty())
     {
-      // Create temporary file for input
-      std::string temp_file =
-          "/tmp/iora_shell_input_" + std::to_string(getpid());
+      full_command += "cd " + options.workingDirectory + " && ";
+    }
 
-      // Write input to temporary file
-      FILE* temp = fopen(temp_file.c_str(), "w");
-      if (!temp)
-      {
-        throw std::runtime_error(
-            "ShellRunner error: Failed to create temporary input file");
-      }
+    full_command += command;
 
-      fwrite(input.c_str(), 1, input.size(), temp);
-      fclose(temp);
+    return full_command;
+  }
 
-      // Execute command with input redirection
-      std::string full_command = command + " < " + temp_file;
-      std::string result = execute(full_command);
+  static ExecutionResult readWithTimeout(FILE *pipe, std::chrono::milliseconds timeout)
+  {
+    ExecutionResult result;
+    std::array<char, 128> buffer;
 
-      // Clean up temporary file
-      unlink(temp_file.c_str());
+    auto start_time = std::chrono::steady_clock::now();
 
-      return result;
-    }
+    // Set pipe to non-blocking mode
+    int fd = fileno(pipe);
+    int flags = fcntl(fd, F_GETFL, 0);
+    fcntl(fd, F_SETFL, flags | O_NONBLOCK);
 
-  private:
-    static std::string buildCommand(const std::string& command,
-                                    const ExecutionOptions& options)
+    while (true)
     {
-      std::string full_command;
+      auto current_time = std::chrono::steady_clock::now();
+      auto elapsed =
+        std::chrono::duration_cast<std::chrono::milliseconds>(current_time - start_time);
 
-      // Add environment variables
-      for (const auto& env : options.environment)
+      if (elapsed >= timeout)
       {
-        full_command += env.first + "=" + env.second + " ";
+        result.timedOut = true;
+        break;
       }
 
-      // Add working directory change
-      if (!options.workingDirectory.empty())
+      char *read_result = fgets(buffer.data(), buffer.size(), pipe);
+      if (read_result != nullptr)
       {
-        full_command += "cd " + options.workingDirectory + " && ";
+        result.stdout += buffer.data();
       }
-
-      full_command += command;
-
-      return full_command;
-    }
-
-    static ExecutionResult readWithTimeout(FILE* pipe,
-                                           std::chrono::milliseconds timeout)
-    {
-      ExecutionResult result;
-      std::array<char, 128> buffer;
-
-      auto start_time = std::chrono::steady_clock::now();
-
-      // Set pipe to non-blocking mode
-      int fd = fileno(pipe);
-      int flags = fcntl(fd, F_GETFL, 0);
-      fcntl(fd, F_SETFL, flags | O_NONBLOCK);
-
-      while (true)
+      else if (feof(pipe))
       {
-        auto current_time = std::chrono::steady_clock::now();
-        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
-            current_time - start_time);
-
-        if (elapsed >= timeout)
-        {
-          result.timedOut = true;
-          break;
-        }
-
-        char* read_result = fgets(buffer.data(), buffer.size(), pipe);
-        if (read_result != nullptr)
-        {
-          result.stdout += buffer.data();
-        }
-        else if (feof(pipe))
-        {
-          break; // End of output
-        }
-        else
-        {
-          // No data available, sleep briefly
-          usleep(1000); // 1ms
-        }
+        break; // End of output
+      }
+      else
+      {
+        // No data available, sleep briefly
+        usleep(1000); // 1ms
       }
-
-      return result;
     }
-  };
+
+    return result;
+  }
+};
 
 } // namespace system
 } // namespace iora
diff --git a/include/iora/util/base64_url.hpp b/include/iora/util/base64_url.hpp
old mode 100755
new mode 100644
index 414c220..9bbee41
--- a/include/iora/util/base64_url.hpp
+++ b/include/iora/util/base64_url.hpp
@@ -16,72 +16,72 @@ namespace iora
 namespace util
 {
 
-  /// \brief Base64URL encoder (RFC 4648) without padding.
-  /// 
-  /// Base64URL encoding uses URL-safe characters and omits padding,
-  /// making it suitable for use in URLs, filenames, and SIP tokens.
-  /// Uses '-' and '_' instead of '+' and '/'.
-  class Base64Url
+/// \brief Base64URL encoder (RFC 4648) without padding.
+///
+/// Base64URL encoding uses URL-safe characters and omits padding,
+/// making it suitable for use in URLs, filenames, and SIP tokens.
+/// Uses '-' and '_' instead of '+' and '/'.
+class Base64Url
+{
+public:
+  /// \brief Encode binary data to Base64URL string (no padding).
+  /// \param data Pointer to binary data
+  /// \param len Number of bytes to encode
+  /// \return Base64URL encoded string
+  static std::string encode(const std::uint8_t *data, std::size_t len)
   {
-  public:
-    /// \brief Encode binary data to Base64URL string (no padding).
-    /// \param data Pointer to binary data
-    /// \param len Number of bytes to encode
-    /// \return Base64URL encoded string
-    static std::string encode(const std::uint8_t* data, std::size_t len)
+    static constexpr char kTable[65] =
+      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
+    if (len == 0)
     {
-      static constexpr char kTable[65] =
-        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
-      if (len == 0)
-      {
-        return {};
-      }
-
-      std::string out;
-      out.reserve(((len + 2) / 3) * 4);
+      return {};
+    }
 
-      std::size_t i = 0;
-      while (i + 3 <= len)
-      {
-        std::uint32_t v = (static_cast<std::uint32_t>(data[i]) << 16) |
-                          (static_cast<std::uint32_t>(data[i + 1]) << 8) |
-                          (static_cast<std::uint32_t>(data[i + 2]));
-        out.push_back(kTable[(v >> 18) & 0x3F]);
-        out.push_back(kTable[(v >> 12) & 0x3F]);
-        out.push_back(kTable[(v >> 6) & 0x3F]);
-        out.push_back(kTable[v & 0x3F]);
-        i += 3;
-      }
+    std::string out;
+    out.reserve(((len + 2) / 3) * 4);
 
-      // Handle remaining bytes (1 or 2)
-      std::size_t rem = len - i;
-      if (rem == 1)
-      {
-        std::uint32_t v = static_cast<std::uint32_t>(data[i]) << 16;
-        out.push_back(kTable[(v >> 18) & 0x3F]);
-        out.push_back(kTable[(v >> 12) & 0x3F]);
-        // No padding in Base64URL
-      }
-      else if (rem == 2)
-      {
-        std::uint32_t v = (static_cast<std::uint32_t>(data[i]) << 16) |
-                          (static_cast<std::uint32_t>(data[i + 1]) << 8);
-        out.push_back(kTable[(v >> 18) & 0x3F]);
-        out.push_back(kTable[(v >> 12) & 0x3F]);
-        out.push_back(kTable[(v >> 6) & 0x3F]);
-        // No padding in Base64URL
-      }
-      return out;
+    std::size_t i = 0;
+    while (i + 3 <= len)
+    {
+      std::uint32_t v = (static_cast<std::uint32_t>(data[i]) << 16) |
+                        (static_cast<std::uint32_t>(data[i + 1]) << 8) |
+                        (static_cast<std::uint32_t>(data[i + 2]));
+      out.push_back(kTable[(v >> 18) & 0x3F]);
+      out.push_back(kTable[(v >> 12) & 0x3F]);
+      out.push_back(kTable[(v >> 6) & 0x3F]);
+      out.push_back(kTable[v & 0x3F]);
+      i += 3;
     }
 
-    /// \brief Encode a vector of bytes to Base64URL string.
-    /// \param bytes Vector containing binary data
-    /// \return Base64URL encoded string
-    static std::string encode(const std::vector<std::uint8_t>& bytes)
+    // Handle remaining bytes (1 or 2)
+    std::size_t rem = len - i;
+    if (rem == 1)
     {
-      return encode(bytes.data(), bytes.size());
+      std::uint32_t v = static_cast<std::uint32_t>(data[i]) << 16;
+      out.push_back(kTable[(v >> 18) & 0x3F]);
+      out.push_back(kTable[(v >> 12) & 0x3F]);
+      // No padding in Base64URL
     }
-  };
+    else if (rem == 2)
+    {
+      std::uint32_t v = (static_cast<std::uint32_t>(data[i]) << 16) |
+                        (static_cast<std::uint32_t>(data[i + 1]) << 8);
+      out.push_back(kTable[(v >> 18) & 0x3F]);
+      out.push_back(kTable[(v >> 12) & 0x3F]);
+      out.push_back(kTable[(v >> 6) & 0x3F]);
+      // No padding in Base64URL
+    }
+    return out;
+  }
+
+  /// \brief Encode a vector of bytes to Base64URL string.
+  /// \param bytes Vector containing binary data
+  /// \return Base64URL encoded string
+  static std::string encode(const std::vector<std::uint8_t> &bytes)
+  {
+    return encode(bytes.data(), bytes.size());
+  }
+};
 
 } // namespace util
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/util/expiring_cache.hpp b/include/iora/util/expiring_cache.hpp
index fe91627..bc9e445 100644
--- a/include/iora/util/expiring_cache.hpp
+++ b/include/iora/util/expiring_cache.hpp
@@ -7,220 +7,210 @@
 
 #pragma once
 
+#include "iora/core/logger.hpp"
 #include <chrono>
 #include <mutex>
+#include <optional>
 #include <thread>
 #include <unordered_map>
-#include <optional>
-#include "iora/core/logger.hpp"
 
 namespace iora
 {
 namespace util
 {
-  // Forward declaration for friend accessor
-  template <typename K, typename V> struct ExpiringCacheTestAccessor;
+// Forward declaration for friend accessor
+template <typename K, typename V> struct ExpiringCacheTestAccessor;
 
-  /// \brief Thread-safe expiring cache with time-to-live (TTL) and automatic
-  /// purging of stale entries.
-  template <typename K, typename V> class ExpiringCache
-  {
-  public:
-    /// \brief Callback function type for cache evictions
-    using EvictionCallback = std::function<void(const K& key, const V& value)>;
+/// \brief Thread-safe expiring cache with time-to-live (TTL) and automatic
+/// purging of stale entries.
+template <typename K, typename V> class ExpiringCache
+{
+public:
+  /// \brief Callback function type for cache evictions
+  using EvictionCallback = std::function<void(const K &key, const V &value)>;
 
-    ExpiringCache() : _ttl(std::chrono::seconds(60)), _stop(false)
-    {
-      iora::core::Logger::info(
-          "ExpiringCache: Initializing with default TTL of 60 seconds");
-      startPurgeThread();
-    }
+  ExpiringCache() : _ttl(std::chrono::seconds(60)), _stop(false)
+  {
+    iora::core::Logger::info("ExpiringCache: Initializing with default TTL of 60 seconds");
+    startPurgeThread();
+  }
 
-    explicit ExpiringCache(std::chrono::seconds ttl) : _ttl(ttl), _stop(false)
-    {
-      iora::core::Logger::info("ExpiringCache: Initializing with TTL of " +
-                               std::to_string(ttl.count()) + " seconds");
-      startPurgeThread();
-    }
+  explicit ExpiringCache(std::chrono::seconds ttl) : _ttl(ttl), _stop(false)
+  {
+    iora::core::Logger::info("ExpiringCache: Initializing with TTL of " +
+                             std::to_string(ttl.count()) + " seconds");
+    startPurgeThread();
+  }
 
-    /// \brief Constructor with TTL and eviction callback
-    explicit ExpiringCache(std::chrono::seconds ttl, EvictionCallback callback) 
+  /// \brief Constructor with TTL and eviction callback
+  explicit ExpiringCache(std::chrono::seconds ttl, EvictionCallback callback)
       : _ttl(ttl), _stop(false), _evictionCallback(callback)
-    {
-      iora::core::Logger::info("ExpiringCache: Initializing with TTL of " +
-                               std::to_string(ttl.count()) + " seconds and eviction callback");
-      startPurgeThread();
-    }
+  {
+    iora::core::Logger::info("ExpiringCache: Initializing with TTL of " +
+                             std::to_string(ttl.count()) + " seconds and eviction callback");
+    startPurgeThread();
+  }
 
-    ~ExpiringCache()
+  ~ExpiringCache()
+  {
+    iora::core::Logger::debug("ExpiringCache: Starting shutdown process");
     {
-      iora::core::Logger::debug("ExpiringCache: Starting shutdown process");
-      {
-        std::lock_guard<std::mutex> lock(_mutex);
-        _stop = true;
-      }
-      if (_purgeThread.joinable())
-      {
-        _purgeThread.join();
-      }
-      iora::core::Logger::debug("ExpiringCache: Shutdown completed");
+      std::lock_guard<std::mutex> lock(_mutex);
+      _stop = true;
     }
-
-    /// \brief Sets a key-value pair in the cache.
-    void set(const K& key, const V& value,
-             std::chrono::seconds customTtl = std::chrono::seconds(0))
+    if (_purgeThread.joinable())
     {
-      auto expiration = std::chrono::steady_clock::now() +
-                        (customTtl.count() > 0 ? customTtl : _ttl);
-      std::lock_guard<std::mutex> lock(_mutex);
-      bool isUpdate = _cache.find(key) != _cache.end();
-      _cache[key] = {value, expiration};
-      iora::core::Logger::debug(
-          std::string("ExpiringCache: ") + (isUpdate ? "Updated" : "Added") +
-          " cache entry (total entries: " + std::to_string(_cache.size()) +
-          ")");
+      _purgeThread.join();
     }
+    iora::core::Logger::debug("ExpiringCache: Shutdown completed");
+  }
 
-    /// \brief Gets a value by key from the cache.
-    std::optional<V> get(const K& key)
+  /// \brief Sets a key-value pair in the cache.
+  void set(const K &key, const V &value, std::chrono::seconds customTtl = std::chrono::seconds(0))
+  {
+    auto expiration = std::chrono::steady_clock::now() + (customTtl.count() > 0 ? customTtl : _ttl);
+    std::lock_guard<std::mutex> lock(_mutex);
+    bool isUpdate = _cache.find(key) != _cache.end();
+    _cache[key] = {value, expiration};
+    iora::core::Logger::debug(std::string("ExpiringCache: ") + (isUpdate ? "Updated" : "Added") +
+                              " cache entry (total entries: " + std::to_string(_cache.size()) +
+                              ")");
+  }
+
+  /// \brief Gets a value by key from the cache.
+  std::optional<V> get(const K &key)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    auto it = _cache.find(key);
+    if (it != _cache.end())
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      auto it = _cache.find(key);
-      if (it != _cache.end())
+      if (it->second.expiration > std::chrono::steady_clock::now())
       {
-        if (it->second.expiration > std::chrono::steady_clock::now())
-        {
-          iora::core::Logger::debug("ExpiringCache: Cache hit for key");
-          return it->second.value;
-        }
-        else
-        {
-          iora::core::Logger::debug(
-              "ExpiringCache: Cache miss - entry expired for key");
-          // Invoke eviction callback before removing
-          if (_evictionCallback)
-          {
-            _evictionCallback(it->first, it->second.value);
-          }
-          _cache.erase(it); // Remove expired entry
-        }
+        iora::core::Logger::debug("ExpiringCache: Cache hit for key");
+        return it->second.value;
       }
       else
       {
-        iora::core::Logger::debug("ExpiringCache: Cache miss - key not found");
-      }
-      return std::nullopt;
-    }
-
-    /// \brief Removes a key from the cache.
-    void remove(const K& key)
-    {
-      std::lock_guard<std::mutex> lock(_mutex);
-      auto it = _cache.find(key);
-      if (it != _cache.end())
-      {
+        iora::core::Logger::debug("ExpiringCache: Cache miss - entry expired for key");
         // Invoke eviction callback before removing
         if (_evictionCallback)
         {
           _evictionCallback(it->first, it->second.value);
         }
-        _cache.erase(it);
-        iora::core::Logger::debug(
-            "ExpiringCache: Removed cache entry (remaining entries: " +
-            std::to_string(_cache.size()) + ")");
+        _cache.erase(it); // Remove expired entry
       }
-      else
+    }
+    else
+    {
+      iora::core::Logger::debug("ExpiringCache: Cache miss - key not found");
+    }
+    return std::nullopt;
+  }
+
+  /// \brief Removes a key from the cache.
+  void remove(const K &key)
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    auto it = _cache.find(key);
+    if (it != _cache.end())
+    {
+      // Invoke eviction callback before removing
+      if (_evictionCallback)
       {
-        iora::core::Logger::debug(
-            "ExpiringCache: Attempted to remove non-existent key");
+        _evictionCallback(it->first, it->second.value);
       }
+      _cache.erase(it);
+      iora::core::Logger::debug("ExpiringCache: Removed cache entry (remaining entries: " +
+                                std::to_string(_cache.size()) + ")");
     }
-
-    /// \brief Get current cache size (number of entries)
-    /// \return Current number of entries in cache
-    std::size_t size() const
+    else
     {
-      std::lock_guard<std::mutex> lock(_mutex);
-      return _cache.size();
+      iora::core::Logger::debug("ExpiringCache: Attempted to remove non-existent key");
     }
+  }
 
-    // Friend accessor for unit testing
-    friend struct ExpiringCacheTestAccessor<K, V>;
+  /// \brief Get current cache size (number of entries)
+  /// \return Current number of entries in cache
+  std::size_t size() const
+  {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _cache.size();
+  }
 
-  private:
-    struct CacheEntry
-    {
-      V value;
-      std::chrono::steady_clock::time_point expiration;
-    };
-
-    std::unordered_map<K, CacheEntry> _cache;
-    std::chrono::seconds _ttl;
-    mutable std::mutex _mutex;
-    std::thread _purgeThread;
-    bool _stop;
-    EvictionCallback _evictionCallback;
-
-    void startPurgeThread()
-    {
-      iora::core::Logger::debug(
-          "ExpiringCache: Starting background purge thread");
-      _purgeThread = std::thread(
-          [this]()
+  // Friend accessor for unit testing
+  friend struct ExpiringCacheTestAccessor<K, V>;
+
+private:
+  struct CacheEntry
+  {
+    V value;
+    std::chrono::steady_clock::time_point expiration;
+  };
+
+  std::unordered_map<K, CacheEntry> _cache;
+  std::chrono::seconds _ttl;
+  mutable std::mutex _mutex;
+  std::thread _purgeThread;
+  bool _stop;
+  EvictionCallback _evictionCallback;
+
+  void startPurgeThread()
+  {
+    iora::core::Logger::debug("ExpiringCache: Starting background purge thread");
+    _purgeThread = std::thread(
+      [this]()
+      {
+        iora::core::Logger::debug("ExpiringCache: Purge thread running");
+        while (true)
+        {
+          std::size_t purgedCount = 0;
           {
-            iora::core::Logger::debug("ExpiringCache: Purge thread running");
-            while (true)
+            std::lock_guard<std::mutex> lock(_mutex);
+            if (_stop)
+            {
+              iora::core::Logger::debug("ExpiringCache: Purge thread stopping");
+              break;
+            }
+            auto now = std::chrono::steady_clock::now();
+            std::size_t beforeSize = _cache.size();
+            for (auto it = _cache.begin(); it != _cache.end();)
             {
-              std::size_t purgedCount = 0;
+              if (it->second.expiration <= now)
               {
-                std::lock_guard<std::mutex> lock(_mutex);
-                if (_stop)
-                {
-                  iora::core::Logger::debug(
-                      "ExpiringCache: Purge thread stopping");
-                  break;
-                }
-                auto now = std::chrono::steady_clock::now();
-                std::size_t beforeSize = _cache.size();
-                for (auto it = _cache.begin(); it != _cache.end();)
+                // Invoke eviction callback before removing
+                if (_evictionCallback)
                 {
-                  if (it->second.expiration <= now)
-                  {
-                    // Invoke eviction callback before removing
-                    if (_evictionCallback)
-                    {
-                      _evictionCallback(it->first, it->second.value);
-                    }
-                    it = _cache.erase(it);
-                    purgedCount++;
-                  }
-                  else
-                  {
-                    ++it;
-                  }
-                }
-                if (purgedCount > 0)
-                {
-                  iora::core::Logger::debug(
-                      "ExpiringCache: Purged " + std::to_string(purgedCount) +
-                      " expired entries (" + std::to_string(beforeSize) +
-                      " -> " + std::to_string(_cache.size()) + ")");
+                  _evictionCallback(it->first, it->second.value);
                 }
+                it = _cache.erase(it);
+                purgedCount++;
+              }
+              else
+              {
+                ++it;
               }
-              std::this_thread::sleep_for(std::chrono::seconds(5));
             }
-          });
-    }
-  };
+            if (purgedCount > 0)
+            {
+              iora::core::Logger::debug("ExpiringCache: Purged " + std::to_string(purgedCount) +
+                                        " expired entries (" + std::to_string(beforeSize) + " -> " +
+                                        std::to_string(_cache.size()) + ")");
+            }
+          }
+          std::this_thread::sleep_for(std::chrono::seconds(5));
+        }
+      });
+  }
+};
 
-  /// \brief Provides unit test access to internal state of ExpiringCache.
-  template <typename K, typename V> struct ExpiringCacheTestAccessor
+/// \brief Provides unit test access to internal state of ExpiringCache.
+template <typename K, typename V> struct ExpiringCacheTestAccessor
+{
+  static std::size_t mapSize(ExpiringCache<K, V> &cache)
   {
-    static std::size_t mapSize(ExpiringCache<K, V>& cache)
-    {
-      std::lock_guard<std::mutex> lock(cache._mutex);
-      return cache._cache.size();
-    }
-  };
+    std::lock_guard<std::mutex> lock(cache._mutex);
+    return cache._cache.size();
+  }
+};
 } // namespace util
 } // namespace iora
\ No newline at end of file
diff --git a/include/iora/util/filesystem.hpp b/include/iora/util/filesystem.hpp
index 19532a3..9533079 100644
--- a/include/iora/util/filesystem.hpp
+++ b/include/iora/util/filesystem.hpp
@@ -6,81 +6,81 @@
 // details.
 
 #pragma once
-#include <string>
-#include <vector>
 #include <filesystem>
+#include <string>
 #include <unistd.h> // for readlink
+#include <vector>
 
 namespace iora
 {
 namespace util
 {
 
-  /// \brief Get the path to the currently running executable
-  /// \return Full path to the executable as a string
-  std::string getExecutablePath()
+/// \brief Get the path to the currently running executable
+/// \return Full path to the executable as a string
+std::string getExecutablePath()
+{
+  std::vector<char> buf(4096);
+  ssize_t len = ::readlink("/proc/self/exe", buf.data(), buf.size() - 1);
+  if (len > 0)
   {
-    std::vector<char> buf(4096);
-    ssize_t len = ::readlink("/proc/self/exe", buf.data(), buf.size() - 1);
-    if (len > 0)
-    {
-      buf[len] = '\0';
-      return std::string(buf.data());
-    }
-    return {};
+    buf[len] = '\0';
+    return std::string(buf.data());
   }
+  return {};
+}
 
-  /// \brief Get the directory of the currently running executable
-  std::string getExecutableDir()
+/// \brief Get the directory of the currently running executable
+std::string getExecutableDir()
+{
+  std::string exePath = getExecutablePath();
+  if (!exePath.empty())
   {
-    std::string exePath = getExecutablePath();
-    if (!exePath.empty())
-    {
-      return std::filesystem::path(exePath).parent_path().string();
-    }
-    return {};
+    return std::filesystem::path(exePath).parent_path().string();
   }
+  return {};
+}
 
-  /// \brief Resolve a relative path against an absolute base path
-  std::string resolveRelativePath(const std::string& base_absolute_path,
-                                  const std::string& relative_path)
-  {
-    // Use std::filesystem to join and normalize the path
-    return std::filesystem::weakly_canonical(
-               std::filesystem::path(base_absolute_path) / relative_path)
-        .string();
-  }
+/// \brief Resolve a relative path against an absolute base path
+std::string resolveRelativePath(const std::string &base_absolute_path,
+                                const std::string &relative_path)
+{
+  // Use std::filesystem to join and normalize the path
+  return std::filesystem::weakly_canonical(std::filesystem::path(base_absolute_path) /
+                                           relative_path)
+    .string();
+}
 
-  /// \brief Remove all files in the current directory that match the given
-  /// prefix
-  void removeFilesMatchingPrefix(const std::string& prefix)
+/// \brief Remove all files in the current directory that match the given
+/// prefix
+void removeFilesMatchingPrefix(const std::string &prefix)
+{
+  for (const auto &file : std::filesystem::directory_iterator("."))
   {
-    for (const auto& file : std::filesystem::directory_iterator("."))
+    if (file.path().string().find(prefix) != std::string::npos)
     {
-      if (file.path().string().find(prefix) != std::string::npos)
-      {
-        std::filesystem::remove(file.path());
-      }
+      std::filesystem::remove(file.path());
     }
   }
+}
 
-  /// \brief Remove all files in the current directory that contain any of the
-  /// given fragments
-  void removeFilesContainingAny(const std::vector<std::string>& fragments)
+/// \brief Remove all files in the current directory that contain any of the
+/// given fragments
+void removeFilesContainingAny(const std::vector<std::string> &fragments)
+{
+  for (const auto &file : std::filesystem::directory_iterator("."))
   {
-    for (const auto& file : std::filesystem::directory_iterator("."))
+    std::string name = file.path().string();
+    for (const auto &fragment : fragments)
     {
-      std::string name = file.path().string();
-      for (const auto& fragment : fragments)
+      if (name.find(fragment) != std::string::npos)
       {
-        if (name.find(fragment) != std::string::npos)
-        {
-          std::filesystem::remove(file.path());
-          break;
-        }
+        std::filesystem::remove(file.path());
+        break;
       }
     }
   }
+}
 
 } // namespace util
 } // namespace iora
diff --git a/sample/plugins/microservice_plugin.cpp b/sample/plugins/microservice_plugin.cpp
index ea969f4..4026b76 100644
--- a/sample/plugins/microservice_plugin.cpp
+++ b/sample/plugins/microservice_plugin.cpp
@@ -29,22 +29,22 @@
 
 #include "iora/iora.hpp"
 #include <atomic>
-#include <unordered_map>
 #include <mutex>
+#include <unordered_map>
 
 class MicroservicePlugin : public iora::IoraService::Plugin
 {
 public:
-  explicit MicroservicePlugin(iora::IoraService* svc) : Plugin(svc) {}
+  explicit MicroservicePlugin(iora::IoraService *svc) : Plugin(svc) {}
 
-  void onLoad(iora::IoraService* svc) override
+  void onLoad(iora::IoraService *svc) override
   {
     // Load API token from persistent store
     auto tokenOpt = svc->jsonFileStore()->get("apiToken");
     if (!tokenOpt)
     {
       // first run: read from environment and persist
-      const char* envToken = std::getenv("OPENAI_API_KEY");
+      const char *envToken = std::getenv("OPENAI_API_KEY");
       if (envToken)
       {
         std::string token = envToken;
@@ -63,79 +63,69 @@ public:
     // Register EventQueue handler for processing summarization requests
     // (fluent)
     svc->onEvent("summarize")
-        .handle(
-            [this, svc](const iora::parsers::Json& input)
-            {
-              std::string requestId = input["requestId"];
-              std::string text = input["text"];
-              int maxTokens = input.contains("max_tokens")
-                                  ? input["max_tokens"].get<int>()
-                                  : 256;
-
-              // Build payload for LLM
-              iora::parsers::Json payload = {
-                  {"model", "gpt-3.5-turbo"},
-                  {"messages",
-                   {{{"role", "user"}, {"content", "Summarise: " + text}}}},
-                  {"max_tokens", maxTokens}};
-
-              // Call LLM provider
-              auto client = svc->makeHttpClient();
-              auto headers = std::map<std::string, std::string>{
-                  {"Authorization",
-                   "Bearer " + svc->jsonFileStore()->get("apiToken").value()},
-                  {"Content-Type", "application/json"}};
-
-              auto llmRes =
-                  client.postJson("https://api.openai.com/v1/chat/completions",
-                                  payload, headers);
-              auto llmJson =
-                  iora::network::HttpClient::parseJsonOrThrow(llmRes);
-              std::string summary =
-                  llmJson["choices"][static_cast<std::size_t>(0)]["message"]
-                         ["content"];
-
-              // Store result in the map
-              {
-                std::lock_guard<std::mutex> lock(_resultsMutex);
-                _results[requestId] = {{"summary", summary}};
-              }
-            });
+      .handle(
+        [this, svc](const iora::parsers::Json &input)
+        {
+          std::string requestId = input["requestId"];
+          std::string text = input["text"];
+          int maxTokens = input.contains("max_tokens") ? input["max_tokens"].get<int>() : 256;
+
+          // Build payload for LLM
+          iora::parsers::Json payload = {
+            {"model", "gpt-3.5-turbo"},
+            {"messages", {{{"role", "user"}, {"content", "Summarise: " + text}}}},
+            {"max_tokens", maxTokens}};
+
+          // Call LLM provider
+          auto client = svc->makeHttpClient();
+          auto headers = std::map<std::string, std::string>{
+            {"Authorization", "Bearer " + svc->jsonFileStore()->get("apiToken").value()},
+            {"Content-Type", "application/json"}};
+
+          auto llmRes =
+            client.postJson("https://api.openai.com/v1/chat/completions", payload, headers);
+          auto llmJson = iora::network::HttpClient::parseJsonOrThrow(llmRes);
+          std::string summary =
+            llmJson["choices"][static_cast<std::size_t>(0)]["message"]["content"];
+
+          // Store result in the map
+          {
+            std::lock_guard<std::mutex> lock(_resultsMutex);
+            _results[requestId] = {{"summary", summary}};
+          }
+        });
 
     // /summarize endpoint queues requests (fluent)
     svc->on("/summarize")
-        .handleJson(
-            [this, svc](const iora::parsers::Json& input) -> iora::parsers::Json
-            {
-              std::string text = input["text"];
-              int maxTokens = input.contains("max_tokens")
-                                  ? input["max_tokens"].get<int>()
-                                  : 256;
-              std::string requestId =
-                  std::to_string(std::hash<std::string>{}(text));
-
-              // Queue the request
-              svc->pushEvent({{"eventId", "summarize"},
-                              {"requestId", requestId},
-                              {"text", text},
-                              {"max_tokens", maxTokens}});
-
-              return {{"status", "processing"}, {"requestId", requestId}};
-            });
+      .handleJson(
+        [this, svc](const iora::parsers::Json &input) -> iora::parsers::Json
+        {
+          std::string text = input["text"];
+          int maxTokens = input.contains("max_tokens") ? input["max_tokens"].get<int>() : 256;
+          std::string requestId = std::to_string(std::hash<std::string>{}(text));
+
+          // Queue the request
+          svc->pushEvent({{"eventId", "summarize"},
+                          {"requestId", requestId},
+                          {"text", text},
+                          {"max_tokens", maxTokens}});
+
+          return {{"status", "processing"}, {"requestId", requestId}};
+        });
 
     // /status endpoint retrieves results (fluent)
     svc->on("/status").handleJson(
-        [this](const iora::parsers::Json& input) -> iora::parsers::Json
-        {
-          std::string requestId = input["requestId"];
+      [this](const iora::parsers::Json &input) -> iora::parsers::Json
+      {
+        std::string requestId = input["requestId"];
 
-          std::lock_guard<std::mutex> lock(_resultsMutex);
-          if (_results.find(requestId) != _results.end())
-          {
-            return _results[requestId];
-          }
-          return {{"status", "pending"}};
-        });
+        std::lock_guard<std::mutex> lock(_resultsMutex);
+        if (_results.find(requestId) != _results.end())
+        {
+          return _results[requestId];
+        }
+        return {{"status", "pending"}};
+      });
 
     IORA_LOG_INFO("Microservice plugin loaded successfully");
   }
diff --git a/src/iora.cpp b/src/iora.cpp
index 00febd4..5688740 100644
--- a/src/iora.cpp
+++ b/src/iora.cpp
@@ -4,349 +4,323 @@
 // This file is part of Iora, which is licensed under the Mozilla Public License 2.0.
 // See the LICENSE file or <https://www.mozilla.org/MPL/2.0/> for details.
 
+#include <csignal>
 #include <iora/iora.hpp>
 #include <iostream>
-#include <csignal>
 
 #define IORA_DEFAULT_CONFIG_FILE_PATH "/etc/iora.conf.d/iora.cfg"
 
 /// \brief Print help message
-  static void printHelp()
-  {
-    std::cout
-        << "Iora Service Options:\n"
-        << "  -h, --help                       Show this help message\n"
-        << "  -c, --config <file>              Configuration file path\n"
-        << "  -p, --port <port>                Server port (default: 8080)\n"
-        << "  -s, --state-file <file>          State persistence file\n"
-        << "  -l, --log-level <level>          Log level (trace, debug, info, "
-           "warning, error, fatal)\n"
-        << "  -f, --log-file <file>            Log file path\n"
-        << "      --log-async                  Enable async logging\n"
-        << "      --log-retention <days>       Log retention in days\n"
-        << "      --log-time-format <format>   Log timestamp format\n"
-        << "      --modules-dir <dir>          Modules directory\n"
-        << "      --modules-auto-load          Auto-load modules\n"
-        << "      --tls-cert <file>            TLS certificate file\n"
-        << "      --tls-key <file>             TLS key file\n"
-        << "      --tls-ca <file>              TLS CA file\n"
-        << "      --tls-require-client-cert    Require client certificate for "
-           "TLS (default: false)\n"
-        << "      --threadpool-min <n>           Set thread pool minimum "
-           "threads (default: 2)\n"
-        << "      --threadpool-max <n>           Set thread pool maximum "
-           "threads (default: 8)\n"
-        << "      --threadpool-queue <n>         Set thread pool queue size "
-           "(default: 128)\n"
-        << "      --threadpool-idle-timeout <n>  Set thread pool idle timeout "
-           "in seconds (default: 60)\n";
-  }
-
+static void printHelp()
+{
+  std::cout << "Iora Service Options:\n"
+            << "  -h, --help                       Show this help message\n"
+            << "  -c, --config <file>              Configuration file path\n"
+            << "  -p, --port <port>                Server port (default: 8080)\n"
+            << "  -s, --state-file <file>          State persistence file\n"
+            << "  -l, --log-level <level>          Log level (trace, debug, info, "
+               "warning, error, fatal)\n"
+            << "  -f, --log-file <file>            Log file path\n"
+            << "      --log-async                  Enable async logging\n"
+            << "      --log-retention <days>       Log retention in days\n"
+            << "      --log-time-format <format>   Log timestamp format\n"
+            << "      --modules-dir <dir>          Modules directory\n"
+            << "      --modules-auto-load          Auto-load modules\n"
+            << "      --tls-cert <file>            TLS certificate file\n"
+            << "      --tls-key <file>             TLS key file\n"
+            << "      --tls-ca <file>              TLS CA file\n"
+            << "      --tls-require-client-cert    Require client certificate for "
+               "TLS (default: false)\n"
+            << "      --threadpool-min <n>           Set thread pool minimum "
+               "threads (default: 2)\n"
+            << "      --threadpool-max <n>           Set thread pool maximum "
+               "threads (default: 8)\n"
+            << "      --threadpool-queue <n>         Set thread pool queue size "
+               "(default: 128)\n"
+            << "      --threadpool-idle-timeout <n>  Set thread pool idle timeout "
+               "in seconds (default: 60)\n";
+}
 
 /// \brief Parse command-line arguments into the internal config
-  void parseCliArgs(int argc, char** argv, iora::IoraService::Config& config, std::unique_ptr<iora::core::ConfigLoader>& configLoader)
+void parseCliArgs(int argc, char **argv, iora::IoraService::Config &config,
+                  std::unique_ptr<iora::core::ConfigLoader> &configLoader)
+{
+  for (int i = 1; i < argc; ++i)
   {
-    for (int i = 1; i < argc; ++i)
+    std::string arg = argv[i];
+    if ((arg == "-p" || arg == "--port") && i + 1 < argc)
     {
-      std::string arg = argv[i];
-      if ((arg == "-p" || arg == "--port") && i + 1 < argc)
+      try
       {
-        try
-        {
-          config.server.port = std::stoi(argv[++i]);
-        }
-        catch (const std::exception& e)
-        {
-          throw std::runtime_error("Invalid port number: " +
-                                   std::string(argv[i]));
-        }
+        config.server.port = std::stoi(argv[++i]);
       }
-      else if ((arg == "-c" || arg == "--config") && i + 1 < argc)
+      catch (const std::exception &e)
       {
-        config.configFile = argv[++i];
-        configLoader = std::make_unique<iora::core::ConfigLoader>(config.configFile.value());
-        IORA_LOG_INFO("Using config file: " + config.configFile.value());
+        throw std::runtime_error("Invalid port number: " + std::string(argv[i]));
       }
-      else if ((arg == "-s" || arg == "--state-file") && i + 1 < argc)
-      {
-        config.state.file = argv[++i];
-      }
-      else if ((arg == "-l" || arg == "--log-level") && i + 1 < argc)
-      {
-        config.log.level = argv[++i];
-      }
-      else if ((arg == "-f" || arg == "--log-file") && i + 1 < argc)
-      {
-        config.log.file = argv[++i];
-      }
-      else if (arg == "--log-async")
-      {
-        config.log.async = true;
-      }
-      else if (arg == "--log-retention" && i + 1 < argc)
-      {
-        try
-        {
-          config.log.retentionDays = std::stoi(argv[++i]);
-        }
-        catch (const std::exception& e)
-        {
-          throw std::runtime_error("Invalid log retention days: " +
-                                   std::string(argv[i]));
-        }
-      }
-      else if (arg == "--log-time-format" && i + 1 < argc)
-      {
-        config.log.timeFormat = argv[++i];
-      }
-      else if (arg == "--modules-dir" && i + 1 < argc)
-      {
-        config.modules.directory = argv[++i];
-      }
-      else if (arg == "--modules-auto-load")
-      {
-        config.modules.autoLoad = true;
-      }
-      else if (arg == "--tls-cert" && i + 1 < argc)
+    }
+    else if ((arg == "-c" || arg == "--config") && i + 1 < argc)
+    {
+      config.configFile = argv[++i];
+      configLoader = std::make_unique<iora::core::ConfigLoader>(config.configFile.value());
+      IORA_LOG_INFO("Using config file: " + config.configFile.value());
+    }
+    else if ((arg == "-s" || arg == "--state-file") && i + 1 < argc)
+    {
+      config.state.file = argv[++i];
+    }
+    else if ((arg == "-l" || arg == "--log-level") && i + 1 < argc)
+    {
+      config.log.level = argv[++i];
+    }
+    else if ((arg == "-f" || arg == "--log-file") && i + 1 < argc)
+    {
+      config.log.file = argv[++i];
+    }
+    else if (arg == "--log-async")
+    {
+      config.log.async = true;
+    }
+    else if (arg == "--log-retention" && i + 1 < argc)
+    {
+      try
       {
-        config.server.tls.certFile = argv[++i];
+        config.log.retentionDays = std::stoi(argv[++i]);
       }
-      else if (arg == "--tls-key" && i + 1 < argc)
+      catch (const std::exception &e)
       {
-        config.server.tls.keyFile = argv[++i];
+        throw std::runtime_error("Invalid log retention days: " + std::string(argv[i]));
       }
-      else if (arg == "--tls-ca" && i + 1 < argc)
+    }
+    else if (arg == "--log-time-format" && i + 1 < argc)
+    {
+      config.log.timeFormat = argv[++i];
+    }
+    else if (arg == "--modules-dir" && i + 1 < argc)
+    {
+      config.modules.directory = argv[++i];
+    }
+    else if (arg == "--modules-auto-load")
+    {
+      config.modules.autoLoad = true;
+    }
+    else if (arg == "--tls-cert" && i + 1 < argc)
+    {
+      config.server.tls.certFile = argv[++i];
+    }
+    else if (arg == "--tls-key" && i + 1 < argc)
+    {
+      config.server.tls.keyFile = argv[++i];
+    }
+    else if (arg == "--tls-ca" && i + 1 < argc)
+    {
+      config.server.tls.caFile = argv[++i];
+    }
+    else if (arg == "--tls-require-client-cert")
+    {
+      config.server.tls.requireClientCert = true;
+    }
+    else if (arg == "--threadpool-min" && i + 1 < argc)
+    {
+      try
       {
-        config.server.tls.caFile = argv[++i];
+        config.threadPool.minThreads = static_cast<std::size_t>(std::stoi(argv[++i]));
       }
-      else if (arg == "--tls-require-client-cert")
+      catch (const std::exception &e)
       {
-        config.server.tls.requireClientCert = true;
+        throw std::runtime_error("Invalid threadpool min threads: " + std::string(argv[i]));
       }
-      else if (arg == "--threadpool-min" && i + 1 < argc)
+    }
+    else if (arg == "--threadpool-max" && i + 1 < argc)
+    {
+      try
       {
-        try
-        {
-          config.threadPool.minThreads =
-              static_cast<std::size_t>(std::stoi(argv[++i]));
-        }
-        catch (const std::exception& e)
-        {
-          throw std::runtime_error("Invalid threadpool min threads: " +
-                                   std::string(argv[i]));
-        }
+        config.threadPool.maxThreads = static_cast<std::size_t>(std::stoi(argv[++i]));
       }
-      else if (arg == "--threadpool-max" && i + 1 < argc)
+      catch (const std::exception &e)
       {
-        try
-        {
-          config.threadPool.maxThreads =
-              static_cast<std::size_t>(std::stoi(argv[++i]));
-        }
-        catch (const std::exception& e)
-        {
-          throw std::runtime_error("Invalid threadpool max threads: " +
-                                   std::string(argv[i]));
-        }
+        throw std::runtime_error("Invalid threadpool max threads: " + std::string(argv[i]));
       }
-      else if (arg == "--threadpool-queue" && i + 1 < argc)
+    }
+    else if (arg == "--threadpool-queue" && i + 1 < argc)
+    {
+      try
       {
-        try
-        {
-          config.threadPool.queueSize =
-              static_cast<std::size_t>(std::stoi(argv[++i]));
-        }
-        catch (const std::exception& e)
-        {
-          throw std::runtime_error("Invalid threadpool queue size: " +
-                                   std::string(argv[i]));
-        }
+        config.threadPool.queueSize = static_cast<std::size_t>(std::stoi(argv[++i]));
       }
-      else if (arg == "--threadpool-idle-timeout" && i + 1 < argc)
+      catch (const std::exception &e)
       {
-        try
-        {
-          config.threadPool.idleTimeoutSeconds =
-              std::chrono::seconds(std::stoi(argv[++i]));
-        }
-        catch (const std::exception& e)
-        {
-          throw std::runtime_error("Invalid threadpool idle timeout: " +
-                                   std::string(argv[i]));
-        }
+        throw std::runtime_error("Invalid threadpool queue size: " + std::string(argv[i]));
       }
-      else if (arg == "-h" || arg == "--help")
+    }
+    else if (arg == "--threadpool-idle-timeout" && i + 1 < argc)
+    {
+      try
       {
-        printHelp();
-        std::exit(0);
+        config.threadPool.idleTimeoutSeconds = std::chrono::seconds(std::stoi(argv[++i]));
       }
-      else if (arg.length() > 0 && arg[0] == '-')
+      catch (const std::exception &e)
       {
-        throw std::runtime_error("Unknown option: " + arg);
+        throw std::runtime_error("Invalid threadpool idle timeout: " + std::string(argv[i]));
       }
     }
+    else if (arg == "-h" || arg == "--help")
+    {
+      printHelp();
+      std::exit(0);
+    }
+    else if (arg.length() > 0 && arg[0] == '-')
+    {
+      throw std::runtime_error("Unknown option: " + arg);
+    }
   }
+}
 
-  /// \brief Parse TOML configuration file
-  void parseTomlConfig(iora::IoraService::Config& config, std::unique_ptr<iora::core::ConfigLoader>& configLoader)
+/// \brief Parse TOML configuration file
+void parseTomlConfig(iora::IoraService::Config &config,
+                     std::unique_ptr<iora::core::ConfigLoader> &configLoader)
+{
+  try
   {
-    try
+    if (!configLoader)
     {
-      if (!configLoader)
-      {
-        std::string defaultConfigFile;
+      std::string defaultConfigFile;
 #ifdef IORA_DEFAULT_CONFIG_FILE_PATH
-        defaultConfigFile = IORA_DEFAULT_CONFIG_FILE_PATH;
+      defaultConfigFile = IORA_DEFAULT_CONFIG_FILE_PATH;
 #endif
-        configLoader = std::make_unique<iora::core::ConfigLoader>(defaultConfigFile);
-        IORA_LOG_INFO("Using default config file: " + defaultConfigFile);
-      }
-      configLoader->reload();
-      if (!config.server.port.has_value())
-      {
-        if (auto portOpt = configLoader->getInt("iora.server.port"))
-        {
-          config.server.port = static_cast<int>(*portOpt);
-        }
-      }
-      if (!config.state.file.has_value())
+      configLoader = std::make_unique<iora::core::ConfigLoader>(defaultConfigFile);
+      IORA_LOG_INFO("Using default config file: " + defaultConfigFile);
+    }
+    configLoader->reload();
+    if (!config.server.port.has_value())
+    {
+      if (auto portOpt = configLoader->getInt("iora.server.port"))
       {
-        if (auto stateFileOpt = configLoader->getString("iora.state.file"))
-        {
-          config.state.file = *stateFileOpt;
-        }
+        config.server.port = static_cast<int>(*portOpt);
       }
-      if (!config.log.level.has_value())
+    }
+    if (!config.state.file.has_value())
+    {
+      if (auto stateFileOpt = configLoader->getString("iora.state.file"))
       {
-        if (auto logLevelOpt = configLoader->getString("iora.log.level"))
-        {
-          config.log.level = *logLevelOpt;
-        }
+        config.state.file = *stateFileOpt;
       }
-      if (!config.log.file.has_value())
+    }
+    if (!config.log.level.has_value())
+    {
+      if (auto logLevelOpt = configLoader->getString("iora.log.level"))
       {
-        if (auto logFileOpt = configLoader->getString("iora.log.file"))
-        {
-          config.log.file = *logFileOpt;
-        }
+        config.log.level = *logLevelOpt;
       }
-      if (!config.log.async.has_value())
+    }
+    if (!config.log.file.has_value())
+    {
+      if (auto logFileOpt = configLoader->getString("iora.log.file"))
       {
-        if (auto logAsyncOpt = configLoader->getBool("iora.log.async"))
-        {
-          config.log.async = *logAsyncOpt;
-        }
+        config.log.file = *logFileOpt;
       }
-      if (!config.log.retentionDays.has_value())
+    }
+    if (!config.log.async.has_value())
+    {
+      if (auto logAsyncOpt = configLoader->getBool("iora.log.async"))
       {
-        if (auto retentionOpt = configLoader->getInt("iora.log.retentionDays"))
-        {
-          config.log.retentionDays = static_cast<int>(*retentionOpt);
-        }
+        config.log.async = *logAsyncOpt;
       }
-      if (!config.log.timeFormat.has_value())
+    }
+    if (!config.log.retentionDays.has_value())
+    {
+      if (auto retentionOpt = configLoader->getInt("iora.log.retentionDays"))
       {
-        if (auto timeFormatOpt =
-                configLoader->getString("iora.log.timeFormat"))
-        {
-          config.log.timeFormat = *timeFormatOpt;
-        }
+        config.log.retentionDays = static_cast<int>(*retentionOpt);
       }
-      if (!config.modules.directory.has_value())
+    }
+    if (!config.log.timeFormat.has_value())
+    {
+      if (auto timeFormatOpt = configLoader->getString("iora.log.timeFormat"))
       {
-        if (auto modulesDirOpt =
-                configLoader->getString("iora.modules.directory"))
-        {
-          config.modules.directory = *modulesDirOpt;
-        }
+        config.log.timeFormat = *timeFormatOpt;
       }
-      if (!config.modules.autoLoad.has_value())
+    }
+    if (!config.modules.directory.has_value())
+    {
+      if (auto modulesDirOpt = configLoader->getString("iora.modules.directory"))
       {
-        if (auto autoLoadOpt = configLoader->getBool("iora.modules.autoLoad"))
-        {
-          config.modules.autoLoad = *autoLoadOpt;
-        }
+        config.modules.directory = *modulesDirOpt;
       }
-      if (!config.server.tls.certFile.has_value())
+    }
+    if (!config.modules.autoLoad.has_value())
+    {
+      if (auto autoLoadOpt = configLoader->getBool("iora.modules.autoLoad"))
       {
-        if (auto certFileOpt =
-                configLoader->getString("iora.server.tls.certFile"))
-        {
-          config.server.tls.certFile = *certFileOpt;
-        }
+        config.modules.autoLoad = *autoLoadOpt;
       }
-      if (!config.server.tls.keyFile.has_value())
+    }
+    if (!config.server.tls.certFile.has_value())
+    {
+      if (auto certFileOpt = configLoader->getString("iora.server.tls.certFile"))
       {
-        if (auto keyFileOpt =
-                configLoader->getString("iora.server.tls.keyFile"))
-        {
-          config.server.tls.keyFile = *keyFileOpt;
-        }
+        config.server.tls.certFile = *certFileOpt;
       }
-      if (!config.server.tls.caFile.has_value())
+    }
+    if (!config.server.tls.keyFile.has_value())
+    {
+      if (auto keyFileOpt = configLoader->getString("iora.server.tls.keyFile"))
       {
-        if (auto caFileOpt = configLoader->getString("iora.server.tls.caFile"))
-        {
-          config.server.tls.caFile = *caFileOpt;
-        }
+        config.server.tls.keyFile = *keyFileOpt;
       }
-      if (!config.server.tls.requireClientCert.has_value())
+    }
+    if (!config.server.tls.caFile.has_value())
+    {
+      if (auto caFileOpt = configLoader->getString("iora.server.tls.caFile"))
       {
-        if (auto requireClientCertOpt =
-                configLoader->getBool("iora.server.tls.requireClientCert"))
-        {
-          config.server.tls.requireClientCert = *requireClientCertOpt;
-        }
+        config.server.tls.caFile = *caFileOpt;
       }
-      if (!config.threadPool.minThreads.has_value())
+    }
+    if (!config.server.tls.requireClientCert.has_value())
+    {
+      if (auto requireClientCertOpt = configLoader->getBool("iora.server.tls.requireClientCert"))
       {
-        if (auto minThreadsOpt =
-                configLoader->getInt("iora.threadPool.minThreads"))
-        {
-          config.threadPool.minThreads =
-              static_cast<std::size_t>(*minThreadsOpt);
-        }
+        config.server.tls.requireClientCert = *requireClientCertOpt;
       }
-      if (!config.threadPool.maxThreads.has_value())
+    }
+    if (!config.threadPool.minThreads.has_value())
+    {
+      if (auto minThreadsOpt = configLoader->getInt("iora.threadPool.minThreads"))
       {
-        if (auto maxThreadsOpt =
-                configLoader->getInt("iora.threadPool.maxThreads"))
-        {
-          config.threadPool.maxThreads =
-              static_cast<std::size_t>(*maxThreadsOpt);
-        }
+        config.threadPool.minThreads = static_cast<std::size_t>(*minThreadsOpt);
       }
-      if (!config.threadPool.queueSize.has_value())
+    }
+    if (!config.threadPool.maxThreads.has_value())
+    {
+      if (auto maxThreadsOpt = configLoader->getInt("iora.threadPool.maxThreads"))
       {
-        if (auto queueSizeOpt =
-                configLoader->getInt("iora.threadPool.queueSize"))
-        {
-          config.threadPool.queueSize =
-              static_cast<std::size_t>(*queueSizeOpt);
-        }
+        config.threadPool.maxThreads = static_cast<std::size_t>(*maxThreadsOpt);
       }
-      if (!config.threadPool.idleTimeoutSeconds.has_value())
+    }
+    if (!config.threadPool.queueSize.has_value())
+    {
+      if (auto queueSizeOpt = configLoader->getInt("iora.threadPool.queueSize"))
       {
-        if (auto idleTimeoutOpt =
-                configLoader->getInt("iora.threadPool.idleTimeoutSeconds"))
-        {
-          config.threadPool.idleTimeoutSeconds =
-              std::chrono::seconds(*idleTimeoutOpt);
-        }
+        config.threadPool.queueSize = static_cast<std::size_t>(*queueSizeOpt);
       }
     }
-    catch (const std::exception& e)
+    if (!config.threadPool.idleTimeoutSeconds.has_value())
     {
-      iora::core::Logger::warning("Failed to load TOML config: " +
-                            std::string(e.what()));
+      if (auto idleTimeoutOpt = configLoader->getInt("iora.threadPool.idleTimeoutSeconds"))
+      {
+        config.threadPool.idleTimeoutSeconds = std::chrono::seconds(*idleTimeoutOpt);
+      }
     }
   }
+  catch (const std::exception &e)
+  {
+    iora::core::Logger::warning("Failed to load TOML config: " + std::string(e.what()));
+  }
+}
 
-  
-
-int main(int argc, char** argv)
+int main(int argc, char **argv)
 {
-  try 
+  try
   {
     std::unique_ptr<iora::core::ConfigLoader> configLoader;
     iora::IoraService::Config config;
@@ -357,24 +331,19 @@ int main(int argc, char** argv)
 
     // Initialize the IoraService with command-line arguments
     iora::IoraService::init(config);
-    
-    std::signal(SIGINT, 
-      [](int) 
-      {
-        iora::IoraService::instanceRef().terminate();
-      }
-    );
-    
+
+    std::signal(SIGINT, [](int) { iora::IoraService::instanceRef().terminate(); });
+
     // Wait for termination
     iora::IoraService::instanceRef().waitForTermination();
   }
-  catch (const std::exception& ex)
+  catch (const std::exception &ex)
   {
     std::cerr << "Error initializing IoraService: " << ex.what() << std::endl;
     iora::IoraService::shutdown();
     return EXIT_FAILURE;
   }
-  
+
   iora::IoraService::shutdown();
   return 0;
 }
\ No newline at end of file
diff --git a/src/modules/connectors/jsonrpc_client/jsonrpc_client.hpp b/src/modules/connectors/jsonrpc_client/jsonrpc_client.hpp
index 643dc78..587379e 100644
--- a/src/modules/connectors/jsonrpc_client/jsonrpc_client.hpp
+++ b/src/modules/connectors/jsonrpc_client/jsonrpc_client.hpp
@@ -8,10 +8,10 @@
 #pragma once
 
 #include <atomic>
+#include <cctype>
 #include <chrono>
 #include <condition_variable>
 #include <cstdint>
-#include <cctype>
 #include <functional>
 #include <future>
 #include <memory>
@@ -26,17 +26,18 @@
 
 #include "iora/iora.hpp"
 
-namespace iora {
-namespace modules {
-namespace connectors {
+namespace iora
+{
+namespace modules
+{
+namespace connectors
+{
 
 /// \brief Base exception for JSON-RPC client errors.
 class JsonRpcError : public std::runtime_error
 {
 public:
-  explicit JsonRpcError(const std::string& what) : std::runtime_error(what)
-  {
-  }
+  explicit JsonRpcError(const std::string &what) : std::runtime_error(what) {}
 };
 
 /// \brief Thrown when a pool has reached its configured maximum size and no
@@ -44,29 +45,24 @@ public:
 class PoolExhaustedError : public JsonRpcError
 {
 public:
-  explicit PoolExhaustedError(const std::string& what) : JsonRpcError(what)
-  {
-  }
+  explicit PoolExhaustedError(const std::string &what) : JsonRpcError(what) {}
 };
 
 /// \brief Thrown when a JSON-RPC response contains an error object.
 class RemoteError : public JsonRpcError
 {
 public:
-  RemoteError(int code, const std::string& message, iora::parsers::Json data)
-    : JsonRpcError("JSON-RPC remote error: (" + std::to_string(code) +
-                    ") " + message),
-      _code(code),
-      _message(message),
-      _data(std::move(data))
+  RemoteError(int code, const std::string &message, iora::parsers::Json data)
+      : JsonRpcError("JSON-RPC remote error: (" + std::to_string(code) + ") " + message),
+        _code(code), _message(message), _data(std::move(data))
   {
   }
 
   int code() const noexcept { return _code; }
 
-  const std::string& message() const noexcept { return _message; }
+  const std::string &message() const noexcept { return _message; }
 
-  const iora::parsers::Json& data() const noexcept { return _data; }
+  const iora::parsers::Json &data() const noexcept { return _data; }
 
 private:
   int _code;
@@ -105,8 +101,7 @@ struct Config
   double retryBackoffMultiplier{2.0};
 
   /// \brief Initial retry delay in milliseconds.
-  std::chrono::milliseconds initialRetryDelay{
-      std::chrono::milliseconds(100)};
+  std::chrono::milliseconds initialRetryDelay{std::chrono::milliseconds(100)};
 
   /// \brief Maximum retry delay in milliseconds.
   std::chrono::milliseconds maxRetryDelay{std::chrono::seconds(5)};
@@ -120,20 +115,18 @@ struct Config
   /// \brief Default HTTP headers applied to every request; call-specific
   /// headers can override.
   std::vector<std::pair<std::string, std::string>> defaultHeaders{
-      {"Content-Type", "application/json"}};
+    {"Content-Type", "application/json"}};
 
   /// \brief Optional factory for creating HttpClient instances (injectable
   /// for tests).
-  std::function<std::unique_ptr<iora::network::HttpClient>(
-      const std::string& endpoint)>
-      httpClientFactory{};
+  std::function<std::unique_ptr<iora::network::HttpClient>(const std::string &endpoint)>
+    httpClientFactory{};
 
   /// \brief Optional hook to configure a freshly created HttpClient (e.g.,
   /// TLS). \details Called after httpClientFactory() returns and before
   /// first use.
-  std::function<void(const std::string& endpoint,
-                      iora::network::HttpClient& client)>
-      httpClientConfigurer{};
+  std::function<void(const std::string &endpoint, iora::network::HttpClient &client)>
+    httpClientConfigurer{};
 };
 
 /// \brief JSON-RPC client statistics.
@@ -174,239 +167,215 @@ struct BatchItem
   std::optional<std::uint64_t> id; // None for notifications
 
   BatchItem(std::string method, iora::parsers::Json params)
-    : method(std::move(method)), params(std::move(params))
+      : method(std::move(method)), params(std::move(params))
   {
   }
 
   BatchItem(std::string method, iora::parsers::Json params, std::uint64_t id)
-    : method(std::move(method)), params(std::move(params)), id(id)
+      : method(std::move(method)), params(std::move(params)), id(id)
   {
   }
 };
 
 namespace detail
 {
-  class PooledConnection
+class PooledConnection
+{
+public:
+  explicit PooledConnection(std::unique_ptr<iora::network::HttpClient> client)
+      : _client(std::move(client)), _inUse(false), _lastUsed(std::chrono::steady_clock::now())
   {
-  public:
-    explicit PooledConnection(
-        std::unique_ptr<iora::network::HttpClient> client)
-      : _client(std::move(client)),
-        _inUse(false),
-        _lastUsed(std::chrono::steady_clock::now())
-    {
-    }
+  }
 
-    iora::network::HttpClient& client() { return *_client; }
+  iora::network::HttpClient &client() { return *_client; }
 
-    void markInUse() { _inUse = true; }
+  void markInUse() { _inUse = true; }
 
-    void markFree()
-    {
-      _inUse = false;
-      _lastUsed = std::chrono::steady_clock::now();
-    }
+  void markFree()
+  {
+    _inUse = false;
+    _lastUsed = std::chrono::steady_clock::now();
+  }
 
-    bool inUse() const { return _inUse; }
+  bool inUse() const { return _inUse; }
 
-    std::chrono::steady_clock::time_point lastUsed() const
-    {
-      return _lastUsed;
-    }
+  std::chrono::steady_clock::time_point lastUsed() const { return _lastUsed; }
 
-  private:
-    std::unique_ptr<iora::network::HttpClient> _client;
-    bool _inUse;
-    std::chrono::steady_clock::time_point _lastUsed;
-  };
+private:
+  std::unique_ptr<iora::network::HttpClient> _client;
+  bool _inUse;
+  std::chrono::steady_clock::time_point _lastUsed;
+};
 
-  class EndpointPool
-  {
-  public:
-    explicit EndpointPool(const std::string& endpoint)
+class EndpointPool
+{
+public:
+  explicit EndpointPool(const std::string &endpoint)
       : _endpoint(endpoint), _lastTouched(std::chrono::steady_clock::now())
-    {
-    }
+  {
+  }
 
-    std::optional<std::size_t>
-    tryAcquireFree(std::chrono::milliseconds idleTimeout)
+  std::optional<std::size_t> tryAcquireFree(std::chrono::milliseconds idleTimeout)
+  {
+    const auto now = std::chrono::steady_clock::now();
+    for (std::size_t i = 0; i < _connections.size(); ++i)
     {
-      const auto now = std::chrono::steady_clock::now();
-      for (std::size_t i = 0; i < _connections.size(); ++i)
+      auto &pc = _connections[i];
+      if (!pc->inUse())
       {
-        auto& pc = _connections[i];
-        if (!pc->inUse())
+        if ((now - pc->lastUsed()) > idleTimeout)
         {
-          if ((now - pc->lastUsed()) > idleTimeout)
-          {
-            _connections.erase(_connections.begin() + static_cast<long>(i));
-            --i;
-            continue;
-          }
-          pc->markInUse();
-          touch();
-          return i;
+          _connections.erase(_connections.begin() + static_cast<long>(i));
+          --i;
+          continue;
         }
+        pc->markInUse();
+        touch();
+        return i;
       }
-      return std::nullopt;
-    }
-
-    std::size_t createAndAcquire(
-        const std::function<std::unique_ptr<iora::network::HttpClient>(
-            const std::string&)>& factory,
-        ClientStats* stats = nullptr)
-    {
-      _connections.emplace_back(
-          std::make_unique<PooledConnection>(factory(_endpoint)));
-      _connections.back()->markInUse();
-      touch();
-      if (stats)
-      {
-        stats->connectionsCreated++;
-      }
-      return _connections.size() - 1;
     }
+    return std::nullopt;
+  }
 
-    void release(std::size_t idx)
+  std::size_t createAndAcquire(
+    const std::function<std::unique_ptr<iora::network::HttpClient>(const std::string &)> &factory,
+    ClientStats *stats = nullptr)
+  {
+    _connections.emplace_back(std::make_unique<PooledConnection>(factory(_endpoint)));
+    _connections.back()->markInUse();
+    touch();
+    if (stats)
     {
-      _connections[idx]->markFree();
-      touch();
+      stats->connectionsCreated++;
     }
+    return _connections.size() - 1;
+  }
 
-    iora::network::HttpClient& clientAt(std::size_t idx)
-    {
-      return _connections[idx]->client();
-    }
+  void release(std::size_t idx)
+  {
+    _connections[idx]->markFree();
+    touch();
+  }
 
-    std::size_t purgeIdle(std::chrono::milliseconds idleTimeout)
-    {
-      const auto now = std::chrono::steady_clock::now();
-      std::size_t evicted = 0;
+  iora::network::HttpClient &clientAt(std::size_t idx) { return _connections[idx]->client(); }
 
-      for (std::size_t i = 0; i < _connections.size(); ++i)
-      {
-        auto& pc = _connections[i];
-        if (!pc->inUse() && ((now - pc->lastUsed()) > idleTimeout))
-        {
-          _connections.erase(_connections.begin() + static_cast<long>(i));
-          ++evicted;
-          --i;
-        }
-      }
-      if (evicted > 0)
-      {
-        touch();
-      }
-      return evicted;
-    }
+  std::size_t purgeIdle(std::chrono::milliseconds idleTimeout)
+  {
+    const auto now = std::chrono::steady_clock::now();
+    std::size_t evicted = 0;
 
-    template <typename Fn> void forEachIdle(Fn&& fn)
+    for (std::size_t i = 0; i < _connections.size(); ++i)
     {
-      for (std::size_t i = 0; i < _connections.size(); ++i)
+      auto &pc = _connections[i];
+      if (!pc->inUse() && ((now - pc->lastUsed()) > idleTimeout))
       {
-        const auto& pc = _connections[i];
-        if (!pc->inUse())
-        {
-          fn(i, pc->lastUsed());
-        }
+        _connections.erase(_connections.begin() + static_cast<long>(i));
+        ++evicted;
+        --i;
       }
     }
-
-    void eraseAt(std::size_t idx)
+    if (evicted > 0)
     {
-      _connections.erase(_connections.begin() + static_cast<long>(idx));
       touch();
     }
+    return evicted;
+  }
 
-    bool allIdle() const
+  template <typename Fn> void forEachIdle(Fn &&fn)
+  {
+    for (std::size_t i = 0; i < _connections.size(); ++i)
     {
-      for (const auto& pc : _connections)
+      const auto &pc = _connections[i];
+      if (!pc->inUse())
       {
-        if (pc->inUse())
-        {
-          return false;
-        }
+        fn(i, pc->lastUsed());
       }
-      return true;
     }
+  }
 
-    void touch() { _lastTouched = std::chrono::steady_clock::now(); }
+  void eraseAt(std::size_t idx)
+  {
+    _connections.erase(_connections.begin() + static_cast<long>(idx));
+    touch();
+  }
 
-    std::chrono::steady_clock::time_point lastTouched() const
+  bool allIdle() const
+  {
+    for (const auto &pc : _connections)
     {
-      return _lastTouched;
+      if (pc->inUse())
+      {
+        return false;
+      }
     }
+    return true;
+  }
+
+  void touch() { _lastTouched = std::chrono::steady_clock::now(); }
 
-    std::size_t size() const { return _connections.size(); }
+  std::chrono::steady_clock::time_point lastTouched() const { return _lastTouched; }
 
-    const std::string& endpoint() const { return _endpoint; }
+  std::size_t size() const { return _connections.size(); }
 
-  private:
-    std::string _endpoint;
-    std::vector<std::unique_ptr<PooledConnection>> _connections;
-    std::chrono::steady_clock::time_point _lastTouched;
-  };
+  const std::string &endpoint() const { return _endpoint; }
 
-  class ConnectionLease
+private:
+  std::string _endpoint;
+  std::vector<std::unique_ptr<PooledConnection>> _connections;
+  std::chrono::steady_clock::time_point _lastTouched;
+};
+
+class ConnectionLease
+{
+public:
+  ConnectionLease() = delete;
+
+  ConnectionLease(EndpointPool &pool, std::size_t index, iora::network::HttpClient &client,
+                  std::mutex &mutex, std::function<void()> notifyReleased)
+      : _pool(&pool), _index(index), _client(&client), _mutex(&mutex),
+        _notifyReleased(std::move(notifyReleased)), _active(true)
   {
-  public:
-    ConnectionLease() = delete;
-
-    ConnectionLease(EndpointPool& pool, std::size_t index,
-                    iora::network::HttpClient& client, std::mutex& mutex,
-                    std::function<void()> notifyReleased)
-      : _pool(&pool),
-        _index(index),
-        _client(&client),
-        _mutex(&mutex),
-        _notifyReleased(std::move(notifyReleased)),
-        _active(true)
-    {
-    }
+  }
 
-    ConnectionLease(ConnectionLease&& other) noexcept
-      : _pool(other._pool),
-        _index(other._index),
-        _client(other._client),
-        _mutex(other._mutex),
-        _notifyReleased(std::move(other._notifyReleased)),
-        _active(other._active)
-    {
-      other._active = false;
-      other._pool = nullptr;
-      other._client = nullptr;
-      other._mutex = nullptr;
-    }
+  ConnectionLease(ConnectionLease &&other) noexcept
+      : _pool(other._pool), _index(other._index), _client(other._client), _mutex(other._mutex),
+        _notifyReleased(std::move(other._notifyReleased)), _active(other._active)
+  {
+    other._active = false;
+    other._pool = nullptr;
+    other._client = nullptr;
+    other._mutex = nullptr;
+  }
 
-    ConnectionLease& operator=(ConnectionLease&&) = delete;
-    ConnectionLease(const ConnectionLease&) = delete;
-    ConnectionLease& operator=(const ConnectionLease&) = delete;
+  ConnectionLease &operator=(ConnectionLease &&) = delete;
+  ConnectionLease(const ConnectionLease &) = delete;
+  ConnectionLease &operator=(const ConnectionLease &) = delete;
 
-    ~ConnectionLease()
+  ~ConnectionLease()
+  {
+    if (_active && _pool != nullptr && _mutex != nullptr)
     {
-      if (_active && _pool != nullptr && _mutex != nullptr)
       {
-        {
-          std::lock_guard<std::mutex> guard(*_mutex);
-          _pool->release(_index);
-        }
-        if (_notifyReleased)
-        {
-          _notifyReleased();
-        }
+        std::lock_guard<std::mutex> guard(*_mutex);
+        _pool->release(_index);
+      }
+      if (_notifyReleased)
+      {
+        _notifyReleased();
       }
     }
+  }
 
-    iora::network::HttpClient& client() { return *_client; }
+  iora::network::HttpClient &client() { return *_client; }
 
-  private:
-    EndpointPool* _pool;
-    std::size_t _index;
-    iora::network::HttpClient* _client;
-    std::mutex* _mutex;
-    std::function<void()> _notifyReleased;
-    bool _active;
-  };
+private:
+  EndpointPool *_pool;
+  std::size_t _index;
+  iora::network::HttpClient *_client;
+  std::mutex *_mutex;
+  std::function<void()> _notifyReleased;
+  bool _active;
+};
 } // namespace detail
 
 /// \brief JSON-RPC 2.0 client with per-endpoint connection pooling and
@@ -414,21 +383,14 @@ namespace detail
 class JsonRpcClient
 {
 public:
-  JsonRpcClient(iora::IoraService& service,
-                iora::core::ThreadPool& threadPool, Config config = {})
-    : _service(service),
-      _threadPool(threadPool),
-      _config(std::move(config)),
-      _nextId(1),
-      _totalConnections(0)
+  JsonRpcClient(iora::IoraService &service, iora::core::ThreadPool &threadPool, Config config = {})
+      : _service(service), _threadPool(threadPool), _config(std::move(config)), _nextId(1),
+        _totalConnections(0)
   {
     if (!_config.httpClientFactory)
     {
-      _config.httpClientFactory = [](const std::string&)
-      {
-        return std::unique_ptr<iora::network::HttpClient>(
-            new iora::network::HttpClient());
-      };
+      _config.httpClientFactory = [](const std::string &)
+      { return std::unique_ptr<iora::network::HttpClient>(new iora::network::HttpClient()); };
     }
 
     // Apply default keep-alive and compression settings
@@ -442,24 +404,22 @@ public:
     }
   }
 
-  iora::parsers::Json
-  call(const std::string& endpoint, const std::string& method,
-        const iora::parsers::Json& params = iora::parsers::Json::object(),
-        const std::vector<std::pair<std::string, std::string>>& headers = {})
+  iora::parsers::Json call(const std::string &endpoint, const std::string &method,
+                           const iora::parsers::Json &params = iora::parsers::Json::object(),
+                           const std::vector<std::pair<std::string, std::string>> &headers = {})
   {
     _stats.totalRequests++;
 
     try
     {
       auto lease = acquire_(endpoint);
-      iora::parsers::Json req =
-          makeRequestEnvelope_(method, params, nextId_());
-      iora::parsers::Json resp = sendJsonWithRetries_(
-          lease.client(), endpoint, req, mergeHeaders_(headers));
+      iora::parsers::Json req = makeRequestEnvelope_(method, params, nextId_());
+      iora::parsers::Json resp =
+        sendJsonWithRetries_(lease.client(), endpoint, req, mergeHeaders_(headers));
       _stats.successfulRequests++;
       return parseResponseOrThrow_(std::move(resp));
     }
-    catch (const PoolExhaustedError&)
+    catch (const PoolExhaustedError &)
     {
       _stats.poolExhaustions++;
       _stats.failedRequests++;
@@ -472,10 +432,9 @@ public:
     }
   }
 
-  void notify(
-      const std::string& endpoint, const std::string& method,
-      const iora::parsers::Json& params = iora::parsers::Json::object(),
-      const std::vector<std::pair<std::string, std::string>>& headers = {})
+  void notify(const std::string &endpoint, const std::string &method,
+              const iora::parsers::Json &params = iora::parsers::Json::object(),
+              const std::vector<std::pair<std::string, std::string>> &headers = {})
   {
     _stats.totalRequests++;
     _stats.notificationRequests++;
@@ -484,11 +443,10 @@ public:
     {
       auto lease = acquire_(endpoint);
       iora::parsers::Json req = makeNotificationEnvelope_(method, params);
-      (void) sendJsonWithRetries_(lease.client(), endpoint, req,
-                                  mergeHeaders_(headers));
+      (void)sendJsonWithRetries_(lease.client(), endpoint, req, mergeHeaders_(headers));
       _stats.successfulRequests++;
     }
-    catch (const PoolExhaustedError&)
+    catch (const PoolExhaustedError &)
     {
       _stats.poolExhaustions++;
       _stats.failedRequests++;
@@ -501,51 +459,49 @@ public:
     }
   }
 
-  std::future<iora::parsers::Json> callAsync(
-      const std::string& endpoint, const std::string& method,
-      const iora::parsers::Json& params = iora::parsers::Json::object(),
-      const std::vector<std::pair<std::string, std::string>>& headers = {})
+  std::future<iora::parsers::Json>
+  callAsync(const std::string &endpoint, const std::string &method,
+            const iora::parsers::Json &params = iora::parsers::Json::object(),
+            const std::vector<std::pair<std::string, std::string>> &headers = {})
   {
     auto self = this;
-    return submitToPool_(
-        [=]() { return self->call(endpoint, method, params, headers); });
+    return submitToPool_([=]() { return self->call(endpoint, method, params, headers); });
   }
 
-  void
-  callAsync(const std::string& endpoint, const std::string& method,
-            const iora::parsers::Json& params,
-            const std::vector<std::pair<std::string, std::string>>& headers,
-            std::function<void(iora::parsers::Json)> onSuccess,
-            std::function<void(std::exception_ptr)> onError)
+  void callAsync(const std::string &endpoint, const std::string &method,
+                 const iora::parsers::Json &params,
+                 const std::vector<std::pair<std::string, std::string>> &headers,
+                 std::function<void(iora::parsers::Json)> onSuccess,
+                 std::function<void(std::exception_ptr)> onError)
   {
     // Use only copyable captures, no mutable, so operator() is const
     auto self = this;
     auto successCopy = onSuccess;
     auto errorCopy = onError;
     _threadPool.enqueue(
-        [=]()
+      [=]()
+      {
+        try
         {
-          try
+          auto result = self->call(endpoint, method, params, headers);
+          if (successCopy)
           {
-            auto result = self->call(endpoint, method, params, headers);
-            if (successCopy)
-            {
-              successCopy(result);
-            }
+            successCopy(result);
           }
-          catch (...)
+        }
+        catch (...)
+        {
+          if (errorCopy)
           {
-            if (errorCopy)
-            {
-              errorCopy(std::current_exception());
-            }
+            errorCopy(std::current_exception());
           }
-        });
+        }
+      });
   }
 
-  std::vector<iora::parsers::Json> callBatch(
-      const std::string& endpoint, const std::vector<BatchItem>& items,
-      const std::vector<std::pair<std::string, std::string>>& headers = {})
+  std::vector<iora::parsers::Json>
+  callBatch(const std::string &endpoint, const std::vector<BatchItem> &items,
+            const std::vector<std::pair<std::string, std::string>> &headers = {})
   {
     if (items.empty())
     {
@@ -558,25 +514,23 @@ public:
     auto lease = acquire_(endpoint);
     iora::parsers::Json batchReq = iora::parsers::Json::array();
 
-    for (const auto& item : items)
+    for (const auto &item : items)
     {
       if (item.id.has_value())
       {
-        batchReq.push_back(makeRequestEnvelope_(item.method, item.params,
-                                                item.id.value()));
+        batchReq.push_back(makeRequestEnvelope_(item.method, item.params, item.id.value()));
       }
       else
       {
-        batchReq.push_back(
-            makeNotificationEnvelope_(item.method, item.params));
+        batchReq.push_back(makeNotificationEnvelope_(item.method, item.params));
         _stats.notificationRequests++;
       }
     }
 
     try
     {
-      iora::parsers::Json batchResp = sendJson_(
-          lease.client(), endpoint, batchReq, mergeHeaders_(headers));
+      iora::parsers::Json batchResp =
+        sendJson_(lease.client(), endpoint, batchReq, mergeHeaders_(headers));
       _stats.successfulRequests++;
       return parseBatchResponseOrThrow_(std::move(batchResp), items);
     }
@@ -587,13 +541,12 @@ public:
     }
   }
 
-  std::future<std::vector<iora::parsers::Json>> callBatchAsync(
-      const std::string& endpoint, const std::vector<BatchItem>& items,
-      const std::vector<std::pair<std::string, std::string>>& headers = {})
+  std::future<std::vector<iora::parsers::Json>>
+  callBatchAsync(const std::string &endpoint, const std::vector<BatchItem> &items,
+                 const std::vector<std::pair<std::string, std::string>> &headers = {})
   {
     auto self = this;
-    return submitToPool_(
-        [=]() { return self->callBatch(endpoint, items, headers); });
+    return submitToPool_([=]() { return self->callBatch(endpoint, items, headers); });
   }
 
   std::size_t purgeIdle()
@@ -602,9 +555,9 @@ public:
     std::size_t evictedTotal = 0;
 
     for (auto it = _pools.begin(); it != _pools.end();
-          /* increment inside */)
+         /* increment inside */)
     {
-      auto& pool = *(it->second);
+      auto &pool = *(it->second);
       std::size_t evicted = pool.purgeIdle(_config.idleTimeout);
       evictedTotal += evicted;
       _stats.connectionsEvicted += evicted;
@@ -622,94 +575,80 @@ public:
     return evictedTotal;
   }
 
-  const Config& config() const noexcept { return _config; }
+  const Config &config() const noexcept { return _config; }
 
-  const ClientStats& getStats() const noexcept { return _stats; }
+  const ClientStats &getStats() const noexcept { return _stats; }
 
   void resetStats() { _stats.reset(); }
 
 private:
-  detail::ConnectionLease acquire_(const std::string& endpoint)
+  detail::ConnectionLease acquire_(const std::string &endpoint)
   {
     std::unique_lock<std::mutex> lock(_mutex);
 
     // Ensure pool exists (respecting maxEndpointPools with LRU idle pool
     // eviction).
-    auto* poolPtr = findPoolPtr_(endpoint);
+    auto *poolPtr = findPoolPtr_(endpoint);
     if (poolPtr == nullptr)
     {
-      if (_config.maxEndpointPools > 0 &&
-          _pools.size() >= _config.maxEndpointPools)
+      if (_config.maxEndpointPools > 0 && _pools.size() >= _config.maxEndpointPools)
       {
         evictOneIdlePoolLruLocked_(); // best-effort
       }
       poolPtr = &getOrCreatePoolLocked_(endpoint);
     }
-    auto& pool = *poolPtr;
+    auto &pool = *poolPtr;
 
     // Try to reuse a free connection first.
     if (auto idx = pool.tryAcquireFree(_config.idleTimeout))
     {
-      auto& ref = pool.clientAt(*idx);
+      auto &ref = pool.clientAt(*idx);
       lock.unlock();
-      return detail::ConnectionLease(pool, *idx, ref, _mutex,
-                                      [this]() { _released.notify_all(); });
+      return detail::ConnectionLease(pool, *idx, ref, _mutex, [this]() { _released.notify_all(); });
     }
 
     // Can we create a new one?
-    const bool underPerEndpointCap =
-        pool.size() < _config.maxConnectionsPerEndpoint;
+    const bool underPerEndpointCap = pool.size() < _config.maxConnectionsPerEndpoint;
     const bool underGlobalCap =
-        (_config.globalMaxConnections == 0) ||
-        (_totalConnections < _config.globalMaxConnections);
+      (_config.globalMaxConnections == 0) || (_totalConnections < _config.globalMaxConnections);
 
     if (underPerEndpointCap && underGlobalCap)
     {
-      const auto idx =
-          pool.createAndAcquire([this](const std::string& ep)
-                                { return this->makeHttpClient_(ep); },
-                                &_stats);
+      const auto idx = pool.createAndAcquire([this](const std::string &ep)
+                                             { return this->makeHttpClient_(ep); }, &_stats);
       ++_totalConnections;
-      auto& ref = pool.clientAt(idx);
+      auto &ref = pool.clientAt(idx);
       lock.unlock();
-      return detail::ConnectionLease(pool, idx, ref, _mutex,
-                                      [this]() { _released.notify_all(); });
+      return detail::ConnectionLease(pool, idx, ref, _mutex, [this]() { _released.notify_all(); });
     }
 
     // Try global LRU eviction of one idle connection across all pools.
     if (underPerEndpointCap && tryEvictOneIdleConnLruLocked_())
     {
-      const auto idx =
-          pool.createAndAcquire([this](const std::string& ep)
-                                { return this->makeHttpClient_(ep); },
-                                &_stats);
+      const auto idx = pool.createAndAcquire([this](const std::string &ep)
+                                             { return this->makeHttpClient_(ep); }, &_stats);
       _totalConnections = recalcTotalLocked_();
-      auto& ref = pool.clientAt(idx);
+      auto &ref = pool.clientAt(idx);
       lock.unlock();
-      return detail::ConnectionLease(pool, idx, ref, _mutex,
-                                      [this]() { _released.notify_all(); });
+      return detail::ConnectionLease(pool, idx, ref, _mutex, [this]() { _released.notify_all(); });
     }
 
     // As a last resort, try to evict an entire idle pool (LRU) to free
     // capacity.
     if (underPerEndpointCap && evictOneIdlePoolLruLocked_())
     {
-      const auto idx =
-          pool.createAndAcquire([this](const std::string& ep)
-                                { return this->makeHttpClient_(ep); },
-                                &_stats);
+      const auto idx = pool.createAndAcquire([this](const std::string &ep)
+                                             { return this->makeHttpClient_(ep); }, &_stats);
       _totalConnections = recalcTotalLocked_();
-      auto& ref = pool.clientAt(idx);
+      auto &ref = pool.clientAt(idx);
       lock.unlock();
-      return detail::ConnectionLease(pool, idx, ref, _mutex,
-                                      [this]() { _released.notify_all(); });
+      return detail::ConnectionLease(pool, idx, ref, _mutex, [this]() { _released.notify_all(); });
     }
 
-    throw PoolExhaustedError(
-        "No available HTTP connections for endpoint: " + endpoint);
+    throw PoolExhaustedError("No available HTTP connections for endpoint: " + endpoint);
   }
 
-  detail::EndpointPool* findPoolPtr_(const std::string& endpoint)
+  detail::EndpointPool *findPoolPtr_(const std::string &endpoint)
   {
     auto it = _pools.find(endpoint);
     if (it == _pools.end())
@@ -719,13 +658,12 @@ private:
     return it->second.get();
   }
 
-  detail::EndpointPool& getOrCreatePoolLocked_(const std::string& endpoint)
+  detail::EndpointPool &getOrCreatePoolLocked_(const std::string &endpoint)
   {
     auto it = _pools.find(endpoint);
     if (it == _pools.end())
     {
-      auto inserted = _pools.emplace(
-          endpoint, std::make_unique<detail::EndpointPool>(endpoint));
+      auto inserted = _pools.emplace(endpoint, std::make_unique<detail::EndpointPool>(endpoint));
       return *(inserted.first->second);
     }
     return *(it->second);
@@ -734,7 +672,7 @@ private:
   std::size_t recalcTotalLocked_() const
   {
     std::size_t total = 0;
-    for (const auto& kv : _pools)
+    for (const auto &kv : _pools)
     {
       total += kv.second->size();
     }
@@ -749,19 +687,19 @@ private:
     std::size_t bestIdx = static_cast<std::size_t>(-1);
     auto bestTime = std::chrono::steady_clock::time_point::max();
 
-    for (auto& kv : _pools)
+    for (auto &kv : _pools)
     {
-      auto& pool = *kv.second;
+      auto &pool = *kv.second;
       pool.forEachIdle(
-          [&](std::size_t idx, std::chrono::steady_clock::time_point t)
+        [&](std::size_t idx, std::chrono::steady_clock::time_point t)
+        {
+          if (t < bestTime)
           {
-            if (t < bestTime)
-            {
-              bestTime = t;
-              bestIdx = idx;
-              bestKey = kv.first;
-            }
-          });
+            bestTime = t;
+            bestIdx = idx;
+            bestKey = kv.first;
+          }
+        });
     }
 
     if (bestIdx != static_cast<std::size_t>(-1))
@@ -788,9 +726,9 @@ private:
     std::string bestKey;
     auto bestTime = std::chrono::steady_clock::time_point::max();
 
-    for (auto& kv : _pools)
+    for (auto &kv : _pools)
     {
-      auto& pool = *kv.second;
+      auto &pool = *kv.second;
       if (pool.allIdle())
       {
         const auto t = pool.lastTouched();
@@ -815,9 +753,9 @@ private:
     return false;
   }
 
-  static iora::parsers::Json
-  makeRequestEnvelope_(const std::string& method,
-                        const iora::parsers::Json& params, std::uint64_t id)
+  static iora::parsers::Json makeRequestEnvelope_(const std::string &method,
+                                                  const iora::parsers::Json &params,
+                                                  std::uint64_t id)
   {
     iora::parsers::Json j;
     j["jsonrpc"] = "2.0";
@@ -832,9 +770,8 @@ private:
     return j;
   }
 
-  static iora::parsers::Json
-  makeNotificationEnvelope_(const std::string& method,
-                            const iora::parsers::Json& params)
+  static iora::parsers::Json makeNotificationEnvelope_(const std::string &method,
+                                                       const iora::parsers::Json &params)
   {
     iora::parsers::Json j;
     j["jsonrpc"] = "2.0";
@@ -848,16 +785,15 @@ private:
     return j;
   }
 
-  std::vector<std::pair<std::string, std::string>> mergeHeaders_(
-      const std::vector<std::pair<std::string, std::string>>& extra) const
+  std::vector<std::pair<std::string, std::string>>
+  mergeHeaders_(const std::vector<std::pair<std::string, std::string>> &extra) const
   {
-    std::vector<std::pair<std::string, std::string>> out =
-        _config.defaultHeaders;
+    std::vector<std::pair<std::string, std::string>> out = _config.defaultHeaders;
 
-    for (const auto& kv : extra)
+    for (const auto &kv : extra)
     {
       bool replaced = false;
-      for (auto& base : out)
+      for (auto &base : out)
       {
         if (casecmp_(base.first, kv.first))
         {
@@ -874,7 +810,7 @@ private:
     return out;
   }
 
-  static bool casecmp_(const std::string& a, const std::string& b)
+  static bool casecmp_(const std::string &a, const std::string &b)
   {
     if (a.size() != b.size())
     {
@@ -882,10 +818,8 @@ private:
     }
     for (std::size_t i = 0; i < a.size(); ++i)
     {
-      char ca =
-          static_cast<char>(std::tolower(static_cast<unsigned char>(a[i])));
-      char cb =
-          static_cast<char>(std::tolower(static_cast<unsigned char>(b[i])));
+      char ca = static_cast<char>(std::tolower(static_cast<unsigned char>(a[i])));
+      char cb = static_cast<char>(std::tolower(static_cast<unsigned char>(b[i])));
       if (ca != cb)
       {
         return false;
@@ -898,14 +832,15 @@ private:
   {
     if (resp.is_object())
     {
-      const auto& obj = resp;
+      const auto &obj = resp;
       if (obj.contains("error"))
       {
-        const auto& err = obj["error"];
+        const auto &err = obj["error"];
         int code = err.contains("code") ? err["code"].get<int>() : -32000;
-        std::string message =
-            err.contains("message") ? err["message"].get<std::string>() : std::string{"Unknown error"};
-        iora::parsers::Json data = err.contains("data") ? err["data"] : iora::parsers::Json(nullptr);
+        std::string message = err.contains("message") ? err["message"].get<std::string>()
+                                                      : std::string{"Unknown error"};
+        iora::parsers::Json data =
+          err.contains("data") ? err["data"] : iora::parsers::Json(nullptr);
         throw RemoteError(code, message, std::move(data));
       }
       if (obj.contains("result"))
@@ -916,58 +851,57 @@ private:
     return resp;
   }
 
-  std::uint64_t nextId_()
-  {
-    return _nextId.fetch_add(1, std::memory_order_relaxed);
-  }
+  std::uint64_t nextId_() { return _nextId.fetch_add(1, std::memory_order_relaxed); }
 
-  std::unique_ptr<iora::network::HttpClient>
-  makeHttpClient_(const std::string& endpoint)
+  std::unique_ptr<iora::network::HttpClient> makeHttpClient_(const std::string &endpoint)
   {
     // Use a future to make HTTP client construction timeout-aware
     // This prevents hanging if there are transport layer conflicts
-    auto clientFuture = std::async(std::launch::async, [this, &endpoint]() {
-      auto cli = _config.httpClientFactory(endpoint);
-      if (!cli)
-      {
-        throw JsonRpcError("httpClientFactory returned null");
-      }
-      if (_config.httpClientConfigurer)
-      {
-        _config.httpClientConfigurer(endpoint, *cli);
-      }
-      return cli;
-    });
-    
+    auto clientFuture = std::async(std::launch::async,
+                                   [this, &endpoint]()
+                                   {
+                                     auto cli = _config.httpClientFactory(endpoint);
+                                     if (!cli)
+                                     {
+                                       throw JsonRpcError("httpClientFactory returned null");
+                                     }
+                                     if (_config.httpClientConfigurer)
+                                     {
+                                       _config.httpClientConfigurer(endpoint, *cli);
+                                     }
+                                     return cli;
+                                   });
+
     // Wait for client creation with timeout (30 seconds should be more than enough)
     auto status = clientFuture.wait_for(std::chrono::seconds(30));
-    if (status == std::future_status::timeout) {
+    if (status == std::future_status::timeout)
+    {
       throw JsonRpcError("HTTP client creation timed out - likely transport layer conflict");
     }
-    
+
     auto cli = clientFuture.get();
     return cli;
   }
 
-  iora::parsers::Json
-  sendJson_(iora::network::HttpClient& http, const std::string& url,
-            const iora::parsers::Json& payload,
-            const std::vector<std::pair<std::string, std::string>>& headers)
+  iora::parsers::Json sendJson_(iora::network::HttpClient &http, const std::string &url,
+                                const iora::parsers::Json &payload,
+                                const std::vector<std::pair<std::string, std::string>> &headers)
   {
     // Convert vector to map for HttpClient
     std::map<std::string, std::string> headerMap;
-    for (const auto& kv : headers)
+    for (const auto &kv : headers)
     {
       headerMap[kv.first] = kv.second;
     }
-    auto response = http.postJson(url, payload, headerMap, 0); // No retries at HTTP level - retries handled by JSON-RPC client
+    auto response = http.postJson(
+      url, payload, headerMap, 0); // No retries at HTTP level - retries handled by JSON-RPC client
     return iora::network::HttpClient::parseJsonOrThrow(response);
   }
 
-  iora::parsers::Json sendJsonWithRetries_(
-      iora::network::HttpClient& http, const std::string& url,
-      const iora::parsers::Json& payload,
-      const std::vector<std::pair<std::string, std::string>>& headers)
+  iora::parsers::Json
+  sendJsonWithRetries_(iora::network::HttpClient &http, const std::string &url,
+                       const iora::parsers::Json &payload,
+                       const std::vector<std::pair<std::string, std::string>> &headers)
   {
     std::size_t attempts = 0;
     std::chrono::milliseconds delay = _config.initialRetryDelay;
@@ -978,7 +912,7 @@ private:
       {
         return sendJson_(http, url, payload, headers);
       }
-      catch (const std::exception& e)
+      catch (const std::exception &e)
       {
         attempts++;
         if (attempts > _config.maxRetries)
@@ -994,17 +928,16 @@ private:
         std::this_thread::sleep_for(delay);
 
         // Exponential backoff with jitter
-        delay =
-            std::min(std::chrono::milliseconds(static_cast<long>(
-                          delay.count() * _config.retryBackoffMultiplier)),
-                      _config.maxRetryDelay);
+        delay = std::min(std::chrono::milliseconds(
+                           static_cast<long>(delay.count() * _config.retryBackoffMultiplier)),
+                         _config.maxRetryDelay);
       }
     }
   }
 
   std::vector<iora::parsers::Json>
   parseBatchResponseOrThrow_(iora::parsers::Json batchResp,
-                              const std::vector<BatchItem>& originalItems)
+                             const std::vector<BatchItem> &originalItems)
   {
     if (!batchResp.is_array())
     {
@@ -1016,7 +949,7 @@ private:
 
     // Create map of id -> response for efficient lookup
     std::unordered_map<std::uint64_t, iora::parsers::Json> responseMap;
-    for (const auto& respItem : batchResp)
+    for (const auto &respItem : batchResp)
     {
       if (respItem.contains("id") && !respItem["id"].is_null())
       {
@@ -1026,7 +959,7 @@ private:
     }
 
     // Match responses to original requests by ID
-    for (const auto& item : originalItems)
+    for (const auto &item : originalItems)
     {
       if (item.id.has_value())
       {
@@ -1037,8 +970,7 @@ private:
         }
         else
         {
-          throw JsonRpcError("Missing response for request ID: " +
-                              std::to_string(item.id.value()));
+          throw JsonRpcError("Missing response for request ID: " + std::to_string(item.id.value()));
         }
       }
       else
@@ -1051,20 +983,18 @@ private:
     return results;
   }
 
-  template <typename Fn>
-  auto submitToPool_(Fn&& fn) -> std::future<std::invoke_result_t<Fn>>
+  template <typename Fn> auto submitToPool_(Fn &&fn) -> std::future<std::invoke_result_t<Fn>>
   {
     return _threadPool.enqueueWithResult(std::forward<Fn>(fn));
   }
 
 private:
-  iora::IoraService& _service;
-  iora::core::ThreadPool& _threadPool;
+  iora::IoraService &_service;
+  iora::core::ThreadPool &_threadPool;
   Config _config;
   ClientStats _stats;
 
-  std::unordered_map<std::string, std::unique_ptr<detail::EndpointPool>>
-      _pools;
+  std::unordered_map<std::string, std::unique_ptr<detail::EndpointPool>> _pools;
   std::mutex _mutex;
   std::condition_variable _released;
 
@@ -1072,4 +1002,6 @@ private:
   std::size_t _totalConnections;
 };
 
-} } } // namespace iora::modules::jsonrpc
+} // namespace connectors
+} // namespace modules
+} // namespace iora
diff --git a/src/modules/connectors/jsonrpc_client/mod_jsonrpc_client.cpp b/src/modules/connectors/jsonrpc_client/mod_jsonrpc_client.cpp
index e934063..e884cb1 100644
--- a/src/modules/connectors/jsonrpc_client/mod_jsonrpc_client.cpp
+++ b/src/modules/connectors/jsonrpc_client/mod_jsonrpc_client.cpp
@@ -102,8 +102,8 @@
 #include <vector>
 
 #include "iora/iora.hpp"
-#include "jsonrpc_client.hpp"
 #include "iora/network/http_client.hpp"
+#include "jsonrpc_client.hpp"
 
 namespace iora
 {
@@ -116,21 +116,17 @@ namespace iora
 class JsonRpcClientPlugin : public IoraService::Plugin
 {
 public:
-  explicit JsonRpcClientPlugin(iora::IoraService* service)
-    : Plugin(service),
-      _enabled(true),
-      _clientConfig(),
-      _jobIdCounter(1),
-      _externalPool(nullptr)
+  explicit JsonRpcClientPlugin(iora::IoraService *service)
+      : Plugin(service), _enabled(true), _clientConfig(), _jobIdCounter(1), _externalPool(nullptr)
   {
   }
 
-  const char* name() const { return "jsonrpc-client"; }
+  const char *name() const { return "jsonrpc-client"; }
 
-  void onLoad(IoraService* service) override
+  void onLoad(IoraService *service) override
   {
     // ---- Load configuration ----
-    auto* loader = service->configLoader().get();
+    auto *loader = service->configLoader().get();
     if (loader)
     {
       try
@@ -138,77 +134,61 @@ public:
         if (auto v = loader->getBool("iora.modules.jsonrpcClient.enabled"))
           _enabled = *v;
 
-        if (auto v =
-                loader->getInt("iora.modules.jsonrpcClient.maxConnections"))
-          _clientConfig.maxConnectionsPerEndpoint =
-              static_cast<std::size_t>(*v);
+        if (auto v = loader->getInt("iora.modules.jsonrpcClient.maxConnections"))
+          _clientConfig.maxConnectionsPerEndpoint = static_cast<std::size_t>(*v);
 
-        if (auto v = loader->getInt(
-                "iora.modules.jsonrpcClient.globalMaxConnections"))
+        if (auto v = loader->getInt("iora.modules.jsonrpcClient.globalMaxConnections"))
           _clientConfig.globalMaxConnections = static_cast<std::size_t>(*v);
 
-        if (auto v =
-                loader->getInt("iora.modules.jsonrpcClient.maxEndpointPools"))
+        if (auto v = loader->getInt("iora.modules.jsonrpcClient.maxEndpointPools"))
           _clientConfig.maxEndpointPools = static_cast<std::size_t>(*v);
 
         if (auto v = loader->getInt("iora.modules.jsonrpcClient.idleTimeoutMs"))
           _clientConfig.idleTimeout = std::chrono::milliseconds(*v);
 
-        if (auto v =
-                loader->getInt("iora.modules.jsonrpcClient.requestTimeoutMs"))
+        if (auto v = loader->getInt("iora.modules.jsonrpcClient.requestTimeoutMs"))
           _clientConfig.requestTimeout = std::chrono::milliseconds(*v);
 
-        if (auto v = loader->getInt(
-                "iora.modules.jsonrpcClient.connectionTimeoutMs"))
+        if (auto v = loader->getInt("iora.modules.jsonrpcClient.connectionTimeoutMs"))
           _clientConfig.connectionTimeout = std::chrono::milliseconds(*v);
 
         if (auto v = loader->getInt("iora.modules.jsonrpcClient.maxRetries"))
           _clientConfig.maxRetries = static_cast<std::size_t>(*v);
 
         // ConfigLoader may not have getDouble, so we'll use getString and parse
-        if (auto v = loader->getString(
-                "iora.modules.jsonrpcClient.retryBackoffMultiplier"))
+        if (auto v = loader->getString("iora.modules.jsonrpcClient.retryBackoffMultiplier"))
           _clientConfig.retryBackoffMultiplier = std::stod(*v);
 
-        if (auto v = loader->getInt(
-                "iora.modules.jsonrpcClient.initialRetryDelayMs"))
+        if (auto v = loader->getInt("iora.modules.jsonrpcClient.initialRetryDelayMs"))
           _clientConfig.initialRetryDelay = std::chrono::milliseconds(*v);
 
-        if (auto v =
-                loader->getInt("iora.modules.jsonrpcClient.maxRetryDelayMs"))
+        if (auto v = loader->getInt("iora.modules.jsonrpcClient.maxRetryDelayMs"))
           _clientConfig.maxRetryDelay = std::chrono::milliseconds(*v);
 
-        if (auto v =
-                loader->getBool("iora.modules.jsonrpcClient.enableKeepAlive"))
+        if (auto v = loader->getBool("iora.modules.jsonrpcClient.enableKeepAlive"))
           _clientConfig.enableKeepAlive = *v;
 
-        if (auto v =
-                loader->getBool("iora.modules.jsonrpcClient.enableCompression"))
+        if (auto v = loader->getBool("iora.modules.jsonrpcClient.enableCompression"))
           _clientConfig.enableCompression = *v;
 
-        if (auto v =
-                loader->getString("iora.modules.jsonrpcClient.defaultHeaders"))
+        if (auto v = loader->getString("iora.modules.jsonrpcClient.defaultHeaders"))
         {
           _clientConfig.defaultHeaders = parseHeaderList(*v);
         }
 
         // TLS options (applied for https:// endpoints)
         const bool verifyPeer =
-            loader->getBool("iora.modules.jsonrpcClient.tls.verifyPeer")
-                .value_or(true);
+          loader->getBool("iora.modules.jsonrpcClient.tls.verifyPeer").value_or(true);
         const std::string caCertPath =
-            loader->getString("iora.modules.jsonrpcClient.tls.caCertPath")
-                .value_or("");
+          loader->getString("iora.modules.jsonrpcClient.tls.caCertPath").value_or("");
         const std::string clientCertPath =
-            loader->getString("iora.modules.jsonrpcClient.tls.clientCertPath")
-                .value_or("");
+          loader->getString("iora.modules.jsonrpcClient.tls.clientCertPath").value_or("");
         const std::string clientKeyPath =
-            loader->getString("iora.modules.jsonrpcClient.tls.clientKeyPath")
-                .value_or("");
+          loader->getString("iora.modules.jsonrpcClient.tls.clientKeyPath").value_or("");
 
         _clientConfig.httpClientConfigurer =
-            [verifyPeer, caCertPath, clientCertPath, clientKeyPath](
-                const std::string& endpoint, iora::network::HttpClient& client)
+          [verifyPeer, caCertPath, clientCertPath, clientKeyPath](const std::string &endpoint,
+                                                                  iora::network::HttpClient &client)
         {
           const bool isHttps = endpoint.rfind("https://", 0) == 0;
           if (!isHttps)
@@ -227,27 +207,23 @@ public:
         };
 
         iora::core::Logger::info(
-            "JSON-RPC client plugin configured: per-endpoint max=" +
-            std::to_string(_clientConfig.maxConnectionsPerEndpoint) +
-            ", global max=" +
-            std::to_string(_clientConfig.globalMaxConnections) +
-            ", pools max=" + std::to_string(_clientConfig.maxEndpointPools) +
-            ", reqTimeoutMs=" +
-            std::to_string(_clientConfig.requestTimeout.count()));
+          "JSON-RPC client plugin configured: per-endpoint max=" +
+          std::to_string(_clientConfig.maxConnectionsPerEndpoint) +
+          ", global max=" + std::to_string(_clientConfig.globalMaxConnections) +
+          ", pools max=" + std::to_string(_clientConfig.maxEndpointPools) +
+          ", reqTimeoutMs=" + std::to_string(_clientConfig.requestTimeout.count()));
       }
-      catch (const std::exception& e)
+      catch (const std::exception &e)
       {
-        iora::core::Logger::warning(
-            "Failed to load JSON-RPC client configuration: " +
-            std::string(e.what()) + ", using defaults");
+        iora::core::Logger::warning("Failed to load JSON-RPC client configuration: " +
+                                    std::string(e.what()) + ", using defaults");
       }
     }
 
     // ---- Resolve ThreadPool ----
     // Integration point: if your service exposes a different accessor, adjust
     // here.
-    _externalPool =
-        service->threadPool().get(); // threadPool() is a const method
+    _externalPool = service->threadPool().get(); // threadPool() is a const method
     if (!_externalPool)
     {
       iora::core::Logger::error("JSON-RPC client plugin requires a ThreadPool, "
@@ -255,8 +231,8 @@ public:
       return;
     }
     // ---- Construct client ----
-    _client = std::make_unique<iora::modules::connectors::JsonRpcClient>(
-        *service, *_externalPool, _clientConfig);
+    _client = std::make_unique<iora::modules::connectors::JsonRpcClient>(*service, *_externalPool,
+                                                                         _clientConfig);
 
     // ---- Export APIs ----
     service->exportApi(*this, "jsonrpc.client.version",
@@ -266,196 +242,206 @@ public:
                        });
 
     service->exportApi(
-        *this, "jsonrpc.client.call",
-        [this](const std::string& endpoint, const std::string& method,
-               const iora::parsers::Json& params,
-               const std::vector<std::pair<std::string, std::string>>& headers)
-            -> iora::parsers::Json
-        {
-          // Direct call - let exceptions propagate for proper error handling
-          return _client->call(endpoint, method, params, headers);
-        });
+      *this, "jsonrpc.client.call",
+      [this](const std::string &endpoint, const std::string &method,
+             const iora::parsers::Json &params,
+             const std::vector<std::pair<std::string, std::string>> &headers) -> iora::parsers::Json
+      {
+        // Direct call - let exceptions propagate for proper error handling
+        return _client->call(endpoint, method, params, headers);
+      });
 
     service->exportApi(
-        *this, "jsonrpc.client.notify",
-        [this](const std::string& endpoint, const std::string& method,
-               const iora::parsers::Json& params,
-               const std::vector<std::pair<std::string, std::string>>& headers)
-            -> void { _client->notify(endpoint, method, params, headers); });
+      *this, "jsonrpc.client.notify",
+      [this](const std::string &endpoint, const std::string &method,
+             const iora::parsers::Json &params,
+             const std::vector<std::pair<std::string, std::string>> &headers) -> void
+      { _client->notify(endpoint, method, params, headers); });
 
     service->exportApi(
-        *this, "jsonrpc.client.callAsync",
-        [this](const std::string& endpoint, const std::string& method,
-               const iora::parsers::Json& params,
-               const std::vector<std::pair<std::string, std::string>>& headers)
-            -> std::string
-        {
-          const std::string jobId = nextJobId_();
+      *this, "jsonrpc.client.callAsync",
+      [this](const std::string &endpoint, const std::string &method,
+             const iora::parsers::Json &params,
+             const std::vector<std::pair<std::string, std::string>> &headers) -> std::string
+      {
+        const std::string jobId = nextJobId_();
 
-          // Lambdas must be copyable/movable for thread pool
-          auto onSuccess = [this, jobId](iora::parsers::Json result)
+        // Lambdas must be copyable/movable for thread pool
+        auto onSuccess = [this, jobId](iora::parsers::Json result)
+        {
+          std::lock_guard<std::mutex> lock(_jobsMutex);
+          auto jobResult = iora::parsers::Json::object();
+          jobResult["done"] = true;
+          jobResult["result"] = std::move(result);
+          _jobs[jobId] = jobResult;
+        };
+        auto onError = [this, jobId](std::exception_ptr ep)
+        {
+          auto err = iora::parsers::Json::object();
+          err["code"] = -32000;
+          err["message"] = "Unknown error";
+          err["data"] = nullptr;
+          try
           {
-            std::lock_guard<std::mutex> lock(_jobsMutex);
-            auto jobResult = iora::parsers::Json::object();
-            jobResult["done"] = true;
-            jobResult["result"] = std::move(result);
-            _jobs[jobId] = jobResult;
-          };
-          auto onError = [this, jobId](std::exception_ptr ep)
+            if (ep)
+              std::rethrow_exception(ep);
+          }
+          catch (const iora::modules::connectors::RemoteError &re)
           {
-            auto err = iora::parsers::Json::object();
-            err["code"] = -32000;
-            err["message"] = "Unknown error";
-            err["data"] = nullptr;
-            try
-            {
-              if (ep)
-                std::rethrow_exception(ep);
-            }
-            catch (const iora::modules::connectors::RemoteError& re)
-            {
-              err["code"] = re.code();
-              err["message"] = re.message();
-              err["data"] = re.data();
-            }
-            catch (const std::exception& e)
-            {
-              err["message"] = e.what();
-            }
+            err["code"] = re.code();
+            err["message"] = re.message();
+            err["data"] = re.data();
+          }
+          catch (const std::exception &e)
+          {
+            err["message"] = e.what();
+          }
 
-            std::lock_guard<std::mutex> lock(_jobsMutex);
-            auto jobError = iora::parsers::Json::object();
-            jobError["done"] = true;
-            jobError["error"] = std::move(err);
-            _jobs[jobId] = jobError;
-          };
+          std::lock_guard<std::mutex> lock(_jobsMutex);
+          auto jobError = iora::parsers::Json::object();
+          jobError["done"] = true;
+          jobError["error"] = std::move(err);
+          _jobs[jobId] = jobError;
+        };
 
-          _client->callAsync(endpoint, method, params, headers,
-                             std::move(onSuccess), std::move(onError));
-          return jobId;
-        });
+        _client->callAsync(endpoint, method, params, headers, std::move(onSuccess),
+                           std::move(onError));
+        return jobId;
+      });
 
     service->exportApi(
-        *this, "jsonrpc.client.callBatch",
-        [this](const std::string& endpoint,
-               const iora::parsers::Json& itemsJson,
-               const std::vector<std::pair<std::string, std::string>>& headers)
-            -> std::vector<iora::parsers::Json>
+      *this, "jsonrpc.client.callBatch",
+      [this](const std::string &endpoint, const iora::parsers::Json &itemsJson,
+             const std::vector<std::pair<std::string, std::string>> &headers)
+        -> std::vector<iora::parsers::Json>
+      {
+        // Convert JSON array to BatchItem vector
+        std::vector<iora::modules::connectors::BatchItem> items;
+        if (!itemsJson.is_array())
         {
-          // Convert JSON array to BatchItem vector
-          std::vector<iora::modules::connectors::BatchItem> items;
-          if (!itemsJson.is_array()) {
-            throw std::invalid_argument("Batch items must be a JSON array");
+          throw std::invalid_argument("Batch items must be a JSON array");
+        }
+
+        for (const auto &item : itemsJson)
+        {
+          if (!item.is_object() || !item.contains("method"))
+          {
+            throw std::invalid_argument("Each batch item must be an object with 'method' field");
           }
-          
-          for (const auto& item : itemsJson) {
-            if (!item.is_object() || !item.contains("method")) {
-              throw std::invalid_argument("Each batch item must be an object with 'method' field");
-            }
-            
-            std::string method = item["method"].get<std::string>();
-            iora::parsers::Json params = item.contains("params") ? item["params"] : iora::parsers::Json::object();
-            
-            if (item.contains("id")) {
-              std::uint64_t id = item["id"].get<std::uint64_t>();
-              items.emplace_back(std::move(method), std::move(params), id);
-            } else {
-              items.emplace_back(std::move(method), std::move(params));
-            }
+
+          std::string method = item["method"].get<std::string>();
+          iora::parsers::Json params =
+            item.contains("params") ? item["params"] : iora::parsers::Json::object();
+
+          if (item.contains("id"))
+          {
+            std::uint64_t id = item["id"].get<std::uint64_t>();
+            items.emplace_back(std::move(method), std::move(params), id);
           }
-          
-          return _client->callBatch(endpoint, items, headers);
-        });
+          else
+          {
+            items.emplace_back(std::move(method), std::move(params));
+          }
+        }
+
+        return _client->callBatch(endpoint, items, headers);
+      });
 
     service->exportApi(
-        *this, "jsonrpc.client.callBatchAsync",
-        [this](const std::string& endpoint,
-               const iora::parsers::Json& itemsJson,
-               const std::vector<std::pair<std::string, std::string>>& headers)
-            -> std::string
+      *this, "jsonrpc.client.callBatchAsync",
+      [this](const std::string &endpoint, const iora::parsers::Json &itemsJson,
+             const std::vector<std::pair<std::string, std::string>> &headers) -> std::string
+      {
+        const std::string jobId = nextJobId_();
+
+        auto onSuccess = [this, jobId](std::vector<iora::parsers::Json> results)
         {
-          const std::string jobId = nextJobId_();
+          std::lock_guard<std::mutex> lock(_jobsMutex);
+          auto jobResult = iora::parsers::Json::object();
+          jobResult["done"] = true;
+          jobResult["result"] = iora::parsers::Json(results);
+          _jobs[jobId] = jobResult;
+        };
 
-          auto onSuccess = [this, jobId](std::vector<iora::parsers::Json> results)
+        auto onError = [this, jobId](std::exception_ptr ep)
+        {
+          auto err = iora::parsers::Json::object();
+          err["code"] = -32000;
+          err["message"] = "Unknown error";
+          err["data"] = nullptr;
+          try
           {
-            std::lock_guard<std::mutex> lock(_jobsMutex);
-            auto jobResult = iora::parsers::Json::object();
-            jobResult["done"] = true;
-            jobResult["result"] = iora::parsers::Json(results);
-            _jobs[jobId] = jobResult;
-          };
-
-          auto onError = [this, jobId](std::exception_ptr ep)
+            if (ep)
+              std::rethrow_exception(ep);
+          }
+          catch (const iora::modules::connectors::RemoteError &re)
+          {
+            err["code"] = re.code();
+            err["message"] = re.message();
+            err["data"] = re.data();
+          }
+          catch (const std::exception &e)
+          {
+            err["message"] = e.what();
+          }
+
+          std::lock_guard<std::mutex> lock(_jobsMutex);
+          auto jobError = iora::parsers::Json::object();
+          jobError["done"] = true;
+          jobError["error"] = std::move(err);
+          _jobs[jobId] = jobError;
+        };
+
+        // Submit batch request to thread pool
+        _externalPool->enqueue(
+          [this, endpoint, itemsJson, headers, onSuccess, onError]()
           {
-            auto err = iora::parsers::Json::object();
-            err["code"] = -32000;
-            err["message"] = "Unknown error";
-            err["data"] = nullptr;
             try
             {
-              if (ep)
-                std::rethrow_exception(ep);
-            }
-            catch (const iora::modules::connectors::RemoteError& re)
-            {
-              err["code"] = re.code();
-              err["message"] = re.message();
-              err["data"] = re.data();
-            }
-            catch (const std::exception& e)
-            {
-              err["message"] = e.what();
-            }
-
-            std::lock_guard<std::mutex> lock(_jobsMutex);
-            auto jobError = iora::parsers::Json::object();
-            jobError["done"] = true;
-            jobError["error"] = std::move(err);
-            _jobs[jobId] = jobError;
-          };
+              // Convert JSON array to BatchItem vector inside the thread
+              std::vector<iora::modules::connectors::BatchItem> items;
+              if (!itemsJson.is_array())
+              {
+                throw std::invalid_argument("Batch items must be a JSON array");
+              }
 
-          // Submit batch request to thread pool
-          _externalPool->enqueue(
-              [this, endpoint, itemsJson, headers, onSuccess, onError]()
+              for (const auto &item : itemsJson)
               {
-                try
+                if (!item.is_object() || !item.contains("method"))
                 {
-                  // Convert JSON array to BatchItem vector inside the thread
-                  std::vector<iora::modules::connectors::BatchItem> items;
-                  if (!itemsJson.is_array()) {
-                    throw std::invalid_argument("Batch items must be a JSON array");
-                  }
-                  
-                  for (const auto& item : itemsJson) {
-                    if (!item.is_object() || !item.contains("method")) {
-                      throw std::invalid_argument("Each batch item must be an object with 'method' field");
-                    }
-                    
-                    std::string method = item["method"].get<std::string>();
-                    iora::parsers::Json params = item.contains("params") ? item["params"] : iora::parsers::Json::object();
-                    
-                    if (item.contains("id")) {
-                      std::uint64_t id = item["id"].get<std::uint64_t>();
-                      items.emplace_back(std::move(method), std::move(params), id);
-                    } else {
-                      items.emplace_back(std::move(method), std::move(params));
-                    }
-                  }
-                  
-                  auto results = _client->callBatch(endpoint, items, headers);
-                  onSuccess(results);
+                  throw std::invalid_argument(
+                    "Each batch item must be an object with 'method' field");
                 }
-                catch (...)
+
+                std::string method = item["method"].get<std::string>();
+                iora::parsers::Json params =
+                  item.contains("params") ? item["params"] : iora::parsers::Json::object();
+
+                if (item.contains("id"))
+                {
+                  std::uint64_t id = item["id"].get<std::uint64_t>();
+                  items.emplace_back(std::move(method), std::move(params), id);
+                }
+                else
                 {
-                  onError(std::current_exception());
+                  items.emplace_back(std::move(method), std::move(params));
                 }
-              });
+              }
+
+              auto results = _client->callBatch(endpoint, items, headers);
+              onSuccess(results);
+            }
+            catch (...)
+            {
+              onError(std::current_exception());
+            }
+          });
 
-          return jobId;
-        });
+        return jobId;
+      });
 
     service->exportApi(*this, "jsonrpc.client.result",
-                       [this](const std::string& jobId) -> iora::parsers::Json
+                       [this](const std::string &jobId) -> iora::parsers::Json
                        {
                          std::lock_guard<std::mutex> lock(_jobsMutex);
                          auto it = _jobs.find(jobId);
@@ -471,7 +457,7 @@ public:
     service->exportApi(*this, "jsonrpc.client.getStats",
                        [this]() -> iora::parsers::Json
                        {
-                         const auto& stats = _client->getStats();
+                         const auto &stats = _client->getStats();
                          auto statsJson = iora::parsers::Json::object();
                          statsJson["totalRequests"] = stats.totalRequests.load();
                          statsJson["successfulRequests"] = stats.successfulRequests.load();
@@ -490,8 +476,7 @@ public:
                        [this]() -> void { _client->resetStats(); });
 
     service->exportApi(*this, "jsonrpc.client.purgeIdle",
-                       [this]() -> std::size_t
-                       { return _client->purgeIdle(); });
+                       [this]() -> std::size_t { return _client->purgeIdle(); });
   }
 
   void onUnload() override
@@ -502,19 +487,18 @@ public:
   }
 
 private:
-  static std::vector<std::pair<std::string, std::string>>
-  parseHeaderList(const std::string& csv)
+  static std::vector<std::pair<std::string, std::string>> parseHeaderList(const std::string &csv)
   {
     // Very small parser for "Key:Val,Key2:Val2"
     std::vector<std::pair<std::string, std::string>> out;
     std::string key;
     std::string val;
-    std::string* cur = &key;
+    std::string *cur = &key;
 
     auto flushPair = [&]()
     {
       // Trim spaces
-      auto trim = [](std::string& s)
+      auto trim = [](std::string &s)
       {
         auto isSpace = [](unsigned char c) { return std::isspace(c) != 0; };
         while (!s.empty() && isSpace(static_cast<unsigned char>(s.front())))
@@ -579,7 +563,7 @@ private:
 
   // ThreadPool: prefer service-owned; fall back to a small internal pool if
   // missing.
-  iora::core::ThreadPool* _externalPool;
+  iora::core::ThreadPool *_externalPool;
 
   std::unique_ptr<iora::modules::connectors::JsonRpcClient> _client;
 };
diff --git a/src/modules/connectors/jsonrpc_client/tests/iora_test_mod_jsonrpc_client_server_real.cpp b/src/modules/connectors/jsonrpc_client/tests/iora_test_mod_jsonrpc_client_server_real.cpp
index 9c2c3c8..d55463b 100644
--- a/src/modules/connectors/jsonrpc_client/tests/iora_test_mod_jsonrpc_client_server_real.cpp
+++ b/src/modules/connectors/jsonrpc_client/tests/iora_test_mod_jsonrpc_client_server_real.cpp
@@ -3,14 +3,14 @@
 //
 // Real integration test that loads both JSON-RPC server and client modules
 #define CATCH_CONFIG_RUNNER
-#include <catch2/catch.hpp>
 #include "iora/iora.hpp"
+#include <atomic>
+#include <catch2/catch.hpp>
+#include <chrono>
+#include <filesystem>
 #include <iostream>
 #include <thread>
-#include <chrono>
 #include <vector>
-#include <atomic>
-#include <filesystem>
 
 using namespace iora;
 
@@ -18,11 +18,11 @@ namespace
 {
 
 // Type aliases for common API signatures to improve readability
-using JsonHandler = std::function<iora::parsers::Json(const iora::parsers::Json&)>;
+using JsonHandler = std::function<iora::parsers::Json(const iora::parsers::Json &)>;
 using Headers = std::vector<std::pair<std::string, std::string>>;
 
 /// \brief Helper function to create a test IoraService instance
-iora::IoraService& createTestService()
+iora::IoraService &createTestService()
 {
   static bool initialized = false;
   if (!initialized)
@@ -45,27 +45,30 @@ iora::IoraService& createTestService()
 
 TEST_CASE("JSON-RPC Client-Server Integration", "[integration][basic]")
 {
-  auto& svc = createTestService();
-  
+  auto &svc = createTestService();
+
   // Load JSON-RPC server module first (using same pattern as server tests)
-  auto serverPluginPath = iora::util::resolveRelativePath(iora::util::getExecutableDir(), "../../../endpoints/jsonrpc_server/") + "/mod_jsonrpc_server.so";
+  auto serverPluginPath = iora::util::resolveRelativePath(iora::util::getExecutableDir(),
+                                                          "../../../endpoints/jsonrpc_server/") +
+                          "/mod_jsonrpc_server.so";
   REQUIRE(std::filesystem::exists(serverPluginPath));
   REQUIRE(svc.loadSingleModule(serverPluginPath));
-  
-  // Load JSON-RPC client module (current module's directory)  
-  auto clientPluginPath = iora::util::resolveRelativePath(iora::util::getExecutableDir(), "../") + "/mod_jsonrpc_client.so";
+
+  // Load JSON-RPC client module (current module's directory)
+  auto clientPluginPath = iora::util::resolveRelativePath(iora::util::getExecutableDir(), "../") +
+                          "/mod_jsonrpc_client.so";
   REQUIRE(std::filesystem::exists(clientPluginPath));
   REQUIRE(svc.loadSingleModule(clientPluginPath));
-  
+
   // Allow some time for the HTTP server to start listening
   std::this_thread::sleep_for(std::chrono::milliseconds(100));
-  
+
   SECTION("Enumerate and test all exported JSON-RPC APIs")
   {
     // Print all exported APIs
     auto apiNames = svc.getExportedApiNames();
     std::cout << "\nExported APIs after plugin load:" << std::endl;
-    for (const auto& name : apiNames)
+    for (const auto &name : apiNames)
     {
       std::cout << "  " << name << std::endl;
     }
@@ -77,17 +80,18 @@ TEST_CASE("JSON-RPC Client-Server Integration", "[integration][basic]")
     std::cout << " Server version: " << serverVersion << std::endl;
 
     // jsonrpc.register
-    JsonHandler echoHandler = [](const parsers::Json& params) -> parsers::Json
+    JsonHandler echoHandler = [](const parsers::Json &params) -> parsers::Json
     {
       std::cout << "Server: echo handler called with: " << params.dump() << std::endl;
       return params;
     };
-    svc.callExportedApi<void, const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>>(
+    svc.callExportedApi<void, const std::string &,
+                        std::function<iora::parsers::Json(const iora::parsers::Json &)>>(
       "jsonrpc.register", "echo", std::move(echoHandler));
     std::cout << " Registered 'echo' method on server" << std::endl;
 
     // jsonrpc.has
-    bool hasEcho = svc.callExportedApi<bool, const std::string&>("jsonrpc.has", "echo");
+    bool hasEcho = svc.callExportedApi<bool, const std::string &>("jsonrpc.has", "echo");
     REQUIRE(hasEcho);
     std::cout << " Server has 'echo' method" << std::endl;
 
@@ -105,12 +109,12 @@ TEST_CASE("JSON-RPC Client-Server Integration", "[integration][basic]")
     std::cout << " Server stats reset" << std::endl;
 
     // jsonrpc.unregister
-    bool unregEcho = svc.callExportedApi<bool, const std::string&>("jsonrpc.unregister", "echo");
+    bool unregEcho = svc.callExportedApi<bool, const std::string &>("jsonrpc.unregister", "echo");
     REQUIRE(unregEcho);
     std::cout << " Unregistered 'echo' method" << std::endl;
 
     // jsonrpc.has (after unregister)
-    bool hasEchoAfter = svc.callExportedApi<bool, const std::string&>("jsonrpc.has", "echo");
+    bool hasEchoAfter = svc.callExportedApi<bool, const std::string &>("jsonrpc.has", "echo");
     REQUIRE(!hasEchoAfter);
     std::cout << " Server no longer has 'echo' method" << std::endl;
 
@@ -128,43 +132,50 @@ TEST_CASE("JSON-RPC Client-Server Integration", "[integration][basic]")
     // jsonrpc.client.call (should fail gracefully if server not running)
     try
     {
-      auto result = svc.callExportedApi<parsers::Json, const std::string&, const std::string&, const parsers::Json&, const Headers&>(
+      auto result = svc.callExportedApi<parsers::Json, const std::string &, const std::string &,
+                                        const parsers::Json &, const Headers &>(
         "jsonrpc.client.call", serverUrl, "echo", params, headers);
       std::cout << " Client call result: " << result.dump() << std::endl;
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
-      std::cout << " Client call failed (expected if server not running): " << e.what() << std::endl;
+      std::cout << " Client call failed (expected if server not running): " << e.what()
+                << std::endl;
     }
 
     // jsonrpc.client.notify
     try
     {
-      svc.callExportedApi<void, const std::string&, const std::string&, const parsers::Json&, const Headers&>(
-        "jsonrpc.client.notify", serverUrl, "echo", params, headers);
+      svc.callExportedApi<void, const std::string &, const std::string &, const parsers::Json &,
+                          const Headers &>("jsonrpc.client.notify", serverUrl, "echo", params,
+                                           headers);
       std::cout << " Client notify sent" << std::endl;
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
-      std::cout << " Client notify failed (expected if server not running): " << e.what() << std::endl;
+      std::cout << " Client notify failed (expected if server not running): " << e.what()
+                << std::endl;
     }
 
     // jsonrpc.client.callAsync
     try
     {
-      auto jobId = svc.callExportedApi<std::string, const std::string&, const std::string&, const parsers::Json&, const Headers&>(
+      auto jobId = svc.callExportedApi<std::string, const std::string &, const std::string &,
+                                       const parsers::Json &, const Headers &>(
         "jsonrpc.client.callAsync", serverUrl, "echo", params, headers);
       std::cout << " Client callAsync jobId: " << jobId << std::endl;
-      auto asyncResult = svc.callExportedApi<parsers::Json, const std::string&>("jsonrpc.client.result", jobId);
+      auto asyncResult =
+        svc.callExportedApi<parsers::Json, const std::string &>("jsonrpc.client.result", jobId);
       std::cout << " Client callAsync result: " << asyncResult.dump() << std::endl;
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
-      std::cout << " Client callAsync failed (expected if server not running): " << e.what() << std::endl;
+      std::cout << " Client callAsync failed (expected if server not running): " << e.what()
+                << std::endl;
     }
 
     /*
-      */
+     */
 
     // jsonrpc.client.resetStats
     try
@@ -172,7 +183,7 @@ TEST_CASE("JSON-RPC Client-Server Integration", "[integration][basic]")
       svc.callExportedApi<void>("jsonrpc.client.resetStats");
       std::cout << " Client stats reset" << std::endl;
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       std::cout << " Client resetStats failed: " << e.what() << std::endl;
     }
@@ -183,13 +194,13 @@ TEST_CASE("JSON-RPC Client-Server Integration", "[integration][basic]")
       auto purged = svc.callExportedApi<std::size_t>("jsonrpc.client.purgeIdle");
       std::cout << " Client purged idle: " << purged << std::endl;
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       std::cout << " Client purgeIdle failed: " << e.what() << std::endl;
     }
 
     // --- Previously Missing Client APIs ---
-    
+
     // jsonrpc.client.getStats (previously leaked internal ClientStats&)
     try
     {
@@ -207,7 +218,7 @@ TEST_CASE("JSON-RPC Client-Server Integration", "[integration][basic]")
       REQUIRE(clientStats.contains("connectionsEvicted"));
       std::cout << " Client getStats (JSON format): " << clientStats.dump() << std::endl;
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       std::cout << " Client getStats failed: " << e.what() << std::endl;
     }
@@ -239,10 +250,12 @@ TEST_CASE("JSON-RPC Client-Server Integration", "[integration][basic]")
       // No "id" field = notification
       batchItems.push_back(item3);
 
-      auto batchResults = svc.callExportedApi<std::vector<parsers::Json>, const std::string&, const parsers::Json&, const Headers&>(
+      auto batchResults = svc.callExportedApi<std::vector<parsers::Json>, const std::string &,
+                                              const parsers::Json &, const Headers &>(
         "jsonrpc.client.callBatch", serverUrl, batchItems, headers);
-      
-      std::cout << " Client callBatch completed with " << batchResults.size() << " results" << std::endl;
+
+      std::cout << " Client callBatch completed with " << batchResults.size() << " results"
+                << std::endl;
       for (size_t i = 0; i < batchResults.size(); ++i)
       {
         if (!batchResults[i].is_null())
@@ -255,9 +268,10 @@ TEST_CASE("JSON-RPC Client-Server Integration", "[integration][basic]")
         }
       }
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
-      std::cout << " Client callBatch failed (expected if server not running): " << e.what() << std::endl;
+      std::cout << " Client callBatch failed (expected if server not running): " << e.what()
+                << std::endl;
     }
 
     // jsonrpc.client.callBatchAsync (previously leaked internal BatchItem)
@@ -280,16 +294,20 @@ TEST_CASE("JSON-RPC Client-Server Integration", "[integration][basic]")
       asyncItem2["id"] = 20;
       batchItems.push_back(asyncItem2);
 
-      auto asyncBatchJobId = svc.callExportedApi<std::string, const std::string&, const iora::parsers::Json&, const Headers&>("jsonrpc.client.callBatchAsync", serverUrl, batchItems, headers);
-      
+      auto asyncBatchJobId = svc.callExportedApi<std::string, const std::string &,
+                                                 const iora::parsers::Json &, const Headers &>(
+        "jsonrpc.client.callBatchAsync", serverUrl, batchItems, headers);
+
       std::cout << " Client callBatchAsync jobId: " << asyncBatchJobId << std::endl;
-      
+
       // Poll for result
       for (int attempts = 0; attempts < 5; ++attempts)
       {
-        auto asyncBatchResult = svc.callExportedApi<iora::parsers::Json, const std::string&>("jsonrpc.client.result", asyncBatchJobId);
-        std::cout << "  Batch async result (attempt " << (attempts + 1) << "): " << asyncBatchResult.dump() << std::endl;
-        
+        auto asyncBatchResult = svc.callExportedApi<iora::parsers::Json, const std::string &>(
+          "jsonrpc.client.result", asyncBatchJobId);
+        std::cout << "  Batch async result (attempt " << (attempts + 1)
+                  << "): " << asyncBatchResult.dump() << std::endl;
+
         if (asyncBatchResult.contains("done") ? asyncBatchResult["done"].get<bool>() : false)
         {
           break;
@@ -297,54 +315,57 @@ TEST_CASE("JSON-RPC Client-Server Integration", "[integration][basic]")
         std::this_thread::sleep_for(std::chrono::milliseconds(100));
       }
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
-      std::cout << " Client callBatchAsync failed (expected if server not running): " << e.what() << std::endl;
+      std::cout << " Client callBatchAsync failed (expected if server not running): " << e.what()
+                << std::endl;
     }
 
-    std::cout << " Comprehensive JSON-RPC API coverage test completed (including previously leaking APIs)" << std::endl;
+    std::cout
+      << " Comprehensive JSON-RPC API coverage test completed (including previously leaking APIs)"
+      << std::endl;
   }
-  
+
   // Cleanup
   util::removeFilesContainingAny({"jsonrpc_client_test"});
 }
 
 TEST_CASE("Server Method Registration with Options", "[integration][server][options]")
 {
-  auto& svc = iora::IoraService::instanceRef();
-  
+  auto &svc = iora::IoraService::instanceRef();
+
   SECTION("Test jsonrpc.registerWithOptions with various configurations")
   {
     // Test method handler that requires authentication
-    auto authHandler = [](const parsers::Json& params) -> parsers::Json
+    auto authHandler = [](const parsers::Json &params) -> parsers::Json
     {
       auto result = parsers::Json::object();
       result["authenticated"] = true;
       result["params"] = params;
       return result;
     };
-    
+
     // Register method with options using new JSON format
-    parsers::Json options = {
-      {"requireAuth", true},
-      {"timeout", 5000},
-      {"maxRequestSize", 1024}
-    };
-    
-    svc.callExportedApi<void, const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>, const iora::parsers::Json&>("jsonrpc.registerWithOptions", "secure_method", std::move(authHandler), options);
-    
+    parsers::Json options = {{"requireAuth", true}, {"timeout", 5000}, {"maxRequestSize", 1024}};
+
+    svc.callExportedApi<void, const std::string &,
+                        std::function<iora::parsers::Json(const iora::parsers::Json &)>,
+                        const iora::parsers::Json &>("jsonrpc.registerWithOptions", "secure_method",
+                                                     std::move(authHandler), options);
+
     // Verify method was registered
-    bool hasSecureMethod = svc.callExportedApi<bool, const std::string&>("jsonrpc.has", "secure_method");
+    bool hasSecureMethod =
+      svc.callExportedApi<bool, const std::string &>("jsonrpc.has", "secure_method");
     REQUIRE(hasSecureMethod);
     std::cout << " Registered 'secure_method' with options" << std::endl;
-    
+
     // Test method list includes our new method
     auto methods = svc.callExportedApi<std::vector<std::string>>("jsonrpc.getMethods");
     REQUIRE(std::find(methods.begin(), methods.end(), "secure_method") != methods.end());
     std::cout << " getMethods includes 'secure_method'" << std::endl;
-    
+
     // Test multiple method registrations
-    auto mathAddHandler = [](const parsers::Json& params) -> parsers::Json
+    auto mathAddHandler = [](const parsers::Json &params) -> parsers::Json
     {
       if (!params.contains("a") || !params.contains("b"))
       {
@@ -356,10 +377,12 @@ TEST_CASE("Server Method Registration with Options", "[integration][server][opti
       result["result"] = a + b;
       return result;
     };
-    
-    svc.callExportedApi<void, const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>>("jsonrpc.register", "math.add", std::move(mathAddHandler));
-    
-    auto mathMultiplyHandler = [](const parsers::Json& params) -> parsers::Json
+
+    svc.callExportedApi<void, const std::string &,
+                        std::function<iora::parsers::Json(const iora::parsers::Json &)>>(
+      "jsonrpc.register", "math.add", std::move(mathAddHandler));
+
+    auto mathMultiplyHandler = [](const parsers::Json &params) -> parsers::Json
     {
       if (!params.contains("a") || !params.contains("b"))
       {
@@ -371,31 +394,37 @@ TEST_CASE("Server Method Registration with Options", "[integration][server][opti
       result["result"] = a * b;
       return result;
     };
-    
-    svc.callExportedApi<void, const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>>("jsonrpc.register", "math.multiply", std::move(mathMultiplyHandler));
-    
+
+    svc.callExportedApi<void, const std::string &,
+                        std::function<iora::parsers::Json(const iora::parsers::Json &)>>(
+      "jsonrpc.register", "math.multiply", std::move(mathMultiplyHandler));
+
     // Verify all methods are registered
     auto updatedMethods = svc.callExportedApi<std::vector<std::string>>("jsonrpc.getMethods");
     REQUIRE(updatedMethods.size() >= 3);
-    REQUIRE(std::find(updatedMethods.begin(), updatedMethods.end(), "secure_method") != updatedMethods.end());
-    REQUIRE(std::find(updatedMethods.begin(), updatedMethods.end(), "math.add") != updatedMethods.end());
-    REQUIRE(std::find(updatedMethods.begin(), updatedMethods.end(), "math.multiply") != updatedMethods.end());
-    
-    std::cout << " Registered multiple methods. Total methods: " << updatedMethods.size() << std::endl;
-    for (const auto& method : updatedMethods)
+    REQUIRE(std::find(updatedMethods.begin(), updatedMethods.end(), "secure_method") !=
+            updatedMethods.end());
+    REQUIRE(std::find(updatedMethods.begin(), updatedMethods.end(), "math.add") !=
+            updatedMethods.end());
+    REQUIRE(std::find(updatedMethods.begin(), updatedMethods.end(), "math.multiply") !=
+            updatedMethods.end());
+
+    std::cout << " Registered multiple methods. Total methods: " << updatedMethods.size()
+              << std::endl;
+    for (const auto &method : updatedMethods)
     {
       std::cout << "  - " << method << std::endl;
     }
-    
+
     // Test server statistics after registrations
     auto serverStats = svc.callExportedApi<iora::parsers::Json>("jsonrpc.getStats");
     std::cout << " Server stats after registrations: " << serverStats.dump() << std::endl;
-    
+
     // Cleanup - unregister all test methods
-    svc.callExportedApi<bool, const std::string&>("jsonrpc.unregister", "secure_method");
-    svc.callExportedApi<bool, const std::string&>("jsonrpc.unregister", "math.add");
-    svc.callExportedApi<bool, const std::string&>("jsonrpc.unregister", "math.multiply");
-    
+    svc.callExportedApi<bool, const std::string &>("jsonrpc.unregister", "secure_method");
+    svc.callExportedApi<bool, const std::string &>("jsonrpc.unregister", "math.add");
+    svc.callExportedApi<bool, const std::string &>("jsonrpc.unregister", "math.multiply");
+
     auto finalMethods = svc.callExportedApi<std::vector<std::string>>("jsonrpc.getMethods");
     std::cout << " Cleanup completed. Remaining methods: " << finalMethods.size() << std::endl;
   }
@@ -403,27 +432,30 @@ TEST_CASE("Server Method Registration with Options", "[integration][server][opti
 
 TEST_CASE("Error Handling and Edge Cases", "[integration][errors]")
 {
-  auto& svc = iora::IoraService::instanceRef();
-  
+  auto &svc = iora::IoraService::instanceRef();
+
   SECTION("Test various error conditions")
   {
     // Test batch with invalid JSON structure
     try
     {
-      parsers::Json invalidBatchItems = "not an array";  // Invalid - should be array
+      parsers::Json invalidBatchItems = "not an array"; // Invalid - should be array
       const std::string serverUrl = "http://localhost:8135/rpc";
       Headers headers;
-      
-      auto results = svc.callExportedApi<std::vector<iora::parsers::Json>, const std::string&, const iora::parsers::Json&, const Headers&>("jsonrpc.client.callBatch", serverUrl, invalidBatchItems, headers);
-      
+
+      auto results = svc.callExportedApi<std::vector<iora::parsers::Json>, const std::string &,
+                                         const iora::parsers::Json &, const Headers &>(
+        "jsonrpc.client.callBatch", serverUrl, invalidBatchItems, headers);
+
       // Should not reach here
       REQUIRE(false);
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
-      std::cout << " Batch with invalid JSON structure properly rejected: " << e.what() << std::endl;
+      std::cout << " Batch with invalid JSON structure properly rejected: " << e.what()
+                << std::endl;
     }
-    
+
     // Test batch with missing method field
     try
     {
@@ -435,25 +467,27 @@ TEST_CASE("Error Handling and Edge Cases", "[integration][errors]")
       invalidItem["id"] = 1;
       // Missing "method" field
       invalidBatchItems.push_back(invalidItem);
-      
+
       const std::string serverUrl = "http://localhost:8135/rpc";
       Headers headers;
-      
-      auto results = svc.callExportedApi<std::vector<iora::parsers::Json>, const std::string&, const iora::parsers::Json&, const Headers&>("jsonrpc.client.callBatch", serverUrl, invalidBatchItems, headers);
-      
+
+      auto results = svc.callExportedApi<std::vector<iora::parsers::Json>, const std::string &,
+                                         const iora::parsers::Json &, const Headers &>(
+        "jsonrpc.client.callBatch", serverUrl, invalidBatchItems, headers);
+
       // Should not reach here
       REQUIRE(false);
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       std::cout << " Batch with missing method field properly rejected: " << e.what() << std::endl;
     }
-    
+
     // Test client statistics validation
     try
     {
       auto stats = svc.callExportedApi<iora::parsers::Json>("jsonrpc.client.getStats");
-      
+
       // Verify all required fields are present and are numbers
       REQUIRE(stats.contains("totalRequests"));
       REQUIRE(stats["totalRequests"].is_number_unsigned());
@@ -461,26 +495,27 @@ TEST_CASE("Error Handling and Edge Cases", "[integration][errors]")
       REQUIRE(stats["successfulRequests"].is_number_unsigned());
       REQUIRE(stats.contains("failedRequests"));
       REQUIRE(stats["failedRequests"].is_number_unsigned());
-      
+
       std::cout << " Client statistics format validation passed" << std::endl;
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       std::cout << " Client statistics test failed: " << e.what() << std::endl;
     }
-    
+
     // Test async result polling for non-existent job
     try
     {
-      auto result = svc.callExportedApi<iora::parsers::Json, const std::string&>("jsonrpc.client.result", "non-existent-job-id");
-      
+      auto result = svc.callExportedApi<iora::parsers::Json, const std::string &>(
+        "jsonrpc.client.result", "non-existent-job-id");
+
       REQUIRE(result.is_object());
       REQUIRE(result.contains("done"));
       REQUIRE(result["done"] == false);
-      
+
       std::cout << " Non-existent async job properly handled: " << result.dump() << std::endl;
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       std::cout << " Async job polling test failed: " << e.what() << std::endl;
     }
@@ -489,18 +524,18 @@ TEST_CASE("Error Handling and Edge Cases", "[integration][errors]")
 
 TEST_CASE("Full Client-Server Communication", "[integration][communication][full]")
 {
-  auto& svc = iora::IoraService::instanceRef();
-  
+  auto &svc = iora::IoraService::instanceRef();
+
   SECTION("Test full client-server communication with running server")
   {
     // Register test methods on the server
-    auto echoHandler = [](const parsers::Json& params) -> parsers::Json
+    auto echoHandler = [](const parsers::Json &params) -> parsers::Json
     {
       std::cout << "Server: echo called with " << params.dump() << std::endl;
       return params;
     };
-    
-    auto addHandler = [](const parsers::Json& params) -> parsers::Json
+
+    auto addHandler = [](const parsers::Json &params) -> parsers::Json
     {
       if (!params.contains("a") || !params.contains("b"))
       {
@@ -512,36 +547,43 @@ TEST_CASE("Full Client-Server Communication", "[integration][communication][full
       result["sum"] = a + b;
       return result;
     };
-    
+
     // Register methods
-    svc.callExportedApi<void, const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>>("jsonrpc.register", "echo", std::move(echoHandler));
-    svc.callExportedApi<void, const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>>("jsonrpc.register", "add", std::move(addHandler));
-    
+    svc.callExportedApi<void, const std::string &,
+                        std::function<iora::parsers::Json(const iora::parsers::Json &)>>(
+      "jsonrpc.register", "echo", std::move(echoHandler));
+    svc.callExportedApi<void, const std::string &,
+                        std::function<iora::parsers::Json(const iora::parsers::Json &)>>(
+      "jsonrpc.register", "add", std::move(addHandler));
+
     std::cout << " Registered echo and add methods on server" << std::endl;
-    
+
     // Start server (it should already be running from service initialization)
     const std::string serverUrl = "http://localhost:8135/rpc";
     Headers headers;
-    
+
     // Wait a moment for server to fully initialize
     std::this_thread::sleep_for(std::chrono::milliseconds(500));
-    
+
     // Test direct RPC calls
     try
     {
       auto echoParams = parsers::Json::object();
       echoParams["message"] = "Hello from client!";
-      auto echoResult = svc.callExportedApi<iora::parsers::Json, const std::string&, const std::string&, const iora::parsers::Json&, const Headers&>("jsonrpc.client.call", serverUrl, "echo", echoParams, headers);
-      
+      auto echoResult =
+        svc.callExportedApi<iora::parsers::Json, const std::string &, const std::string &,
+                            const iora::parsers::Json &, const Headers &>(
+          "jsonrpc.client.call", serverUrl, "echo", echoParams, headers);
+
       REQUIRE(echoResult.contains("message"));
       REQUIRE(echoResult["message"] == "Hello from client!");
       std::cout << " Direct RPC call successful: " << echoResult.dump() << std::endl;
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       std::cout << " Direct RPC call failed: " << e.what() << std::endl;
     }
-    
+
     // Test batch operations with running server
     try
     {
@@ -568,11 +610,13 @@ TEST_CASE("Full Client-Server Communication", "[integration][communication][full
       batchItem3["params"] = batchParams3;
       // No id = notification
       batchItems.push_back(batchItem3);
-      
-      auto batchResults = svc.callExportedApi<std::vector<parsers::Json>, const std::string&, const parsers::Json&, const Headers&>(
+
+      auto batchResults = svc.callExportedApi<std::vector<parsers::Json>, const std::string &,
+                                              const parsers::Json &, const Headers &>(
         "jsonrpc.client.callBatch", serverUrl, batchItems, headers);
-      
-      std::cout << " Batch RPC call successful with " << batchResults.size() << " results:" << std::endl;
+
+      std::cout << " Batch RPC call successful with " << batchResults.size()
+                << " results:" << std::endl;
       for (size_t i = 0; i < batchResults.size(); ++i)
       {
         if (!batchResults[i].is_null())
@@ -580,7 +624,7 @@ TEST_CASE("Full Client-Server Communication", "[integration][communication][full
           std::cout << "  Result[" << i << "]: " << batchResults[i].dump() << std::endl;
         }
       }
-      
+
       // Validate batch results
       if (batchResults.size() >= 2)
       {
@@ -597,7 +641,7 @@ TEST_CASE("Full Client-Server Communication", "[integration][communication][full
           REQUIRE(batchResults[0].contains("msg"));
           REQUIRE(batchResults[0]["msg"] == "batch echo test");
         }
-        
+
         // Second result should be add
         if (batchResults[1].contains("result"))
         {
@@ -613,28 +657,31 @@ TEST_CASE("Full Client-Server Communication", "[integration][communication][full
         }
       }
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       std::cout << " Batch RPC call failed: " << e.what() << std::endl;
     }
-    
+
     // Test async operations with real server
     try
     {
       auto asyncParams = parsers::Json::object();
       asyncParams["async_test"] = "value";
-      auto jobId = svc.callExportedApi<std::string, const std::string&, const std::string&, const iora::parsers::Json&, const Headers&>("jsonrpc.client.callAsync", serverUrl, "echo", asyncParams, headers);
-      
+      auto jobId = svc.callExportedApi<std::string, const std::string &, const std::string &,
+                                       const iora::parsers::Json &, const Headers &>(
+        "jsonrpc.client.callAsync", serverUrl, "echo", asyncParams, headers);
+
       std::cout << " Async RPC call initiated with jobId: " << jobId << std::endl;
-      
+
       // Poll for completion
       bool completed = false;
       for (int attempt = 0; attempt < 10 && !completed; ++attempt)
       {
-        auto result = svc.callExportedApi<iora::parsers::Json, const std::string&>("jsonrpc.client.result", jobId);
-        
+        auto result = svc.callExportedApi<iora::parsers::Json, const std::string &>(
+          "jsonrpc.client.result", jobId);
+
         std::cout << "  Async poll attempt " << (attempt + 1) << ": " << result.dump() << std::endl;
-        
+
         if ((result.contains("done") ? result["done"].get<bool>() : false))
         {
           completed = true;
@@ -654,67 +701,69 @@ TEST_CASE("Full Client-Server Communication", "[integration][communication][full
           }
           else if (result.contains("error"))
           {
-            std::cout << " Async operation completed with error: " << result["error"].dump() << std::endl;
+            std::cout << " Async operation completed with error: " << result["error"].dump()
+                      << std::endl;
           }
         }
-        
+
         if (!completed)
         {
           std::this_thread::sleep_for(std::chrono::milliseconds(100));
         }
       }
-      
+
       if (!completed)
       {
         std::cout << " Async operation did not complete within timeout" << std::endl;
       }
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       std::cout << " Async RPC call failed: " << e.what() << std::endl;
     }
-    
+
     // Test client and server statistics after real operations
     try
     {
       auto clientStats = svc.callExportedApi<iora::parsers::Json>("jsonrpc.client.getStats");
       auto serverStats = svc.callExportedApi<iora::parsers::Json>("jsonrpc.getStats");
-      
+
       std::cout << " Final client statistics: " << clientStats.dump() << std::endl;
       std::cout << " Final server statistics: " << serverStats.dump() << std::endl;
-      
+
       // Verify that some requests were processed
       REQUIRE(clientStats["totalRequests"].get<std::uint64_t>() > 0);
       REQUIRE(serverStats["totalRequests"].get<std::uint64_t>() > 0);
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       std::cout << " Statistics collection failed: " << e.what() << std::endl;
     }
-    
+
     // Cleanup
-    svc.callExportedApi<bool, const std::string&>("jsonrpc.unregister", "echo");
-    svc.callExportedApi<bool, const std::string&>("jsonrpc.unregister", "add");
-    
+    svc.callExportedApi<bool, const std::string &>("jsonrpc.unregister", "echo");
+    svc.callExportedApi<bool, const std::string &>("jsonrpc.unregister", "add");
+
     std::cout << " Full client-server communication test completed" << std::endl;
   }
 }
 
 TEST_CASE("HTTP Client Connection Timeout Test", "[integration][timeout]")
 {
-  auto& svc = createTestService();
-  
+  auto &svc = createTestService();
+
   // Load only the client module for this test (no server)
   // Note: Plugin may already be loaded from main(), handle gracefully
-  auto clientPluginPath = iora::util::resolveRelativePath(iora::util::getExecutableDir(), "../") + "/mod_jsonrpc_client.so";
+  auto clientPluginPath = iora::util::resolveRelativePath(iora::util::getExecutableDir(), "../") +
+                          "/mod_jsonrpc_client.so";
   REQUIRE(std::filesystem::exists(clientPluginPath));
-  
+
   // Try to load the client plugin, but don't fail if it's already loaded
   try
   {
     svc.loadSingleModule(clientPluginPath);
   }
-  catch (const std::exception& e)
+  catch (const std::exception &e)
   {
     // Plugin likely already loaded from main() - that's OK for this test
     std::string error = e.what();
@@ -724,87 +773,91 @@ TEST_CASE("HTTP Client Connection Timeout Test", "[integration][timeout]")
       throw;
     }
   }
-  
+
   SECTION("Client should timeout when connecting to unavailable server")
   {
     // Test connecting to a non-existent server port (use IP to avoid DNS issues)
-    const std::string unavailableServerUrl = "http://127.0.0.1:9999/rpc"; // Port 9999 should be unavailable
+    const std::string unavailableServerUrl =
+      "http://127.0.0.1:9999/rpc"; // Port 9999 should be unavailable
     auto params = parsers::Json::object();
     params["test"] = "timeout";
     Headers headers;
-    
+
     auto startTime = std::chrono::steady_clock::now();
-    
+
     try
     {
       // This should timeout, not hang indefinitely
-      auto result = svc.callExportedApi<parsers::Json, const std::string&, const std::string&, const parsers::Json&, const Headers&>(
+      auto result = svc.callExportedApi<parsers::Json, const std::string &, const std::string &,
+                                        const parsers::Json &, const Headers &>(
         "jsonrpc.client.call", unavailableServerUrl, "test", params, headers);
-      
+
       // If we get here, the test failed - we should have gotten an exception
       REQUIRE(false);
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       auto endTime = std::chrono::steady_clock::now();
       auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(endTime - startTime);
-      
-      std::cout << " Client correctly threw exception after " << elapsed.count() << " seconds: " << e.what() << std::endl;
-      
+
+      std::cout << " Client correctly threw exception after " << elapsed.count()
+                << " seconds: " << e.what() << std::endl;
+
       // Verify that it timed out in a reasonable time (should be less than 30 seconds)
       REQUIRE(elapsed.count() < 30);
-      
+
       // Verify the exception message indicates a timeout or connection failure
       std::string errorMsg = e.what();
       bool isTimeoutError = (errorMsg.find("timeout") != std::string::npos) ||
-                           (errorMsg.find("connection") != std::string::npos) ||
-                           (errorMsg.find("connect") != std::string::npos) ||
-                           (errorMsg.find("failed") != std::string::npos) ||
-                           (errorMsg.find("callback") != std::string::npos);
+                            (errorMsg.find("connection") != std::string::npos) ||
+                            (errorMsg.find("connect") != std::string::npos) ||
+                            (errorMsg.find("failed") != std::string::npos) ||
+                            (errorMsg.find("callback") != std::string::npos);
       REQUIRE(isTimeoutError);
     }
   }
-  
+
   SECTION("Client should handle invalid URLs gracefully")
   {
     const std::string invalidUrl = "not-a-valid-url";
     auto params = parsers::Json::object();
     params["test"] = "invalid";
     Headers headers;
-    
+
     try
     {
-      auto result = svc.callExportedApi<parsers::Json, const std::string&, const std::string&, const parsers::Json&, const Headers&>(
+      auto result = svc.callExportedApi<parsers::Json, const std::string &, const std::string &,
+                                        const parsers::Json &, const Headers &>(
         "jsonrpc.client.call", invalidUrl, "test", params, headers);
-      
+
       // Should not reach here
       REQUIRE(false);
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       std::cout << " Client correctly rejected invalid URL: " << e.what() << std::endl;
-      
+
       // Should contain some indication that the URL is invalid
       std::string errorMsg = e.what();
       bool isUrlError = (errorMsg.find("URL") != std::string::npos) ||
-                       (errorMsg.find("url") != std::string::npos) ||
-                       (errorMsg.find("format") != std::string::npos) ||
-                       (errorMsg.find("Invalid") != std::string::npos);
+                        (errorMsg.find("url") != std::string::npos) ||
+                        (errorMsg.find("format") != std::string::npos) ||
+                        (errorMsg.find("Invalid") != std::string::npos);
       REQUIRE(isUrlError);
     }
   }
-  
+
   // Cleanup
   util::removeFilesContainingAny({"jsonrpc_client_test"});
 }
 
-int main(int argc, char* argv[])
+int main(int argc, char *argv[])
 {
   std::cout << "Real JSON-RPC Client-Server Integration Test\n";
   std::cout << "============================================\n" << std::endl;
 
   // Initialize service properly
-  auto& svc = createTestService();
+  auto &svc = createTestService();
   iora::IoraService::AutoServiceShutdown autoShutdown(svc);
 
   // Resolve paths for plugins
diff --git a/src/modules/endpoints/jsonrpc_server/jsonrpc_server.hpp b/src/modules/endpoints/jsonrpc_server/jsonrpc_server.hpp
index e4c7f39..faa0665 100644
--- a/src/modules/endpoints/jsonrpc_server/jsonrpc_server.hpp
+++ b/src/modules/endpoints/jsonrpc_server/jsonrpc_server.hpp
@@ -6,16 +6,16 @@
 
 #pragma once
 
+#include <chrono>
 #include <cstdint>
+#include <functional>
+#include <memory>
 #include <mutex>
 #include <optional>
 #include <stdexcept>
 #include <string>
 #include <unordered_map>
 #include <utility>
-#include <memory>
-#include <chrono>
-#include <functional>
 #include <vector>
 
 #include "iora/iora.hpp"
@@ -30,13 +30,13 @@ namespace jsonrpc
 /// \brief JSON-RPC 2.0 server error codes.
 enum class ErrorCode : int
 {
-  ParseError      = -32700,
-  InvalidRequest  = -32600,
-  MethodNotFound  = -32601,
-  InvalidParams   = -32602,
-  InternalError   = -32603,
+  ParseError = -32700,
+  InvalidRequest = -32600,
+  MethodNotFound = -32601,
+  InvalidParams = -32602,
+  InternalError = -32603,
   // Custom application error codes (start from -32000)
-  TimeoutError    = -32000,
+  TimeoutError = -32000,
   AuthenticationError = -32001,
   RateLimitExceeded = -32002
 };
@@ -48,12 +48,8 @@ struct RequestMetadata
   std::string clientId;
   std::string method;
   std::size_t requestSize;
-  
-  RequestMetadata()
-    : startTime(std::chrono::steady_clock::now()),
-      requestSize(0)
-  {
-  }
+
+  RequestMetadata() : startTime(std::chrono::steady_clock::now()), requestSize(0) {}
 };
 
 /// \brief Per-request context made available to JSON-RPC handlers.
@@ -61,57 +57,46 @@ class RpcContext
 {
 public:
   /// \brief Construct a context with access to the owning service and optional subject.
-  explicit RpcContext(IoraService& service, std::optional<std::string> subject = {})
-    : _service(service),
-      _authSubject(std::move(subject)),
-      _metadata(std::make_unique<RequestMetadata>())
+  explicit RpcContext(IoraService &service, std::optional<std::string> subject = {})
+      : _service(service), _authSubject(std::move(subject)),
+        _metadata(std::make_unique<RequestMetadata>())
   {
   }
-  
+
   /// \brief Move constructor.
-  RpcContext(RpcContext&& other) noexcept = default;
-  RpcContext& operator=(RpcContext&& other) noexcept = default;
-  
+  RpcContext(RpcContext &&other) noexcept = default;
+  RpcContext &operator=(RpcContext &&other) noexcept = default;
+
   // Disable copy constructor and assignment
-  RpcContext(const RpcContext&) = delete;
-  RpcContext& operator=(const RpcContext&) = delete;
+  RpcContext(const RpcContext &) = delete;
+  RpcContext &operator=(const RpcContext &) = delete;
 
   /// \brief Access the owning IoraService.
-  IoraService& service() const
-  {
-    return _service;
-  }
+  IoraService &service() const { return _service; }
 
   /// \brief Optional authenticated subject identifier.
-  const std::optional<std::string>& authSubject() const
-  {
-    return _authSubject;
-  }
-  
+  const std::optional<std::string> &authSubject() const { return _authSubject; }
+
   /// \brief Get request metadata.
-  const RequestMetadata& metadata() const
-  {
-    return *_metadata;
-  }
-  
+  const RequestMetadata &metadata() const { return *_metadata; }
+
   /// \brief Get mutable request metadata.
-  RequestMetadata& metadata()
-  {
-    return *_metadata;
-  }
+  RequestMetadata &metadata() { return *_metadata; }
 
 private:
-  IoraService& _service;
+  IoraService &_service;
   std::optional<std::string> _authSubject;
   std::unique_ptr<RequestMetadata> _metadata;
 };
 
 /// \brief Method handler signature: takes params JSON and context, returns result JSON (or throws).
-using MethodHandler = std::function<iora::parsers::Json(const iora::parsers::Json&, RpcContext&)>;
+using MethodHandler = std::function<iora::parsers::Json(const iora::parsers::Json &, RpcContext &)>;
 
 /// \brief Optional method pre/post hooks.
-using MethodPreHook = std::function<void(const std::string&, const iora::parsers::Json&, RpcContext&)>;
-using MethodPostHook = std::function<void(const std::string&, const iora::parsers::Json&, const iora::parsers::Json&, RpcContext&)>;
+using MethodPreHook =
+  std::function<void(const std::string &, const iora::parsers::Json &, RpcContext &)>;
+using MethodPostHook = std::function<void(const std::string &, const iora::parsers::Json &,
+                                          const iora::parsers::Json &, RpcContext &)>;
 
 /// \brief Method registration options.
 struct MethodOptions
@@ -132,7 +117,7 @@ struct ServerStats
   std::atomic<std::uint64_t> timeoutRequests{0};
   std::atomic<std::uint64_t> batchRequests{0};
   std::atomic<std::uint64_t> notificationRequests{0};
-  
+
   /// \brief Reset all counters.
   void reset()
   {
@@ -150,32 +135,32 @@ class JsonRpcServer
 {
 public:
   JsonRpcServer() = default;
-  
+
   /// \brief Disable copy constructor and assignment.
-  JsonRpcServer(const JsonRpcServer&) = delete;
-  JsonRpcServer& operator=(const JsonRpcServer&) = delete;
+  JsonRpcServer(const JsonRpcServer &) = delete;
+  JsonRpcServer &operator=(const JsonRpcServer &) = delete;
 
   /// \brief Register (or replace) a method handler.
-  void registerMethod(const std::string& name, MethodHandler handler)
+  void registerMethod(const std::string &name, MethodHandler handler)
   {
     registerMethod(name, std::move(handler), MethodOptions{});
   }
-  
+
   /// \brief Register a method handler with options.
-  void registerMethod(const std::string& name, MethodHandler handler, const MethodOptions& options)
+  void registerMethod(const std::string &name, MethodHandler handler, const MethodOptions &options)
   {
     if (name.empty())
     {
       throw std::invalid_argument("Method name cannot be empty");
     }
-    
+
     std::lock_guard<std::mutex> lock(_mutex);
     _handlers[name] = std::move(handler);
     _methodOptions[name] = options;
   }
 
   /// \brief Unregister a method handler. Returns true if removed.
-  bool unregisterMethod(const std::string& name)
+  bool unregisterMethod(const std::string &name)
   {
     std::lock_guard<std::mutex> lock(_mutex);
     bool removed = _handlers.erase(name) > 0;
@@ -184,45 +169,38 @@ public:
   }
 
   /// \brief Check if a handler exists.
-  bool hasMethod(const std::string& name) const
+  bool hasMethod(const std::string &name) const
   {
     std::lock_guard<std::mutex> lock(_mutex);
     return _handlers.find(name) != _handlers.end();
   }
-  
+
   /// \brief Get list of registered method names.
   std::vector<std::string> getMethodNames() const
   {
     std::lock_guard<std::mutex> lock(_mutex);
     std::vector<std::string> names;
     names.reserve(_handlers.size());
-    for (const auto& [name, _] : _handlers)
+    for (const auto &[name, _] : _handlers)
     {
       names.push_back(name);
     }
     return names;
   }
-  
+
   /// \brief Get server statistics.
-  const ServerStats& getStats() const
-  {
-    return _stats;
-  }
-  
+  const ServerStats &getStats() const { return _stats; }
+
   /// \brief Reset server statistics.
-  void resetStats()
-  {
-    _stats.reset();
-  }
+  void resetStats() { _stats.reset(); }
 
   /// \brief Handle a raw JSON request body; returns response body (empty for pure notifications).
-  std::string handleRequest(const std::string& body,
-                            RpcContext& ctx,
+  std::string handleRequest(const std::string &body, RpcContext &ctx,
                             std::size_t maxBatchItems = 50)
   {
     _stats.totalRequests++;
     ctx.metadata().requestSize = body.size();
-    
+
     if (body.empty())
     {
       _stats.failedRequests++;
@@ -233,7 +211,7 @@ public:
     {
       in = iora::parsers::Json::parseString(body);
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       _stats.failedRequests++;
       std::string errorMsg = "Parse error: " + std::string(e.what());
@@ -248,7 +226,7 @@ public:
     if (in.is_array())
     {
       _stats.batchRequests++;
-      
+
       if (in.empty())
       {
         _stats.failedRequests++;
@@ -257,16 +235,16 @@ public:
       if (in.size() > maxBatchItems)
       {
         _stats.failedRequests++;
-        std::string errorMsg = "Batch size " + std::to_string(in.size()) + 
-                              " exceeds maximum " + std::to_string(maxBatchItems);
+        std::string errorMsg = "Batch size " + std::to_string(in.size()) + " exceeds maximum " +
+                               std::to_string(maxBatchItems);
         return makeError(nullptr, ErrorCode::InvalidRequest, errorMsg).dump();
       }
 
       iora::parsers::Json out = iora::parsers::Json::array();
       std::size_t successCount = 0;
       std::size_t errorCount = 0;
-      
-      for (const auto& item : in)
+
+      for (const auto &item : in)
       {
         iora::parsers::Json r = handleSingle(item, ctx);
         if (!r.is_null())
@@ -282,7 +260,7 @@ public:
           out.push_back(std::move(r));
         }
       }
-      
+
       if (errorCount > 0)
       {
         _stats.failedRequests++;
@@ -291,12 +269,12 @@ public:
       {
         _stats.successfulRequests++;
       }
-      
+
       return out.empty() ? std::string{} : out.dump();
     }
 
     iora::parsers::Json r = handleSingle(in, ctx);
-    
+
     if (!r.is_null())
     {
       if (r.contains("error"))
@@ -308,12 +286,12 @@ public:
         _stats.successfulRequests++;
       }
     }
-    
+
     return r.is_null() ? std::string{} : r.dump();
   }
 
 private:
-  iora::parsers::Json handleSingle(const iora::parsers::Json& req, RpcContext& ctx)
+  iora::parsers::Json handleSingle(const iora::parsers::Json &req, RpcContext &ctx)
   {
     const iora::parsers::Json id = req.contains("id") ? req["id"] : iora::parsers::Json();
 
@@ -322,29 +300,30 @@ private:
     {
       return makeError(id, ErrorCode::InvalidRequest, "Request must be a JSON object");
     }
-    
+
     if ((req.contains("jsonrpc") ? req["jsonrpc"].get<std::string>() : "") != "2.0")
     {
       return makeError(id, ErrorCode::InvalidRequest, "Missing or invalid jsonrpc version");
     }
-    
+
     if (!req.contains("method"))
     {
       return makeError(id, ErrorCode::InvalidRequest, "Missing method field");
     }
 
-    const std::string method = req["method"].is_string() ? 
-      req["method"].get<std::string>() : std::string{};
+    const std::string method =
+      req["method"].is_string() ? req["method"].get<std::string>() : std::string{};
     if (method.empty())
     {
       return makeError(id, ErrorCode::InvalidRequest, "Method name cannot be empty");
     }
-    
+
     // Store method name in context
     ctx.metadata().method = method;
 
-    iora::parsers::Json params = req.contains("params") ? req["params"] : iora::parsers::Json::object();
-    
+    iora::parsers::Json params =
+      req.contains("params") ? req["params"] : iora::parsers::Json::object();
+
     bool isNotif = isNotification(req);
     if (isNotif)
     {
@@ -358,30 +337,29 @@ private:
       auto handlerIt = _handlers.find(method);
       if (handlerIt == _handlers.end())
       {
-        return makeError(id, ErrorCode::MethodNotFound, 
-                        "Method '" + method + "' not found");
+        return makeError(id, ErrorCode::MethodNotFound, "Method '" + method + "' not found");
       }
       handler = handlerIt->second;
-      
+
       auto optionsIt = _methodOptions.find(method);
       if (optionsIt != _methodOptions.end())
       {
         options = optionsIt->second;
       }
     }
-    
+
     // Check authentication requirement
     if (options.requireAuth && !ctx.authSubject().has_value())
     {
       return makeError(id, ErrorCode::AuthenticationError, "Authentication required");
     }
-    
+
     // Check request size limit
     if (ctx.metadata().requestSize > options.maxRequestSize)
     {
       return makeError(id, ErrorCode::InvalidRequest, "Request too large");
     }
-    
+
     try
     {
       // Execute pre-hook if available
@@ -389,33 +367,33 @@ private:
       {
         options.preHook(method, params, ctx);
       }
-      
+
       // Execute the method handler
       iora::parsers::Json result = handler(params, ctx);
-      
+
       // Execute post-hook if available
       if (options.postHook)
       {
         options.postHook(method, params, result, ctx);
       }
-      
+
       if (isNotif)
       {
         return iora::parsers::Json(); // no response for notifications
       }
-      
+
       auto response = iora::parsers::Json::object();
       response["jsonrpc"] = "2.0";
       response["result"] = std::move(result);
       response["id"] = id.is_null() ? nullptr : id;
       return response;
     }
-    catch (const std::invalid_argument& e)
+    catch (const std::invalid_argument &e)
     {
       std::string errorMsg = "Invalid params: " + std::string(e.what());
       return makeError(id, ErrorCode::InvalidParams, errorMsg);
     }
-    catch (const std::runtime_error& e)
+    catch (const std::runtime_error &e)
     {
       std::string errorMsg = "Runtime error: " + std::string(e.what());
       return makeError(id, ErrorCode::InternalError, errorMsg);
@@ -426,23 +404,24 @@ private:
     }
   }
 
-  iora::parsers::Json makeError(const iora::parsers::Json& id, ErrorCode code, const std::string& message)
+  iora::parsers::Json makeError(const iora::parsers::Json &id, ErrorCode code,
+                                const std::string &message)
   {
     return makeError(id, code, message, iora::parsers::Json());
   }
-  
-  iora::parsers::Json makeError(const iora::parsers::Json& id, ErrorCode code, 
-                            const std::string& message, const iora::parsers::Json& data)
+
+  iora::parsers::Json makeError(const iora::parsers::Json &id, ErrorCode code,
+                                const std::string &message, const iora::parsers::Json &data)
   {
     auto error = iora::parsers::Json::object();
     error["code"] = static_cast<int>(code);
     error["message"] = message;
-    
+
     if (!data.is_null())
     {
       error["data"] = data;
     }
-    
+
     auto response = iora::parsers::Json::object();
     response["jsonrpc"] = "2.0";
     response["error"] = std::move(error);
@@ -450,10 +429,7 @@ private:
     return response;
   }
 
-  bool isNotification(const iora::parsers::Json& req) const
-  {
-    return !req.contains("id");
-  }
+  bool isNotification(const iora::parsers::Json &req) const { return !req.contains("id"); }
 
 private:
   mutable std::mutex _mutex;
@@ -462,4 +438,6 @@ private:
   ServerStats _stats;
 };
 
-} } } // namespace iora::modules::jsonrpc
+} // namespace jsonrpc
+} // namespace modules
+} // namespace iora
diff --git a/src/modules/endpoints/jsonrpc_server/mod_jsonrpc_server.cpp b/src/modules/endpoints/jsonrpc_server/mod_jsonrpc_server.cpp
index 3fb1c33..f3a49c3 100644
--- a/src/modules/endpoints/jsonrpc_server/mod_jsonrpc_server.cpp
+++ b/src/modules/endpoints/jsonrpc_server/mod_jsonrpc_server.cpp
@@ -6,8 +6,8 @@
 
 #include "jsonrpc_server.hpp"
 
-#include <cstdint>
 #include <chrono>
+#include <cstdint>
 #include <thread>
 
 #include "iora/iora.hpp"
@@ -20,8 +20,10 @@ namespace iora
 /// Exposes POST {path} on the service webhookServer and exports the following API
 /// callables via IoraService::exportApi:
 ///   - "jsonrpc.version"       -> std::uint32_t()
-///   - "jsonrpc.register"      -> void(const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>)
-///   - "jsonrpc.registerWithOptions" -> void(const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>, const iora::parsers::Json&)
+///   - "jsonrpc.register"      -> void(const std::string&, std::function<iora::parsers::Json(const
+///   iora::parsers::Json&)>)
+///   - "jsonrpc.registerWithOptions" -> void(const std::string&,
+///   std::function<iora::parsers::Json(const iora::parsers::Json&)>, const iora::parsers::Json&)
 ///   - "jsonrpc.unregister"    -> bool(const std::string&)
 ///   - "jsonrpc.has"           -> bool(const std::string&)
 ///   - "jsonrpc.getMethods"    -> std::vector<std::string>()
@@ -30,28 +32,19 @@ namespace iora
 class JsonRpcServerPlugin : public IoraService::Plugin
 {
 public:
-  JsonRpcServerPlugin(iora::IoraService* service)
-    : Plugin(service),
-      _enabled(true),
-      _path("/rpc"),
-      _maxRequestBytes(1 * 1024 * 1024),
-      _maxBatchItems(50),
-      _requireAuth(false),
-      _timeoutMs(5000),
-      _logRequests(false),
-      _enableMetrics(true)
+  JsonRpcServerPlugin(iora::IoraService *service)
+      : Plugin(service), _enabled(true), _path("/rpc"), _maxRequestBytes(1 * 1024 * 1024),
+        _maxBatchItems(50), _requireAuth(false), _timeoutMs(5000), _logRequests(false),
+        _enableMetrics(true)
   {
   }
 
-  const char* name() const
-  {
-    return "jsonrpc";
-  }
+  const char *name() const { return "jsonrpc"; }
 
-  void onLoad(IoraService* service) override
+  void onLoad(IoraService *service) override
   {
     // Load configuration from IoraService config system
-    auto* loader = service->configLoader().get();
+    auto *loader = service->configLoader().get();
     if (loader)
     {
       try
@@ -72,133 +65,124 @@ public:
           _logRequests = *v;
         if (auto v = loader->getBool("iora.modules.jsonrpc_server.enableMetrics"))
           _enableMetrics = *v;
-        
-        iora::core::Logger::info("JSON-RPC server plugin configured: path=" + _path + ", auth=" + 
-                                (_requireAuth ? "true" : "false") + ", timeout=" + std::to_string(_timeoutMs) + "ms");
+
+        iora::core::Logger::info("JSON-RPC server plugin configured: path=" + _path +
+                                 ", auth=" + (_requireAuth ? "true" : "false") +
+                                 ", timeout=" + std::to_string(_timeoutMs) + "ms");
       }
-      catch (const std::exception& e)
+      catch (const std::exception &e)
       {
-        iora::core::Logger::warning("Failed to load JSON-RPC configuration: " + std::string(e.what()) + ", using defaults");
+        iora::core::Logger::warning(
+          "Failed to load JSON-RPC configuration: " + std::string(e.what()) + ", using defaults");
       }
     }
 
     // Export callable APIs (matches IoraService::exportApi signature).
     service->exportApi(*this, "jsonrpc.version",
-      [this]() -> std::uint32_t
-      {
-        return 2U; // Version 2 with enhanced features
-      });
+                       [this]() -> std::uint32_t
+                       {
+                         return 2U; // Version 2 with enhanced features
+                       });
 
-    service->exportApi(*this, "jsonrpc.register",
-      [this](const std::string& method, std::function<iora::parsers::Json(const iora::parsers::Json&)> handler) -> void
+    service->exportApi(
+      *this, "jsonrpc.register",
+      [this](const std::string &method,
+             std::function<iora::parsers::Json(const iora::parsers::Json &)> handler) -> void
       {
-        _router.registerMethod(method, 
-          [handler](const iora::parsers::Json& params, modules::jsonrpc::RpcContext& ctx) -> iora::parsers::Json
-          {
-            return handler(params);
-          });
+        _router.registerMethod(method,
+                               [handler](const iora::parsers::Json &params,
+                                         modules::jsonrpc::RpcContext &ctx) -> iora::parsers::Json
+                               { return handler(params); });
       });
-      
-    service->exportApi(*this, "jsonrpc.registerWithOptions",
-      [this](const std::string& method, std::function<iora::parsers::Json(const iora::parsers::Json&)> handler, const iora::parsers::Json& optionsJson) -> void
+
+    service->exportApi(
+      *this, "jsonrpc.registerWithOptions",
+      [this](const std::string &method,
+             std::function<iora::parsers::Json(const iora::parsers::Json &)> handler,
+             const iora::parsers::Json &optionsJson) -> void
       {
         modules::jsonrpc::MethodOptions options;
         if (optionsJson.contains("requireAuth") && optionsJson["requireAuth"].is_boolean())
           options.requireAuth = optionsJson["requireAuth"];
         if (optionsJson.contains("timeout") && optionsJson["timeout"].is_number_integer())
           options.timeout = std::chrono::milliseconds(optionsJson["timeout"].get<int>());
-        if (optionsJson.contains("maxRequestSize") && optionsJson["maxRequestSize"].is_number_integer())
+        if (optionsJson.contains("maxRequestSize") &&
+            optionsJson["maxRequestSize"].is_number_integer())
           options.maxRequestSize = optionsJson["maxRequestSize"].get<std::size_t>();
-        
-        _router.registerMethod(method, 
-          [handler](const iora::parsers::Json& params, modules::jsonrpc::RpcContext& ctx) -> iora::parsers::Json
-          {
-            return handler(params);
-          }, options);
-      });
 
-    service->exportApi(*this, "jsonrpc.unregister",
-      [this](const std::string& method) -> bool
-      {
-        return _router.unregisterMethod(method);
+        _router.registerMethod(
+          method,
+          [handler](const iora::parsers::Json &params,
+                    modules::jsonrpc::RpcContext &ctx) -> iora::parsers::Json
+          { return handler(params); },
+          options);
       });
 
-    service->exportApi(*this, "jsonrpc.has",
-      [this](const std::string& method) -> bool
-      {
-        return _router.hasMethod(method);
-      });
-      
+    service->exportApi(*this, "jsonrpc.unregister", [this](const std::string &method) -> bool
+                       { return _router.unregisterMethod(method); });
+
+    service->exportApi(*this, "jsonrpc.has", [this](const std::string &method) -> bool
+                       { return _router.hasMethod(method); });
+
     service->exportApi(*this, "jsonrpc.getMethods",
-      [this]() -> std::vector<std::string>
-      {
-        return _router.getMethodNames();
-      });
-      
+                       [this]() -> std::vector<std::string> { return _router.getMethodNames(); });
+
     service->exportApi(*this, "jsonrpc.getStats",
-      [this]() -> iora::parsers::Json
-      {
-        const auto& stats = _router.getStats();
-        auto statsJson = iora::parsers::Json::object();
-        statsJson["totalRequests"] = stats.totalRequests.load();
-        statsJson["successfulRequests"] = stats.successfulRequests.load();
-        statsJson["failedRequests"] = stats.failedRequests.load();
-        statsJson["timeoutRequests"] = stats.timeoutRequests.load();
-        statsJson["batchRequests"] = stats.batchRequests.load();
-        statsJson["notificationRequests"] = stats.notificationRequests.load();
-        return statsJson;
-      });
-      
-    service->exportApi(*this, "jsonrpc.resetStats",
-      [this]() -> void
-      {
-        _router.resetStats();
-      });
+                       [this]() -> iora::parsers::Json
+                       {
+                         const auto &stats = _router.getStats();
+                         auto statsJson = iora::parsers::Json::object();
+                         statsJson["totalRequests"] = stats.totalRequests.load();
+                         statsJson["successfulRequests"] = stats.successfulRequests.load();
+                         statsJson["failedRequests"] = stats.failedRequests.load();
+                         statsJson["timeoutRequests"] = stats.timeoutRequests.load();
+                         statsJson["batchRequests"] = stats.batchRequests.load();
+                         statsJson["notificationRequests"] = stats.notificationRequests.load();
+                         return statsJson;
+                       });
 
+    service->exportApi(*this, "jsonrpc.resetStats", [this]() -> void { _router.resetStats(); });
 
     // Mount POST {path} directly on the webhookServer.
-    service->webhookServer()->onPost(_path,
-      [this](const iora::network::WebhookServer::Request& req, iora::network::WebhookServer::Response& res)
-      {
-        this->handlePost(req, res);
-      });
+    service->webhookServer()->onPost(_path, [this](const iora::network::WebhookServer::Request &req,
+                                                   iora::network::WebhookServer::Response &res)
+                                     { this->handlePost(req, res); });
   }
 
-
 private:
-  void handlePost(const iora::network::WebhookServer::Request& req, iora::network::WebhookServer::Response& res)
+  void handlePost(const iora::network::WebhookServer::Request &req,
+                  iora::network::WebhookServer::Response &res)
   {
-    
+
     auto startTime = std::chrono::steady_clock::now();
-    
+
     if (_logRequests)
     {
       iora::core::Logger::debug("JSON-RPC request: " + std::to_string(req.body.size()) + " bytes");
     }
-    
+
     // Set CORS headers if needed
     res.set_header("Access-Control-Allow-Origin", "*");
     res.set_header("Access-Control-Allow-Methods", "POST, OPTIONS");
     res.set_header("Access-Control-Allow-Headers", "Content-Type, Authorization");
-    
+
     // Handle preflight OPTIONS request
     if (req.method == iora::network::HttpMethod::OPTIONS)
     {
       res.status = 200;
       return;
     }
-    
+
     // Enforce JSON content type for JSON-RPC 2.0.
     {
       auto it = req.headers.find("Content-Type");
-      if (it == req.headers.end() ||
-          it->second.find("application/json") == std::string::npos)
+      if (it == req.headers.end() || it->second.find("application/json") == std::string::npos)
       {
         res.status = 415;
         res.set_content(
           R"({"jsonrpc":"2.0","error":{"code":-32600,"message":"Unsupported Media Type"},"id":null})",
           "application/json");
-        
+
         if (_logRequests)
         {
           iora::core::Logger::warning("JSON-RPC request rejected: unsupported media type");
@@ -214,11 +198,12 @@ private:
       res.set_content(
         R"({"jsonrpc":"2.0","error":{"code":-32600,"message":"Request Entity Too Large"},"id":null})",
         "application/json");
-      
+
       if (_logRequests)
       {
-        iora::core::Logger::warning("JSON-RPC request rejected: body size " + std::to_string(req.body.size()) + 
-                                   " exceeds limit " + std::to_string(_maxRequestBytes));
+        iora::core::Logger::warning("JSON-RPC request rejected: body size " +
+                                    std::to_string(req.body.size()) + " exceeds limit " +
+                                    std::to_string(_maxRequestBytes));
       }
       return;
     }
@@ -238,14 +223,14 @@ private:
           subject = auth.substr(7); // Remove "Bearer " prefix
         }
       }
-      
+
       if (!subject)
       {
         res.status = 401;
         res.set_content(
           R"({"jsonrpc":"2.0","error":{"code":-32001,"message":"Authentication required"},"id":null})",
           "application/json");
-          
+
         if (_logRequests)
         {
           iora::core::Logger::warning("JSON-RPC request rejected: authentication required");
@@ -255,41 +240,44 @@ private:
     }
 
     modules::jsonrpc::RpcContext ctx{IoraService::instanceRef(), subject};
-    
+
     // Set client metadata
     ctx.metadata().clientId = "unknown"; // TODO: Add remote address to WebhookServer::Request
 
     try
     {
       std::string out = _router.handleRequest(req.body, ctx, _maxBatchItems);
-      
+
       auto endTime = std::chrono::steady_clock::now();
       auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
-      
+
       if (out.empty())
       {
         // Notification-only request or batch with only notifications.
         res.status = 204;
-        
+
         if (_logRequests)
         {
-          iora::core::Logger::debug("JSON-RPC notification processed in " + std::to_string(duration.count()) + "ms");
+          iora::core::Logger::debug("JSON-RPC notification processed in " +
+                                    std::to_string(duration.count()) + "ms");
         }
         return;
       }
 
       res.status = 200;
       res.set_content(std::move(out), "application/json");
-      
+
       if (_logRequests)
       {
-        iora::core::Logger::debug("JSON-RPC request processed in " + std::to_string(duration.count()) + "ms, response size: " + std::to_string(out.size()) + " bytes");
+        iora::core::Logger::debug("JSON-RPC request processed in " +
+                                  std::to_string(duration.count()) +
+                                  "ms, response size: " + std::to_string(out.size()) + " bytes");
       }
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       iora::core::Logger::error("JSON-RPC internal error: " + std::string(e.what()));
-      
+
       res.status = 500;
       res.set_content(
         R"({"jsonrpc":"2.0","error":{"code":-32603,"message":"Internal server error"},"id":null})",
@@ -298,7 +286,7 @@ private:
     catch (...)
     {
       iora::core::Logger::error("JSON-RPC unknown internal error");
-      
+
       res.status = 500;
       res.set_content(
         R"({"jsonrpc":"2.0","error":{"code":-32603,"message":"Unknown internal error"},"id":null})",
diff --git a/src/modules/endpoints/jsonrpc_server/tests/iora_test_mod_jsonrpc_server.cpp b/src/modules/endpoints/jsonrpc_server/tests/iora_test_mod_jsonrpc_server.cpp
index 00f86f2..9ba468f 100644
--- a/src/modules/endpoints/jsonrpc_server/tests/iora_test_mod_jsonrpc_server.cpp
+++ b/src/modules/endpoints/jsonrpc_server/tests/iora_test_mod_jsonrpc_server.cpp
@@ -5,26 +5,27 @@
 // See the LICENSE file or <https://www.mozilla.org/MPL/2.0/> for details.
 
 #include "../jsonrpc_server.hpp"
+#include "iora/iora.hpp"
+#include <atomic>
 #include <catch2/catch.hpp>
-#include <random>
-#include <string>
-#include <vector>
-#include <cstdio>
-#include <thread>
 #include <chrono>
-#include <fstream>
+#include <cstdio>
+#include <dlfcn.h>
 #include <filesystem>
-#include <atomic>
+#include <fstream>
 #include <mutex>
-#include "iora/iora.hpp"
-#include <dlfcn.h>
+#include <random>
+#include <string>
+#include <thread>
+#include <vector>
 
 using namespace iora::modules::jsonrpc;
 
-namespace {
+namespace
+{
 
 /// \brief Helper function to create a test IoraService instance
-iora::IoraService& createTestService()
+iora::IoraService &createTestService()
 {
   static bool initialized = false;
   if (!initialized)
@@ -33,8 +34,8 @@ iora::IoraService& createTestService()
     config.server.port = 8132;
     config.log.file = "jsonrpc_test";
     config.log.level = "info";
-    
-    try 
+
+    try
     {
       iora::IoraService::shutdown(); // Ensure clean state
     }
@@ -42,7 +43,7 @@ iora::IoraService& createTestService()
     {
       // Ignore shutdown errors if already shutdown
     }
-    
+
     iora::IoraService::init(config);
     initialized = true;
   }
@@ -50,25 +51,25 @@ iora::IoraService& createTestService()
 }
 
 /// \brief Test method handler that echoes parameters
-iora::parsers::Json echoHandler(const iora::parsers::Json& params, RpcContext& ctx)
+iora::parsers::Json echoHandler(const iora::parsers::Json &params, RpcContext &ctx)
 {
   return params;
 }
 
 /// \brief Test method handler that throws invalid_argument
-iora::parsers::Json invalidParamsHandler(const iora::parsers::Json& params, RpcContext& ctx)
+iora::parsers::Json invalidParamsHandler(const iora::parsers::Json &params, RpcContext &ctx)
 {
   throw std::invalid_argument("Invalid parameters provided");
 }
 
 /// \brief Test method handler that throws runtime_error
-iora::parsers::Json internalErrorHandler(const iora::parsers::Json& params, RpcContext& ctx)
+iora::parsers::Json internalErrorHandler(const iora::parsers::Json &params, RpcContext &ctx)
 {
   throw std::runtime_error("Internal processing error");
 }
 
 /// \brief Test method handler that requires authentication
-iora::parsers::Json authRequiredHandler(const iora::parsers::Json& params, RpcContext& ctx)
+iora::parsers::Json authRequiredHandler(const iora::parsers::Json &params, RpcContext &ctx)
 {
   if (!ctx.authSubject().has_value())
   {
@@ -80,7 +81,7 @@ iora::parsers::Json authRequiredHandler(const iora::parsers::Json& params, RpcCo
 }
 
 /// \brief Test method handler with pre/post hooks
-iora::parsers::Json hookedHandler(const iora::parsers::Json& params, RpcContext& ctx)
+iora::parsers::Json hookedHandler(const iora::parsers::Json &params, RpcContext &ctx)
 {
   auto result = iora::parsers::Json::object();
   result["processed"] = true;
@@ -92,18 +93,18 @@ iora::parsers::Json hookedHandler(const iora::parsers::Json& params, RpcContext&
 TEST_CASE("JsonRpcServer basic method registration", "[jsonrpc][basic]")
 {
   JsonRpcServer server;
-  
+
   SECTION("Register and check method existence")
   {
     REQUIRE_FALSE(server.hasMethod("test"));
     server.registerMethod("test", echoHandler);
     REQUIRE(server.hasMethod("test"));
-    
+
     auto methods = server.getMethodNames();
     REQUIRE(methods.size() == 1);
     REQUIRE(methods[static_cast<std::size_t>(0)] == "test");
   }
-  
+
   SECTION("Unregister method")
   {
     server.registerMethod("test", echoHandler);
@@ -112,7 +113,7 @@ TEST_CASE("JsonRpcServer basic method registration", "[jsonrpc][basic]")
     REQUIRE_FALSE(server.hasMethod("test"));
     REQUIRE_FALSE(server.unregisterMethod("nonexistent"));
   }
-  
+
   SECTION("Empty method name validation")
   {
     REQUIRE_THROWS_AS(server.registerMethod("", echoHandler), std::invalid_argument);
@@ -122,42 +123,38 @@ TEST_CASE("JsonRpcServer basic method registration", "[jsonrpc][basic]")
 TEST_CASE("JsonRpcServer method options", "[jsonrpc][options]")
 {
   JsonRpcServer server;
-  
+
   SECTION("Register method with options")
   {
     MethodOptions opts;
     opts.requireAuth = true;
     opts.timeout = std::chrono::milliseconds(1000);
     opts.maxRequestSize = 512;
-    
+
     server.registerMethod("auth_method", authRequiredHandler, opts);
     REQUIRE(server.hasMethod("auth_method"));
   }
-  
+
   SECTION("Method with hooks")
   {
     std::atomic<int> preHookCalls{0};
     std::atomic<int> postHookCalls{0};
-    
+
     MethodOptions opts;
-    opts.preHook = [&preHookCalls](const std::string& method, const iora::parsers::Json& params, RpcContext& ctx)
-    {
-      preHookCalls++;
-    };
-    opts.postHook = [&postHookCalls](const std::string& method, const iora::parsers::Json& params, 
-                                    const iora::parsers::Json& result, RpcContext& ctx)
-    {
-      postHookCalls++;
-    };
-    
+    opts.preHook = [&preHookCalls](const std::string &method, const iora::parsers::Json &params,
+                                   RpcContext &ctx) { preHookCalls++; };
+    opts.postHook = [&postHookCalls](const std::string &method, const iora::parsers::Json &params,
+                                     const iora::parsers::Json &result, RpcContext &ctx)
+    { postHookCalls++; };
+
     server.registerMethod("hooked", hookedHandler, opts);
-    
-    auto& service = createTestService();
+
+    auto &service = createTestService();
     RpcContext ctx(service);
-    
+
     std::string request = R"({"jsonrpc":"2.0","method":"hooked","params":{},"id":1})";
     std::string response = server.handleRequest(request, ctx);
-    
+
     REQUIRE(preHookCalls == 1);
     REQUIRE(postHookCalls == 1);
     REQUIRE_FALSE(response.empty());
@@ -168,10 +165,10 @@ TEST_CASE("JsonRpcServer request validation", "[jsonrpc][validation]")
 {
   JsonRpcServer server;
   server.registerMethod("echo", echoHandler);
-  
-  auto& service = createTestService();
+
+  auto &service = createTestService();
   RpcContext ctx(service);
-  
+
   SECTION("Empty request body")
   {
     std::string response = server.handleRequest("", ctx);
@@ -180,7 +177,7 @@ TEST_CASE("JsonRpcServer request validation", "[jsonrpc][validation]")
     REQUIRE(resp.contains("error"));
     REQUIRE(resp["error"]["code"] == static_cast<int>(ErrorCode::InvalidRequest));
   }
-  
+
   SECTION("Invalid JSON")
   {
     std::string response = server.handleRequest("{invalid json", ctx);
@@ -189,7 +186,7 @@ TEST_CASE("JsonRpcServer request validation", "[jsonrpc][validation]")
     REQUIRE(resp.contains("error"));
     REQUIRE(resp["error"]["code"] == static_cast<int>(ErrorCode::ParseError));
   }
-  
+
   SECTION("Missing jsonrpc version")
   {
     std::string request = R"({"method":"echo","params":{},"id":1})";
@@ -198,7 +195,7 @@ TEST_CASE("JsonRpcServer request validation", "[jsonrpc][validation]")
     REQUIRE(resp.contains("error"));
     REQUIRE(resp["error"]["code"] == static_cast<int>(ErrorCode::InvalidRequest));
   }
-  
+
   SECTION("Wrong jsonrpc version")
   {
     std::string request = R"({"jsonrpc":"1.0","method":"echo","params":{},"id":1})";
@@ -207,7 +204,7 @@ TEST_CASE("JsonRpcServer request validation", "[jsonrpc][validation]")
     REQUIRE(resp.contains("error"));
     REQUIRE(resp["error"]["code"] == static_cast<int>(ErrorCode::InvalidRequest));
   }
-  
+
   SECTION("Missing method")
   {
     std::string request = R"({"jsonrpc":"2.0","params":{},"id":1})";
@@ -216,7 +213,7 @@ TEST_CASE("JsonRpcServer request validation", "[jsonrpc][validation]")
     REQUIRE(resp.contains("error"));
     REQUIRE(resp["error"]["code"] == static_cast<int>(ErrorCode::InvalidRequest));
   }
-  
+
   SECTION("Empty method name")
   {
     std::string request = R"({"jsonrpc":"2.0","method":"","params":{},"id":1})";
@@ -225,7 +222,7 @@ TEST_CASE("JsonRpcServer request validation", "[jsonrpc][validation]")
     REQUIRE(resp.contains("error"));
     REQUIRE(resp["error"]["code"] == static_cast<int>(ErrorCode::InvalidRequest));
   }
-  
+
   SECTION("Non-string method")
   {
     std::string request = R"({"jsonrpc":"2.0","method":123,"params":{},"id":1})";
@@ -240,15 +237,15 @@ TEST_CASE("JsonRpcServer single request handling", "[jsonrpc][single]")
 {
   JsonRpcServer server;
   server.registerMethod("echo", echoHandler);
-  
-  auto& service = createTestService();
+
+  auto &service = createTestService();
   RpcContext ctx(service);
-  
+
   SECTION("Valid request with result")
   {
     std::string request = R"({"jsonrpc":"2.0","method":"echo","params":{"test":"value"},"id":1})";
     std::string response = server.handleRequest(request, ctx);
-    
+
     REQUIRE_FALSE(response.empty());
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp["jsonrpc"] == "2.0");
@@ -256,19 +253,19 @@ TEST_CASE("JsonRpcServer single request handling", "[jsonrpc][single]")
     REQUIRE(resp.contains("result"));
     REQUIRE(resp["result"]["test"] == "value");
   }
-  
+
   SECTION("Notification request (no response)")
   {
     std::string request = R"({"jsonrpc":"2.0","method":"echo","params":{"test":"value"}})";
     std::string response = server.handleRequest(request, ctx);
     REQUIRE(response.empty());
   }
-  
+
   SECTION("Method not found")
   {
     std::string request = R"({"jsonrpc":"2.0","method":"nonexistent","params":{},"id":1})";
     std::string response = server.handleRequest(request, ctx);
-    
+
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp.contains("error"));
     REQUIRE(resp["error"]["code"] == static_cast<int>(ErrorCode::MethodNotFound));
@@ -281,10 +278,10 @@ TEST_CASE("JsonRpcServer batch request handling", "[jsonrpc][batch]")
   JsonRpcServer server;
   server.registerMethod("echo", echoHandler);
   server.registerMethod("error", invalidParamsHandler);
-  
-  auto& service = createTestService();
+
+  auto &service = createTestService();
   RpcContext ctx(service);
-  
+
   SECTION("Valid batch request")
   {
     std::string request = R"([
@@ -292,44 +289,45 @@ TEST_CASE("JsonRpcServer batch request handling", "[jsonrpc][batch]")
       {"jsonrpc":"2.0","method":"echo","params":{"value":2},"id":2}
     ])";
     std::string response = server.handleRequest(request, ctx);
-    
+
     REQUIRE_FALSE(response.empty());
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp.is_array());
     REQUIRE(resp.size() == 2);
-    
+
     REQUIRE(resp[static_cast<std::size_t>(0)]["id"] == 1);
     REQUIRE(resp[static_cast<std::size_t>(0)]["result"]["value"] == 1);
     REQUIRE(resp[1]["id"] == 2);
     REQUIRE(resp[1]["result"]["value"] == 2);
   }
-  
+
   SECTION("Empty batch request")
   {
     std::string request = R"([])";
     std::string response = server.handleRequest(request, ctx);
-    
+
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp.contains("error"));
     REQUIRE(resp["error"]["code"] == static_cast<int>(ErrorCode::InvalidRequest));
   }
-  
+
   SECTION("Batch too large")
   {
     std::string request = "[";
     for (int i = 0; i < 55; ++i) // Default max is 50
     {
-      if (i > 0) request += ",";
+      if (i > 0)
+        request += ",";
       request += R"({"jsonrpc":"2.0","method":"echo","params":{},"id":)" + std::to_string(i) + "}";
     }
     request += "]";
-    
+
     std::string response = server.handleRequest(request, ctx);
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp.contains("error"));
     REQUIRE(resp["error"]["code"] == static_cast<int>(ErrorCode::InvalidRequest));
   }
-  
+
   SECTION("Batch with mixed success and error")
   {
     std::string request = R"([
@@ -337,18 +335,18 @@ TEST_CASE("JsonRpcServer batch request handling", "[jsonrpc][batch]")
       {"jsonrpc":"2.0","method":"error","params":{},"id":2}
     ])";
     std::string response = server.handleRequest(request, ctx);
-    
+
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp.is_array());
     REQUIRE(resp.size() == 2);
-    
+
     REQUIRE(resp[static_cast<std::size_t>(0)]["id"] == 1);
     REQUIRE(resp[static_cast<std::size_t>(0)].contains("result"));
     REQUIRE(resp[1]["id"] == 2);
     REQUIRE(resp[1].contains("error"));
     REQUIRE(resp[1]["error"]["code"] == static_cast<int>(ErrorCode::InvalidParams));
   }
-  
+
   SECTION("Batch with notifications only")
   {
     std::string request = R"([
@@ -365,26 +363,26 @@ TEST_CASE("JsonRpcServer error handling", "[jsonrpc][errors]")
   JsonRpcServer server;
   server.registerMethod("invalid_params", invalidParamsHandler);
   server.registerMethod("internal_error", internalErrorHandler);
-  
-  auto& service = createTestService();
+
+  auto &service = createTestService();
   RpcContext ctx(service);
-  
+
   SECTION("Invalid parameters error")
   {
     std::string request = R"({"jsonrpc":"2.0","method":"invalid_params","params":{},"id":1})";
     std::string response = server.handleRequest(request, ctx);
-    
+
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp.contains("error"));
     REQUIRE(resp["error"]["code"] == static_cast<int>(ErrorCode::InvalidParams));
     REQUIRE(resp["id"] == 1);
   }
-  
+
   SECTION("Internal error")
   {
     std::string request = R"({"jsonrpc":"2.0","method":"internal_error","params":{},"id":1})";
     std::string response = server.handleRequest(request, ctx);
-    
+
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp.contains("error"));
     REQUIRE(resp["error"]["code"] == static_cast<int>(ErrorCode::InternalError));
@@ -397,44 +395,44 @@ TEST_CASE("JsonRpcServer statistics", "[jsonrpc][stats]")
   JsonRpcServer server;
   server.registerMethod("echo", echoHandler);
   server.registerMethod("error", invalidParamsHandler);
-  
-  auto& service = createTestService();
+
+  auto &service = createTestService();
   RpcContext ctx(service);
-  
+
   // Reset stats before testing
   server.resetStats();
-  const auto& stats = server.getStats();
+  const auto &stats = server.getStats();
   REQUIRE(stats.totalRequests == 0);
-  
+
   SECTION("Successful request increments stats")
   {
     std::string request = R"({"jsonrpc":"2.0","method":"echo","params":{},"id":1})";
     server.handleRequest(request, ctx);
-    
+
     REQUIRE(stats.totalRequests == 1);
     REQUIRE(stats.successfulRequests == 1);
     REQUIRE(stats.failedRequests == 0);
   }
-  
+
   SECTION("Failed request increments stats")
   {
     std::string request = R"({"jsonrpc":"2.0","method":"error","params":{},"id":1})";
     server.handleRequest(request, ctx);
-    
+
     REQUIRE(stats.totalRequests == 1);
     REQUIRE(stats.successfulRequests == 0);
     REQUIRE(stats.failedRequests == 1);
   }
-  
+
   SECTION("Notification request increments stats")
   {
     std::string request = R"({"jsonrpc":"2.0","method":"echo","params":{}})";
     server.handleRequest(request, ctx);
-    
+
     REQUIRE(stats.totalRequests == 1);
     REQUIRE(stats.notificationRequests == 1);
   }
-  
+
   SECTION("Batch request increments stats")
   {
     std::string request = R"([
@@ -442,7 +440,7 @@ TEST_CASE("JsonRpcServer statistics", "[jsonrpc][stats]")
       {"jsonrpc":"2.0","method":"echo","params":{},"id":2}
     ])";
     server.handleRequest(request, ctx);
-    
+
     REQUIRE(stats.totalRequests == 1);
     REQUIRE(stats.batchRequests == 1);
     REQUIRE(stats.successfulRequests == 1);
@@ -452,32 +450,34 @@ TEST_CASE("JsonRpcServer statistics", "[jsonrpc][stats]")
 TEST_CASE("JsonRpcServer context functionality", "[jsonrpc][context]")
 {
   JsonRpcServer server;
-  
+
   // Handler that uses context information
-  server.registerMethod("context_test", [](const iora::parsers::Json& params, RpcContext& ctx) -> iora::parsers::Json
-  {
-    iora::parsers::Json result;
-    result["hasAuth"] = ctx.authSubject().has_value();
-    if (ctx.authSubject().has_value())
+  server.registerMethod(
+    "context_test",
+    [](const iora::parsers::Json &params, RpcContext &ctx) -> iora::parsers::Json
     {
-      result["authSubject"] = ctx.authSubject().value();
-    }
-    result["requestSize"] = ctx.metadata().requestSize;
-    result["method"] = ctx.metadata().method;
-    result["clientId"] = ctx.metadata().clientId;
-    return result;
-  });
-  
-  auto& service = createTestService();
-  
+      iora::parsers::Json result;
+      result["hasAuth"] = ctx.authSubject().has_value();
+      if (ctx.authSubject().has_value())
+      {
+        result["authSubject"] = ctx.authSubject().value();
+      }
+      result["requestSize"] = ctx.metadata().requestSize;
+      result["method"] = ctx.metadata().method;
+      result["clientId"] = ctx.metadata().clientId;
+      return result;
+    });
+
+  auto &service = createTestService();
+
   SECTION("Context without authentication")
   {
     RpcContext ctx(service);
     ctx.metadata().clientId = "test_client";
-    
+
     std::string request = R"({"jsonrpc":"2.0","method":"context_test","params":{},"id":1})";
     std::string response = server.handleRequest(request, ctx);
-    
+
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp.contains("result"));
     REQUIRE(resp["result"]["hasAuth"] == false);
@@ -485,14 +485,14 @@ TEST_CASE("JsonRpcServer context functionality", "[jsonrpc][context]")
     REQUIRE(resp["result"]["clientId"] == "test_client");
     REQUIRE(resp["result"]["requestSize"] > 0);
   }
-  
+
   SECTION("Context with authentication")
   {
     RpcContext ctx(service, "test_user");
-    
+
     std::string request = R"({"jsonrpc":"2.0","method":"context_test","params":{},"id":1})";
     std::string response = server.handleRequest(request, ctx);
-    
+
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp.contains("result"));
     REQUIRE(resp["result"]["hasAuth"] == true);
@@ -503,68 +503,71 @@ TEST_CASE("JsonRpcServer context functionality", "[jsonrpc][context]")
 TEST_CASE("JsonRpcServer concurrency", "[jsonrpc][concurrency]")
 {
   JsonRpcServer server;
-  
+
   // Thread-safe counter for testing
   std::atomic<int> counter{0};
-  server.registerMethod("increment", [&counter](const iora::parsers::Json& params, RpcContext& ctx) -> iora::parsers::Json
-  {
-    int value = ++counter;
-    std::this_thread::sleep_for(std::chrono::milliseconds(1)); // Simulate some work
-    auto result = iora::parsers::Json::object();
-    result["value"] = value;
-    return result;
-  });
-  
-  auto& service = createTestService();
-  
+  server.registerMethod(
+    "increment",
+    [&counter](const iora::parsers::Json &params, RpcContext &ctx) -> iora::parsers::Json
+    {
+      int value = ++counter;
+      std::this_thread::sleep_for(std::chrono::milliseconds(1)); // Simulate some work
+      auto result = iora::parsers::Json::object();
+      result["value"] = value;
+      return result;
+    });
+
+  auto &service = createTestService();
+
   SECTION("Concurrent requests")
   {
     const int numThreads = 4;
     const int requestsPerThread = 10;
     std::vector<std::thread> threads;
     std::vector<bool> results(numThreads * requestsPerThread, false);
-    
+
     for (int t = 0; t < numThreads; ++t)
     {
-      threads.emplace_back([&, t]()
-      {
-        for (int r = 0; r < requestsPerThread; ++r)
+      threads.emplace_back(
+        [&, t]()
         {
-          RpcContext ctx(service);
-          std::string request = R"({"jsonrpc":"2.0","method":"increment","params":{},"id":)" + 
-                               std::to_string(t * requestsPerThread + r) + "}";
-          std::string response = server.handleRequest(request, ctx);
-          
-          if (!response.empty())
+          for (int r = 0; r < requestsPerThread; ++r)
           {
-            try
+            RpcContext ctx(service);
+            std::string request = R"({"jsonrpc":"2.0","method":"increment","params":{},"id":)" +
+                                  std::to_string(t * requestsPerThread + r) + "}";
+            std::string response = server.handleRequest(request, ctx);
+
+            if (!response.empty())
             {
-              iora::parsers::Json resp = iora::parsers::Json::parseString(response);
-              if (resp.contains("result") && resp["result"].contains("value"))
+              try
               {
-                results[t * requestsPerThread + r] = true;
+                iora::parsers::Json resp = iora::parsers::Json::parseString(response);
+                if (resp.contains("result") && resp["result"].contains("value"))
+                {
+                  results[t * requestsPerThread + r] = true;
+                }
+              }
+              catch (...)
+              {
+                // Parse error, leave as false
               }
-            }
-            catch (...)
-            {
-              // Parse error, leave as false
             }
           }
-        }
-      });
+        });
     }
-    
-    for (auto& thread : threads)
+
+    for (auto &thread : threads)
     {
       thread.join();
     }
-    
+
     // All requests should have succeeded
     for (bool result : results)
     {
       REQUIRE(result);
     }
-    
+
     // Counter should equal total number of requests
     REQUIRE(counter == numThreads * requestsPerThread);
   }
@@ -573,35 +576,39 @@ TEST_CASE("JsonRpcServer concurrency", "[jsonrpc][concurrency]")
 TEST_CASE("JsonRpcServer method replacement", "[jsonrpc][replacement]")
 {
   JsonRpcServer server;
-  
+
   // Original handler
-  server.registerMethod("test", [](const iora::parsers::Json& params, RpcContext& ctx) -> iora::parsers::Json
-  {
-    auto result = iora::parsers::Json::object();
-    result["version"] = 1;
-    return result;
-  });
-  
-  auto& service = createTestService();
+  server.registerMethod(
+    "test",
+    [](const iora::parsers::Json &params, RpcContext &ctx) -> iora::parsers::Json
+    {
+      auto result = iora::parsers::Json::object();
+      result["version"] = 1;
+      return result;
+    });
+
+  auto &service = createTestService();
   RpcContext ctx(service);
-  
+
   SECTION("Replace method handler")
   {
     // Test original handler
     std::string request = R"({"jsonrpc":"2.0","method":"test","params":{},"id":1})";
     std::string response = server.handleRequest(request, ctx);
-    
+
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp["result"]["version"] == 1);
-    
+
     // Replace with new handler
-    server.registerMethod("test", [](const iora::parsers::Json& params, RpcContext& ctx) -> iora::parsers::Json
-    {
-      auto result = iora::parsers::Json::object();
-      result["version"] = 2;
-      return result;
-    });
-    
+    server.registerMethod(
+      "test",
+      [](const iora::parsers::Json &params, RpcContext &ctx) -> iora::parsers::Json
+      {
+        auto result = iora::parsers::Json::object();
+        result["version"] = 2;
+        return result;
+      });
+
     // Test new handler
     response = server.handleRequest(request, ctx);
     resp = iora::parsers::Json::parseString(response);
@@ -613,20 +620,20 @@ TEST_CASE("JsonRpcServer edge cases", "[jsonrpc][edge]")
 {
   JsonRpcServer server;
   server.registerMethod("echo", echoHandler);
-  
-  auto& service = createTestService();
+
+  auto &service = createTestService();
   RpcContext ctx(service);
-  
+
   SECTION("Request with null id")
   {
     std::string request = R"({"jsonrpc":"2.0","method":"echo","params":{},"id":null})";
     std::string response = server.handleRequest(request, ctx);
-    
+
     REQUIRE_FALSE(response.empty());
     iora::parsers::Json resp = iora::parsers::Json::parseString(response);
     REQUIRE(resp["id"].is_null());
   }
-  
+
   SECTION("Request with different id types")
   {
     // String id
@@ -634,14 +641,14 @@ TEST_CASE("JsonRpcServer edge cases", "[jsonrpc][edge]")
     std::string response1 = server.handleRequest(request1, ctx);
     iora::parsers::Json resp1 = iora::parsers::Json::parseString(response1);
     REQUIRE(resp1["id"] == "test");
-    
+
     // Number id
     std::string request2 = R"({"jsonrpc":"2.0","method":"echo","params":{},"id":42})";
     std::string response2 = server.handleRequest(request2, ctx);
     iora::parsers::Json resp2 = iora::parsers::Json::parseString(response2);
     REQUIRE(resp2["id"] == 42);
   }
-  
+
   SECTION("Request with different param types")
   {
     // Array params
@@ -650,13 +657,13 @@ TEST_CASE("JsonRpcServer edge cases", "[jsonrpc][edge]")
     iora::parsers::Json resp1 = iora::parsers::Json::parseString(response1);
     REQUIRE(resp1["result"].is_array());
     REQUIRE(resp1["result"][static_cast<std::size_t>(0)] == 1);
-    
+
     // Object params
     std::string request2 = R"({"jsonrpc":"2.0","method":"echo","params":{"key":"value"},"id":2})";
     std::string response2 = server.handleRequest(request2, ctx);
     iora::parsers::Json resp2 = iora::parsers::Json::parseString(response2);
     REQUIRE(resp2["result"]["key"] == "value");
-    
+
     // No params
     std::string request3 = R"({"jsonrpc":"2.0","method":"echo","id":3})";
     std::string response3 = server.handleRequest(request3, ctx);
@@ -675,13 +682,14 @@ TEST_CASE("JsonRpcServerPlugin basic functionality", "[jsonrpc][plugin][basic]")
   config.state.file = "ioraservice_jsonrpc_state.json";
   config.log.file = "ioraservice_jsonrpc_log";
   config.log.level = "info";
-  
+
   iora::IoraService::shutdown(); // Ensure clean state
   iora::IoraService::init(config);
-  iora::IoraService& svc = iora::IoraService::instanceRef();
+  iora::IoraService &svc = iora::IoraService::instanceRef();
   iora::IoraService::AutoServiceShutdown autoShutdown(svc);
 
-  auto pluginPath = iora::util::resolveRelativePath(iora::util::getExecutableDir(), "../") + "/mod_jsonrpc_server.so";
+  auto pluginPath = iora::util::resolveRelativePath(iora::util::getExecutableDir(), "../") +
+                    "/mod_jsonrpc_server.so";
   REQUIRE(std::filesystem::exists(pluginPath));
   REQUIRE(svc.loadSingleModule(pluginPath));
 
@@ -694,19 +702,21 @@ TEST_CASE("JsonRpcServerPlugin basic functionality", "[jsonrpc][plugin][basic]")
   SECTION("Plugin API: register and call methods")
   {
     // Register a test method via plugin API
-    auto handler = [](const iora::parsers::Json& params) -> iora::parsers::Json
+    auto handler = [](const iora::parsers::Json &params) -> iora::parsers::Json
     {
       auto result = iora::parsers::Json::object();
       result["echo"] = params;
       return result;
     };
-    
-    svc.callExportedApi<void, const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>>("jsonrpc.register", "plugin_test", handler);
-    
+
+    svc.callExportedApi<void, const std::string &,
+                        std::function<iora::parsers::Json(const iora::parsers::Json &)>>(
+      "jsonrpc.register", "plugin_test", handler);
+
     // Check if method was registered
-    auto hasMethod = svc.callExportedApi<bool, const std::string&>("jsonrpc.has", "plugin_test");
+    auto hasMethod = svc.callExportedApi<bool, const std::string &>("jsonrpc.has", "plugin_test");
     REQUIRE(hasMethod);
-    
+
     // Get method list
     auto methods = svc.callExportedApi<std::vector<std::string>>("jsonrpc.getMethods");
     REQUIRE(std::find(methods.begin(), methods.end(), "plugin_test") != methods.end());
@@ -715,61 +725,63 @@ TEST_CASE("JsonRpcServerPlugin basic functionality", "[jsonrpc][plugin][basic]")
   SECTION("Plugin API: unregister methods")
   {
     // Register method
-    auto handler = [](const iora::parsers::Json& params) -> iora::parsers::Json
-    {
-      return params;
-    };
-    svc.callExportedApi<void, const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>>("jsonrpc.register", "temp_method", handler);
-    REQUIRE(svc.callExportedApi<bool, const std::string&>("jsonrpc.has", "temp_method"));
-    
+    auto handler = [](const iora::parsers::Json &params) -> iora::parsers::Json { return params; };
+    svc.callExportedApi<void, const std::string &,
+                        std::function<iora::parsers::Json(const iora::parsers::Json &)>>(
+      "jsonrpc.register", "temp_method", handler);
+    REQUIRE(svc.callExportedApi<bool, const std::string &>("jsonrpc.has", "temp_method"));
+
     // Unregister method
-    bool removed = svc.callExportedApi<bool, const std::string&>("jsonrpc.unregister", "temp_method");
+    bool removed =
+      svc.callExportedApi<bool, const std::string &>("jsonrpc.unregister", "temp_method");
     REQUIRE(removed);
-    REQUIRE_FALSE(svc.callExportedApi<bool, const std::string&>("jsonrpc.has", "temp_method"));
+    REQUIRE_FALSE(svc.callExportedApi<bool, const std::string &>("jsonrpc.has", "temp_method"));
   }
 
   SECTION("Plugin API: method registration with options")
   {
-    auto handler = [](const iora::parsers::Json& params) -> iora::parsers::Json
+    auto handler = [](const iora::parsers::Json &params) -> iora::parsers::Json
     {
       auto result = iora::parsers::Json::object();
       result["auth_required"] = true;
       return result;
     };
-    
+
     iora::parsers::Json opts;
     opts["requireAuth"] = true;
     opts["maxRequestSize"] = 1024;
-    
-    svc.callExportedApi<void, const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>, const iora::parsers::Json&>(
-      "jsonrpc.registerWithOptions", "auth_method", handler, opts);
-    
-    REQUIRE(svc.callExportedApi<bool, const std::string&>("jsonrpc.has", "auth_method"));
+
+    svc.callExportedApi<void, const std::string &,
+                        std::function<iora::parsers::Json(const iora::parsers::Json &)>,
+                        const iora::parsers::Json &>("jsonrpc.registerWithOptions", "auth_method",
+                                                     handler, opts);
+
+    REQUIRE(svc.callExportedApi<bool, const std::string &>("jsonrpc.has", "auth_method"));
   }
 
   SECTION("Plugin API: statistics")
   {
     // Reset stats
     svc.callExportedApi<void>("jsonrpc.resetStats");
-    
-    // Get initial stats  
+
+    // Get initial stats
     auto statsJson = svc.callExportedApi<iora::parsers::Json>("jsonrpc.getStats");
     REQUIRE(statsJson["totalRequests"].get<std::uint64_t>() == 0);
-    
+
     // Register and simulate some activity (this would normally be done via HTTP requests)
-    auto handler = [](const iora::parsers::Json& params) -> iora::parsers::Json
-    {
-      return params;
-    };
-    svc.callExportedApi<void, const std::string&, std::function<iora::parsers::Json(const iora::parsers::Json&)>>("jsonrpc.register", "stats_test", handler);
-    
+    auto handler = [](const iora::parsers::Json &params) -> iora::parsers::Json { return params; };
+    svc.callExportedApi<void, const std::string &,
+                        std::function<iora::parsers::Json(const iora::parsers::Json &)>>(
+      "jsonrpc.register", "stats_test", handler);
+
     // Note: HTTP request testing would require starting the webhook server,
     // which is beyond the scope of unit tests. The stats functionality
     // is tested at the JsonRpcServer level above.
   }
 
   // Cleanup
-  iora::util::removeFilesContainingAny({"ioraservice_jsonrpc_log", "ioraservice_jsonrpc_state.json"});
+  iora::util::removeFilesContainingAny(
+    {"ioraservice_jsonrpc_log", "ioraservice_jsonrpc_state.json"});
 }
 
 TEST_CASE("JsonRpcServerPlugin configuration", "[jsonrpc][plugin][config]")
@@ -778,19 +790,20 @@ TEST_CASE("JsonRpcServerPlugin configuration", "[jsonrpc][plugin][config]")
   iora::IoraService::Config config;
   config.server.port = 8134;
   config.log.level = "info";
-  
+
   iora::IoraService::shutdown(); // Ensure clean state
   iora::IoraService::init(config);
-  iora::IoraService& svc = iora::IoraService::instanceRef();
+  iora::IoraService &svc = iora::IoraService::instanceRef();
   iora::IoraService::AutoServiceShutdown autoShutdown(svc);
 
-  auto pluginPath = iora::util::resolveRelativePath(iora::util::getExecutableDir(), "../") + "/mod_jsonrpc_server.so";
-  
+  auto pluginPath = iora::util::resolveRelativePath(iora::util::getExecutableDir(), "../") +
+                    "/mod_jsonrpc_server.so";
+
   SECTION("Plugin loads with default configuration")
   {
     REQUIRE(std::filesystem::exists(pluginPath));
     REQUIRE(svc.loadSingleModule(pluginPath));
-    
+
     // Verify plugin is loaded by checking API availability
     REQUIRE_NOTHROW(svc.callExportedApi<std::uint32_t>("jsonrpc.version"));
   }
diff --git a/src/modules/storage/kvstore/kvstore.hpp b/src/modules/storage/kvstore/kvstore.hpp
index 37b763a..5314bcc 100644
--- a/src/modules/storage/kvstore/kvstore.hpp
+++ b/src/modules/storage/kvstore/kvstore.hpp
@@ -6,25 +6,25 @@
 
 #pragma once
 
-#include <string>
-#include <vector>
-#include <unordered_map>
+#include <algorithm>
+#include <atomic>
+#include <chrono>
+#include <condition_variable>
+#include <cstring>
+#include <filesystem>
 #include <fstream>
+#include <memory>
 #include <optional>
 #include <shared_mutex>
-#include <filesystem>
-#include <thread>
-#include <condition_variable>
-#include <atomic>
-#include <memory>
-#include <chrono>
 #include <stdexcept>
-#include <algorithm>
-#include <cstring>
+#include <string>
+#include <thread>
+#include <unordered_map>
+#include <vector>
 
 #ifdef __unix__
-#include <unistd.h>
 #include <fcntl.h>
+#include <unistd.h>
 #endif
 
 /// @brief Maximum length for keys in KVStore
@@ -49,16 +49,17 @@ struct KVStoreConfig
 class KVStoreException : public std::runtime_error
 {
 public:
-  explicit KVStoreException(const std::string& msg) : std::runtime_error(msg) {}
+  explicit KVStoreException(const std::string &msg) : std::runtime_error(msg) {}
 };
 
-/// \brief A robust binary persistent key-value store with atomic operations, concurrent reads, and background compaction.
+/// \brief A robust binary persistent key-value store with atomic operations, concurrent reads, and
+/// background compaction.
 class KVStore
 {
 public:
-  explicit KVStore(const std::string& path, const KVStoreConfig& config = {})
-    : _config(config), _path(path), _logPath(path + ".log"), _tempPath(path + ".tmp"),
-      _shutdown(false), _compactionInProgress(false)
+  explicit KVStore(const std::string &path, const KVStoreConfig &config = {})
+      : _config(config), _path(path), _logPath(path + ".log"), _tempPath(path + ".tmp"),
+        _shutdown(false), _compactionInProgress(false)
   {
     try
     {
@@ -69,7 +70,7 @@ public:
         _compactionThread = std::thread(&KVStore::compactionWorker, this);
       }
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       throw KVStoreException("Failed to initialize KVStore: " + std::string(e.what()));
     }
@@ -87,12 +88,12 @@ public:
     }
   }
 
-  void setString(const std::string& key, const std::string& value)
+  void setString(const std::string &key, const std::string &value)
   {
     set(key, std::vector<std::uint8_t>(value.begin(), value.end()));
   }
 
-  std::optional<std::string> getString(const std::string& key)
+  std::optional<std::string> getString(const std::string &key)
   {
     auto binary = get(key);
     if (binary.has_value())
@@ -102,7 +103,7 @@ public:
     return std::nullopt;
   }
 
-  void set(const std::string& key, const std::vector<std::uint8_t>& value)
+  void set(const std::string &key, const std::vector<std::uint8_t> &value)
   {
     if (key.empty())
     {
@@ -121,22 +122,22 @@ public:
     std::unique_lock<std::shared_mutex> lock(_mutex);
     _kv[key] = value;
     updateCache(key, value);
-    
+
     try
     {
       writeLogEntry('S', key, value);
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       _kv.erase(key);
       _cache.erase(key);
       throw KVStoreException("Failed to write log entry: " + std::string(e.what()));
     }
-    
+
     maybeCompact();
   }
 
-  std::optional<std::vector<std::uint8_t>> get(const std::string& key)
+  std::optional<std::vector<std::uint8_t>> get(const std::string &key)
   {
     if (key.empty())
     {
@@ -163,7 +164,7 @@ public:
     return std::nullopt;
   }
 
-  void remove(const std::string& key)
+  void remove(const std::string &key)
   {
     if (key.empty())
     {
@@ -177,26 +178,27 @@ public:
         std::unique_lock<std::shared_mutex> cacheLock(_cacheMutex);
         _cache.erase(key);
       }
-      
+
       try
       {
         writeLogEntry('D', key, {});
       }
-      catch (const std::exception& e)
+      catch (const std::exception &e)
       {
         throw KVStoreException("Failed to write delete log entry: " + std::string(e.what()));
       }
-      
+
       maybeCompact();
     }
   }
 
   // Batch operations for better performance
-  void setBatch(const std::unordered_map<std::string, std::vector<std::uint8_t>>& batch)
+  void setBatch(const std::unordered_map<std::string, std::vector<std::uint8_t>> &batch)
   {
-    if (batch.empty()) return;
+    if (batch.empty())
+      return;
 
-    for (const auto& [key, value] : batch)
+    for (const auto &[key, value] : batch)
     {
       if (key.empty() || key.size() > MAX_KEY_LENGTH || value.size() > MAX_VALUE_LENGTH)
       {
@@ -205,9 +207,9 @@ public:
     }
 
     std::unique_lock<std::shared_mutex> lock(_mutex);
-    
+
     // Apply all changes to memory first
-    for (const auto& [key, value] : batch)
+    for (const auto &[key, value] : batch)
     {
       _kv[key] = value;
       updateCache(key, value);
@@ -216,15 +218,15 @@ public:
     // Then write to log
     try
     {
-      for (const auto& [key, value] : batch)
+      for (const auto &[key, value] : batch)
       {
         writeLogEntry('S', key, value);
       }
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       // Rollback memory changes
-      for (const auto& [key, value] : batch)
+      for (const auto &[key, value] : batch)
       {
         _kv.erase(key);
         _cache.erase(key);
@@ -235,12 +237,13 @@ public:
     maybeCompact();
   }
 
-  std::unordered_map<std::string, std::vector<std::uint8_t>> getBatch(const std::vector<std::string>& keys)
+  std::unordered_map<std::string, std::vector<std::uint8_t>>
+  getBatch(const std::vector<std::string> &keys)
   {
     std::unordered_map<std::string, std::vector<std::uint8_t>> result;
     std::shared_lock<std::shared_mutex> lock(_mutex);
-    
-    for (const auto& key : keys)
+
+    for (const auto &key : keys)
     {
       if (!key.empty())
       {
@@ -251,7 +254,7 @@ public:
         }
       }
     }
-    
+
     return result;
   }
 
@@ -263,8 +266,8 @@ public:
       _logStream.flush();
 #ifdef __unix__
       // Get file descriptor properly
-      //std::ofstream* ofs = &_logStream;
-      //auto* filebuf = static_cast<std::filebuf*>(ofs->rdbuf());
+      // std::ofstream* ofs = &_logStream;
+      // auto* filebuf = static_cast<std::filebuf*>(ofs->rdbuf());
       // Use lower-level approach to get fd
       int fd = open(_logPath.c_str(), O_WRONLY | O_APPEND);
       if (fd != -1)
@@ -280,7 +283,7 @@ public:
   {
     std::unique_lock<std::shared_mutex> lock(_mutex);
     _compactionInProgress = true;
-    
+
     try
     {
       // Create snapshot with proper error handling
@@ -290,35 +293,35 @@ public:
         {
           throw KVStoreException("Failed to open temp file for compaction: " + _tempPath);
         }
-        
+
         // Write header with validation
         if (!writeHeader(out))
         {
           throw KVStoreException("Failed to write header during compaction");
         }
-        
+
         uint32_t count = static_cast<uint32_t>(_kv.size());
-        if (!out.write(reinterpret_cast<const char*>(&count), sizeof(count)))
+        if (!out.write(reinterpret_cast<const char *>(&count), sizeof(count)))
         {
           throw KVStoreException("Failed to write count during compaction");
         }
-        
+
         // Write all key-value pairs with validation
-        for (const auto& [key, value] : _kv)
+        for (const auto &[key, value] : _kv)
         {
           if (!writeKeyValue(out, key, value))
           {
             throw KVStoreException("Failed to write key-value pair during compaction");
           }
         }
-        
+
         out.flush();
         if (!out.good())
         {
           throw KVStoreException("Stream error during compaction");
         }
       }
-      
+
       // Atomic rename operation
       std::error_code ec;
       std::filesystem::rename(_tempPath, _path, ec);
@@ -327,7 +330,7 @@ public:
         std::filesystem::remove(_tempPath, ec); // Cleanup
         throw KVStoreException("Failed to rename temp file: " + ec.message());
       }
-      
+
       // Reset log file
       _logStream.close();
       {
@@ -337,17 +340,17 @@ public:
           throw KVStoreException("Failed to clear log file");
         }
       }
-      
+
       openLogFile();
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       _compactionInProgress = false;
       std::error_code ec;
       std::filesystem::remove(_tempPath, ec); // Cleanup on failure
       throw;
     }
-    
+
     _compactionInProgress = false;
   }
 
@@ -358,55 +361,55 @@ public:
     return _kv.size();
   }
 
-  bool exists(const std::string& key) const
+  bool exists(const std::string &key) const
   {
-    if (key.empty()) return false;
+    if (key.empty())
+      return false;
     std::shared_lock<std::shared_mutex> lock(_mutex);
     return _kv.find(key) != _kv.end();
   }
 
-  void forceCompact()
-  {
-    compact();
-  }
+  void forceCompact() { compact(); }
 
   // Shutdown method for proper cleanup
   void shutdown()
   {
     _shutdown = true;
     _compactionCV.notify_all();
-    
+
     if (_compactionThread.joinable())
     {
       _compactionThread.join();
     }
-    
+
     flush();
     _logStream.close();
   }
 
-  KVStore(const KVStore&) = delete;
-  KVStore& operator=(const KVStore&) = delete;
-  KVStore(KVStore&&) = delete;
-  KVStore& operator=(KVStore&&) = delete;
+  KVStore(const KVStore &) = delete;
+  KVStore &operator=(const KVStore &) = delete;
+  KVStore(KVStore &&) = delete;
+  KVStore &operator=(KVStore &&) = delete;
 
 private:
   // Helper methods for atomic operations
-  bool writeHeader(std::ofstream& out) const
+  bool writeHeader(std::ofstream &out) const
   {
-    return out.write(reinterpret_cast<const char*>(&_config.magicNumber), sizeof(_config.magicNumber)) &&
-           out.write(reinterpret_cast<const char*>(&_config.version), sizeof(_config.version));
+    return out.write(reinterpret_cast<const char *>(&_config.magicNumber),
+                     sizeof(_config.magicNumber)) &&
+           out.write(reinterpret_cast<const char *>(&_config.version), sizeof(_config.version));
   }
 
-  bool writeKeyValue(std::ofstream& out, const std::string& key, const std::vector<std::uint8_t>& value) const
+  bool writeKeyValue(std::ofstream &out, const std::string &key,
+                     const std::vector<std::uint8_t> &value) const
   {
     uint32_t keyLen = static_cast<uint32_t>(key.size());
     uint32_t valLen = static_cast<uint32_t>(value.size());
-    
-    return out.write(reinterpret_cast<const char*>(&keyLen), sizeof(keyLen)) &&
+
+    return out.write(reinterpret_cast<const char *>(&keyLen), sizeof(keyLen)) &&
            out.write(key.data(), keyLen) &&
-           out.write(reinterpret_cast<const char*>(&valLen), sizeof(valLen)) &&
-           out.write(reinterpret_cast<const char*>(value.data()), valLen);
+           out.write(reinterpret_cast<const char *>(&valLen), sizeof(valLen)) &&
+           out.write(reinterpret_cast<const char *>(value.data()), valLen);
   }
 
   void openLogFile()
@@ -425,9 +428,10 @@ private:
     {
       std::unique_lock<std::mutex> lock(_compactionMutex);
       _compactionCV.wait_for(lock, _config.compactionInterval, [this] { return _shutdown.load(); });
-      
-      if (_shutdown) break;
-      
+
+      if (_shutdown)
+        break;
+
       try
       {
         if (shouldCompact())
@@ -435,7 +439,7 @@ private:
           compact();
         }
       }
-      catch (const std::exception& e)
+      catch (const std::exception &e)
       {
         // Log error but continue - don't crash the background thread
       }
@@ -458,7 +462,7 @@ private:
   }
 
   // Cache management
-  void updateCache(const std::string& key, const std::vector<std::uint8_t>& value) const
+  void updateCache(const std::string &key, const std::vector<std::uint8_t> &value) const
   {
     std::unique_lock<std::shared_mutex> lock(_cacheMutex);
     if (_cache.size() >= _config.maxCacheSize)
@@ -470,10 +474,11 @@ private:
   }
 
   // Enhanced CRC32 with input validation
-  uint32_t crc32(const std::vector<std::uint8_t>& data) const
+  uint32_t crc32(const std::vector<std::uint8_t> &data) const
   {
-    if (data.empty()) return 0;
-    
+    if (data.empty())
+      return 0;
+
     uint32_t crc = 0xFFFFFFFF;
     for (uint8_t b : data)
     {
@@ -490,11 +495,13 @@ private:
   }
 
   // Enhanced corruption detection
-  bool validateLogEntry(const std::vector<std::uint8_t>& buffer, size_t expectedSize) const
+  bool validateLogEntry(const std::vector<std::uint8_t> &buffer, size_t expectedSize) const
   {
-    if (buffer.size() < 10) return false; // Minimum size check
-    if (buffer.size() != expectedSize) return false;
-    
+    if (buffer.size() < 10)
+      return false; // Minimum size check
+    if (buffer.size() != expectedSize)
+      return false;
+
     // Additional integrity checks can be added here
     return true;
   }
@@ -506,25 +513,25 @@ private:
     if (snapshot.is_open())
     {
       uint32_t magic = 0;
-      if (!snapshot.read(reinterpret_cast<char*>(&magic), sizeof(magic)) ||
+      if (!snapshot.read(reinterpret_cast<char *>(&magic), sizeof(magic)) ||
           magic != _config.magicNumber)
       {
         throw KVStoreException("Invalid or corrupted snapshot file: bad magic number");
       }
 
       uint32_t version = 0;
-      if (!snapshot.read(reinterpret_cast<char*>(&version), sizeof(version)) ||
+      if (!snapshot.read(reinterpret_cast<char *>(&version), sizeof(version)) ||
           version != _config.version)
       {
         throw KVStoreException("Unsupported snapshot version: " + std::to_string(version));
       }
 
       uint32_t count = 0;
-      if (!snapshot.read(reinterpret_cast<char*>(&count), sizeof(count)))
+      if (!snapshot.read(reinterpret_cast<char *>(&count), sizeof(count)))
       {
         throw KVStoreException("Failed to read entry count from snapshot");
       }
-      
+
       if (count > 10000000) // Sanity check
       {
         throw KVStoreException("Unreasonable entry count in snapshot: " + std::to_string(count));
@@ -533,48 +540,52 @@ private:
       for (uint32_t i = 0; i < count; ++i)
       {
         uint32_t keyLen = 0;
-        if (!snapshot.read(reinterpret_cast<char*>(&keyLen), sizeof(keyLen)) || keyLen == 0 || keyLen > 65536)
+        if (!snapshot.read(reinterpret_cast<char *>(&keyLen), sizeof(keyLen)) || keyLen == 0 ||
+            keyLen > 65536)
         {
           throw KVStoreException("Invalid key length in snapshot at entry " + std::to_string(i));
         }
-        
+
         std::string key(keyLen, '\0');
         if (!snapshot.read(&key[0], keyLen))
         {
           throw KVStoreException("Failed to read key in snapshot at entry " + std::to_string(i));
         }
-        
+
         uint32_t valLen = 0;
-        if (!snapshot.read(reinterpret_cast<char*>(&valLen), sizeof(valLen)) || valLen > 100*1024*1024)
+        if (!snapshot.read(reinterpret_cast<char *>(&valLen), sizeof(valLen)) ||
+            valLen > 100 * 1024 * 1024)
         {
           throw KVStoreException("Invalid value length in snapshot at entry " + std::to_string(i));
         }
-        
+
         std::vector<std::uint8_t> value(valLen);
-        if (!snapshot.read(reinterpret_cast<char*>(value.data()), valLen))
+        if (!snapshot.read(reinterpret_cast<char *>(value.data()), valLen))
         {
           throw KVStoreException("Failed to read value in snapshot at entry " + std::to_string(i));
         }
-        
+
         _kv[std::move(key)] = std::move(value);
       }
     }
 
     // Load log with enhanced error handling and corruption detection
     std::ifstream log(_logPath, std::ios::binary);
-    if (!log.is_open()) return; // No log file yet
-    
+    if (!log.is_open())
+      return; // No log file yet
+
     size_t entriesProcessed = 0;
     while (log.peek() != EOF)
     {
       uint32_t totalLen = 0;
-      if (!log.read(reinterpret_cast<char*>(&totalLen), sizeof(totalLen)) || totalLen < 10 || totalLen > 100*1024*1024)
+      if (!log.read(reinterpret_cast<char *>(&totalLen), sizeof(totalLen)) || totalLen < 10 ||
+          totalLen > 100 * 1024 * 1024)
       {
         break; // Invalid or corrupted entry
       }
 
       std::vector<std::uint8_t> buffer(totalLen);
-      if (!log.read(reinterpret_cast<char*>(buffer.data()), totalLen))
+      if (!log.read(reinterpret_cast<char *>(buffer.data()), totalLen))
       {
         break; // Incomplete entry
       }
@@ -584,9 +595,9 @@ private:
         continue; // Skip corrupted entry
       }
 
-      const char* ptr = reinterpret_cast<const char*>(buffer.data());
+      const char *ptr = reinterpret_cast<const char *>(buffer.data());
       char op = *ptr++;
-      
+
       if (op != 'S' && op != 'D')
       {
         continue; // Unknown operation
@@ -595,30 +606,32 @@ private:
       uint32_t keyLen;
       std::memcpy(&keyLen, ptr, 4);
       ptr += 4;
-      
-      if (keyLen == 0 || keyLen > 65536 || ptr + keyLen > reinterpret_cast<const char*>(buffer.data()) + buffer.size())
+
+      if (keyLen == 0 || keyLen > 65536 ||
+          ptr + keyLen > reinterpret_cast<const char *>(buffer.data()) + buffer.size())
       {
         continue; // Invalid key length
       }
-      
+
       std::string key(ptr, keyLen);
       ptr += keyLen;
 
       if (op == 'S')
       {
         uint32_t valLen;
-        if (ptr + 4 > reinterpret_cast<const char*>(buffer.data()) + buffer.size())
+        if (ptr + 4 > reinterpret_cast<const char *>(buffer.data()) + buffer.size())
         {
           continue;
         }
         std::memcpy(&valLen, ptr, 4);
         ptr += 4;
-        
-        if (valLen > 100*1024*1024 || ptr + valLen + 4 > reinterpret_cast<const char*>(buffer.data()) + buffer.size())
+
+        if (valLen > 100 * 1024 * 1024 ||
+            ptr + valLen + 4 > reinterpret_cast<const char *>(buffer.data()) + buffer.size())
         {
           continue; // Invalid value length
         }
-        
+
         std::vector<std::uint8_t> value(valLen);
         std::memcpy(value.data(), ptr, valLen);
         ptr += valLen;
@@ -639,44 +652,46 @@ private:
       {
         _kv.erase(key);
       }
-      
+
       entriesProcessed++;
     }
   }
 
-  void writeLogEntry(char op, const std::string& key, const std::vector<std::uint8_t>& value)
+  void writeLogEntry(char op, const std::string &key, const std::vector<std::uint8_t> &value)
   {
     if (!_logStream.is_open())
     {
       throw KVStoreException("Log stream is not open");
     }
-    
+
     std::vector<std::uint8_t> buffer;
     buffer.reserve(1 + 4 + key.size() + (op == 'S' ? 4 + value.size() : 0)); // Pre-allocate
-    
+
     buffer.push_back(static_cast<uint8_t>(op));
     uint32_t keyLen = static_cast<uint32_t>(key.size());
-    buffer.insert(buffer.end(), reinterpret_cast<const uint8_t*>(&keyLen), reinterpret_cast<const uint8_t*>(&keyLen) + 4);
+    buffer.insert(buffer.end(), reinterpret_cast<const uint8_t *>(&keyLen),
+                  reinterpret_cast<const uint8_t *>(&keyLen) + 4);
     buffer.insert(buffer.end(), key.begin(), key.end());
 
     if (op == 'S')
     {
       uint32_t valLen = static_cast<uint32_t>(value.size());
-      buffer.insert(buffer.end(), reinterpret_cast<const uint8_t*>(&valLen), reinterpret_cast<const uint8_t*>(&valLen) + 4);
+      buffer.insert(buffer.end(), reinterpret_cast<const uint8_t *>(&valLen),
+                    reinterpret_cast<const uint8_t *>(&valLen) + 4);
       buffer.insert(buffer.end(), value.begin(), value.end());
     }
 
     uint32_t checksum = crc32(buffer);
     uint32_t totalLen = static_cast<uint32_t>(buffer.size()) + 4; // +4 for checksum
-    
+
     // Write atomically
-    if (!_logStream.write(reinterpret_cast<const char*>(&totalLen), 4) ||
-        !_logStream.write(reinterpret_cast<const char*>(buffer.data()), buffer.size()) ||
-        !_logStream.write(reinterpret_cast<const char*>(&checksum), 4))
+    if (!_logStream.write(reinterpret_cast<const char *>(&totalLen), 4) ||
+        !_logStream.write(reinterpret_cast<const char *>(buffer.data()), buffer.size()) ||
+        !_logStream.write(reinterpret_cast<const char *>(&checksum), 4))
     {
       throw KVStoreException("Failed to write log entry");
     }
-    
+
     _logStream.flush();
   }
 
@@ -685,21 +700,21 @@ private:
   const std::string _path;
   const std::string _logPath;
   const std::string _tempPath;
-  
+
   // File streams
   std::ofstream _logStream;
-  
+
   // Data storage
   std::unordered_map<std::string, std::vector<std::uint8_t>> _kv;
   mutable std::unordered_map<std::string, std::vector<std::uint8_t>> _cache;
-  
+
   // Threading and synchronization
   mutable std::shared_mutex _mutex;
   mutable std::shared_mutex _cacheMutex;
   std::mutex _compactionMutex;
   std::condition_variable _compactionCV;
   std::thread _compactionThread;
-  
+
   // State management
   std::atomic<bool> _shutdown;
   std::atomic<bool> _compactionInProgress;
diff --git a/src/modules/storage/kvstore/mod_kvstore.cpp b/src/modules/storage/kvstore/mod_kvstore.cpp
index f5a1093..030fa9b 100644
--- a/src/modules/storage/kvstore/mod_kvstore.cpp
+++ b/src/modules/storage/kvstore/mod_kvstore.cpp
@@ -6,23 +6,19 @@
 
 #include "iora/iora.hpp"
 #include "kvstore.hpp"
-#include <string>
-#include <vector>
 #include <memory>
 #include <stdexcept>
-
+#include <string>
+#include <vector>
 
 class KVStorePlugin : public iora::IoraService::Plugin
 {
 public:
-  explicit KVStorePlugin(iora::IoraService* service)
-    : Plugin(service)
-  {
-  }
+  explicit KVStorePlugin(iora::IoraService *service) : Plugin(service) {}
 
-  void onLoad(iora::IoraService* service) override
+  void onLoad(iora::IoraService *service) override
   {
-    auto* loader = service->configLoader().get();
+    auto *loader = service->configLoader().get();
     if (!loader)
     {
       throw std::runtime_error("KVStorePlugin: configLoader is not available");
@@ -39,26 +35,29 @@ public:
     if (auto v = loader->getInt("iora.modules.kvstore.compaction_interval_ms"))
       config.compactionInterval = std::chrono::milliseconds(*v);
     _store = std::make_unique<KVStore>(path, config);
-    
+
     // Export API: get, set, setBatch, getBatch
-    service->exportApi(*this, "kvstore.get", [this](const std::string& key) -> std::optional<std::vector<std::uint8_t>> {
-      return _store->get(key);
-    });
-    service->exportApi(*this, "kvstore.set", [this](const std::string& key, const std::vector<std::uint8_t>& value) -> void {
-      _store->set(key, value);
-    });
-    service->exportApi(*this, "kvstore.setBatch", [this](const std::unordered_map<std::string, std::vector<std::uint8_t>>& batch) -> void {
-      _store->setBatch(batch);
-    });
-    service->exportApi(*this, "kvstore.getBatch", [this](const std::vector<std::string>& keys) -> std::unordered_map<std::string, std::vector<std::uint8_t>> {
-      return _store->getBatch(keys);
-    });
-    service->exportApi(*this, "kvstore.getString", [this](const std::string& key) -> std::optional<std::string> {
-      return _store->getString(key);
-    });
-    service->exportApi(*this, "kvstore.setString", [this](const std::string& key, const std::string& value) -> void {
-      _store->setString(key, value);
-    });
+    service->exportApi(*this, "kvstore.get",
+                       [this](const std::string &key) -> std::optional<std::vector<std::uint8_t>>
+                       { return _store->get(key); });
+    service->exportApi(
+      *this, "kvstore.set",
+      [this](const std::string &key, const std::vector<std::uint8_t> &value) -> void
+      { _store->set(key, value); });
+    service->exportApi(
+      *this, "kvstore.setBatch",
+      [this](const std::unordered_map<std::string, std::vector<std::uint8_t>> &batch) -> void
+      { _store->setBatch(batch); });
+    service->exportApi(*this, "kvstore.getBatch",
+                       [this](const std::vector<std::string> &keys)
+                         -> std::unordered_map<std::string, std::vector<std::uint8_t>>
+                       { return _store->getBatch(keys); });
+    service->exportApi(*this, "kvstore.getString",
+                       [this](const std::string &key) -> std::optional<std::string>
+                       { return _store->getString(key); });
+    service->exportApi(*this, "kvstore.setString",
+                       [this](const std::string &key, const std::string &value) -> void
+                       { _store->setString(key, value); });
   }
 
   void onUnload() override
@@ -74,5 +73,4 @@ private:
   std::unique_ptr<KVStore> _store;
 };
 
-
 IORA_DECLARE_PLUGIN(KVStorePlugin);
diff --git a/src/modules/storage/kvstore/tests/iora_test_mod_kvstore.cpp b/src/modules/storage/kvstore/tests/iora_test_mod_kvstore.cpp
index 26859e9..7d14360 100644
--- a/src/modules/storage/kvstore/tests/iora_test_mod_kvstore.cpp
+++ b/src/modules/storage/kvstore/tests/iora_test_mod_kvstore.cpp
@@ -4,11 +4,13 @@
 // This file is part of Iora, which is licensed under the Mozilla Public License 2.0.
 // See the LICENSE file or <https://www.mozilla.org/MPL/2.0/> for details.
 
-#include <dlfcn.h>
+#include "iora/iora.hpp"
+#include "kvstore.hpp"
 #include <atomic>
 #include <catch2/catch.hpp>
 #include <chrono>
 #include <cstdio>
+#include <dlfcn.h>
 #include <filesystem>
 #include <fstream>
 #include <mutex>
@@ -16,24 +18,22 @@
 #include <string>
 #include <thread>
 #include <vector>
-#include "iora/iora.hpp"
-#include "kvstore.hpp"
 
 namespace
 {
-  std::vector<uint8_t> randomBytes(size_t n)
+std::vector<uint8_t> randomBytes(size_t n)
+{
+  std::vector<uint8_t> v(n);
+  std::random_device rd;
+  std::mt19937 gen(rd());
+  std::uniform_int_distribution<> dis(0, 255);
+  for (size_t i = 0; i < n; ++i)
   {
-    std::vector<uint8_t> v(n);
-    std::random_device rd;
-    std::mt19937 gen(rd());
-    std::uniform_int_distribution<> dis(0, 255);
-    for (size_t i = 0; i < n; ++i)
-    {
-      v[i] = static_cast<uint8_t>(dis(gen));
-    }
-    return v;
+    v[i] = static_cast<uint8_t>(dis(gen));
   }
-}  // namespace
+  return v;
+}
+} // namespace
 
 TEST_CASE("KVStore basic set/get/remove", "[kvstore]")
 {
@@ -69,13 +69,13 @@ TEST_CASE("KVStore batch set/get", "[kvstore][batch]")
   }
   store.setBatch(batch);
   auto keys = std::vector<std::string>{};
-  for (const auto& [k, _] : batch)
+  for (const auto &[k, _] : batch)
   {
     keys.push_back(k);
   }
   auto result = store.getBatch(keys);
   REQUIRE(result.size() == batch.size());
-  for (const auto& [k, v] : batch)
+  for (const auto &[k, v] : batch)
   {
     REQUIRE(result[k] == v);
   }
@@ -108,7 +108,7 @@ TEST_CASE("KVStore handles large values and compaction", "[kvstore][large][compa
   std::remove(file.c_str());
   std::remove((file + ".log").c_str());
   KVStoreConfig cfg;
-  cfg.maxLogSizeBytes = 1024 * 10;  // force compaction quickly
+  cfg.maxLogSizeBytes = 1024 * 10; // force compaction quickly
   KVStore store(file, cfg);
 
   std::string key = "big";
@@ -135,7 +135,8 @@ TEST_CASE("KVStore handles invalid operations", "[kvstore][invalid]")
   KVStore store(file);
   REQUIRE_THROWS_AS(store.set("", {1, 2, 3}), KVStoreException);
   REQUIRE_THROWS_AS(store.set(std::string(MAX_KEY_LENGTH + 1, 'x'), {1, 2, 3}), KVStoreException);
-  REQUIRE_THROWS_AS(store.set("ok", std::vector<uint8_t>(MAX_VALUE_LENGTH + 1, 1)), KVStoreException);
+  REQUIRE_THROWS_AS(store.set("ok", std::vector<uint8_t>(MAX_VALUE_LENGTH + 1, 1)),
+                    KVStoreException);
   std::remove(file.c_str());
   std::remove((file + ".log").c_str());
 }
@@ -171,10 +172,10 @@ TEST_CASE("KVStore persistence with mixed operations", "[kvstore][persistence][e
     KVStore store(file);
     store.set("key1", {1, 2, 3});
     store.set("key2", {4, 5, 6});
-    store.remove("key1");  // Remove then re-add
+    store.remove("key1"); // Remove then re-add
     store.set("key1", {7, 8, 9});
     store.set("key3", {10, 11, 12});
-    store.remove("key2");  // Remove permanently
+    store.remove("key2"); // Remove permanently
     store.flush();
   }
 
@@ -228,13 +229,13 @@ TEST_CASE("KVStore handles truncated log file", "[kvstore][corruption][log]")
   // Truncate the log file (simulate corruption)
   {
     std::ofstream logFile(file + ".log", std::ios::binary | std::ios::trunc);
-    logFile.write("corrupt", 7);  // Write invalid data
+    logFile.write("corrupt", 7); // Write invalid data
   }
 
   // Store should recover gracefully
   {
     KVStore store(file);
-    REQUIRE_NOTHROW(store.size());  // Should not crash
+    REQUIRE_NOTHROW(store.size()); // Should not crash
     store.set("recovery_test", {99});
     REQUIRE(store.get("recovery_test").value() == std::vector<uint8_t>({99}));
   }
@@ -252,7 +253,7 @@ TEST_CASE("KVStore handles corrupted snapshot file", "[kvstore][corruption][snap
   // Create a corrupted snapshot file
   {
     std::ofstream corrupt(file, std::ios::binary);
-    corrupt.write("BADMAGIC", 8);  // Invalid magic number
+    corrupt.write("BADMAGIC", 8); // Invalid magic number
   }
 
   // Should throw exception for corrupted snapshot
@@ -270,8 +271,8 @@ TEST_CASE("KVStore compaction reduces file size", "[kvstore][compaction][size]")
   std::remove((file + ".log").c_str());
 
   KVStoreConfig cfg;
-  cfg.maxLogSizeBytes = 1024;              // Small log to force compaction
-  cfg.enableBackgroundCompaction = false;  // Manual control
+  cfg.maxLogSizeBytes = 1024;             // Small log to force compaction
+  cfg.enableBackgroundCompaction = false; // Manual control
 
   std::vector<uint8_t> finalValue;
 
@@ -286,7 +287,7 @@ TEST_CASE("KVStore compaction reduces file size", "[kvstore][compaction][size]")
       store.set(key, data);
       if (i == 9)
       {
-        finalValue = data;  // Remember the final value
+        finalValue = data; // Remember the final value
       }
     }
 
@@ -295,7 +296,7 @@ TEST_CASE("KVStore compaction reduces file size", "[kvstore][compaction][size]")
 
     // Data should still be accessible
     REQUIRE(store.get(key).value() == finalValue);
-  }  // Destructor releases locks
+  } // Destructor releases locks
 
   // Verify log file was reset
   std::error_code ec;
@@ -304,7 +305,7 @@ TEST_CASE("KVStore compaction reduces file size", "[kvstore][compaction][size]")
     auto logSize = std::filesystem::file_size(file + ".log", ec);
     if (!ec)
     {
-      REQUIRE(logSize == 0);  // Should be empty after compaction
+      REQUIRE(logSize == 0); // Should be empty after compaction
     }
   }
 
@@ -344,7 +345,7 @@ TEST_CASE("KVStore compaction preserves all data", "[kvstore][compaction][integr
   store.forceCompact();
 
   // Verify all remaining data is intact
-  for (const auto& [key, expectedValue] : testData)
+  for (const auto &[key, expectedValue] : testData)
   {
     auto actualValue = store.get(key);
     REQUIRE(actualValue.has_value());
@@ -363,15 +364,15 @@ TEST_CASE("KVStore cache eviction with LRU", "[kvstore][cache][lru]")
   std::remove((file + ".log").c_str());
 
   KVStoreConfig cfg;
-  cfg.maxCacheSize = 3;  // Small cache
+  cfg.maxCacheSize = 3; // Small cache
   KVStore store(file, cfg);
 
   // Fill cache beyond capacity
   store.set("a", {1});
   store.set("b", {2});
   store.set("c", {3});
-  store.set("d", {4});  // Should evict oldest
-  store.set("e", {5});  // Should evict next oldest
+  store.set("d", {4}); // Should evict oldest
+  store.set("e", {5}); // Should evict next oldest
 
   // All keys should still be retrievable (from disk if not in cache)
   REQUIRE(store.get("a").value() == std::vector<uint8_t>({1}));
@@ -410,21 +411,21 @@ TEST_CASE("KVStore concurrent read operations", "[kvstore][concurrency][reads]")
   for (int t = 0; t < numThreads; ++t)
   {
     threads.emplace_back(
-        [&store, &successCount, numKeys, t]()
-        {
-          for (int i = t; i < numKeys; i += 4)
-          {  // Interleaved access
-            std::string key = "key_" + std::to_string(i);
-            auto result = store.get(key);
-            if (result.has_value() && result.value()[0] == static_cast<uint8_t>(i))
-            {
-              successCount++;
-            }
+      [&store, &successCount, numKeys, t]()
+      {
+        for (int i = t; i < numKeys; i += 4)
+        { // Interleaved access
+          std::string key = "key_" + std::to_string(i);
+          auto result = store.get(key);
+          if (result.has_value() && result.value()[0] == static_cast<uint8_t>(i))
+          {
+            successCount++;
           }
-        });
+        }
+      });
   }
 
-  for (auto& thread : threads)
+  for (auto &thread : threads)
   {
     thread.join();
   }
@@ -450,67 +451,67 @@ TEST_CASE("KVStore concurrent mixed operations", "[kvstore][concurrency][mixed]"
 
   // Writer thread
   threads.emplace_back(
-      [&store, &operationCount, &errors, &errorMutex]()
+    [&store, &operationCount, &errors, &errorMutex]()
+    {
+      try
       {
-        try
+        for (int i = 0; i < 50; ++i)
         {
-          for (int i = 0; i < 50; ++i)
-          {
-            std::string key = "write_" + std::to_string(i);
-            std::vector<uint8_t> value = randomBytes(10);
-            store.set(key, value);
-            operationCount++;
-          }
+          std::string key = "write_" + std::to_string(i);
+          std::vector<uint8_t> value = randomBytes(10);
+          store.set(key, value);
+          operationCount++;
         }
-        catch (const std::exception& e)
-        {
-          std::lock_guard<std::mutex> lock(errorMutex);
-          errors.push_back(std::string("Writer: ") + e.what());
-        }
-      });
+      }
+      catch (const std::exception &e)
+      {
+        std::lock_guard<std::mutex> lock(errorMutex);
+        errors.push_back(std::string("Writer: ") + e.what());
+      }
+    });
 
   // Reader thread
   threads.emplace_back(
-      [&store, &operationCount, &errors, &errorMutex]()
+    [&store, &operationCount, &errors, &errorMutex]()
+    {
+      try
       {
-        try
+        for (int i = 0; i < 100; ++i)
         {
-          for (int i = 0; i < 100; ++i)
-          {
-            std::string key = "write_" + std::to_string(i % 50);
-            auto result = store.get(key);
-            operationCount++;
-          }
+          std::string key = "write_" + std::to_string(i % 50);
+          auto result = store.get(key);
+          operationCount++;
         }
-        catch (const std::exception& e)
-        {
-          std::lock_guard<std::mutex> lock(errorMutex);
-          errors.push_back(std::string("Reader: ") + e.what());
-        }
-      });
+      }
+      catch (const std::exception &e)
+      {
+        std::lock_guard<std::mutex> lock(errorMutex);
+        errors.push_back(std::string("Reader: ") + e.what());
+      }
+    });
 
   // Deleter thread
   threads.emplace_back(
-      [&store, &operationCount, &errors, &errorMutex]()
+    [&store, &operationCount, &errors, &errorMutex]()
+    {
+      try
       {
-        try
-        {
-          std::this_thread::sleep_for(std::chrono::milliseconds(10));  // Let some writes happen first
-          for (int i = 0; i < 25; ++i)
-          {
-            std::string key = "write_" + std::to_string(i * 2);
-            store.remove(key);
-            operationCount++;
-          }
-        }
-        catch (const std::exception& e)
+        std::this_thread::sleep_for(std::chrono::milliseconds(10)); // Let some writes happen first
+        for (int i = 0; i < 25; ++i)
         {
-          std::lock_guard<std::mutex> lock(errorMutex);
-          errors.push_back(std::string("Deleter: ") + e.what());
+          std::string key = "write_" + std::to_string(i * 2);
+          store.remove(key);
+          operationCount++;
         }
-      });
+      }
+      catch (const std::exception &e)
+      {
+        std::lock_guard<std::mutex> lock(errorMutex);
+        errors.push_back(std::string("Deleter: ") + e.what());
+      }
+    });
 
-  for (auto& thread : threads)
+  for (auto &thread : threads)
   {
     thread.join();
   }
@@ -526,7 +527,7 @@ TEST_CASE("KVStore concurrent mixed operations", "[kvstore][concurrency][mixed]"
 // Exception Safety Tests
 TEST_CASE("KVStore handles write failures gracefully", "[kvstore][exceptions][write]")
 {
-  const std::string file = "/dev/null/impossible_path/test.bin";  // Invalid path
+  const std::string file = "/dev/null/impossible_path/test.bin"; // Invalid path
 
   // Should throw during construction when trying to create log file
   REQUIRE_THROWS_AS(KVStore(file), KVStoreException);
@@ -547,7 +548,7 @@ TEST_CASE("KVStore batch operation rollback on failure", "[kvstore][exceptions][
   std::unordered_map<std::string, std::vector<uint8_t>> batch;
   batch["valid1"] = {4, 5, 6};
   batch["valid2"] = {7, 8, 9};
-  batch[""] = {10, 11, 12};  // Invalid empty key
+  batch[""] = {10, 11, 12}; // Invalid empty key
 
   // Batch should fail and not modify store
   REQUIRE_THROWS_AS(store.setBatch(batch), KVStoreException);
@@ -596,7 +597,7 @@ TEST_CASE("KVStore handles maximum value length", "[kvstore][boundary][value]")
   std::string key = "test";
 
   // Test with large but valid value (smaller than max for practical testing)
-  std::vector<uint8_t> largeValue(1024 * 1024, 42);  // 1MB
+  std::vector<uint8_t> largeValue(1024 * 1024, 42); // 1MB
   REQUIRE_NOTHROW(store.set(key, largeValue));
   REQUIRE(store.get(key).value() == largeValue);
 
@@ -641,7 +642,7 @@ TEST_CASE("KVStore stress test with many entries", "[kvstore][stress][large]")
   std::remove((file + ".log").c_str());
 
   KVStoreConfig cfg;
-  cfg.enableBackgroundCompaction = true;  // Test background compaction
+  cfg.enableBackgroundCompaction = true; // Test background compaction
   KVStore store(file, cfg);
 
   const int numEntries = 1000;
@@ -657,7 +658,7 @@ TEST_CASE("KVStore stress test with many entries", "[kvstore][stress][large]")
   }
 
   // Verify all entries
-  for (const auto& [key, expectedValue] : testData)
+  for (const auto &[key, expectedValue] : testData)
   {
     auto actualValue = store.get(key);
     REQUIRE(actualValue.has_value());
@@ -694,7 +695,7 @@ TEST_CASE("KVStore properly cleans up temporary files", "[kvstore][cleanup][temp
   {
     KVStore store(file);
     store.set("test", {1, 2, 3});
-    store.forceCompact();  // This creates and should clean up temp files
+    store.forceCompact(); // This creates and should clean up temp files
   }
 
   // Temporary file should not exist after compaction
@@ -723,7 +724,7 @@ TEST_CASE("KVStore handles shutdown and cleanup", "[kvstore][cleanup][shutdown]"
 
     // Explicit shutdown
     store.shutdown();
-  }  // Destructor should handle cleanup gracefully
+  } // Destructor should handle cleanup gracefully
 
   // Files should exist (data was persisted)
   bool filesExist = std::filesystem::exists(file) || std::filesystem::exists(file + ".log");
@@ -739,7 +740,8 @@ TEST_CASE("KVStore handles shutdown and cleanup", "[kvstore][cleanup][shutdown]"
   std::remove((file + ".log").c_str());
 }
 
-TEST_CASE("KVStore plugin API set/get via IoraService (full integration)", "[kvstore][plugin][api][integration]")
+TEST_CASE("KVStore plugin API set/get via IoraService (full integration)",
+          "[kvstore][plugin][api][integration]")
 {
   // Setup IoraService config
   iora::IoraService::Config config;
@@ -749,10 +751,11 @@ TEST_CASE("KVStore plugin API set/get via IoraService (full integration)", "[kvs
 
   // Initialize service with CLI args
   iora::IoraService::init(config);
-  iora::IoraService& svc = iora::IoraService::instanceRef();
+  iora::IoraService &svc = iora::IoraService::instanceRef();
   iora::IoraService::AutoServiceShutdown autoShutdown(svc);
 
-  auto pluginPathOpt = iora::util::resolveRelativePath(iora::util::getExecutableDir(), "../") + "/mod_kvstore.so";
+  auto pluginPathOpt =
+    iora::util::resolveRelativePath(iora::util::getExecutableDir(), "../") + "/mod_kvstore.so";
   std::cout << "Plugin path: " << pluginPathOpt << std::endl;
   REQUIRE(std::filesystem::exists(pluginPathOpt));
   REQUIRE(svc.loadSingleModule(pluginPathOpt));
@@ -761,8 +764,10 @@ TEST_CASE("KVStore plugin API set/get via IoraService (full integration)", "[kvs
   {
     std::string key = "plugin_key";
     std::vector<uint8_t> value = {42, 43, 44};
-    svc.callExportedApi<void, const std::string&, const std::vector<uint8_t>&>("kvstore.set", key, value);
-    auto got = svc.callExportedApi<std::optional<std::vector<uint8_t>>, const std::string&>("kvstore.get", key);
+    svc.callExportedApi<void, const std::string &, const std::vector<uint8_t> &>("kvstore.set", key,
+                                                                                 value);
+    auto got = svc.callExportedApi<std::optional<std::vector<uint8_t>>, const std::string &>(
+      "kvstore.get", key);
     REQUIRE(got.has_value());
     REQUIRE(got.value() == value);
   }
@@ -771,14 +776,17 @@ TEST_CASE("KVStore plugin API set/get via IoraService (full integration)", "[kvs
   {
     std::string key = "reload_key";
     std::vector<uint8_t> value = {99, 100, 101};
-    svc.callExportedApi<void, const std::string&, const std::vector<uint8_t>&>("kvstore.set", key, value);
+    svc.callExportedApi<void, const std::string &, const std::vector<uint8_t> &>("kvstore.set", key,
+                                                                                 value);
     REQUIRE(svc.unloadSingleModule("mod_kvstore.so"));
     REQUIRE(svc.loadSingleModule(pluginPathOpt));
-    auto got = svc.callExportedApi<std::optional<std::vector<uint8_t>>, const std::string&>("kvstore.get", key);
+    auto got = svc.callExportedApi<std::optional<std::vector<uint8_t>>, const std::string &>(
+      "kvstore.get", key);
     REQUIRE(got.has_value());
     REQUIRE(got.value() == value);
   }
 
   iora::util::removeFilesContainingAny({"ioraservice_kvstore_log", "ioraservice_kvstore_state.json",
-                                        "test_kvstore_plugin_api.bin", "test_kvstore_plugin_api.bin.log"});
+                                        "test_kvstore_plugin_api.bin",
+                                        "test_kvstore_plugin_api.bin.log"});
 }
diff --git a/test_dns_compression.cpp b/test_dns_compression.cpp
index 37aa740..166448d 100644
--- a/test_dns_compression.cpp
+++ b/test_dns_compression.cpp
@@ -4,42 +4,46 @@
 
 using namespace iora::network::dns;
 
-int main() {
-    // Test case from the failing test
-    std::vector<std::uint8_t> maliciousMessage = {
-        // DNS Header (12 bytes)
-        0x12, 0x34,  // Query ID
-        0x81, 0x80,  // Flags: QR=1, OPCODE=0, AA=0, TC=0, RD=1, RA=1, Z=0, RCODE=0
-        0x00, 0x01,  // QDCOUNT=1
-        0x00, 0x01,  // ANCOUNT=1  
-        0x00, 0x00,  // NSCOUNT=0
-        0x00, 0x00,  // ARCOUNT=0
-        
-        // Question section: "test.com" A IN
-        0x04, 't', 'e', 's', 't',  // label "test"
-        0x03, 'c', 'o', 'm',       // label "com"
-        0x00,                      // null terminator
-        0x00, 0x01,               // QTYPE=A
-        0x00, 0x01,               // QCLASS=IN
-        
-        // Answer section with compression pointer loop
-        0xc0, 0x0c,               // NAME: pointer to offset 12 (question name)
-        0x00, 0x01,               // TYPE=A
-        0x00, 0x01,               // CLASS=IN
-        0x00, 0x00, 0x0e, 0x10,   // TTL=3600
-        0x00, 0x04,               // RDLENGTH=4
-        
-        // RDATA with pointer loop: points back to itself
-        0xc0, 0x20,               // Pointer to offset 32 (points to this very pointer!)
-        0x00, 0x00                // Padding to make RDLENGTH=4
-    };
-    
-    try {
-        auto result = DnsMessage::parse(maliciousMessage);
-        std::cout << "Parse succeeded - no exception thrown!" << std::endl;
-        return 1;
-    } catch (const DnsParseException& e) {
-        std::cout << "Parse failed with exception: " << e.what() << std::endl;
-        return 0;
-    }
+int main()
+{
+  // Test case from the failing test
+  std::vector<std::uint8_t> maliciousMessage = {
+    // DNS Header (12 bytes)
+    0x12, 0x34, // Query ID
+    0x81, 0x80, // Flags: QR=1, OPCODE=0, AA=0, TC=0, RD=1, RA=1, Z=0, RCODE=0
+    0x00, 0x01, // QDCOUNT=1
+    0x00, 0x01, // ANCOUNT=1
+    0x00, 0x00, // NSCOUNT=0
+    0x00, 0x00, // ARCOUNT=0
+
+    // Question section: "test.com" A IN
+    0x04, 't', 'e', 's', 't', // label "test"
+    0x03, 'c', 'o', 'm',      // label "com"
+    0x00,                     // null terminator
+    0x00, 0x01,               // QTYPE=A
+    0x00, 0x01,               // QCLASS=IN
+
+    // Answer section with compression pointer loop
+    0xc0, 0x0c,             // NAME: pointer to offset 12 (question name)
+    0x00, 0x01,             // TYPE=A
+    0x00, 0x01,             // CLASS=IN
+    0x00, 0x00, 0x0e, 0x10, // TTL=3600
+    0x00, 0x04,             // RDLENGTH=4
+
+    // RDATA with pointer loop: points back to itself
+    0xc0, 0x20, // Pointer to offset 32 (points to this very pointer!)
+    0x00, 0x00  // Padding to make RDLENGTH=4
+  };
+
+  try
+  {
+    auto result = DnsMessage::parse(maliciousMessage);
+    std::cout << "Parse succeeded - no exception thrown!" << std::endl;
+    return 1;
+  }
+  catch (const DnsParseException &e)
+  {
+    std::cout << "Parse failed with exception: " << e.what() << std::endl;
+    return 0;
+  }
 }
\ No newline at end of file
diff --git a/tests/MockDnsServer.hpp b/tests/MockDnsServer.hpp
index 5078873..1901f8d 100644
--- a/tests/MockDnsServer.hpp
+++ b/tests/MockDnsServer.hpp
@@ -1,5 +1,5 @@
 //  Joegen Baclor. All rights reserved.
-// Unauthorized use, reproduction, distribution, or modification 
+// Unauthorized use, reproduction, distribution, or modification
 // of this library in any form is strictly prohibited.
 
 /// \file MockDnsServer.hpp
@@ -19,19 +19,19 @@
 #include <chrono>
 #include <condition_variable>
 #include <functional>
+#include <memory>
 #include <mutex>
+#include <queue>
+#include <random>
+#include <sstream>
 #include <string>
 #include <thread>
 #include <unordered_map>
 #include <vector>
-#include <memory>
-#include <random>
-#include <sstream>
-#include <queue>
 
-#include <sys/socket.h>
-#include <netinet/in.h>
 #include <arpa/inet.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
 #include <unistd.h>
 
 /// \brief Advanced mock DNS server for comprehensive testing
@@ -39,41 +39,41 @@ class MockDnsServer
 {
 public:
   /// \brief DNS wire-format response data
-  struct WireResponse 
+  struct WireResponse
   {
     std::vector<std::uint8_t> data;
-    bool isTruncated{false};               // Set TC bit for UDP responses
-    bool forceInvalidCompression{false};   // Inject malicious compression
-    std::chrono::milliseconds delay{0};    // Response delay
-    bool shouldTimeout{false};             // Force timeout
-    bool shouldDrop{false};               // Drop packet (no response)
+    bool isTruncated{false};             // Set TC bit for UDP responses
+    bool forceInvalidCompression{false}; // Inject malicious compression
+    std::chrono::milliseconds delay{0};  // Response delay
+    bool shouldTimeout{false};           // Force timeout
+    bool shouldDrop{false};              // Drop packet (no response)
   };
-  
+
   /// \brief TCP frame fragmentation control
   struct TcpFragmentation
   {
-    std::vector<std::vector<std::uint8_t>> fragments;  // Ordered fragments
-    std::vector<std::chrono::milliseconds> delays;     // Delay between fragments  
-    bool incomplete{false};                            // Leave final fragment unset
+    std::vector<std::vector<std::uint8_t>> fragments; // Ordered fragments
+    std::vector<std::chrono::milliseconds> delays;    // Delay between fragments
+    bool incomplete{false};                           // Leave final fragment unset
   };
 
   /// \brief DNS query record for structured responses (legacy compatibility)
   struct DnsRecord
   {
     std::string name;
-    std::string type;  // A, AAAA, SRV, NAPTR, SOA, CNAME, MX, TXT
+    std::string type; // A, AAAA, SRV, NAPTR, SOA, CNAME, MX, TXT
     std::string value;
     std::uint32_t ttl{3600};
-    std::uint16_t priority{0};  // For SRV/MX records
-    std::uint16_t weight{0};    // For SRV records
-    std::uint16_t port{5060};   // For SRV records
-    
+    std::uint16_t priority{0}; // For SRV/MX records
+    std::uint16_t weight{0};   // For SRV records
+    std::uint16_t port{5060};  // For SRV records
+
     // SOA-specific fields for negative caching tests
-    std::string mname;          // SOA primary nameserver
-    std::string rname;          // SOA responsible person
-    std::uint32_t serial{1};    // SOA serial
-    std::uint32_t refresh{3600}; // SOA refresh
-    std::uint32_t retry{1800};  // SOA retry  
+    std::string mname;            // SOA primary nameserver
+    std::string rname;            // SOA responsible person
+    std::uint32_t serial{1};      // SOA serial
+    std::uint32_t refresh{3600};  // SOA refresh
+    std::uint32_t retry{1800};    // SOA retry
     std::uint32_t expire{604800}; // SOA expire
     std::uint32_t minimum{86400}; // SOA minimum (negative cache TTL)
   };
@@ -81,42 +81,42 @@ public:
   /// \brief Query behavior configuration
   struct QueryConfig
   {
-    std::chrono::milliseconds delay{0};          // Network delay simulation
-    bool shouldFail{false};                     // Force query failure
-    bool shouldTimeout{false};                  // Force query timeout
-    bool shouldTruncate{false};                // Force UDP truncation (TC=1)
-    bool shouldFragmentTcp{false};             // Fragment TCP response
-    bool useWireFormat{false};                 // Use raw wire response
-    bool enableCompression{true};              // Enable name compression
-    bool injectMaliciousPointers{false};       // Test pointer loop handling
-    std::string errorMessage;                  // Custom error message
+    std::chrono::milliseconds delay{0};  // Network delay simulation
+    bool shouldFail{false};              // Force query failure
+    bool shouldTimeout{false};           // Force query timeout
+    bool shouldTruncate{false};          // Force UDP truncation (TC=1)
+    bool shouldFragmentTcp{false};       // Fragment TCP response
+    bool useWireFormat{false};           // Use raw wire response
+    bool enableCompression{true};        // Enable name compression
+    bool injectMaliciousPointers{false}; // Test pointer loop handling
+    std::string errorMessage;            // Custom error message
   };
 
-  /// \brief RNG hook for deterministic testing  
+  /// \brief RNG hook for deterministic testing
   using RngHook = std::function<std::uint32_t()>;
-  
+
   /// \brief Mock DNS server configuration
   struct Config
   {
-    std::uint16_t udpPort{5353};                      // UDP server port
-    std::uint16_t tcpPort{5353};                      // TCP server port  
-    std::chrono::milliseconds defaultDelay{10};       // Default query delay
-    std::chrono::milliseconds queryTimeout{5000};     // Query timeout
-    bool enableLogging{false};                        // Enable query logging
-    bool enableUdp{true};                             // Enable UDP server
-    bool enableTcp{true};                             // Enable TCP server
-    std::size_t maxUdpSize{512};                      // Max UDP response size
-    std::size_t maxTcpFragmentSize{64};               // TCP fragment size for testing
+    std::uint16_t udpPort{5353};                  // UDP server port
+    std::uint16_t tcpPort{5353};                  // TCP server port
+    std::chrono::milliseconds defaultDelay{10};   // Default query delay
+    std::chrono::milliseconds queryTimeout{5000}; // Query timeout
+    bool enableLogging{false};                    // Enable query logging
+    bool enableUdp{true};                         // Enable UDP server
+    bool enableTcp{true};                         // Enable TCP server
+    std::size_t maxUdpSize{512};                  // Max UDP response size
+    std::size_t maxTcpFragmentSize{64};           // TCP fragment size for testing
   };
 
 private:
   Config config_;
   std::atomic<bool> running_{false};
-  
+
   // Server threads
   std::thread udpServerThread_;
   std::thread tcpServerThread_;
-  
+
   // Socket handles
   int udpSocket_{-1};
   int tcpSocket_{-1};
@@ -134,34 +134,31 @@ private:
   std::atomic<std::uint64_t> udpQueryCount_{0};
   std::atomic<std::uint64_t> tcpQueryCount_{0};
   std::atomic<std::uint64_t> truncatedCount_{0};
-  
+
   // RNG control for testing
   mutable std::mutex rngMutex_;
   RngHook rngHook_;
   mutable std::mt19937 defaultRng_;
-  
+
   // Name compression dictionary for wire format responses
   mutable std::unordered_map<std::string, std::uint16_t> compressionTable_;
 
 public:
   MockDnsServer() : config_({}), defaultRng_(std::random_device{}()) {}
-  
-  explicit MockDnsServer(const Config& config) 
-    : config_(config), defaultRng_(std::random_device{}()) 
-  {
-  }
 
-  ~MockDnsServer()
+  explicit MockDnsServer(const Config &config)
+      : config_(config), defaultRng_(std::random_device{}())
   {
-    stop();
   }
 
+  ~MockDnsServer() { stop(); }
+
   /// \brief Start the mock DNS server with real UDP/TCP sockets
   bool start()
   {
     if (running_.exchange(true))
     {
-      return false;  // Already running
+      return false; // Already running
     }
 
     try
@@ -171,7 +168,7 @@ public:
         startUdpServer();
         udpServerThread_ = std::thread([this]() { udpServerLoop(); });
       }
-      
+
       if (config_.enableTcp)
       {
         startTcpServer();
@@ -180,16 +177,16 @@ public:
 
       // Wait for servers to initialize
       std::this_thread::sleep_for(std::chrono::milliseconds(100));
-      
+
       if (config_.enableLogging)
       {
-        logQuery("MockDnsServer started - UDP:" + std::to_string(config_.udpPort) + 
-                " TCP:" + std::to_string(config_.tcpPort));
+        logQuery("MockDnsServer started - UDP:" + std::to_string(config_.udpPort) +
+                 " TCP:" + std::to_string(config_.tcpPort));
       }
-      
+
       return true;
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       running_.store(false);
       if (config_.enableLogging)
@@ -212,7 +209,7 @@ public:
         close(udpSocket_);
         udpSocket_ = -1;
       }
-      
+
       if (tcpSocket_ >= 0)
       {
         shutdown(tcpSocket_, SHUT_RDWR); // Force wake up accept
@@ -228,7 +225,7 @@ public:
       {
         udpServerThread_.join();
       }
-      
+
       if (tcpServerThread_.joinable())
       {
         tcpServerThread_.join();
@@ -242,38 +239,38 @@ public:
   }
 
   /// \brief Set wire-format response for a query name
-  void setWireResponse(const std::string& name, const WireResponse& response)
+  void setWireResponse(const std::string &name, const WireResponse &response)
   {
     std::lock_guard<std::mutex> lock(recordsMutex_);
     wireResponses_[name] = response;
   }
 
-  /// \brief Set TCP fragmentation for a query name  
-  void setTcpFragmentation(const std::string& name, const TcpFragmentation& fragmentation)
+  /// \brief Set TCP fragmentation for a query name
+  void setTcpFragmentation(const std::string &name, const TcpFragmentation &fragmentation)
   {
     std::lock_guard<std::mutex> lock(recordsMutex_);
     tcpFragments_[name] = fragmentation;
   }
 
   /// \brief Add a DNS record
-  void addRecord(const DnsRecord& record)
+  void addRecord(const DnsRecord &record)
   {
     std::lock_guard<std::mutex> lock(recordsMutex_);
     records_[record.name].push_back(record);
   }
 
   /// \brief Add multiple DNS records for a name
-  void addRecords(const std::string& name, const std::vector<DnsRecord>& recordList)
+  void addRecords(const std::string &name, const std::vector<DnsRecord> &recordList)
   {
     std::lock_guard<std::mutex> lock(recordsMutex_);
-    for (const auto& record : recordList)
+    for (const auto &record : recordList)
     {
       records_[name].push_back(record);
     }
   }
 
   /// \brief Configure query behavior for a specific name
-  void configureQuery(const std::string& name, const QueryConfig& config)
+  void configureQuery(const std::string &name, const QueryConfig &config)
   {
     std::lock_guard<std::mutex> lock(recordsMutex_);
     queryConfigs_[name] = config;
@@ -328,7 +325,7 @@ public:
     stats.tcpQueries = tcpQueryCount_.load();
     stats.truncatedResponses = truncatedCount_.load();
 
-    for (const auto& pair : records_)
+    for (const auto &pair : records_)
     {
       stats.totalRecords += pair.second.size();
     }
@@ -336,7 +333,7 @@ public:
     return stats;
   }
 
-  // =============================================================================  
+  // =============================================================================
   // Test Setup Helpers
   // =============================================================================
 
@@ -367,8 +364,9 @@ public:
     // Truncated UDP response that triggers TCP fallback
     WireResponse truncatedResponse;
     truncatedResponse.isTruncated = true;
-    truncatedResponse.data = generateWireResponse("truncated.example.com", 1, 
-      {{"truncated.example.com", "A", "192.168.1.100", 3600}}, true, false);
+    truncatedResponse.data =
+      generateWireResponse("truncated.example.com", 1,
+                           {{"truncated.example.com", "A", "192.168.1.100", 3600}}, true, false);
     setWireResponse("truncated.example.com", truncatedResponse);
 
     // Response with malicious compression pointers
@@ -390,16 +388,16 @@ public:
 
     // TCP fragmentation test
     TcpFragmentation fragmentation;
-    auto fullResponse = generateWireResponse("fragmented.example.com", 1,
-      {{"fragmented.example.com", "A", "192.168.1.200", 3600}}, true, false);
-    
+    auto fullResponse =
+      generateWireResponse("fragmented.example.com", 1,
+                           {{"fragmented.example.com", "A", "192.168.1.200", 3600}}, true, false);
+
     // Split into small fragments
     size_t fragmentSize = config_.maxTcpFragmentSize;
     for (size_t i = 0; i < fullResponse.size(); i += fragmentSize)
     {
       size_t size = std::min(fragmentSize, fullResponse.size() - i);
-      std::vector<std::uint8_t> fragment(fullResponse.begin() + i, 
-                                        fullResponse.begin() + i + size);
+      std::vector<std::uint8_t> fragment(fullResponse.begin() + i, fullResponse.begin() + i + size);
       fragmentation.fragments.push_back(fragment);
       fragmentation.delays.push_back(std::chrono::milliseconds(10));
     }
@@ -410,7 +408,7 @@ private:
   // =============================================================================
   // Server Implementation
   // =============================================================================
-  
+
   void startUdpServer()
   {
     udpSocket_ = socket(AF_INET, SOCK_DGRAM, 0);
@@ -428,10 +426,11 @@ private:
     addr.sin_addr.s_addr = INADDR_ANY;
     addr.sin_port = htons(config_.udpPort);
 
-    if (bind(udpSocket_, (struct sockaddr*)&addr, sizeof(addr)) < 0)
+    if (bind(udpSocket_, (struct sockaddr *)&addr, sizeof(addr)) < 0)
     {
       close(udpSocket_);
-      throw std::runtime_error("Failed to bind UDP socket to port " + std::to_string(config_.udpPort));
+      throw std::runtime_error("Failed to bind UDP socket to port " +
+                               std::to_string(config_.udpPort));
     }
   }
 
@@ -452,10 +451,11 @@ private:
     addr.sin_addr.s_addr = INADDR_ANY;
     addr.sin_port = htons(config_.tcpPort);
 
-    if (bind(tcpSocket_, (struct sockaddr*)&addr, sizeof(addr)) < 0)
+    if (bind(tcpSocket_, (struct sockaddr *)&addr, sizeof(addr)) < 0)
     {
       close(tcpSocket_);
-      throw std::runtime_error("Failed to bind TCP socket to port " + std::to_string(config_.tcpPort));
+      throw std::runtime_error("Failed to bind TCP socket to port " +
+                               std::to_string(config_.tcpPort));
     }
 
     if (listen(tcpSocket_, 5) < 0)
@@ -474,8 +474,8 @@ private:
     while (running_)
     {
       ssize_t received = recvfrom(udpSocket_, buffer.data(), buffer.size(), 0,
-                                 (struct sockaddr*)&clientAddr, &clientLen);
-      
+                                  (struct sockaddr *)&clientAddr, &clientLen);
+
       if (received < 0)
       {
         if (running_) // Only log if not shutting down
@@ -489,25 +489,25 @@ private:
       }
 
       udpQueryCount_++;
-      
+
       // Process DNS query and send response
       auto response = processDnsQuery(buffer.data(), received, false);
       if (!response.empty())
       {
-        sendto(udpSocket_, response.data(), response.size(), 0,
-               (struct sockaddr*)&clientAddr, clientLen);
+        sendto(udpSocket_, response.data(), response.size(), 0, (struct sockaddr *)&clientAddr,
+               clientLen);
       }
     }
   }
 
-  void tcpServerLoop() 
+  void tcpServerLoop()
   {
     while (running_)
     {
       struct sockaddr_in clientAddr{};
       socklen_t clientLen = sizeof(clientAddr);
-      
-      int clientSocket = accept(tcpSocket_, (struct sockaddr*)&clientAddr, &clientLen);
+
+      int clientSocket = accept(tcpSocket_, (struct sockaddr *)&clientAddr, &clientLen);
       if (clientSocket < 0)
       {
         if (running_) // Only log if not shutting down
@@ -521,9 +521,7 @@ private:
       }
 
       // Handle TCP client in separate thread to support concurrent connections
-      std::thread([this, clientSocket]() {
-        handleTcpClient(clientSocket);
-      }).detach();
+      std::thread([this, clientSocket]() { handleTcpClient(clientSocket); }).detach();
     }
   }
 
@@ -553,17 +551,15 @@ private:
 
     tcpQueryCount_++;
 
-    // Process query and send response  
+    // Process query and send response
     auto response = processDnsQuery(queryBuffer.data(), messageLength, true);
     if (!response.empty())
     {
       // Send length-prefixed response
       std::uint16_t responseLength = response.size();
-      std::uint8_t lengthPrefix[2] = {
-        static_cast<std::uint8_t>(responseLength >> 8),
-        static_cast<std::uint8_t>(responseLength & 0xFF)
-      };
-      
+      std::uint8_t lengthPrefix[2] = {static_cast<std::uint8_t>(responseLength >> 8),
+                                      static_cast<std::uint8_t>(responseLength & 0xFF)};
+
       send(clientSocket, lengthPrefix, 2, 0);
       send(clientSocket, response.data(), response.size(), 0);
     }
@@ -572,35 +568,38 @@ private:
   }
 
   // =============================================================================
-  // DNS Message Processing 
+  // DNS Message Processing
   // =============================================================================
 
-  std::vector<std::uint8_t> processDnsQuery(const std::uint8_t* data, size_t length, bool isTcp)
+  std::vector<std::uint8_t> processDnsQuery(const std::uint8_t *data, size_t length, bool isTcp)
   {
     // Parse query (simplified - extract question name and type)
-    if (length < 12) return {}; // Invalid DNS header
-    
+    if (length < 12)
+      return {}; // Invalid DNS header
+
     // Extract query ID
     std::uint16_t queryId = (data[0] << 8) | data[1];
-    
-    // Parse question section 
+
+    // Parse question section
     size_t nameEndPos = 0;
     std::string questionName = parseQuestionName(data + 12, length - 12, &nameEndPos);
-    
+
     if (questionName.empty())
     {
       return {};
     }
-    
+
     // Extract query type (QTYPE) - it's right after the name
     size_t qtypePos = 12 + nameEndPos;
-    if (qtypePos + 4 > length) return {}; // Need 4 bytes for QTYPE + QCLASS
-    
+    if (qtypePos + 4 > length)
+      return {}; // Need 4 bytes for QTYPE + QCLASS
+
     std::uint16_t queryType = (data[qtypePos] << 8) | data[qtypePos + 1];
 
     if (config_.enableLogging)
     {
-      logQuery("DNS query: " + questionName + " type=" + std::to_string(queryType) + " via " + (isTcp ? "TCP" : "UDP"));
+      logQuery("DNS query: " + questionName + " type=" + std::to_string(queryType) + " via " +
+               (isTcp ? "TCP" : "UDP"));
     }
 
     // Check for configured wire response
@@ -609,28 +608,28 @@ private:
       auto wireIt = wireResponses_.find(questionName);
       if (wireIt != wireResponses_.end())
       {
-        const auto& wireResponse = wireIt->second;
-        
+        const auto &wireResponse = wireIt->second;
+
         // Apply delay if configured
         if (wireResponse.delay.count() > 0)
         {
           std::this_thread::sleep_for(wireResponse.delay);
         }
-        
+
         if (wireResponse.shouldTimeout || wireResponse.shouldDrop)
         {
           return {}; // No response
         }
 
         auto response = wireResponse.data;
-        
+
         // Set correct query ID
         if (response.size() >= 2)
         {
           response[0] = static_cast<std::uint8_t>(queryId >> 8);
           response[1] = static_cast<std::uint8_t>(queryId & 0xFF);
         }
-        
+
         // Handle truncation for UDP
         if (!isTcp && wireResponse.isTruncated)
         {
@@ -645,24 +644,24 @@ private:
             response.resize(config_.maxUdpSize);
           }
         }
-        
+
         return response;
       }
-      
+
       // Check for TCP fragmentation
       if (isTcp)
       {
         auto fragIt = tcpFragments_.find(questionName);
         if (fragIt != tcpFragments_.end())
         {
-          // For now, return full response - fragmentation would be handled 
+          // For now, return full response - fragmentation would be handled
           // at the socket send level in a real implementation
-          const auto& frag = fragIt->second;
+          const auto &frag = fragIt->second;
           if (!frag.fragments.empty())
           {
             // Combine all fragments
             std::vector<std::uint8_t> combined;
-            for (const auto& fragment : frag.fragments)
+            for (const auto &fragment : frag.fragments)
             {
               combined.insert(combined.end(), fragment.begin(), fragment.end());
             }
@@ -670,25 +669,25 @@ private:
           }
         }
       }
-      
+
       // Check for query-specific configuration (timeout, failure, etc.)
       auto configIt = queryConfigs_.find(questionName);
       if (configIt != queryConfigs_.end())
       {
-        const auto& queryConfig = configIt->second;
-        
+        const auto &queryConfig = configIt->second;
+
         // Handle timeout (no response)
         if (queryConfig.shouldTimeout)
         {
           return {}; // No response (simulates timeout)
         }
-        
+
         // Handle server failure (return SERVFAIL response)
         if (queryConfig.shouldFail)
         {
           return generateServfailResponse(queryId, questionName, queryType);
         }
-        
+
         // Apply delay only for successful responses
         if (queryConfig.delay.count() > 0)
         {
@@ -697,38 +696,44 @@ private:
       }
     }
 
-    // Fallback to structured record responses  
+    // Fallback to structured record responses
     return generateStructuredResponse(queryId, questionName, queryType);
   }
 
-  std::string parseQuestionName(const std::uint8_t* data, size_t length, size_t* endPos = nullptr)
+  std::string parseQuestionName(const std::uint8_t *data, size_t length, size_t *endPos = nullptr)
   {
     // Simple DNS name parsing (no compression handling for queries)
     std::string name;
     size_t pos = 0;
-    
+
     while (pos < length)
     {
       std::uint8_t labelLen = data[pos++];
-      if (labelLen == 0) {
-        if (endPos) *endPos = pos; // Set end position after null terminator
-        break; // End of name
+      if (labelLen == 0)
+      {
+        if (endPos)
+          *endPos = pos; // Set end position after null terminator
+        break;           // End of name
       }
-      
-      if (pos + labelLen > length) return ""; // Invalid
-      
-      if (!name.empty()) name += ".";
-      name += std::string(reinterpret_cast<const char*>(data + pos), labelLen);
+
+      if (pos + labelLen > length)
+        return ""; // Invalid
+
+      if (!name.empty())
+        name += ".";
+      name += std::string(reinterpret_cast<const char *>(data + pos), labelLen);
       pos += labelLen;
     }
-    
+
     return name;
   }
 
-  std::vector<std::uint8_t> generateStructuredResponse(std::uint16_t queryId, const std::string& questionName, std::uint16_t queryType)
+  std::vector<std::uint8_t> generateStructuredResponse(std::uint16_t queryId,
+                                                       const std::string &questionName,
+                                                       std::uint16_t queryType)
   {
     std::lock_guard<std::mutex> lock(recordsMutex_);
-    
+
     auto recordIt = records_.find(questionName);
     if (recordIt == records_.end())
     {
@@ -736,58 +741,81 @@ private:
     }
 
     // Filter records by type
-    const auto& allRecords = recordIt->second;
+    const auto &allRecords = recordIt->second;
     std::vector<DnsRecord> filteredRecords;
-    
+
     // Map query type to record type string
     std::string typeStr;
-    switch (queryType) {
-      case 1: typeStr = "A"; break;
-      case 28: typeStr = "AAAA"; break;
-      case 33: typeStr = "SRV"; break;
-      case 5: typeStr = "CNAME"; break;
-      case 15: typeStr = "MX"; break;
-      default: typeStr = ""; break;
+    switch (queryType)
+    {
+    case 1:
+      typeStr = "A";
+      break;
+    case 28:
+      typeStr = "AAAA";
+      break;
+    case 33:
+      typeStr = "SRV";
+      break;
+    case 5:
+      typeStr = "CNAME";
+      break;
+    case 15:
+      typeStr = "MX";
+      break;
+    default:
+      typeStr = "";
+      break;
     }
-    
+
     // Only include records matching the query type
-    for (const auto& record : allRecords) {
-      if (record.type == typeStr) {
+    for (const auto &record : allRecords)
+    {
+      if (record.type == typeStr)
+      {
         filteredRecords.push_back(record);
       }
     }
-    
-    if (filteredRecords.empty()) {
+
+    if (filteredRecords.empty())
+    {
       return generateNxdomainResponse(queryId, questionName, queryType);
     }
-    
+
     return generateWireResponse(questionName, queryType, filteredRecords, true, false, queryId);
   }
 
-  std::vector<std::uint8_t> generateNxdomainResponse(std::uint16_t queryId, const std::string& questionName, std::uint16_t queryType = 1)
+  std::vector<std::uint8_t> generateNxdomainResponse(std::uint16_t queryId,
+                                                     const std::string &questionName,
+                                                     std::uint16_t queryType = 1)
   {
     // Generate NXDOMAIN response with SOA record
     std::vector<std::uint8_t> response;
-    
+
     // DNS header (12 bytes)
     response.resize(12);
     response[0] = static_cast<std::uint8_t>(queryId >> 8);
     response[1] = static_cast<std::uint8_t>(queryId & 0xFF);
     response[2] = 0x81; // Response, recursion desired
     response[3] = 0x83; // NXDOMAIN
-    
+
     // Question count = 1, Answer count = 0, Authority count = 1, Additional = 0
-    response[4] = 0; response[5] = 1; // QDCOUNT
-    response[6] = 0; response[7] = 0; // ANCOUNT  
-    response[8] = 0; response[9] = 1; // NSCOUNT
-    response[10] = 0; response[11] = 0; // ARCOUNT
-    
+    response[4] = 0;
+    response[5] = 1; // QDCOUNT
+    response[6] = 0;
+    response[7] = 0; // ANCOUNT
+    response[8] = 0;
+    response[9] = 1; // NSCOUNT
+    response[10] = 0;
+    response[11] = 0; // ARCOUNT
+
     // Question section - echo back the exact query
     encodeQuestionName(response, questionName);
-    response.push_back((queryType >> 8) & 0xFF);  // QTYPE high byte
-    response.push_back(queryType & 0xFF);         // QTYPE low byte
-    response.push_back(0); response.push_back(1); // CLASS IN
-    
+    response.push_back((queryType >> 8) & 0xFF); // QTYPE high byte
+    response.push_back(queryType & 0xFF);        // QTYPE low byte
+    response.push_back(0);
+    response.push_back(1); // CLASS IN
+
     // Authority section with SOA
     DnsRecord soaRecord;
     soaRecord.type = "SOA";
@@ -795,46 +823,53 @@ private:
     soaRecord.mname = "ns1.example.com";
     soaRecord.rname = "admin.example.com";
     soaRecord.minimum = 3600;
-    
+
     auto soaData = generateSoaResponse(questionName, soaRecord);
     response.insert(response.end(), soaData.begin() + 12, soaData.end()); // Skip header
-    
+
     return response;
   }
 
-  std::vector<std::uint8_t> generateServfailResponse(std::uint16_t queryId, const std::string& questionName, std::uint16_t queryType = 1)
+  std::vector<std::uint8_t> generateServfailResponse(std::uint16_t queryId,
+                                                     const std::string &questionName,
+                                                     std::uint16_t queryType = 1)
   {
     // Generate SERVFAIL response (similar to NXDOMAIN but with different error code)
     std::vector<std::uint8_t> response;
-    
+
     // DNS header (12 bytes)
     response.resize(12);
     response[0] = static_cast<std::uint8_t>(queryId >> 8);
     response[1] = static_cast<std::uint8_t>(queryId & 0xFF);
     response[2] = 0x81; // Response, recursion desired
     response[3] = 0x82; // SERVFAIL (0x80 | 0x02)
-    
+
     // Question count = 1, Answer count = 0, Authority count = 0, Additional = 0
-    response[4] = 0; response[5] = 1; // QDCOUNT
-    response[6] = 0; response[7] = 0; // ANCOUNT  
-    response[8] = 0; response[9] = 0; // NSCOUNT (no authority section for SERVFAIL)
-    response[10] = 0; response[11] = 0; // ARCOUNT
-    
+    response[4] = 0;
+    response[5] = 1; // QDCOUNT
+    response[6] = 0;
+    response[7] = 0; // ANCOUNT
+    response[8] = 0;
+    response[9] = 0; // NSCOUNT (no authority section for SERVFAIL)
+    response[10] = 0;
+    response[11] = 0; // ARCOUNT
+
     // Add question section
     encodeQuestionName(response, questionName);
     response.push_back(static_cast<std::uint8_t>(queryType >> 8));
     response.push_back(static_cast<std::uint8_t>(queryType & 0xFF));
-    response.push_back(0x00); response.push_back(0x01); // Class IN
-    
+    response.push_back(0x00);
+    response.push_back(0x01); // Class IN
+
     return response;
   }
 
-  void encodeQuestionName(std::vector<std::uint8_t>& buffer, const std::string& name)
+  void encodeQuestionName(std::vector<std::uint8_t> &buffer, const std::string &name)
   {
     // Simple DNS name encoding
     std::istringstream iss(name);
     std::string label;
-    
+
     while (std::getline(iss, label, '.'))
     {
       buffer.push_back(static_cast<std::uint8_t>(label.length()));
@@ -843,63 +878,61 @@ private:
     buffer.push_back(0); // End of name
   }
 
-  void logQuery(const std::string& query) const
+  void logQuery(const std::string &query) const
   {
-    if (!config_.enableLogging) return;
-    
+    if (!config_.enableLogging)
+      return;
+
     std::lock_guard<std::mutex> lock(logMutex_);
     queryLog_.push_back(query);
   }
-  
+
   // =============================================================================
   // Wire Format Generation (Method Stubs - To Be Implemented)
   // =============================================================================
-  
-  std::vector<std::uint8_t> generateWireResponse(
-    const std::string& queryName,
-    std::uint16_t queryType,
-    const std::vector<DnsRecord>& records,
-    bool enableCompression,
-    bool injectMaliciousPointers,
-    std::uint16_t queryId = 0x1234)
+
+  std::vector<std::uint8_t>
+  generateWireResponse(const std::string &queryName, std::uint16_t queryType,
+                       const std::vector<DnsRecord> &records, bool enableCompression,
+                       bool injectMaliciousPointers, std::uint16_t queryId = 0x1234)
   {
     std::vector<std::uint8_t> response;
-    
+
     // DNS Header (12 bytes)
     response.resize(12);
-    
+
     // Transaction ID (from query)
     response[0] = (queryId >> 8) & 0xFF;
     response[1] = queryId & 0xFF;
-    
+
     // Flags: QR=1 (response), AA=1 (authoritative), RD=1 (recursion desired)
-    response[2] = 0x85; // 10000101 
+    response[2] = 0x85; // 10000101
     response[3] = 0x00; // No errors (RCODE = 0)
-    
+
     // Question count
-    response[4] = 0; 
+    response[4] = 0;
     response[5] = 1;
-    
+
     // Answer count
-    response[6] = 0; 
+    response[6] = 0;
     response[7] = static_cast<std::uint8_t>(records.size());
-    
+
     // Authority and Additional counts (0)
     response[8] = response[9] = response[10] = response[11] = 0;
-    
+
     // Question Section
     encodeQuestionName(response, queryName);
-    
+
     // QTYPE (2 bytes)
     response.push_back((queryType >> 8) & 0xFF);
     response.push_back(queryType & 0xFF);
-    
+
     // QCLASS (2 bytes) - IN = 1
     response.push_back(0x00);
     response.push_back(0x01);
-    
+
     // Answer Section
-    for (const auto& record : records)
+    for (const auto &record : records)
     {
       // NAME - use compression pointer to question if same name
       if (enableCompression && record.name == queryName)
@@ -911,35 +944,39 @@ private:
       {
         encodeQuestionName(response, record.name);
       }
-      
+
       // TYPE
       std::uint16_t recordType = 1; // A record
-      if (record.type == "AAAA") recordType = 28;
-      else if (record.type == "CNAME") recordType = 5;
-      else if (record.type == "MX") recordType = 15;
-      else if (record.type == "SRV") recordType = 33;
-      
+      if (record.type == "AAAA")
+        recordType = 28;
+      else if (record.type == "CNAME")
+        recordType = 5;
+      else if (record.type == "MX")
+        recordType = 15;
+      else if (record.type == "SRV")
+        recordType = 33;
+
       response.push_back((recordType >> 8) & 0xFF);
       response.push_back(recordType & 0xFF);
-      
+
       // CLASS (IN = 1)
       response.push_back(0x00);
       response.push_back(0x01);
-      
+
       // TTL (4 bytes)
       std::uint32_t ttl = record.ttl;
       response.push_back((ttl >> 24) & 0xFF);
       response.push_back((ttl >> 16) & 0xFF);
       response.push_back((ttl >> 8) & 0xFF);
       response.push_back(ttl & 0xFF);
-      
+
       // RDLENGTH and RDATA
       if (record.type == "A")
       {
         // IPv4 address (4 bytes)
         response.push_back(0x00);
         response.push_back(0x04); // RDLENGTH = 4
-        
+
         // Parse IP address
         std::istringstream iss(record.value);
         std::string octet;
@@ -953,23 +990,25 @@ private:
         // IPv6 address (16 bytes)
         response.push_back(0x00);
         response.push_back(0x10); // RDLENGTH = 16
-        
+
         // Parse IPv6 address (simplified - hardcode common test addresses)
-        if (record.value == "2001:db8::1") {
-          std::vector<std::uint8_t> ipv6 = {
-            0x20, 0x01, 0x0d, 0xb8, 0x00, 0x00, 0x00, 0x00,
-            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
-          };
+        if (record.value == "2001:db8::1")
+        {
+          std::vector<std::uint8_t> ipv6 = {0x20, 0x01, 0x0d, 0xb8, 0x00, 0x00, 0x00, 0x00,
+                                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
           response.insert(response.end(), ipv6.begin(), ipv6.end());
-        } else if (record.value == "2001:db8::2") {
-          std::vector<std::uint8_t> ipv6 = {
-            0x20, 0x01, 0x0d, 0xb8, 0x00, 0x00, 0x00, 0x00,
-            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
-          };
+        }
+        else if (record.value == "2001:db8::2")
+        {
+          std::vector<std::uint8_t> ipv6 = {0x20, 0x01, 0x0d, 0xb8, 0x00, 0x00, 0x00, 0x00,
+                                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02};
           response.insert(response.end(), ipv6.begin(), ipv6.end());
-        } else {
+        }
+        else
+        {
           // Fallback for other IPv6 addresses - zero address
-          for (int i = 0; i < 16; i++) {
+          for (int i = 0; i < 16; i++)
+          {
             response.push_back(0x00);
           }
         }
@@ -978,26 +1017,26 @@ private:
       {
         // SRV record: Priority(2) + Weight(2) + Port(2) + Target(variable)
         std::size_t rdlengthPos = response.size(); // Position of RDLENGTH field
-        response.push_back(0x00); // RDLENGTH high byte (placeholder)
-        response.push_back(0x00); // RDLENGTH low byte (placeholder)
-        
+        response.push_back(0x00);                  // RDLENGTH high byte (placeholder)
+        response.push_back(0x00);                  // RDLENGTH low byte (placeholder)
+
         std::size_t rdataStart = response.size(); // Start of actual RDATA
-        
+
         // Priority (2 bytes)
         response.push_back((record.priority >> 8) & 0xFF);
         response.push_back(record.priority & 0xFF);
-        
+
         // Weight (2 bytes)
         response.push_back((record.weight >> 8) & 0xFF);
         response.push_back(record.weight & 0xFF);
-        
+
         // Port (2 bytes)
         response.push_back((record.port >> 8) & 0xFF);
         response.push_back(record.port & 0xFF);
-        
+
         // Target name
         encodeQuestionName(response, record.value);
-        
+
         // Update RDLENGTH
         std::size_t rdataLength = response.size() - rdataStart;
         response[rdlengthPos] = (rdataLength >> 8) & 0xFF;
@@ -1007,122 +1046,125 @@ private:
       {
         // For other record types, encode as name
         std::size_t rdlengthPos = response.size(); // Position of RDLENGTH field
-        response.push_back(0x00); // RDLENGTH high byte (placeholder)
-        response.push_back(0x00); // RDLENGTH low byte (placeholder)
-        
+        response.push_back(0x00);                  // RDLENGTH high byte (placeholder)
+        response.push_back(0x00);                  // RDLENGTH low byte (placeholder)
+
         std::size_t rdataStart = response.size(); // Start of actual RDATA
-        
+
         encodeQuestionName(response, record.value);
-        
+
         // Update RDLENGTH
         std::size_t rdataLength = response.size() - rdataStart;
         response[rdlengthPos] = (rdataLength >> 8) & 0xFF;
         response[rdlengthPos + 1] = rdataLength & 0xFF;
       }
     }
-    
+
     return response;
   }
 
-  std::vector<std::uint8_t> generateSoaResponse(const std::string& domain, const DnsRecord& soaRecord)
+  std::vector<std::uint8_t> generateSoaResponse(const std::string &domain,
+                                                const DnsRecord &soaRecord)
   {
     std::vector<std::uint8_t> response;
     response.resize(12); // DNS header placeholder
-    
+
     // Authority record: NAME + TYPE + CLASS + TTL + RDLENGTH + RDATA
-    
+
     // NAME (use compression pointer to question or encode full name)
     encodeQuestionName(response, domain);
-    
+
     // TYPE: SOA = 6
     response.push_back(0x00);
     response.push_back(0x06);
-    
+
     // CLASS: IN = 1
     response.push_back(0x00);
     response.push_back(0x01);
-    
+
     // TTL (4 bytes)
     std::uint32_t ttl = soaRecord.ttl;
     response.push_back((ttl >> 24) & 0xFF);
     response.push_back((ttl >> 16) & 0xFF);
     response.push_back((ttl >> 8) & 0xFF);
     response.push_back(ttl & 0xFF);
-    
+
     // SOA RDATA
     std::size_t rdlengthPos = response.size();
     response.push_back(0x00); // RDLENGTH placeholder
     response.push_back(0x00);
-    
+
     std::size_t rdataStart = response.size();
-    
+
     // MNAME (primary nameserver)
     encodeQuestionName(response, soaRecord.mname);
-    
+
     // RNAME (responsible person)
     encodeQuestionName(response, soaRecord.rname);
-    
+
     // Serial (4 bytes)
     std::uint32_t serial = soaRecord.serial;
     response.push_back((serial >> 24) & 0xFF);
     response.push_back((serial >> 16) & 0xFF);
     response.push_back((serial >> 8) & 0xFF);
     response.push_back(serial & 0xFF);
-    
+
     // Refresh (4 bytes)
     std::uint32_t refresh = soaRecord.refresh;
     response.push_back((refresh >> 24) & 0xFF);
     response.push_back((refresh >> 16) & 0xFF);
     response.push_back((refresh >> 8) & 0xFF);
     response.push_back(refresh & 0xFF);
-    
+
     // Retry (4 bytes)
     std::uint32_t retry = soaRecord.retry;
     response.push_back((retry >> 24) & 0xFF);
     response.push_back((retry >> 16) & 0xFF);
     response.push_back((retry >> 8) & 0xFF);
     response.push_back(retry & 0xFF);
-    
+
     // Expire (4 bytes) - use refresh value as default
     response.push_back((refresh >> 24) & 0xFF);
     response.push_back((refresh >> 16) & 0xFF);
     response.push_back((refresh >> 8) & 0xFF);
     response.push_back(refresh & 0xFF);
-    
+
     // Minimum TTL (4 bytes)
     std::uint32_t minimum = soaRecord.minimum;
     response.push_back((minimum >> 24) & 0xFF);
     response.push_back((minimum >> 16) & 0xFF);
     response.push_back((minimum >> 8) & 0xFF);
     response.push_back(minimum & 0xFF);
-    
+
     // Update RDLENGTH
     std::size_t rdataLength = response.size() - rdataStart;
     response[rdlengthPos] = (rdataLength >> 8) & 0xFF;
     response[rdlengthPos + 1] = rdataLength & 0xFF;
-    
+
     return response;
   }
 
-  std::vector<std::uint8_t> generateMaliciousResponse(const std::string& maliciousType)
+  std::vector<std::uint8_t> generateMaliciousResponse(const std::string &maliciousType)
   {
     // TODO: Implement malicious response generation for robustness testing
     // Types: "pointer_loop", "invalid_compression", "buffer_overflow", etc.
-    
+
     std::vector<std::uint8_t> response;
-    
+
     if (maliciousType == "pointer_loop")
     {
       // Create a response with circular name compression pointers
       response.resize(20);
       // DNS header
       response[2] = 0x84; // Response flags
-      
+
       // Question name with pointer loop: ptr -> ptr (circular)
-      response[12] = 0xC0; response[13] = 0x0E; // Pointer to offset 14
-      response[14] = 0xC0; response[15] = 0x0C; // Pointer to offset 12 (loop!)
+      response[12] = 0xC0;
+      response[13] = 0x0E; // Pointer to offset 14
+      response[14] = 0xC0;
+      response[15] = 0x0C; // Pointer to offset 12 (loop!)
     }
-    
+
     return response;
   }
 };
\ No newline at end of file
diff --git a/tests/core/iora_test_config_loader.cpp b/tests/core/iora_test_config_loader.cpp
index 309bd45..66aeae8 100644
--- a/tests/core/iora_test_config_loader.cpp
+++ b/tests/core/iora_test_config_loader.cpp
@@ -5,8 +5,8 @@
 // See the LICENSE file or <https://www.mozilla.org/MPL/2.0/> for details.
 
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 #include <limits>
 #include <type_traits>
 
@@ -28,7 +28,7 @@ TEST_CASE("ConfigLoader basic operations", "[config][ConfigLoader]")
   SECTION("Reload and load returns table")
   {
     REQUIRE(loader.reload());
-    const auto& tbl = loader.load();
+    const auto &tbl = loader.load();
     REQUIRE(tbl.contains("section"));
     REQUIRE(tbl.contains("other"));
   }
@@ -54,7 +54,7 @@ TEST_CASE("ConfigLoader basic operations", "[config][ConfigLoader]")
   SECTION("table() returns the parsed table")
   {
     loader.reload();
-    const auto& tbl = loader.table();
+    const auto &tbl = loader.table();
     REQUIRE(tbl.contains("section"));
     REQUIRE(tbl.at_path("section.int_val").is_value());
   }
@@ -118,8 +118,7 @@ TEST_CASE("ConfigLoader extended functionality", "[config][ConfigLoader]")
     }
     iora::core::ConfigLoader badArrLoader(badArrFile);
     badArrLoader.reload();
-    REQUIRE_THROWS_AS(badArrLoader.getStringArray("section.mixed_array"),
-                      std::runtime_error);
+    REQUIRE_THROWS_AS(badArrLoader.getStringArray("section.mixed_array"), std::runtime_error);
     std::filesystem::remove(badArrFile);
   }
 
diff --git a/tests/core/iora_test_event_queue.cpp b/tests/core/iora_test_event_queue.cpp
index 26a7bd3..f8ce73a 100644
--- a/tests/core/iora_test_event_queue.cpp
+++ b/tests/core/iora_test_event_queue.cpp
@@ -5,8 +5,8 @@
 // See the LICENSE file or <https://www.mozilla.org/MPL/2.0/> for details.
 
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 
 TEST_CASE("EventQueue processes valid events", "[EventQueue]")
 {
@@ -14,7 +14,7 @@ TEST_CASE("EventQueue processes valid events", "[EventQueue]")
   std::atomic<int> counter{0};
 
   queue.onEventId("testId",
-                  [&](const iora::parsers::Json& event)
+                  [&](const iora::parsers::Json &event)
                   {
                     REQUIRE(event["eventId"] == "testId");
                     counter++;
@@ -33,7 +33,7 @@ TEST_CASE("EventQueue drops invalid events", "[EventQueue]")
   iora::core::EventQueue queue(2);
   std::atomic<int> counter{0};
 
-  queue.onEventId("testId", [&](const iora::parsers::Json&) { counter++; });
+  queue.onEventId("testId", [&](const iora::parsers::Json &) { counter++; });
 
   auto invalidEvent = iora::parsers::Json::object();
   invalidEvent["eventName"] = "testEvent";
@@ -47,13 +47,12 @@ TEST_CASE("EventQueue matches eventName with glob patterns", "[EventQueue]")
   iora::core::EventQueue queue(2);
   std::atomic<int> counter{0};
 
-  queue.onEventNameMatches(
-      "^test.*",
-      [&](const iora::parsers::Json& event)
-      {
-        REQUIRE(event["eventName"].get<std::string>().find("test") == 0);
-        counter++;
-      });
+  queue.onEventNameMatches("^test.*",
+                           [&](const iora::parsers::Json &event)
+                           {
+                             REQUIRE(event["eventName"].get<std::string>().find("test") == 0);
+                             counter++;
+                           });
 
   auto matching = iora::parsers::Json::object();
   matching["eventId"] = "id1";
@@ -74,7 +73,7 @@ TEST_CASE("EventQueue matches eventName exactly", "[EventQueue]")
   std::atomic<int> counter{0};
 
   queue.onEventName("testEvent",
-                    [&](const iora::parsers::Json& event)
+                    [&](const iora::parsers::Json &event)
                     {
                       REQUIRE(event["eventName"] == "testEvent");
                       counter++;
@@ -97,22 +96,22 @@ TEST_CASE("EventQueue handles concurrent pushes and handlers", "[EventQueue]")
 {
   iora::core::EventQueue queue(4);
   std::atomic<int> counter{0};
-  queue.onEventId("testId", [&](const iora::parsers::Json&) { counter++; });
+  queue.onEventId("testId", [&](const iora::parsers::Json &) { counter++; });
 
   std::vector<std::thread> threads;
   for (int i = 0; i < 10; ++i)
   {
     threads.emplace_back(
-        [&queue]()
-        {
-          auto event = iora::parsers::Json::object();
-          event["eventId"] = "testId";
-          event["eventName"] = "testEvent";
-          queue.push(event);
-        });
+      [&queue]()
+      {
+        auto event = iora::parsers::Json::object();
+        event["eventId"] = "testId";
+        event["eventName"] = "testEvent";
+        queue.push(event);
+      });
   }
 
-  for (auto& t : threads)
+  for (auto &t : threads)
   {
     t.join();
   }
@@ -126,7 +125,7 @@ TEST_CASE("EventQueue shuts down gracefully", "[EventQueue]")
   iora::core::EventQueue queue(2);
   std::atomic<int> counter{0};
 
-  queue.onEventId("testId", [&](const iora::parsers::Json&) { counter++; });
+  queue.onEventId("testId", [&](const iora::parsers::Json &) { counter++; });
   auto event = iora::parsers::Json::object();
   event["eventId"] = "testId";
   event["eventName"] = "testEvent";
diff --git a/tests/core/iora_test_external_logger.cpp b/tests/core/iora_test_external_logger.cpp
index 8575c09..385d166 100644
--- a/tests/core/iora_test_external_logger.cpp
+++ b/tests/core/iora_test_external_logger.cpp
@@ -6,28 +6,29 @@
 // details.
 
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 
-#include <vector>
 #include <string>
+#include <vector>
 
 namespace
 {
-  struct LogCapture
-  {
-    iora::core::Logger::Level level;
-    std::string formattedMessage;
-    std::string rawMessage;
-  };
+struct LogCapture
+{
+  iora::core::Logger::Level level;
+  std::string formattedMessage;
+  std::string rawMessage;
+};
 
-  std::vector<LogCapture> capturedLogs;
+std::vector<LogCapture> capturedLogs;
 
-  void externalLogHandler(iora::core::Logger::Level level, const std::string& formattedMessage, const std::string& rawMessage)
-  {
-    capturedLogs.push_back({level, formattedMessage, rawMessage});
-  }
+void externalLogHandler(iora::core::Logger::Level level, const std::string &formattedMessage,
+                        const std::string &rawMessage)
+{
+  capturedLogs.push_back({level, formattedMessage, rawMessage});
 }
+} // namespace
 
 TEST_CASE("External log handler", "[logger][external]")
 {
@@ -48,7 +49,7 @@ TEST_CASE("External log handler", "[logger][external]")
     iora::core::Logger::flush();
 
     REQUIRE(capturedLogs.size() == 3);
-    
+
     REQUIRE(capturedLogs[0].level == iora::core::Logger::Level::Info);
     REQUIRE(capturedLogs[0].rawMessage == "Test info message");
     REQUIRE(capturedLogs[0].formattedMessage.find("Test info message") != std::string::npos);
@@ -101,14 +102,14 @@ TEST_CASE("External log handler", "[logger][external]")
     std::filesystem::remove(testLogFile); // Clean up any existing file
 
     iora::core::Logger::init(iora::core::Logger::Level::Info, testLogFile);
-    
+
     // Log a message normally (should go to file)
     iora::core::Logger::info("Message before external handler");
     iora::core::Logger::flush();
 
     // Set external handler (should disable file logging)
     iora::core::Logger::setExternalHandler(externalLogHandler);
-    
+
     // Log messages (should go to external handler only)
     iora::core::Logger::info("Message with external handler");
     iora::core::Logger::flush();
diff --git a/tests/core/iora_test_logger.cpp b/tests/core/iora_test_logger.cpp
index 1bc214f..0ef8561 100644
--- a/tests/core/iora_test_logger.cpp
+++ b/tests/core/iora_test_logger.cpp
@@ -5,8 +5,8 @@
 // See the LICENSE file or <https://www.mozilla.org/MPL/2.0/> for details.
 
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 
 TEST_CASE("Logger Basic Levels", "[logger][levels]")
 {
@@ -31,12 +31,11 @@ TEST_CASE("Logger Basic Levels", "[logger][levels]")
 TEST_CASE("Logger Stream Logging", "[logger][stream]")
 {
   iora::core::Logger::init(iora::core::Logger::Level::Info, "streamlog", false);
-  iora::core::Logger << iora::core::Logger::Level::Info
-                     << "Stream log test: " << 123 << iora::core::Logger::endl;
+  iora::core::Logger << iora::core::Logger::Level::Info << "Stream log test: " << 123
+                     << iora::core::Logger::endl;
   iora::core::Logger::shutdown();
 
-  std::string logFile =
-      "streamlog." + iora::core::Logger::currentDate() + ".log";
+  std::string logFile = "streamlog." + iora::core::Logger::currentDate() + ".log";
   std::ifstream in(logFile);
   REQUIRE(in.is_open());
 
@@ -61,13 +60,12 @@ TEST_CASE("Logger Async Logging", "[logger][async]")
   iora::core::Logger::init(iora::core::Logger::Level::Info, "asynclog", true);
   for (int i = 0; i < 100; ++i)
   {
-    iora::core::Logger << iora::core::Logger::Level::Info << "Async message "
-                       << i << iora::core::Logger::endl;
+    iora::core::Logger << iora::core::Logger::Level::Info << "Async message " << i
+                       << iora::core::Logger::endl;
   }
   iora::core::Logger::shutdown();
 
-  std::string logFile =
-      "asynclog." + iora::core::Logger::currentDate() + ".log";
+  std::string logFile = "asynclog." + iora::core::Logger::currentDate() + ".log";
   std::ifstream in(logFile);
   REQUIRE(in.is_open());
   REQUIRE(std::count(std::istreambuf_iterator<char>(in), {}, '\n') >= 100);
@@ -86,28 +84,25 @@ TEST_CASE("Logger Thread Safety", "[logger][threaded]")
   for (int i = 0; i < threads; ++i)
   {
     workers.emplace_back(
-        [i]()
+      [i]()
+      {
+        for (int j = 0; j < messagesPerThread; ++j)
         {
-          for (int j = 0; j < messagesPerThread; ++j)
-          {
-            iora::core::Logger << iora::core::Logger::Level::Info << "Thread "
-                               << i << " message " << j
-                               << iora::core::Logger::endl;
-          }
-        });
+          iora::core::Logger << iora::core::Logger::Level::Info << "Thread " << i << " message "
+                             << j << iora::core::Logger::endl;
+        }
+      });
   }
-  for (auto& t : workers)
+  for (auto &t : workers)
   {
     t.join();
   }
   iora::core::Logger::shutdown();
 
-  std::string logFile =
-      "threadlog." + iora::core::Logger::currentDate() + ".log";
+  std::string logFile = "threadlog." + iora::core::Logger::currentDate() + ".log";
   std::ifstream in(logFile);
   REQUIRE(in.is_open());
-  REQUIRE(std::count(std::istreambuf_iterator<char>(in), {}, '\n') >=
-          threads * messagesPerThread);
+  REQUIRE(std::count(std::istreambuf_iterator<char>(in), {}, '\n') >= threads * messagesPerThread);
   iora::util::removeFilesMatchingPrefix("threadlog.");
 }
 
@@ -116,8 +111,7 @@ TEST_CASE("Logger File Rotation and Retention", "[logger][rotation]")
   const std::string base = "rotate_test";
   const int retention = 1;
 
-  iora::core::Logger::init(iora::core::Logger::Level::Info, base, false,
-                           retention);
+  iora::core::Logger::init(iora::core::Logger::Level::Info, base, false, retention);
   IORA_LOG_INFO("Rotation start");
   iora::core::Logger::shutdown();
 
@@ -125,12 +119,10 @@ TEST_CASE("Logger File Rotation and Retention", "[logger][rotation]")
   std::ofstream fakeOld(oldFile);
   fakeOld << "old log" << std::endl;
   fakeOld.close();
-  std::filesystem::last_write_time(
-      oldFile,
-      std::filesystem::file_time_type::clock::now() - std::chrono::hours(25));
+  std::filesystem::last_write_time(oldFile, std::filesystem::file_time_type::clock::now() -
+                                              std::chrono::hours(25));
 
-  iora::core::Logger::init(iora::core::Logger::Level::Info, base, false,
-                           retention);
+  iora::core::Logger::init(iora::core::Logger::Level::Info, base, false, retention);
   IORA_LOG_INFO("Trigger rotation");
   iora::core::Logger::shutdown();
 
diff --git a/tests/core/iora_test_threadpool.cpp b/tests/core/iora_test_threadpool.cpp
index 1f31c75..e54e5ae 100644
--- a/tests/core/iora_test_threadpool.cpp
+++ b/tests/core/iora_test_threadpool.cpp
@@ -1,8 +1,8 @@
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "test_helpers.hpp"
-#include <vector>
+#include <catch2/catch.hpp>
 #include <stdexcept>
+#include <vector>
 
 //
 // Basic task execution using fire-and-forget
@@ -46,11 +46,12 @@ TEST_CASE("ThreadPool scales up under load", "[threadpool][scaling]")
 
   for (int i = 0; i < tasks; ++i)
   {
-    pool.enqueue([&completed]()
-    {
-      std::this_thread::sleep_for(std::chrono::milliseconds(100));
-      completed.fetch_add(1);
-    });
+    pool.enqueue(
+      [&completed]()
+      {
+        std::this_thread::sleep_for(std::chrono::milliseconds(100));
+        completed.fetch_add(1);
+      });
   }
 
   std::this_thread::sleep_for(std::chrono::milliseconds(500));
@@ -67,9 +68,7 @@ TEST_CASE("ThreadPool handles queue overflow", "[threadpool][overflow]")
   pool.enqueue([]() { std::this_thread::sleep_for(std::chrono::milliseconds(100)); });
   pool.enqueue([]() { std::this_thread::sleep_for(std::chrono::milliseconds(100)); });
 
-  REQUIRE_THROWS_AS(
-      pool.enqueue([]() {}),
-      std::runtime_error);
+  REQUIRE_THROWS_AS(pool.enqueue([]() {}), std::runtime_error);
 }
 
 //
@@ -79,10 +78,7 @@ TEST_CASE("ThreadPool handles exceptions without handler", "[threadpool][excepti
 {
   iora::core::ThreadPool pool;
 
-  pool.enqueue([]()
-  {
-    throw std::runtime_error("oops");
-  });
+  pool.enqueue([]() { throw std::runtime_error("oops"); });
 
   std::this_thread::sleep_for(std::chrono::milliseconds(100));
   SUCCEED("Exception was swallowed safely");
@@ -95,31 +91,33 @@ TEST_CASE("ThreadPool handles exceptions with handler", "[threadpool][exception-
 {
   std::atomic<bool> caught{false};
 
-  iora::core::ThreadPool pool(
-      2, 4, std::chrono::seconds(1), 128,
-      [&caught](std::exception_ptr eptr)
-      {
-        try
-        {
-          if (eptr) std::rethrow_exception(eptr);
-        }
-        catch (const std::runtime_error& e)
-        {
-          if (std::string(e.what()) == "fail") caught = true;
-        }
-      });
-
-  auto fut = pool.enqueueWithResult([]()
-  {
-    std::cerr << "[TEST] throwing now\n";
-    throw std::runtime_error("fail");
-  });
+  iora::core::ThreadPool pool(2, 4, std::chrono::seconds(1), 128,
+                              [&caught](std::exception_ptr eptr)
+                              {
+                                try
+                                {
+                                  if (eptr)
+                                    std::rethrow_exception(eptr);
+                                }
+                                catch (const std::runtime_error &e)
+                                {
+                                  if (std::string(e.what()) == "fail")
+                                    caught = true;
+                                }
+                              });
+
+  auto fut = pool.enqueueWithResult(
+    []()
+    {
+      std::cerr << "[TEST] throwing now\n";
+      throw std::runtime_error("fail");
+    });
 
   try
   {
     fut.get();
   }
-  catch (const std::runtime_error& e)
+  catch (const std::runtime_error &e)
   {
     if (std::string(e.what()) == "fail")
     {
@@ -129,10 +127,7 @@ TEST_CASE("ThreadPool handles exceptions with handler", "[threadpool][exception-
   REQUIRE(caught);
 
   caught = false; // Reset for next test
-  pool.enqueue([]()
-  {
-    throw std::runtime_error("fail");
-  });
+  pool.enqueue([]() { throw std::runtime_error("fail"); });
 
   const auto deadline = std::chrono::steady_clock::now() + std::chrono::seconds(2);
   while (!caught && std::chrono::steady_clock::now() < deadline)
@@ -152,10 +147,7 @@ TEST_CASE("ThreadPool shrinks idle threads", "[threadpool][scaling-down]")
 
   for (int i = 0; i < 4; ++i)
   {
-    pool.enqueue([]()
-    {
-      std::this_thread::sleep_for(std::chrono::milliseconds(50));
-    });
+    pool.enqueue([]() { std::this_thread::sleep_for(std::chrono::milliseconds(50)); });
   }
 
   std::this_thread::sleep_for(std::chrono::milliseconds(500));
@@ -173,11 +165,12 @@ TEST_CASE("ThreadPool destruction completes pending tasks", "[threadpool][lifecy
     iora::core::ThreadPool pool(2, 4);
     for (int i = 0; i < 5; ++i)
     {
-      pool.enqueue([&completed]()
-      {
-        std::this_thread::sleep_for(std::chrono::milliseconds(50));
-        completed++;
-      });
+      pool.enqueue(
+        [&completed]()
+        {
+          std::this_thread::sleep_for(std::chrono::milliseconds(50));
+          completed++;
+        });
     }
   }
 
@@ -195,11 +188,12 @@ TEST_CASE("ThreadPool rapid enqueue and shutdown", "[threadpool][race]")
     iora::core::ThreadPool pool(4, 4);
     for (int i = 0; i < 20; ++i)
     {
-      pool.enqueue([&completed]()
-      {
-        std::this_thread::sleep_for(std::chrono::milliseconds(10));
-        completed++;
-      });
+      pool.enqueue(
+        [&completed]()
+        {
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+          completed++;
+        });
     }
     // destructor will be called immediately
   }
@@ -214,9 +208,7 @@ TEST_CASE("ThreadPool propagates exception through future", "[threadpool][future
 {
   iora::core::ThreadPool pool(2);
 
-  auto future = pool.enqueueWithResult([]() -> int {
-    throw std::runtime_error("bad future");
-  });
+  auto future = pool.enqueueWithResult([]() -> int { throw std::runtime_error("bad future"); });
 
   REQUIRE_THROWS_AS(future.get(), std::runtime_error);
 }
@@ -226,214 +218,226 @@ TEST_CASE("ThreadPool backpressure and monitoring", "[threadpool][backpressure]"
   SECTION("getPendingTaskCount works correctly")
   {
     iora::core::ThreadPool pool(1, 1, std::chrono::seconds(1), 3);
-    
+
     REQUIRE(pool.getPendingTaskCount() == 0);
-    
+
     // Add a long-running task to occupy the single thread
     std::atomic<bool> taskStarted{false};
     std::atomic<bool> allowTaskComplete{false};
-    
-    pool.enqueue([&taskStarted, &allowTaskComplete]()
-    {
-      taskStarted = true;
-      while (!allowTaskComplete)
+
+    pool.enqueue(
+      [&taskStarted, &allowTaskComplete]()
       {
-        std::this_thread::sleep_for(std::chrono::milliseconds(10));
-      }
-    });
-    
+        taskStarted = true;
+        while (!allowTaskComplete)
+        {
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      });
+
     // Wait for the task to start
     while (!taskStarted)
     {
       std::this_thread::sleep_for(std::chrono::milliseconds(1));
     }
-    
+
     // Add tasks to the queue
-    pool.enqueue([]()
-    {
-      std::this_thread::sleep_for(std::chrono::milliseconds(10));
-    });
-    pool.enqueue([]()
-    {
-      std::this_thread::sleep_for(std::chrono::milliseconds(10));
-    });
-    
+    pool.enqueue([]() { std::this_thread::sleep_for(std::chrono::milliseconds(10)); });
+    pool.enqueue([]() { std::this_thread::sleep_for(std::chrono::milliseconds(10)); });
+
     REQUIRE(pool.getPendingTaskCount() == 2);
-    
+
     // Allow tasks to complete
     allowTaskComplete = true;
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
-    
+
     REQUIRE(pool.getPendingTaskCount() == 0);
   }
-  
+
   SECTION("getQueueUtilization returns correct percentage")
   {
     iora::core::ThreadPool pool(1, 1, std::chrono::seconds(1), 4); // Queue size 4
-    
+
     REQUIRE(pool.getQueueUtilization() == 0.0);
-    
+
     // Block the thread with a task that won't be in the queue (it's being executed)
     std::atomic<bool> taskStarted{false};
     std::atomic<bool> allowComplete{false};
-    pool.enqueue([&taskStarted, &allowComplete]() {
-      taskStarted = true;
-      while (!allowComplete) {
-        std::this_thread::sleep_for(std::chrono::milliseconds(10));
-      }
-    });
-    
+    pool.enqueue(
+      [&taskStarted, &allowComplete]()
+      {
+        taskStarted = true;
+        while (!allowComplete)
+        {
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      });
+
     // Wait for the blocking task to start (so it's not in the queue)
-    while (!taskStarted) {
+    while (!taskStarted)
+    {
       std::this_thread::sleep_for(std::chrono::milliseconds(1));
     }
-    
+
     // Now the queue should be empty
     REQUIRE(pool.getQueueUtilization() == 0.0);
-    
+
     // Add tasks to fill 50% of queue (2 out of 4)
     pool.enqueue([]() {});
     pool.enqueue([]() {});
-    
+
     REQUIRE(pool.getQueueUtilization() == 50.0);
-    
+
     // Fill to 100% (4 out of 4)
     pool.enqueue([]() {});
     pool.enqueue([]() {});
-    
+
     REQUIRE(pool.getQueueUtilization() == 100.0);
-    
+
     allowComplete = true;
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
   }
-  
+
   SECTION("isUnderHighLoad detects high queue utilization")
   {
     iora::core::ThreadPool pool(1, 1, std::chrono::seconds(1), 5); // Queue size 5
-    
+
     REQUIRE_FALSE(pool.isUnderHighLoad());
-    
+
     // Block the thread
     std::atomic<bool> allowComplete{false};
-    pool.enqueue([&allowComplete]()
-    {
-      while (!allowComplete)
+    pool.enqueue(
+      [&allowComplete]()
       {
-        std::this_thread::sleep_for(std::chrono::milliseconds(10));
-      }
-    });
-    
+        while (!allowComplete)
+        {
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      });
+
     // Add tasks to reach 80% (4 out of 5)
     // These tasks need to block too, otherwise they execute instantly
-    pool.enqueue([&allowComplete]() {
-      while (!allowComplete) {
-        std::this_thread::sleep_for(std::chrono::milliseconds(10));
-      }
-    });
-    pool.enqueue([&allowComplete]() {
-      while (!allowComplete) {
-        std::this_thread::sleep_for(std::chrono::milliseconds(10));
-      }
-    });
-    pool.enqueue([&allowComplete]() {
-      while (!allowComplete) {
-        std::this_thread::sleep_for(std::chrono::milliseconds(10));
-      }
-    });
-    pool.enqueue([&allowComplete]() {
-      while (!allowComplete) {
-        std::this_thread::sleep_for(std::chrono::milliseconds(10));
-      }
-    });
-    
+    pool.enqueue(
+      [&allowComplete]()
+      {
+        while (!allowComplete)
+        {
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      });
+    pool.enqueue(
+      [&allowComplete]()
+      {
+        while (!allowComplete)
+        {
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      });
+    pool.enqueue(
+      [&allowComplete]()
+      {
+        while (!allowComplete)
+        {
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      });
+    pool.enqueue(
+      [&allowComplete]()
+      {
+        while (!allowComplete)
+        {
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      });
+
     REQUIRE(pool.isUnderHighLoad());
-    
+
     allowComplete = true;
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
   }
-  
+
   SECTION("tryEnqueue provides non-blocking backpressure")
   {
     iora::core::ThreadPool pool(1, 1, std::chrono::seconds(1), 2); // Small queue
-    
+
     // Block the single thread
     std::atomic<bool> taskStarted{false};
     std::atomic<bool> allowComplete{false};
-    REQUIRE(pool.tryEnqueue([&taskStarted, &allowComplete]()
-    {
-      taskStarted = true;
-      while (!allowComplete)
+    REQUIRE(pool.tryEnqueue(
+      [&taskStarted, &allowComplete]()
       {
-        std::this_thread::sleep_for(std::chrono::milliseconds(10));
-      }
-    }));
-    
+        taskStarted = true;
+        while (!allowComplete)
+        {
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      }));
+
     // Wait for the blocking task to start
     while (!taskStarted)
     {
       std::this_thread::sleep_for(std::chrono::milliseconds(1));
     }
-    
+
     // Fill the queue (2 slots)
-    REQUIRE(pool.tryEnqueue([]{}));
-    REQUIRE(pool.tryEnqueue([]{}));
-    
+    REQUIRE(pool.tryEnqueue([] {}));
+    REQUIRE(pool.tryEnqueue([] {}));
+
     // Next enqueue should fail due to backpressure
-    REQUIRE_FALSE(pool.tryEnqueue([]{}));
-    
+    REQUIRE_FALSE(pool.tryEnqueue([] {}));
+
     // Queue should be at capacity
     REQUIRE(pool.getQueueUtilization() == 100.0);
     REQUIRE(pool.getPendingTaskCount() == 2);
-    
+
     allowComplete = true;
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
-    
+
     // After completion, should be able to enqueue again
-    REQUIRE(pool.tryEnqueue([]{}));
+    REQUIRE(pool.tryEnqueue([] {}));
   }
-  
 
   SECTION("thread count monitoring works correctly")
   {
-    iora::core::ThreadPool pool(
-        static_cast<std::size_t>(2),                           // initialSize
-        static_cast<std::size_t>(4),                           // maxSize  
-        std::chrono::milliseconds(1000),                       // idleTimeout
-        static_cast<std::size_t>(10)                           // maxQueueSize
+    iora::core::ThreadPool pool(static_cast<std::size_t>(2),     // initialSize
+                                static_cast<std::size_t>(4),     // maxSize
+                                std::chrono::milliseconds(1000), // idleTimeout
+                                static_cast<std::size_t>(10)     // maxQueueSize
     );
-    
-    REQUIRE(pool.getTotalThreadCount() == 2); // Initial size
+
+    REQUIRE(pool.getTotalThreadCount() == 2);  // Initial size
     REQUIRE(pool.getActiveThreadCount() == 0); // No active tasks
-    
+
     // Add tasks that will cause thread pool to grow
     std::atomic<int> activeTasks{0};
     std::atomic<bool> allowComplete{false};
-    
+
     for (int i = 0; i < 4; ++i)
     {
-      pool.enqueue([&activeTasks, &allowComplete]()
-      {
-        ++activeTasks;
-        while (!allowComplete)
+      pool.enqueue(
+        [&activeTasks, &allowComplete]()
         {
-          std::this_thread::sleep_for(std::chrono::milliseconds(10));
-        }
-        --activeTasks;
-      });
+          ++activeTasks;
+          while (!allowComplete)
+          {
+            std::this_thread::sleep_for(std::chrono::milliseconds(10));
+          }
+          --activeTasks;
+        });
     }
-    
+
     // Wait for tasks to start
     while (activeTasks < 4)
     {
       std::this_thread::sleep_for(std::chrono::milliseconds(10));
     }
-    
+
     REQUIRE(pool.getActiveThreadCount() == 4);
     REQUIRE(pool.getTotalThreadCount() >= 4); // Should have grown
-    
+
     allowComplete = true;
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
-    
+
     REQUIRE(pool.getActiveThreadCount() == 0);
   }
 }
diff --git a/tests/core/iora_test_timer.cpp b/tests/core/iora_test_timer.cpp
index b055627..82e0539 100644
--- a/tests/core/iora_test_timer.cpp
+++ b/tests/core/iora_test_timer.cpp
@@ -1,7 +1,7 @@
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
-#include "test_helpers.hpp"
 #include "iora/core/timer.hpp"
+#include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 
 using namespace iora::core;
 using namespace std::chrono_literals;
@@ -17,20 +17,21 @@ public:
     TimerError error;
     int errno_val;
   };
-  
+
   mutable std::vector<LogEntry> entries;
-  
-  void log(Level level, const std::string& message, TimerError error = TimerError::None, int errno_val = 0) override
+
+  void log(Level level, const std::string &message, TimerError error = TimerError::None,
+           int errno_val = 0) override
   {
     entries.push_back({level, message, error, errno_val});
   }
-  
+
   void clear() { entries.clear(); }
   size_t count() const { return entries.size(); }
-  
-  bool hasMessage(const std::string& msg) const
+
+  bool hasMessage(const std::string &msg) const
   {
-    for (const auto& entry : entries)
+    for (const auto &entry : entries)
     {
       if (entry.message.find(msg) != std::string::npos)
       {
@@ -45,66 +46,67 @@ TEST_CASE("TimerService basic functionality", "[enhanced_timer][basic]")
 {
   SECTION("Service initialization and shutdown")
   {
-    auto config = TimerConfigBuilder()
-      .enableStatistics(true)
-      .threadName("TestTimer")
-      .build();
-    
+    auto config = TimerConfigBuilder().enableStatistics(true).threadName("TestTimer").build();
+
     TimerService service(config);
-    
+
     // Service should start successfully
     REQUIRE_NOTHROW(service.scheduleAfter(1ms, []() {}));
-    
+
     // Wait briefly for any scheduled timers
     std::this_thread::sleep_for(10ms);
-    
-    const auto& stats = service.getStats();
+
+    const auto &stats = service.getStats();
     REQUIRE(stats.timersScheduled.load() == 1);
   }
-  
+
   SECTION("Basic timer execution")
   {
     TimerService service;
     std::atomic<bool> executed{false};
-    
-    service.scheduleAfter(50ms, [&executed]() {
-      executed = true;
-    });
-    
+
+    service.scheduleAfter(50ms, [&executed]() { executed = true; });
+
     // Timer should not have executed yet
     REQUIRE(executed.load() == false);
-    
+
     // Wait for execution
     std::this_thread::sleep_for(100ms);
-    
+
     // Timer should have executed
     REQUIRE(executed.load() == true);
   }
-  
+
   SECTION("Multiple timers execution order")
   {
     TimerService service;
     std::vector<int> execution_order;
     std::mutex order_mutex;
-    
+
     // Schedule timers in reverse order of execution
-    service.scheduleAfter(100ms, [&]() {
-      std::lock_guard<std::mutex> lock(order_mutex);
-      execution_order.push_back(3);
-    });
-    
-    service.scheduleAfter(50ms, [&]() {
-      std::lock_guard<std::mutex> lock(order_mutex);
-      execution_order.push_back(2);
-    });
-    
-    service.scheduleAfter(25ms, [&]() {
-      std::lock_guard<std::mutex> lock(order_mutex);
-      execution_order.push_back(1);
-    });
-    
+    service.scheduleAfter(100ms,
+                          [&]()
+                          {
+                            std::lock_guard<std::mutex> lock(order_mutex);
+                            execution_order.push_back(3);
+                          });
+
+    service.scheduleAfter(50ms,
+                          [&]()
+                          {
+                            std::lock_guard<std::mutex> lock(order_mutex);
+                            execution_order.push_back(2);
+                          });
+
+    service.scheduleAfter(25ms,
+                          [&]()
+                          {
+                            std::lock_guard<std::mutex> lock(order_mutex);
+                            execution_order.push_back(1);
+                          });
+
     std::this_thread::sleep_for(150ms);
-    
+
     REQUIRE(execution_order.size() == 3);
     REQUIRE(execution_order[0] == 1);
     REQUIRE(execution_order[1] == 2);
@@ -116,43 +118,39 @@ TEST_CASE("TimerService statistics", "[enhanced_timer][stats]")
 {
   SECTION("Basic statistics tracking")
   {
-    auto config = TimerConfigBuilder()
-      .enableStatistics(true)
-      .build();
-    
+    auto config = TimerConfigBuilder().enableStatistics(true).build();
+
     TimerService service(config);
-    
+
     // Schedule some timers
     service.scheduleAfter(10ms, []() {});
     service.scheduleAfter(20ms, []() {});
     service.scheduleAfter(30ms, []() {});
-    
+
     // Wait for execution
     std::this_thread::sleep_for(50ms);
-    
-    const auto& stats = service.getStats();
+
+    const auto &stats = service.getStats();
     REQUIRE(stats.timersScheduled.load() == 3);
     REQUIRE(stats.timersExecuted.load() == 3);
     REQUIRE(stats.timersCanceled.load() == 0);
   }
-  
+
   SECTION("Cancellation statistics")
   {
-    auto config = TimerConfigBuilder()
-      .enableStatistics(true)
-      .build();
-    
+    auto config = TimerConfigBuilder().enableStatistics(true).build();
+
     TimerService service(config);
-    
+
     // Schedule and cancel a timer
     auto id = service.scheduleAfter(100ms, []() {});
     bool canceled = service.cancel(id);
-    
+
     REQUIRE(canceled == true);
-    
+
     std::this_thread::sleep_for(150ms);
-    
-    const auto& stats = service.getStats();
+
+    const auto &stats = service.getStats();
     REQUIRE(stats.timersScheduled.load() == 1);
     REQUIRE(stats.timersExecuted.load() == 0);
     REQUIRE(stats.timersCanceled.load() == 1);
@@ -163,44 +161,39 @@ TEST_CASE("TimerService error handling", "[enhanced_timer][errors]")
 {
   SECTION("Exception handling in timer callbacks")
   {
-    auto config = TimerConfigBuilder()
-      .enableStatistics(true)
-      .throwOnSystemError(false)
-      .build();
-    
+    auto config = TimerConfigBuilder().enableStatistics(true).throwOnSystemError(false).build();
+
     auto logger = std::make_shared<TestTimerLogger>();
     TimerService service(config, logger);
-    
+
     // Schedule timer that throws
-    service.scheduleAfter(10ms, []() {
-      throw std::runtime_error("Test exception");
-    });
-    
+    service.scheduleAfter(10ms, []() { throw std::runtime_error("Test exception"); });
+
     std::this_thread::sleep_for(50ms);
-    
-    const auto& stats = service.getStats();
+
+    const auto &stats = service.getStats();
     REQUIRE(stats.exceptionsSwallowed.load() == 1);
     REQUIRE(logger->hasMessage("Timer handler threw exception"));
   }
-  
+
   SECTION("Custom error handler")
   {
     TimerService service;
     std::string last_error;
     TimerError last_error_code = TimerError::None;
-    
-    service.setErrorHandler([&](TimerError error, const std::string& message, int errno_val) {
-      last_error = message;
-      last_error_code = error;
-    });
-    
+
+    service.setErrorHandler(
+      [&](TimerError error, const std::string &message, int errno_val)
+      {
+        last_error = message;
+        last_error_code = error;
+      });
+
     // Schedule timer that throws
-    service.scheduleAfter(10ms, []() {
-      throw std::logic_error("Logic error test");
-    });
-    
+    service.scheduleAfter(10ms, []() { throw std::logic_error("Logic error test"); });
+
     std::this_thread::sleep_for(50ms);
-    
+
     REQUIRE(last_error_code == TimerError::HandlerException);
     REQUIRE(last_error.find("Timer handler threw exception") != std::string::npos);
   }
@@ -210,27 +203,23 @@ TEST_CASE("TimerService periodic timers", "[enhanced_timer][periodic]")
 {
   SECTION("Basic periodic timer")
   {
-    auto config = TimerConfigBuilder()
-      .enableStatistics(true)
-      .build();
-    
+    auto config = TimerConfigBuilder().enableStatistics(true).build();
+
     TimerService service(config);
     std::atomic<int> tick_count{0};
-    
-    auto id = service.schedulePeriodic(20ms, [&tick_count]() {
-      tick_count++;
-    });
-    
+
+    auto id = service.schedulePeriodic(20ms, [&tick_count]() { tick_count++; });
+
     // Let it run for a while
     std::this_thread::sleep_for(100ms);
-    
+
     // Cancel the periodic timer
     service.cancel(id);
-    
+
     int final_count = tick_count.load();
     REQUIRE(final_count >= 1); // Should have ticked at least once
     REQUIRE(final_count <= 8); // But not too many times
-    
+
     // Wait a bit more and ensure it doesn't tick again
     std::this_thread::sleep_for(50ms);
     REQUIRE(tick_count.load() == final_count);
@@ -245,48 +234,50 @@ TEST_CASE("TimerService perfect forwarding", "[enhanced_timer][forwarding]")
     {
     public:
       MoveOnlyHandler(std::string msg) : _message(std::move(msg)) {}
-      MoveOnlyHandler(const MoveOnlyHandler&) = delete;
-      MoveOnlyHandler& operator=(const MoveOnlyHandler&) = delete;
-      MoveOnlyHandler(MoveOnlyHandler&&) = default;
-      MoveOnlyHandler& operator=(MoveOnlyHandler&&) = default;
-      
+      MoveOnlyHandler(const MoveOnlyHandler &) = delete;
+      MoveOnlyHandler &operator=(const MoveOnlyHandler &) = delete;
+      MoveOnlyHandler(MoveOnlyHandler &&) = default;
+      MoveOnlyHandler &operator=(MoveOnlyHandler &&) = default;
+
       void operator()() const
       {
         executed = true;
         message_copy = _message;
       }
-      
+
       mutable bool executed = false;
       mutable std::string message_copy;
-      
+
     private:
       std::string _message;
     };
-    
+
     TimerService service;
-    
+
     MoveOnlyHandler handler("test message");
     service.scheduleAfter(10ms, std::move(handler));
-    
+
     std::this_thread::sleep_for(50ms);
-    
+
     // Note: We can't directly check the handler since it was moved
     // But the test passes if compilation succeeds and no crashes occur
     REQUIRE(true); // If we get here, perfect forwarding worked
   }
-  
+
   SECTION("Lambda with move capture")
   {
     TimerService service;
     std::atomic<bool> executed{false};
-    
+
     std::string captured = "captured string";
-    service.scheduleAfter(10ms, [captured = std::move(captured), &executed]() {
-      executed = true;
-      // Use captured string to ensure it was moved properly
-      REQUIRE(captured == "captured string");
-    });
-    
+    service.scheduleAfter(10ms,
+                          [captured = std::move(captured), &executed]()
+                          {
+                            executed = true;
+                            // Use captured string to ensure it was moved properly
+                            REQUIRE(captured == "captured string");
+                          });
+
     std::this_thread::sleep_for(50ms);
     REQUIRE(executed.load() == true);
   }
@@ -296,26 +287,22 @@ TEST_CASE("TimerServicePool functionality", "[enhanced_timer][pool]")
 {
   SECTION("Load distribution across pool")
   {
-    auto config = TimerConfigBuilder()
-      .enableStatistics(true)
-      .build();
-    
+    auto config = TimerConfigBuilder().enableStatistics(true).build();
+
     TimerServicePool pool(3, config);
     std::atomic<int> total_executed{0};
-    
+
     // Schedule timers across the pool
     for (int i = 0; i < 9; ++i)
     {
-      auto& service = pool.getService();
-      service.scheduleAfter(10ms, [&total_executed]() {
-        total_executed++;
-      });
+      auto &service = pool.getService();
+      service.scheduleAfter(10ms, [&total_executed]() { total_executed++; });
     }
-    
+
     std::this_thread::sleep_for(50ms);
-    
+
     REQUIRE(total_executed.load() == 9);
-    
+
     // Check aggregated statistics
     TimerStats aggregated;
     pool.getAggregatedStats(aggregated);
@@ -330,40 +317,36 @@ TEST_CASE("SteadyTimer compatibility", "[enhanced_timer][steady]")
   {
     TimerService service;
     SteadyTimer timer(service);
-    
+
     std::atomic<bool> executed{false};
-    
+
     timer.expiresAfter(25ms);
-    timer.asyncWait([&executed]() {
-      executed = true;
-    });
-    
+    timer.asyncWait([&executed]() { executed = true; });
+
     // Should not have executed yet
     std::this_thread::sleep_for(10ms);
     REQUIRE(executed.load() == false);
-    
+
     // Should execute after the delay
     std::this_thread::sleep_for(30ms);
     REQUIRE(executed.load() == true);
   }
-  
+
   SECTION("Timer cancellation")
   {
     TimerService service;
     SteadyTimer timer(service);
-    
+
     std::atomic<bool> executed{false};
-    
+
     timer.expiresAfter(50ms);
-    timer.asyncWait([&executed]() {
-      executed = true;
-    });
-    
+    timer.asyncWait([&executed]() { executed = true; });
+
     // Cancel before execution
     std::this_thread::sleep_for(10ms);
     bool canceled = timer.cancel();
     REQUIRE(canceled == true);
-    
+
     // Wait past the original expiry time
     std::this_thread::sleep_for(60ms);
     REQUIRE(executed.load() == false);
@@ -375,33 +358,32 @@ TEST_CASE("Timer configuration options", "[enhanced_timer][config]")
   SECTION("Configuration builder pattern")
   {
     auto config = TimerConfigBuilder()
-      .enableStatistics(true)
-      .enableDetailedLogging(true)
-      .maxConcurrentTimers(500)
-      .threadName("CustomTimer")
-      .throwOnSystemError(false)
-      .build();
-    
+                    .enableStatistics(true)
+                    .enableDetailedLogging(true)
+                    .maxConcurrentTimers(500)
+                    .threadName("CustomTimer")
+                    .throwOnSystemError(false)
+                    .build();
+
     REQUIRE(config.enableStatistics == true);
     REQUIRE(config.enableDetailedLogging == true);
     REQUIRE(config.limits.maxConcurrentTimers == 500);
     REQUIRE(config.threadName == "CustomTimer");
     REQUIRE(config.throwOnSystemError == false);
   }
-  
+
   SECTION("Service with custom configuration")
   {
-    auto config = TimerConfigBuilder()
-      .enableStatistics(true)
-      .maxConcurrentTimers(100)
-      .build();
-    
+    auto config = TimerConfigBuilder().enableStatistics(true).maxConcurrentTimers(100).build();
+
     auto logger = std::make_shared<TestTimerLogger>();
-    
-    REQUIRE_NOTHROW([&]() {
-      TimerService service(config, logger);
-      service.scheduleAfter(1ms, []() {});
-      std::this_thread::sleep_for(10ms);
-    }());
+
+    REQUIRE_NOTHROW(
+      [&]()
+      {
+        TimerService service(config, logger);
+        service.scheduleAfter(1ms, []() {});
+        std::this_thread::sleep_for(10ms);
+      }());
   }
 }
\ No newline at end of file
diff --git a/tests/debug_chained_test.cpp b/tests/debug_chained_test.cpp
index a8deeb6..44ef407 100644
--- a/tests/debug_chained_test.cpp
+++ b/tests/debug_chained_test.cpp
@@ -1,7 +1,7 @@
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
-#include "test_helpers.hpp"
 #include "iora/iora.hpp"
+#include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 
 using AutoServiceShutdown = iora::IoraService::AutoServiceShutdown;
 
@@ -23,26 +23,27 @@ TEST_CASE("Debug chained dependencies only", "[debug]")
 
     // Initialize service with config
     iora::IoraService::init(config);
-    iora::IoraService& svc = iora::IoraService::instanceRef();
+    iora::IoraService &svc = iora::IoraService::instanceRef();
     AutoServiceShutdown autoShutdown(svc);
-    
+
     // Load all three plugins in correct order
     REQUIRE(svc.loadSingleModule(basePluginPath));
     REQUIRE(svc.loadSingleModule(dependentPluginPath));
     REQUIRE(svc.loadSingleModule(chainedPluginPath));
-    
+
     // Verify chained plugin can access all dependencies
     std::string chainResult = svc.callExportedApi<std::string>("chainedplugin.useChain");
     REQUIRE(chainResult.find("BasePlugin v1.0") != std::string::npos);
     REQUIRE(chainResult.find("BasePlugin available") != std::string::npos);
-    
+
     // Verify dependency status tracking
     std::string depStatus = svc.callExportedApi<std::string>("chainedplugin.getDependencyStatus");
     REQUIRE(depStatus == "BaseDep: 1, DependentDep: 1");
-    
+
     // Test complex operation using multiple dependencies
     std::string complexResult = svc.callExportedApi<std::string>("chainedplugin.complexOperation");
     REQUIRE(complexResult.find("Complex operation result") != std::string::npos);
-    REQUIRE(complexResult.find("counter: 3") != std::string::npos); // Should be 3 after 2 increments
+    REQUIRE(complexResult.find("counter: 3") !=
+            std::string::npos); // Should be 3 after 2 increments
   }
 }
\ No newline at end of file
diff --git a/tests/iora_test_net_utils.hpp b/tests/iora_test_net_utils.hpp
index 0747fe9..9694d52 100644
--- a/tests/iora_test_net_utils.hpp
+++ b/tests/iora_test_net_utils.hpp
@@ -1,19 +1,19 @@
 #pragma once
 
 #include <arpa/inet.h>
-#include <netinet/in.h>
-#include <sys/socket.h>
-#include <sys/epoll.h>
-#include <sys/eventfd.h>
-#include <system_error>
-#include <unistd.h>
 #include <chrono>
 #include <condition_variable>
 #include <cstdint>
 #include <cstring>
 #include <mutex>
+#include <netinet/in.h>
 #include <string>
+#include <sys/epoll.h>
+#include <sys/eventfd.h>
+#include <sys/socket.h>
+#include <system_error>
 #include <thread>
+#include <unistd.h>
 
 namespace testnet
 {
@@ -28,10 +28,10 @@ inline std::uint16_t getFreePortTCP()
   addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
   addr.sin_port = 0;
 
-  REQUIRE(::bind(fd, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) == 0);
+  REQUIRE(::bind(fd, reinterpret_cast<sockaddr *>(&addr), sizeof(addr)) == 0);
 
   socklen_t len = sizeof(addr);
-  REQUIRE(::getsockname(fd, reinterpret_cast<sockaddr*>(&addr), &len) == 0);
+  REQUIRE(::getsockname(fd, reinterpret_cast<sockaddr *>(&addr), &len) == 0);
   std::uint16_t port = ntohs(addr.sin_port);
   ::close(fd);
   return port;
@@ -47,10 +47,10 @@ inline std::uint16_t getFreePortUDP()
   addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
   addr.sin_port = 0;
 
-  REQUIRE(::bind(fd, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) == 0);
+  REQUIRE(::bind(fd, reinterpret_cast<sockaddr *>(&addr), sizeof(addr)) == 0);
 
   socklen_t len = sizeof(addr);
-  REQUIRE(::getsockname(fd, reinterpret_cast<sockaddr*>(&addr), &len) == 0);
+  REQUIRE(::getsockname(fd, reinterpret_cast<sockaddr *>(&addr), &len) == 0);
   std::uint16_t port = ntohs(addr.sin_port);
   ::close(fd);
   return port;
@@ -66,8 +66,7 @@ public:
   {
     if (epollFd_ < 0)
     {
-      throw std::system_error(errno, std::system_category(),
-                              "epoll_create1 failed");
+      throw std::system_error(errno, std::system_category(), "epoll_create1 failed");
     }
   }
 
@@ -89,8 +88,7 @@ public:
 
     if (epoll_ctl(epollFd_, EPOLL_CTL_ADD, fd, &ev) < 0)
     {
-      throw std::system_error(errno, std::system_category(),
-                              "epoll_ctl ADD failed");
+      throw std::system_error(errno, std::system_category(), "epoll_ctl ADD failed");
     }
   }
 
diff --git a/tests/network/iora_test_batch_integration.cpp b/tests/network/iora_test_batch_integration.cpp
index 3479fcc..e701108 100644
--- a/tests/network/iora_test_batch_integration.cpp
+++ b/tests/network/iora_test_batch_integration.cpp
@@ -6,12 +6,12 @@
 
 #define CATCH_CONFIG_MAIN
 #include <catch2/catch.hpp>
-#include "test_helpers.hpp"
-#include "iora/network/transport_with_batching.hpp"
 #include "iora/network/event_batch_processor.hpp"
+#include "iora/network/transport_with_batching.hpp"
 #include "iora_test_net_utils.hpp"
-#include <thread>
+#include "test_helpers.hpp"
 #include <chrono>
+#include <thread>
 
 using namespace std::chrono_literals;
 using namespace iora::network;
@@ -46,8 +46,7 @@ private:
   uint32_t lastEvents_{0};
 };
 
-TEST_CASE("BatchingTransportWrapper basic functionality",
-          "[batch][integration][basic]")
+TEST_CASE("BatchingTransportWrapper basic functionality", "[batch][integration][basic]")
 {
   BatchProcessingConfig config;
   config.maxBatchSize = 8;
@@ -58,7 +57,7 @@ TEST_CASE("BatchingTransportWrapper basic functionality",
 
   SECTION("Wrapper forwards to base transport")
   {
-    auto& base = wrapper.getBase();
+    auto &base = wrapper.getBase();
     base.processEvent(100, EPOLLIN);
 
     REQUIRE(base.getEventsProcessed() == 1);
@@ -82,8 +81,7 @@ TEST_CASE("BatchingTransportWrapper basic functionality",
   }
 }
 
-TEST_CASE("BatchingTransportWrapper configuration helpers",
-          "[batch][integration][config]")
+TEST_CASE("BatchingTransportWrapper configuration helpers", "[batch][integration][config]")
 {
   SECTION("Server configuration is optimized for throughput")
   {
@@ -129,8 +127,7 @@ TEST_CASE("BatchingTransportWrapper configuration helpers",
   }
 }
 
-TEST_CASE("BatchingTransportWrapper event processing",
-          "[batch][integration][events]")
+TEST_CASE("BatchingTransportWrapper event processing", "[batch][integration][events]")
 {
   EpollHelper epoll;
   EventFdHelper eventFd, timerFd, sessionFd;
@@ -156,8 +153,7 @@ TEST_CASE("BatchingTransportWrapper event processing",
 
     auto onTimerFd = [&timerFdTriggered]() { timerFdTriggered = true; };
 
-    auto sessionHandler =
-        [&sessionEventsProcessed](int /*fd*/, uint32_t /*events*/)
+    auto sessionHandler = [&sessionEventsProcessed](int /*fd*/, uint32_t /*events*/)
     { sessionEventsProcessed++; };
 
     // Signal all FDs
@@ -167,19 +163,18 @@ TEST_CASE("BatchingTransportWrapper event processing",
 
     // Run one batch processing iteration with timeout
     std::thread processor_thread(
-        [&]()
+      [&]()
+      {
+        try
+        {
+          wrapper.runTransportEventLoop(epoll.fd(), eventFd.fd(), timerFd.fd(), onEventFd,
+                                        onTimerFd, sessionHandler);
+        }
+        catch (...)
         {
-          try
-          {
-            wrapper.runTransportEventLoop(epoll.fd(), eventFd.fd(),
-                                          timerFd.fd(), onEventFd, onTimerFd,
-                                          sessionHandler);
-          }
-          catch (...)
-          {
-            // Timeout or other errors expected
-          }
-        });
+          // Timeout or other errors expected
+        }
+      });
 
     processor_thread.join();
 
@@ -193,8 +188,7 @@ TEST_CASE("BatchingTransportWrapper event processing",
   }
 }
 
-TEST_CASE("BatchingTransportWrapper statistics and monitoring",
-          "[batch][integration][stats]")
+TEST_CASE("BatchingTransportWrapper statistics and monitoring", "[batch][integration][stats]")
 {
   BatchingTransportWrapper<MockTransport> wrapper(createBalancedConfig());
 
@@ -225,21 +219,17 @@ TEST_CASE("BatchingTransportWrapper statistics and monitoring",
 class MetricsTrackingWrapper : public BatchingTransportWrapper<MockTransport>
 {
 public:
-  explicit MetricsTrackingWrapper(const BatchProcessingConfig& config)
-    : BatchingTransportWrapper<MockTransport>(config)
+  explicit MetricsTrackingWrapper(const BatchProcessingConfig &config)
+      : BatchingTransportWrapper<MockTransport>(config)
   {
   }
 
   int getBatchesProcessed() const { return batchesProcessed_; }
-  std::chrono::microseconds getTotalProcessingTime() const
-  {
-    return totalProcessingTime_;
-  }
+  std::chrono::microseconds getTotalProcessingTime() const { return totalProcessingTime_; }
   std::size_t getMaxBatchSize() const { return maxBatchSize_; }
 
 protected:
-  void onBatchProcessed(std::size_t batchSize,
-                        std::chrono::microseconds processingTime) override
+  void onBatchProcessed(std::size_t batchSize, std::chrono::microseconds processingTime) override
   {
     batchesProcessed_++;
     totalProcessingTime_ += processingTime;
@@ -269,8 +259,7 @@ TEST_CASE("Custom batch processing metrics", "[batch][integration][metrics]")
   }
 }
 
-TEST_CASE("BatchingTransportWrapper error handling",
-          "[batch][integration][error]")
+TEST_CASE("BatchingTransportWrapper error handling", "[batch][integration][error]")
 {
   BatchingTransportWrapper<MockTransport> wrapper(createBalancedConfig());
 
@@ -281,14 +270,12 @@ TEST_CASE("BatchingTransportWrapper error handling",
     auto onTimerFd = []() {};
 
     // Should handle invalid epoll FD gracefully by throwing
-    REQUIRE_THROWS_AS(wrapper.runTransportEventLoop(-1, 1, 2, onEventFd,
-                                                    onTimerFd, sessionHandler),
+    REQUIRE_THROWS_AS(wrapper.runTransportEventLoop(-1, 1, 2, onEventFd, onTimerFd, sessionHandler),
                       std::system_error);
   }
 }
 
-TEST_CASE("Performance comparison with and without batching",
-          "[batch][integration][performance]")
+TEST_CASE("Performance comparison with and without batching", "[batch][integration][performance]")
 {
   // This test demonstrates the potential benefits of batch processing
   EpollHelper epoll;
@@ -321,7 +308,7 @@ TEST_CASE("Performance comparison with and without batching",
     };
 
     // Signal all event FDs
-    for (auto& eventFd : eventFds)
+    for (auto &eventFd : eventFds)
     {
       eventFd->signal();
     }
@@ -329,25 +316,24 @@ TEST_CASE("Performance comparison with and without batching",
     auto start = std::chrono::high_resolution_clock::now();
 
     std::thread processor_thread(
-        [&]()
+      [&]()
+      {
+        try
+        {
+          wrapper.runTransportEventLoop(
+            epoll.fd(), -1, -1, // No special FDs
+            []() {}, []() {}, sessionHandler);
+        }
+        catch (...)
         {
-          try
-          {
-            wrapper.runTransportEventLoop(
-                epoll.fd(), -1, -1, // No special FDs
-                []() {}, []() {}, sessionHandler);
-          }
-          catch (...)
-          {
-            // Handle timeouts gracefully
-          }
-        });
+          // Handle timeouts gracefully
+        }
+      });
 
     processor_thread.join();
 
     auto end = std::chrono::high_resolution_clock::now();
-    auto duration =
-        std::chrono::duration_cast<std::chrono::microseconds>(end - start);
+    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
 
     auto stats = wrapper.getBatchingStats();
 
@@ -362,8 +348,7 @@ TEST_CASE("Performance comparison with and without batching",
       // Verify some efficiency gained from batching
       if (stats.totalEvents == numEvents)
       {
-        double eventsPerBatch =
-            static_cast<double>(stats.totalEvents) / stats.totalBatches;
+        double eventsPerBatch = static_cast<double>(stats.totalEvents) / stats.totalBatches;
         REQUIRE(eventsPerBatch >= 1.0); // At least one event per batch
       }
     }
diff --git a/tests/network/iora_test_batch_processor.cpp b/tests/network/iora_test_batch_processor.cpp
index 1dfc07d..333c600 100644
--- a/tests/network/iora_test_batch_processor.cpp
+++ b/tests/network/iora_test_batch_processor.cpp
@@ -6,9 +6,9 @@
 
 #define CATCH_CONFIG_MAIN
 #include <catch2/catch.hpp>
-#include "test_helpers.hpp"
-#include "iora_test_net_utils.hpp"
 #include "iora/network/event_batch_processor.hpp"
+#include "iora_test_net_utils.hpp"
+#include "test_helpers.hpp"
 
 using namespace std::chrono_literals;
 using namespace iora::network;
@@ -70,17 +70,17 @@ TEST_CASE("EventBatchProcessor with real epoll", "[batch][epoll]")
 
     // Process batch in background thread with short timeout
     std::thread processor_thread(
-        [&]()
+      [&]()
+      {
+        try
         {
-          try
-          {
-            processor.processBatch(epoll.fd(), generalHandler, specialHandler);
-          }
-          catch (...)
-          {
-            // Ignore timeout or other errors for this test
-          }
-        });
+          processor.processBatch(epoll.fd(), generalHandler, specialHandler);
+        }
+        catch (...)
+        {
+          // Ignore timeout or other errors for this test
+        }
+      });
 
     // Wait for processing
     processor_thread.join();
@@ -104,8 +104,7 @@ TEST_CASE("EventBatchProcessor with real epoll", "[batch][epoll]")
 
     auto specialHandler = [](int /*fd*/, uint32_t /*events*/) { return false; };
 
-    auto batchCompleteHandler =
-        [&batchSize](std::size_t size, std::chrono::microseconds /*time*/)
+    auto batchCompleteHandler = [&batchSize](std::size_t size, std::chrono::microseconds /*time*/)
     { batchSize = size; };
 
     // Signal both event fds
@@ -114,18 +113,17 @@ TEST_CASE("EventBatchProcessor with real epoll", "[batch][epoll]")
 
     // Process batch
     std::thread processor_thread(
-        [&]()
+      [&]()
+      {
+        try
         {
-          try
-          {
-            processor.processBatch(epoll.fd(), generalHandler, specialHandler,
-                                   batchCompleteHandler);
-          }
-          catch (...)
-          {
-            // Ignore errors for this test
-          }
-        });
+          processor.processBatch(epoll.fd(), generalHandler, specialHandler, batchCompleteHandler);
+        }
+        catch (...)
+        {
+          // Ignore errors for this test
+        }
+      });
 
     processor_thread.join();
 
@@ -162,8 +160,7 @@ TEST_CASE("EventBatchProcessor special FD handling", "[batch][special]")
 
     auto onEventFd = [&eventFdTriggered]() { eventFdTriggered = true; };
     auto onTimerFd = [&timerFdTriggered]() { timerFdTriggered = true; };
-    auto generalHandler = [&normalFds](int fd, uint32_t /*events*/)
-    { normalFds.push_back(fd); };
+    auto generalHandler = [&normalFds](int fd, uint32_t /*events*/) { normalFds.push_back(fd); };
 
     // Signal all fds
     eventFd.signal();
@@ -171,19 +168,18 @@ TEST_CASE("EventBatchProcessor special FD handling", "[batch][special]")
     normalFd.signal();
 
     std::thread processor_thread(
-        [&]()
+      [&]()
+      {
+        try
         {
-          try
-          {
-            processor.processBatchWithSpecialFDs(epoll.fd(), eventFd.fd(),
-                                                 timerFd.fd(), generalHandler,
-                                                 onEventFd, onTimerFd);
-          }
-          catch (...)
-          {
-            // Ignore timeout
-          }
-        });
+          processor.processBatchWithSpecialFDs(epoll.fd(), eventFd.fd(), timerFd.fd(),
+                                               generalHandler, onEventFd, onTimerFd);
+        }
+        catch (...)
+        {
+          // Ignore timeout
+        }
+      });
 
     processor_thread.join();
 
@@ -247,17 +243,17 @@ TEST_CASE("EventBatchProcessor statistics tracking", "[batch][stats]")
     auto initialStats = processor.getStats();
 
     std::thread processor_thread(
-        [&]()
+      [&]()
+      {
+        try
         {
-          try
-          {
-            processor.processBatch(epoll.fd(), generalHandler, specialHandler);
-          }
-          catch (...)
-          {
-            // Ignore timeouts
-          }
-        });
+          processor.processBatch(epoll.fd(), generalHandler, specialHandler);
+        }
+        catch (...)
+        {
+          // Ignore timeouts
+        }
+      });
 
     processor_thread.join();
 
@@ -274,18 +270,17 @@ TEST_CASE("EventBatchProcessor statistics tracking", "[batch][stats]")
     eventFd.signal();
 
     std::thread processor_thread(
-        [&]()
+      [&]()
+      {
+        try
         {
-          try
-          {
-            processor.processBatch(
-                epoll.fd(), [](int, uint32_t) {},
-                [](int, uint32_t) { return false; });
-          }
-          catch (...)
-          {
-          }
-        });
+          processor.processBatch(
+            epoll.fd(), [](int, uint32_t) {}, [](int, uint32_t) { return false; });
+        }
+        catch (...)
+        {
+        }
+      });
     processor_thread.join();
 
     processor.resetStats();
@@ -340,9 +335,8 @@ TEST_CASE("EventBatchProcessor error conditions", "[batch][error]")
     auto specialHandler = [](int, uint32_t) { return false; };
 
     // Using invalid fd should throw
-    REQUIRE_THROWS_AS(
-        processor.processBatch(-1, generalHandler, specialHandler),
-        std::system_error);
+    REQUIRE_THROWS_AS(processor.processBatch(-1, generalHandler, specialHandler),
+                      std::system_error);
   }
 
   SECTION("Configuration updates work correctly")
@@ -363,8 +357,7 @@ TEST_CASE("EventBatchProcessor error conditions", "[batch][error]")
   }
 }
 
-TEST_CASE("EventBatchProcessor performance characteristics",
-          "[batch][performance]")
+TEST_CASE("EventBatchProcessor performance characteristics", "[batch][performance]")
 {
   EpollHelper epoll;
   std::vector<std::unique_ptr<EventFdHelper>> eventFds;
@@ -400,12 +393,11 @@ TEST_CASE("EventBatchProcessor performance characteristics",
     auto specialHandler = [](int /*fd*/, uint32_t /*events*/) { return false; };
 
     auto batchCompleteHandler =
-        [&batchesProcessed](std::size_t /*size*/,
-                            std::chrono::microseconds /*time*/)
+      [&batchesProcessed](std::size_t /*size*/, std::chrono::microseconds /*time*/)
     { batchesProcessed.fetch_add(1, std::memory_order_relaxed); };
 
     // Signal all event fds
-    for (auto& eventFd : eventFds)
+    for (auto &eventFd : eventFds)
     {
       eventFd->signal();
     }
@@ -413,24 +405,22 @@ TEST_CASE("EventBatchProcessor performance characteristics",
     auto start = std::chrono::high_resolution_clock::now();
 
     std::thread processor_thread(
-        [&]()
+      [&]()
+      {
+        try
         {
-          try
-          {
-            processor.processBatch(epoll.fd(), generalHandler, specialHandler,
-                                   batchCompleteHandler);
-          }
-          catch (...)
-          {
-            // Ignore timeouts
-          }
-        });
+          processor.processBatch(epoll.fd(), generalHandler, specialHandler, batchCompleteHandler);
+        }
+        catch (...)
+        {
+          // Ignore timeouts
+        }
+      });
 
     processor_thread.join();
 
     auto end = std::chrono::high_resolution_clock::now();
-    auto duration =
-        std::chrono::duration_cast<std::chrono::microseconds>(end - start);
+    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
 
     auto stats = processor.getStats();
 
@@ -451,8 +441,7 @@ TEST_CASE("EventBatchProcessor performance characteristics",
   }
 }
 
-TEST_CASE("EventBatchProcessor concurrency stress test",
-          "[batch][stress][concurrent]")
+TEST_CASE("EventBatchProcessor concurrency stress test", "[batch][stress][concurrent]")
 {
   // This test verifies that the batch processor can handle high event rates
   EpollHelper epoll;
@@ -488,39 +477,38 @@ TEST_CASE("EventBatchProcessor concurrency stress test",
 
     // Start processor thread
     std::thread processor_thread(
-        [&]()
+      [&]()
+      {
+        while (!stopProcessing.load(std::memory_order_relaxed))
         {
-          while (!stopProcessing.load(std::memory_order_relaxed))
+          try
           {
-            try
-            {
-              processor.processBatch(epoll.fd(), generalHandler,
-                                     specialHandler);
-            }
-            catch (...)
-            {
-              // Continue on timeout or other errors
-            }
+            processor.processBatch(epoll.fd(), generalHandler, specialHandler);
           }
-        });
+          catch (...)
+          {
+            // Continue on timeout or other errors
+          }
+        }
+      });
 
     // Start signaling threads
     std::vector<std::thread> signalers;
     for (int i = 0; i < numFds; ++i)
     {
       signalers.emplace_back(
-          [&eventFds, i, signalsPerFd]()
+        [&eventFds, i, signalsPerFd]()
+        {
+          for (int j = 0; j < signalsPerFd; ++j)
           {
-            for (int j = 0; j < signalsPerFd; ++j)
-            {
-              eventFds[i]->signal();
-              std::this_thread::sleep_for(1ms); // Spread out signals
-            }
-          });
+            eventFds[i]->signal();
+            std::this_thread::sleep_for(1ms); // Spread out signals
+          }
+        });
     }
 
     // Wait for signalers to complete
-    for (auto& thread : signalers)
+    for (auto &thread : signalers)
     {
       thread.join();
     }
@@ -535,14 +523,13 @@ TEST_CASE("EventBatchProcessor concurrency stress test",
 
     // Verify we processed some events (exact count depends on timing)
     // If no batches were processed, it might be due to timing or setup issues
-    INFO("Total batches: " << stats.totalBatches
-                           << ", Total events: " << stats.totalEvents);
+    INFO("Total batches: " << stats.totalBatches << ", Total events: " << stats.totalEvents);
     INFO("Total processed: " << totalProcessed.load());
 
     // More lenient check - either batches were processed OR events were handled
     // directly
-    bool hasActivity = (stats.totalBatches > 0) || (stats.totalEvents > 0) ||
-                       (totalProcessed.load() > 0);
+    bool hasActivity =
+      (stats.totalBatches > 0) || (stats.totalEvents > 0) || (totalProcessed.load() > 0);
 
     if (!hasActivity)
     {
@@ -550,8 +537,7 @@ TEST_CASE("EventBatchProcessor concurrency stress test",
       // or system limitations
       WARN("No batch processing activity detected - may be due to test "
            "environment limitations");
-      SUCCEED(
-          "Stress test environment may not support this level of concurrency");
+      SUCCEED("Stress test environment may not support this level of concurrency");
       return;
     }
 
diff --git a/tests/network/iora_test_dns_async.cpp b/tests/network/iora_test_dns_async.cpp
index 5dd7e9c..14383b0 100644
--- a/tests/network/iora_test_dns_async.cpp
+++ b/tests/network/iora_test_dns_async.cpp
@@ -18,90 +18,98 @@
 #include <catch2/catch.hpp>
 
 #include "iora/network/dns/dns_types.hpp"
-#include <thread>
-#include <chrono>
 #include <atomic>
+#include <chrono>
+#include <thread>
 
 using namespace iora::network::dns;
 
 TEST_CASE("DNS API Design Requirements Validation", "[dns][async][api]")
 {
-    SECTION("Your design decisions implemented correctly")
-    {
-        // 1. Primary API style: Callback-first 
-        // 2. Thread model: Accept multi-threaded callbacks  
-        // 3. Error handling: Exception-based 
-        // 4. Cancellation: Simple boolean 
-        
-        bool callbackFirst = true;
-        bool multiThreadedCallbacks = true; 
-        bool exceptionBased = true;
-        bool simpleBooleanCancellation = true;
-        
-        CHECK(callbackFirst);
-        CHECK(multiThreadedCallbacks);
-        CHECK(exceptionBased);
-        CHECK(simpleBooleanCancellation);
-    }
-    
-    SECTION("Exception-based error handling design")
-    {
-        // Exception-based design means:
-        // - Callbacks receive std::exception_ptr for errors
-        // - Rich error information via exception hierarchy
-        // - Standard C++ error handling patterns
-        
-        bool usesExceptionPtr = true;
-        bool richErrorInfo = true;
-        bool standardCppPatterns = true;
-        
-        CHECK(usesExceptionPtr);
-        CHECK(richErrorInfo); 
-        CHECK(standardCppPatterns);
-    }
-    
-    SECTION("DNS types and enumerations")
-    {
-        // Verify core DNS types work
-        DnsType aType = DnsType::A;
-        DnsType aaaaType = DnsType::AAAA;
-        DnsType srvType = DnsType::SRV;
-        
-        CHECK(static_cast<uint16_t>(aType) == 1);
-        CHECK(static_cast<uint16_t>(aaaaType) == 28);
-        CHECK(static_cast<uint16_t>(srvType) == 33);
-        
-        DnsClass inClass = DnsClass::IN;
-        CHECK(static_cast<uint16_t>(inClass) == 1);
-    }
+  SECTION("Your design decisions implemented correctly")
+  {
+    // 1. Primary API style: Callback-first 
+    // 2. Thread model: Accept multi-threaded callbacks 
+    // 3. Error handling: Exception-based 
+    // 4. Cancellation: Simple boolean 
+
+    bool callbackFirst = true;
+    bool multiThreadedCallbacks = true;
+    bool exceptionBased = true;
+    bool simpleBooleanCancellation = true;
+
+    CHECK(callbackFirst);
+    CHECK(multiThreadedCallbacks);
+    CHECK(exceptionBased);
+    CHECK(simpleBooleanCancellation);
+  }
+
+  SECTION("Exception-based error handling design")
+  {
+    // Exception-based design means:
+    // - Callbacks receive std::exception_ptr for errors
+    // - Rich error information via exception hierarchy
+    // - Standard C++ error handling patterns
+
+    bool usesExceptionPtr = true;
+    bool richErrorInfo = true;
+    bool standardCppPatterns = true;
+
+    CHECK(usesExceptionPtr);
+    CHECK(richErrorInfo);
+    CHECK(standardCppPatterns);
+  }
+
+  SECTION("DNS types and enumerations")
+  {
+    // Verify core DNS types work
+    DnsType aType = DnsType::A;
+    DnsType aaaaType = DnsType::AAAA;
+    DnsType srvType = DnsType::SRV;
+
+    CHECK(static_cast<uint16_t>(aType) == 1);
+    CHECK(static_cast<uint16_t>(aaaaType) == 28);
+    CHECK(static_cast<uint16_t>(srvType) == 33);
+
+    DnsClass inClass = DnsClass::IN;
+    CHECK(static_cast<uint16_t>(inClass) == 1);
+  }
 }
 
 TEST_CASE("Async Callback Signature Validation", "[dns][async][callback]")
 {
-    SECTION("Callback signature matches your requirements")
+  SECTION("Callback signature matches your requirements")
+  {
+    // Exception-based error handling with std::exception_ptr
+    auto callback = [](std::vector<std::string> addresses, std::exception_ptr error)
     {
-        // Exception-based error handling with std::exception_ptr
-        auto callback = [](std::vector<std::string> addresses, std::exception_ptr error) {
-            if (error) {
-                try { 
-                    std::rethrow_exception(error); 
-                } catch (const std::exception& e) {
-                    // Handle DNS errors - exception-based approach
-                    std::string errorMsg = e.what();
-                    (void)errorMsg; // Use error message
-                }
-            } else {
-                // Use addresses vector
-                for (const auto& addr : addresses) {
-                    (void)addr; // Process address
-                }
-            }
-        };
-        
-        // Verify callback compiles with expected signature
-        using CallbackType = std::function<void(std::vector<std::string>, std::exception_ptr)>;
-        CallbackType cb = callback;
-        
-        CHECK(cb != nullptr);
-    }
+      if (error)
+      {
+        try
+        {
+          std::rethrow_exception(error);
+        }
+        catch (const std::exception &e)
+        {
+          // Handle DNS errors - exception-based approach
+          std::string errorMsg = e.what();
+          (void)errorMsg; // Use error message
+        }
+      }
+      else
+      {
+        // Use addresses vector
+        for (const auto &addr : addresses)
+        {
+          (void)addr; // Process address
+        }
+      }
+    };
+
+    // Verify callback compiles with expected signature
+    using CallbackType = std::function<void(std::vector<std::string>, std::exception_ptr)>;
+    CallbackType cb = callback;
+
+    CHECK(cb != nullptr);
+  }
 }
\ No newline at end of file
diff --git a/tests/network/iora_test_dns_basic.cpp b/tests/network/iora_test_dns_basic.cpp
index 6c059c9..24e1be8 100644
--- a/tests/network/iora_test_dns_basic.cpp
+++ b/tests/network/iora_test_dns_basic.cpp
@@ -20,66 +20,63 @@ using namespace iora::network::dns;
 
 TEST_CASE("DNS Message Basic Functionality", "[dns][basic]")
 {
-    SECTION("DNS question construction")
-    {
-        DnsQuestion q("example.com", DnsType::A, DnsClass::IN);
-        
-        CHECK(q.qname == "example.com");
-        CHECK(q.qtype == DnsType::A);
-        CHECK(q.qclass == DnsClass::IN);
-    }
-    
-    SECTION("DNS resource record construction") 
-    {
-        DnsResourceRecord rr;
-        rr.name = "test.example.com";
-        rr.type = DnsType::A;
-        rr.cls = DnsClass::IN;
-        rr.ttl = 3600;
-        rr.rdlength = 4;
-        rr.rdata = {192, 168, 1, 1}; // 192.168.1.1
-        
-        CHECK(rr.name == "test.example.com");
-        CHECK(rr.type == DnsType::A);
-        CHECK(rr.ttl == 3600);
-        CHECK(rr.rdlength == 4);
-        CHECK(rr.rdata.size() == 4);
-    }
+  SECTION("DNS question construction")
+  {
+    DnsQuestion q("example.com", DnsType::A, DnsClass::IN);
+
+    CHECK(q.qname == "example.com");
+    CHECK(q.qtype == DnsType::A);
+    CHECK(q.qclass == DnsClass::IN);
+  }
+
+  SECTION("DNS resource record construction")
+  {
+    DnsResourceRecord rr;
+    rr.name = "test.example.com";
+    rr.type = DnsType::A;
+    rr.cls = DnsClass::IN;
+    rr.ttl = 3600;
+    rr.rdlength = 4;
+    rr.rdata = {192, 168, 1, 1}; // 192.168.1.1
+
+    CHECK(rr.name == "test.example.com");
+    CHECK(rr.type == DnsType::A);
+    CHECK(rr.ttl == 3600);
+    CHECK(rr.rdlength == 4);
+    CHECK(rr.rdata.size() == 4);
+  }
 }
 
 TEST_CASE("DNS Message Parsing", "[dns][parsing]")
 {
-    SECTION("DNS header parsing")
-    {
-        DnsHeader header;
-        header.id = 0x1234;
-        header.qr = true;    // Response
-        header.aa = true;    // Authoritative answer
-        header.qdcount = 1;
-        header.ancount = 1;
-        header.nscount = 0;
-        header.arcount = 0;
-        
-        CHECK(header.id == 0x1234);
-        CHECK(header.qr == true);
-        CHECK(header.aa == true);
-        CHECK(header.qdcount == 1);
-        CHECK(header.ancount == 1);
-    }
+  SECTION("DNS header parsing")
+  {
+    DnsHeader header;
+    header.id = 0x1234;
+    header.qr = true; // Response
+    header.aa = true; // Authoritative answer
+    header.qdcount = 1;
+    header.ancount = 1;
+    header.nscount = 0;
+    header.arcount = 0;
+
+    CHECK(header.id == 0x1234);
+    CHECK(header.qr == true);
+    CHECK(header.aa == true);
+    CHECK(header.qdcount == 1);
+    CHECK(header.ancount == 1);
+  }
 }
 
 TEST_CASE("DNS Types and Constants", "[dns][types]")
 {
-    SECTION("DNS type enumeration")
-    {
-        CHECK(static_cast<std::uint16_t>(DnsType::A) == 1);
-        CHECK(static_cast<std::uint16_t>(DnsType::AAAA) == 28);
-        CHECK(static_cast<std::uint16_t>(DnsType::SRV) == 33);
-        CHECK(static_cast<std::uint16_t>(DnsType::SOA) == 6);
-    }
-    
-    SECTION("DNS class enumeration")
-    {
-        CHECK(static_cast<std::uint16_t>(DnsClass::IN) == 1);
-    }
+  SECTION("DNS type enumeration")
+  {
+    CHECK(static_cast<std::uint16_t>(DnsType::A) == 1);
+    CHECK(static_cast<std::uint16_t>(DnsType::AAAA) == 28);
+    CHECK(static_cast<std::uint16_t>(DnsType::SRV) == 33);
+    CHECK(static_cast<std::uint16_t>(DnsType::SOA) == 6);
+  }
+
+  SECTION("DNS class enumeration") { CHECK(static_cast<std::uint16_t>(DnsClass::IN) == 1); }
 }
\ No newline at end of file
diff --git a/tests/network/iora_test_dns_comprehensive.cpp b/tests/network/iora_test_dns_comprehensive.cpp
index 498b11e..42e9e8e 100644
--- a/tests/network/iora_test_dns_comprehensive.cpp
+++ b/tests/network/iora_test_dns_comprehensive.cpp
@@ -8,28 +8,29 @@
 /// \brief Comprehensive DNS client testing with wire-level validation
 ///
 /// This test suite provides thorough coverage of the DNS client implementation
-/// including wire-format message handling, network behavior simulation, 
+/// including wire-format message handling, network behavior simulation,
 /// compression edge cases, and all RFC compliance aspects.
 
 #define CATCH_CONFIG_MAIN
 #include <catch2/catch.hpp>
 
-#include "iora/network/dns_client.hpp"
-#include "iora/network/dns/dns_transport.hpp"
+#include "MockDnsServer.hpp"
 #include "iora/network/dns/dns_cache.hpp"
 #include "iora/network/dns/dns_resolver.hpp"
+#include "iora/network/dns/dns_transport.hpp"
 #include "iora/network/dns/dns_types.hpp"
-#include "MockDnsServer.hpp"
+#include "iora/network/dns_client.hpp"
 
-#include <thread>
 #include <chrono>
 #include <future>
 #include <random>
+#include <thread>
 
 using namespace iora::network::dns;
 using iora::network::DnsClient;
 
-namespace {
+namespace
+{
 
 /// \brief Test configuration constants
 constexpr std::uint16_t TEST_UDP_PORT = 15353; // Non-standard port for testing
@@ -38,61 +39,63 @@ constexpr std::chrono::milliseconds ASYNC_TIMEOUT{2000};
 constexpr std::chrono::milliseconds SERVER_STARTUP_DELAY{200};
 
 /// \brief Test fixture for DNS client testing
-class DnsTestFixture 
+class DnsTestFixture
 {
 public:
-    DnsTestFixture() 
-    {
-        // Configure mock server for comprehensive testing
-        MockDnsServer::Config serverConfig;
-        serverConfig.udpPort = TEST_UDP_PORT;
-        serverConfig.tcpPort = TEST_TCP_PORT;
-        serverConfig.enableLogging = true;
-        serverConfig.maxUdpSize = 512; // Standard DNS UDP size limit
-        serverConfig.maxTcpFragmentSize = 64; // Small fragments for testing
-        
-        mockServer_ = std::make_unique<MockDnsServer>(serverConfig);
-        
-        // Configure DNS client to use test server
-        DnsConfig clientConfig;
-        clientConfig.servers = {"127.0.0.1"};
-        clientConfig.port = TEST_UDP_PORT;
-        clientConfig.timeout = std::chrono::milliseconds(1000);
-        clientConfig.retryCount = 2;
-        clientConfig.transportMode = DnsTransportMode::Both; // Test UDP->TCP fallback
-        clientConfig.enableCache = true;
-        clientConfig.maxCacheSize = 1000;
-        
-        dnsClient_ = std::make_unique<DnsClient>(clientConfig);
-    }
-    
-    ~DnsTestFixture() 
+  DnsTestFixture()
+  {
+    // Configure mock server for comprehensive testing
+    MockDnsServer::Config serverConfig;
+    serverConfig.udpPort = TEST_UDP_PORT;
+    serverConfig.tcpPort = TEST_TCP_PORT;
+    serverConfig.enableLogging = true;
+    serverConfig.maxUdpSize = 512;        // Standard DNS UDP size limit
+    serverConfig.maxTcpFragmentSize = 64; // Small fragments for testing
+
+    mockServer_ = std::make_unique<MockDnsServer>(serverConfig);
+
+    // Configure DNS client to use test server
+    DnsConfig clientConfig;
+    std::vector<std::string> testServers = {"127.0.0.1:" + std::to_string(TEST_UDP_PORT)};
+    clientConfig.setServers(testServers);
+    clientConfig.timeout = std::chrono::milliseconds(1000);
+    clientConfig.retryCount = 2;
+    clientConfig.transportMode = DnsTransportMode::Both; // Test UDP->TCP fallback
+    clientConfig.enableCache = true;
+    clientConfig.maxCacheSize = 1000;
+
+    dnsClient_ = std::make_unique<DnsClient>(clientConfig);
+  }
+
+  ~DnsTestFixture()
+  {
+    // Destroy client first to stop any ongoing operations
+    dnsClient_.reset();
+
+    if (mockServer_)
     {
-        // Destroy client first to stop any ongoing operations
-        dnsClient_.reset();
-        
-        if (mockServer_) {
-            mockServer_->stop();
-        }
+      mockServer_->stop();
     }
-    
-    void startServer() 
+  }
+
+  void startServer()
+  {
+    // Stop server if already running (for section isolation)
+    if (mockServer_)
     {
-        // Stop server if already running (for section isolation)
-        if (mockServer_) {
-            mockServer_->stop();
-            std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Allow cleanup
-        }
-        REQUIRE(mockServer_->start());
-        std::this_thread::sleep_for(SERVER_STARTUP_DELAY);
+      mockServer_->stop();
+      std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Allow cleanup
     }
-    
-    MockDnsServer& server() { return *mockServer_; }
-    DnsClient& client() { return *dnsClient_; }
-    
+    REQUIRE(mockServer_->start());
+    std::this_thread::sleep_for(SERVER_STARTUP_DELAY);
+  }
+
+  MockDnsServer &server() { return *mockServer_; }
+  DnsClient &client() { return *dnsClient_; }
+
 private:
-    std::unique_ptr<MockDnsServer> mockServer_;
-    std::unique_ptr<DnsClient> dnsClient_;
+  std::unique_ptr<MockDnsServer> mockServer_;
+  std::unique_ptr<DnsClient> dnsClient_;
 };
 
 } // anonymous namespace
@@ -103,269 +106,271 @@ private:
 
 TEST_CASE_METHOD(DnsTestFixture, "DNS Client Basic A Record Resolution", "[dns][basic]")
 {
-    startServer();
-    
-    // Setup basic A record
-    server().addRecord({"test.example.com", "A", "192.168.1.100", 3600});
-    // Add AAAA record to prevent fallback queries from hanging
-    server().addRecord({"test.example.com", "AAAA", "2001:db8::1", 3600});
-    
-    // Direct test without SECTION
-    auto results = client().resolveA("test.example.com");
-    
-    REQUIRE(results.size() == 1);
-    CHECK(results[0] == "192.168.1.100");
+  startServer();
+
+  // Setup basic A record
+  server().addRecord({"test.example.com", "A", "192.168.1.100", 3600});
+  // Add AAAA record to prevent fallback queries from hanging
+  server().addRecord({"test.example.com", "AAAA", "2001:db8::1", 3600});
+
+  // Direct test without SECTION
+  auto results = client().resolveA("test.example.com");
+
+  REQUIRE(results.size() == 1);
+  CHECK(results[0] == "192.168.1.100");
 }
 
 TEST_CASE_METHOD(DnsTestFixture, "DNS Client Additional A Record Tests", "[dns][basic]")
 {
-    startServer();
-    
-    SECTION("Different hostname test") 
-    {
-        // Test with different hostname to verify multiple queries work
-        server().addRecord({"test2.example.com", "A", "192.168.1.101", 3600});
-        
-        auto results = client().resolveA("test2.example.com");
-        REQUIRE(results.size() == 1);
-        CHECK(results[0] == "192.168.1.101");
-    }
-    
-    SECTION("Multiple A records for same domain") 
-    {
-        server().addRecord({"multi.example.com", "A", "192.168.1.10", 3600});
-        server().addRecord({"multi.example.com", "A", "192.168.1.11", 3600});
-        server().addRecord({"multi.example.com", "A", "192.168.1.12", 3600});
-        
-        auto results = client().resolveA("multi.example.com");
-        
-        REQUIRE(results.size() == 3);
-        CHECK(std::find(results.begin(), results.end(), "192.168.1.10") != results.end());
-        CHECK(std::find(results.begin(), results.end(), "192.168.1.11") != results.end());
-        CHECK(std::find(results.begin(), results.end(), "192.168.1.12") != results.end());
-    }
+  startServer();
+
+  SECTION("Different hostname test")
+  {
+    // Test with different hostname to verify multiple queries work
+    server().addRecord({"test2.example.com", "A", "192.168.1.101", 3600});
+
+    auto results = client().resolveA("test2.example.com");
+    REQUIRE(results.size() == 1);
+    CHECK(results[0] == "192.168.1.101");
+  }
+
+  SECTION("Multiple A records for same domain")
+  {
+    server().addRecord({"multi.example.com", "A", "192.168.1.10", 3600});
+    server().addRecord({"multi.example.com", "A", "192.168.1.11", 3600});
+    server().addRecord({"multi.example.com", "A", "192.168.1.12", 3600});
+
+    auto results = client().resolveA("multi.example.com");
+
+    REQUIRE(results.size() == 3);
+    CHECK(std::find(results.begin(), results.end(), "192.168.1.10") != results.end());
+    CHECK(std::find(results.begin(), results.end(), "192.168.1.11") != results.end());
+    CHECK(std::find(results.begin(), results.end(), "192.168.1.12") != results.end());
+  }
 }
 
 TEST_CASE_METHOD(DnsTestFixture, "DNS Client AAAA Record Resolution", "[dns][basic][ipv6]")
 {
-    startServer();
-    
-    server().addRecord({"ipv6.example.com", "AAAA", "2001:db8::1", 3600});
-    server().addRecord({"ipv6.example.com", "AAAA", "2001:db8::2", 3600});
-    
-    auto results = client().resolveAAAA("ipv6.example.com");
-    
-    REQUIRE(results.size() == 2);
-    CHECK(std::find(results.begin(), results.end(), "2001:db8::1") != results.end());
-    CHECK(std::find(results.begin(), results.end(), "2001:db8::2") != results.end());
+  startServer();
+
+  server().addRecord({"ipv6.example.com", "AAAA", "2001:db8::1", 3600});
+  server().addRecord({"ipv6.example.com", "AAAA", "2001:db8::2", 3600});
+
+  auto results = client().resolveAAAA("ipv6.example.com");
+
+  REQUIRE(results.size() == 2);
+  CHECK(std::find(results.begin(), results.end(), "2001:db8::1") != results.end());
+  CHECK(std::find(results.begin(), results.end(), "2001:db8::2") != results.end());
 }
 
 // =============================================================================
 // SERVICE DISCOVERY TESTS (RFC 3263)
 // =============================================================================
 
-TEST_CASE_METHOD(DnsTestFixture, "DNS Service Discovery SRV Records", "[dns][srv][service-discovery]")
+TEST_CASE_METHOD(DnsTestFixture, "DNS Service Discovery SRV Records",
+                 "[dns][srv][service-discovery]")
 {
-    startServer();
-    
-    SECTION("Basic SRV record resolution") 
+  startServer();
+
+  SECTION("Basic SRV record resolution")
+  {
+    server().addRecord({"_sip._udp.example.com", "SRV", "sip1.example.com", 3600, 10, 5, 5060});
+    server().addRecord({"_sip._udp.example.com", "SRV", "sip2.example.com", 3600, 20, 10, 5061});
+    server().addRecord({"sip1.example.com", "A", "192.168.1.10", 3600});
+    server().addRecord({"sip2.example.com", "A", "192.168.1.11", 3600});
+
+    auto result = client().resolveServiceDomain("example.com");
+
+    REQUIRE_FALSE(result.targets.empty());
+
+    // Should have resolved SRV records and their A records
+    bool foundSip1 = false, foundSip2 = false;
+    for (const auto &target : result.targets)
     {
-        server().addRecord({"_sip._udp.example.com", "SRV", "sip1.example.com", 3600, 10, 5, 5060});
-        server().addRecord({"_sip._udp.example.com", "SRV", "sip2.example.com", 3600, 20, 10, 5061});
-        server().addRecord({"sip1.example.com", "A", "192.168.1.10", 3600});
-        server().addRecord({"sip2.example.com", "A", "192.168.1.11", 3600});
-        
-        auto result = client().resolveServiceDomain("example.com");
-        
-        REQUIRE_FALSE(result.targets.empty());
-        
-        // Should have resolved SRV records and their A records
-        bool foundSip1 = false, foundSip2 = false;
-        for (const auto& target : result.targets) 
-        {
-            if (target.hostname == "sip1.example.com" && target.port == 5060) {
-                foundSip1 = true;
-                CHECK(target.priority == 10);
-                CHECK(target.weight == 5);
-            }
-            if (target.hostname == "sip2.example.com" && target.port == 5061) {
-                foundSip2 = true;
-                CHECK(target.priority == 20);
-                CHECK(target.weight == 10);
-            }
-        }
-        
-        CHECK(foundSip1);
-        CHECK(foundSip2);
+      if (target.hostname == "sip1.example.com" && target.port == 5060)
+      {
+        foundSip1 = true;
+        CHECK(target.priority == 10);
+        CHECK(target.weight == 5);
+      }
+      if (target.hostname == "sip2.example.com" && target.port == 5061)
+      {
+        foundSip2 = true;
+        CHECK(target.priority == 20);
+        CHECK(target.weight == 10);
+      }
     }
-    
-    // Weighted SRV selection test temporarily disabled
-    // due to MockDnsServer implementation requirements
+
+    CHECK(foundSip1);
+    CHECK(foundSip2);
+  }
+
+  // Weighted SRV selection test temporarily disabled
+  // due to MockDnsServer implementation requirements
 }
 
 // =============================================================================
 // WIRE-FORMAT AND NETWORK BEHAVIOR TESTS
 // =============================================================================
 
-TEST_CASE_METHOD(DnsTestFixture, "DNS Parser Compression Pointer Security", "[dns][parser][security]")
+TEST_CASE_METHOD(DnsTestFixture, "DNS Parser Compression Pointer Security",
+                 "[dns][parser][security]")
 {
-    SECTION("Compression pointer loop detection") 
-    {
-        // Create malicious DNS message with pointer loop
-        // Message format: Header(12) + Question(varies) + Answer with pointer loop
-        
-        std::vector<std::uint8_t> maliciousMessage = {
-            // DNS Header (12 bytes)
-            0x12, 0x34,  // Query ID
-            0x81, 0x80,  // Flags: QR=1, OPCODE=0, AA=0, TC=0, RD=1, RA=1, Z=0, RCODE=0
-            0x00, 0x01,  // QDCOUNT=1
-            0x00, 0x01,  // ANCOUNT=1  
-            0x00, 0x00,  // NSCOUNT=0
-            0x00, 0x00,  // ARCOUNT=0
-            
-            // Question section: "test.com" A IN
-            0x04, 't', 'e', 's', 't',  // label "test"
-            0x03, 'c', 'o', 'm',       // label "com"
-            0x00,                      // null terminator
-            0x00, 0x01,               // QTYPE=A
-            0x00, 0x01,               // QCLASS=IN
-            
-            // Answer section with compression pointer loop
-            0xc0, 0x0c,               // NAME: pointer to offset 12 (question name)
-            0x00, 0x01,               // TYPE=A
-            0x00, 0x01,               // CLASS=IN
-            0x00, 0x00, 0x0e, 0x10,   // TTL=3600
-            0x00, 0x04,               // RDLENGTH=4
-            
-            // RDATA with pointer loop: points back to itself
-            0xc0, 0x20,               // Pointer to offset 32 (points to this very pointer!)
-            0x00, 0x00                // Padding to make RDLENGTH=4
-        };
-        
-        // Test that DnsMessage throws on pointer loop
-        REQUIRE_THROWS_AS(DnsMessage::parse(maliciousMessage), DnsParseException);
-    }
-    
-    SECTION("Compression pointer beyond bounds") 
-    {
-        std::vector<std::uint8_t> maliciousMessage = {
-            // DNS Header
-            0x12, 0x34,  // Query ID
-            0x81, 0x80,  // Flags
-            0x00, 0x01,  // QDCOUNT=1
-            0x00, 0x01,  // ANCOUNT=1
-            0x00, 0x00,  // NSCOUNT=0
-            0x00, 0x00,  // ARCOUNT=0
-            
-            // Question section
-            0x04, 't', 'e', 's', 't',
-            0x03, 'c', 'o', 'm',
-            0x00,
-            0x00, 0x01,  // TYPE=A
-            0x00, 0x01,  // CLASS=IN
-            
-            // Answer section
-            0xc0, 0x0c,               // NAME: pointer to question
-            0x00, 0x01,               // TYPE=A
-            0x00, 0x01,               // CLASS=IN
-            0x00, 0x00, 0x0e, 0x10,   // TTL
-            0x00, 0x02,               // RDLENGTH=2
-            
-            // RDATA with pointer beyond message bounds
-            0xc0, 0xFF                // Pointer to offset 255 (beyond message!)
-        };
-        
-        REQUIRE_THROWS_AS(DnsMessage::parse(maliciousMessage), DnsParseException);
-    }
-    
-    SECTION("Compression pointer to non-label position") 
-    {
-        std::vector<std::uint8_t> maliciousMessage = {
-            // DNS Header
-            0x12, 0x34, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
-            
-            // Question section  
-            0x04, 't', 'e', 's', 't', 0x03, 'c', 'o', 'm', 0x00,
-            0x00, 0x01, 0x00, 0x01,
-            
-            // Answer section
-            0xc0, 0x0c,               // NAME: pointer to question
-            0x00, 0x01,               // TYPE=A
-            0x00, 0x01,               // CLASS=IN  
-            0x00, 0x00, 0x0e, 0x10,   // TTL
-            0x00, 0x02,               // RDLENGTH=2
-            
-            // RDATA with pointer to middle of TYPE field (invalid position)
-            0xc0, 0x1a                // Pointer to offset 26 (middle of question TYPE)
-        };
-        
-        REQUIRE_THROWS_AS(DnsMessage::parse(maliciousMessage), DnsParseException);
-    }
+  SECTION("Compression pointer loop detection")
+  {
+    // Create malicious DNS message with pointer loop
+    // Message format: Header(12) + Question(varies) + Answer with pointer loop
+
+    std::vector<std::uint8_t> maliciousMessage = {
+      // DNS Header (12 bytes)
+      0x12, 0x34, // Query ID
+      0x81, 0x80, // Flags: QR=1, OPCODE=0, AA=0, TC=0, RD=1, RA=1, Z=0, RCODE=0
+      0x00, 0x01, // QDCOUNT=1
+      0x00, 0x01, // ANCOUNT=1
+      0x00, 0x00, // NSCOUNT=0
+      0x00, 0x00, // ARCOUNT=0
+
+      // Question section: "test.com" A IN
+      0x04, 't', 'e', 's', 't', // label "test"
+      0x03, 'c', 'o', 'm',      // label "com"
+      0x00,                     // null terminator
+      0x00, 0x01,               // QTYPE=A
+      0x00, 0x01,               // QCLASS=IN
+
+      // Answer section with compression pointer loop
+      0xc0, 0x0c,             // NAME: pointer to offset 12 (question name)
+      0x00, 0x01,             // TYPE=A
+      0x00, 0x01,             // CLASS=IN
+      0x00, 0x00, 0x0e, 0x10, // TTL=3600
+      0x00, 0x04,             // RDLENGTH=4
+
+      // RDATA with pointer loop: points back to itself
+      0xc0, 0x20, // Pointer to offset 32 (points to this very pointer!)
+      0x00, 0x00  // Padding to make RDLENGTH=4
+    };
+
+    // Test that DnsMessage throws on pointer loop
+    REQUIRE_THROWS_AS(DnsMessage::parse(maliciousMessage), DnsParseException);
+  }
+
+  SECTION("Compression pointer beyond bounds")
+  {
+    std::vector<std::uint8_t> maliciousMessage = {
+      // DNS Header
+      0x12, 0x34, // Query ID
+      0x81, 0x80, // Flags
+      0x00, 0x01, // QDCOUNT=1
+      0x00, 0x01, // ANCOUNT=1
+      0x00, 0x00, // NSCOUNT=0
+      0x00, 0x00, // ARCOUNT=0
+
+      // Question section
+      0x04, 't', 'e', 's', 't', 0x03, 'c', 'o', 'm', 0x00, 0x00, 0x01, // TYPE=A
+      0x00, 0x01,                                                      // CLASS=IN
+
+      // Answer section
+      0xc0, 0x0c,             // NAME: pointer to question
+      0x00, 0x01,             // TYPE=A
+      0x00, 0x01,             // CLASS=IN
+      0x00, 0x00, 0x0e, 0x10, // TTL
+      0x00, 0x02,             // RDLENGTH=2
+
+      // RDATA with pointer beyond message bounds
+      0xc0, 0xFF // Pointer to offset 255 (beyond message!)
+    };
+
+    REQUIRE_THROWS_AS(DnsMessage::parse(maliciousMessage), DnsParseException);
+  }
+
+  SECTION("Compression pointer to non-label position")
+  {
+    std::vector<std::uint8_t> maliciousMessage = {
+      // DNS Header
+      0x12, 0x34, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+
+      // Question section
+      0x04, 't', 'e', 's', 't', 0x03, 'c', 'o', 'm', 0x00, 0x00, 0x01, 0x00, 0x01,
+
+      // Answer section
+      0xc0, 0x0c,             // NAME: pointer to question
+      0x00, 0x01,             // TYPE=A
+      0x00, 0x01,             // CLASS=IN
+      0x00, 0x00, 0x0e, 0x10, // TTL
+      0x00, 0x02,             // RDLENGTH=2
+
+      // RDATA with pointer to middle of TYPE field (invalid position)
+      0xc0, 0x1a // Pointer to offset 26 (middle of question TYPE)
+    };
+
+    REQUIRE_THROWS_AS(DnsMessage::parse(maliciousMessage), DnsParseException);
+  }
 }
 
-TEST_CASE_METHOD(DnsTestFixture, "DNS UDP Truncation and TCP Fallback", "[dns][transport][truncation]")
+TEST_CASE_METHOD(DnsTestFixture, "DNS UDP Truncation and TCP Fallback",
+                 "[dns][transport][truncation]")
 {
-    startServer();
-    
-    SECTION("TC bit triggers TCP fallback")
-    {
-        // NOTE: This test requires wire-mode MockDnsServer capabilities
-        // Current MockDnsServer works at record level, not wire level
-        // TODO: Implement wire-mode mock to send raw DNS bytes with TC bit
-        
-        INFO("Test requires wire-mode MockDnsServer implementation");
-        INFO("Required capabilities:");
-        INFO("1. Send UDP response with TC (truncation) bit set");
-        INFO("2. Send full TCP response when client retries over TCP");
-        INFO("3. Verify transport layer handles UDPTCP fallback correctly");
-        
-        // Placeholder test structure for when wire-mode mock is available:
-        /*
-        // Setup large response that would require TCP
-        server().addLargeRecord("large.example.com", "TXT", largeTextRecord);
-        
-        // Configure UDP to return truncated response (TC=1)
-        MockDnsServer::WireConfig udpConfig;
-        udpConfig.setTruncationFlag = true;
-        udpConfig.protocol = ProtocolType::UDP;
-        server().configureWireResponse("large.example.com", udpConfig);
-        
-        // Configure TCP to return full response
-        MockDnsServer::WireConfig tcpConfig;
-        tcpConfig.setTruncationFlag = false;
-        tcpConfig.protocol = ProtocolType::TCP;
-        server().configureWireResponse("large.example.com", tcpConfig);
-        
-        // Query should automatically fallback to TCP and succeed
-        auto result = client().resolveTXT("large.example.com");
-        CHECK_FALSE(result.empty());
-        
-        // Verify both UDP and TCP were used
-        auto stats = server().getStats();
-        CHECK(stats.udpQueries > 0);  // Initial UDP attempt
-        CHECK(stats.tcpQueries > 0);  // TCP fallback
-        */
-        
-        WARN("UDP Truncation  TCP fallback test requires wire-mode MockDnsServer");
-    }
+  startServer();
+
+  SECTION("TC bit triggers TCP fallback")
+  {
+    // NOTE: This test requires wire-mode MockDnsServer capabilities
+    // Current MockDnsServer works at record level, not wire level
+    // TODO: Implement wire-mode mock to send raw DNS bytes with TC bit
+
+    INFO("Test requires wire-mode MockDnsServer implementation");
+    INFO("Required capabilities:");
+    INFO("1. Send UDP response with TC (truncation) bit set");
+    INFO("2. Send full TCP response when client retries over TCP");
+    INFO("3. Verify transport layer handles UDPTCP fallback correctly");
+
+    // Placeholder test structure for when wire-mode mock is available:
+    /*
+    // Setup large response that would require TCP
+    server().addLargeRecord("large.example.com", "TXT", largeTextRecord);
+
+    // Configure UDP to return truncated response (TC=1)
+    MockDnsServer::WireConfig udpConfig;
+    udpConfig.setTruncationFlag = true;
+    udpConfig.protocol = ProtocolType::UDP;
+    server().configureWireResponse("large.example.com", udpConfig);
+
+    // Configure TCP to return full response
+    MockDnsServer::WireConfig tcpConfig;
+    tcpConfig.setTruncationFlag = false;
+    tcpConfig.protocol = ProtocolType::TCP;
+    server().configureWireResponse("large.example.com", tcpConfig);
+
+    // Query should automatically fallback to TCP and succeed
+    auto result = client().resolveTXT("large.example.com");
+    CHECK_FALSE(result.empty());
+
+    // Verify both UDP and TCP were used
+    auto stats = server().getStats();
+    CHECK(stats.udpQueries > 0);  // Initial UDP attempt
+    CHECK(stats.tcpQueries > 0);  // TCP fallback
+    */
+
+    WARN("UDP Truncation  TCP fallback test requires wire-mode MockDnsServer");
+  }
 }
 
-TEST_CASE_METHOD(DnsTestFixture, "DNS TCP Fragmentation Reassembly", "[dns][transport][tcp][fragmentation]")
+TEST_CASE_METHOD(DnsTestFixture, "DNS TCP Fragmentation Reassembly",
+                 "[dns][transport][tcp][fragmentation]")
 {
-    startServer();
-    
-    SECTION("TCP response fragmentation handling")
-    {
-        // NOTE: This test requires wire-mode MockDnsServer with TCP fragmentation
-        INFO("Test requires wire-mode MockDnsServer with TCP fragmentation support");
-        INFO("Required capabilities:");
-        INFO("1. Fragment TCP responses across multiple send() calls");
-        INFO("2. Test 2-byte length prefix fragmentation");
-        INFO("3. Test DNS message payload fragmentation");
-        INFO("4. Verify transport correctly reassembles fragmented TCP responses");
-        
-        WARN("TCP fragmentation test requires enhanced MockDnsServer");
-    }
+  startServer();
+
+  SECTION("TCP response fragmentation handling")
+  {
+    // NOTE: This test requires wire-mode MockDnsServer with TCP fragmentation
+    INFO("Test requires wire-mode MockDnsServer with TCP fragmentation support");
+    INFO("Required capabilities:");
+    INFO("1. Fragment TCP responses across multiple send() calls");
+    INFO("2. Test 2-byte length prefix fragmentation");
+    INFO("3. Test DNS message payload fragmentation");
+    INFO("4. Verify transport correctly reassembles fragmented TCP responses");
+
+    WARN("TCP fragmentation test requires enhanced MockDnsServer");
+  }
 }
 
 // =============================================================================
@@ -374,59 +379,60 @@ TEST_CASE_METHOD(DnsTestFixture, "DNS TCP Fragmentation Reassembly", "[dns][tran
 
 TEST_CASE_METHOD(DnsTestFixture, "DNS Caching and TTL Handling", "[dns][cache][ttl]")
 {
-    startServer();
-    
-    SECTION("Positive cache hit") 
-    {
-        server().addRecord({"cached.example.com", "A", "192.168.1.50", 300}); // 5 min TTL
-        
-        // First query - cache miss
-        auto results1 = client().resolveA("cached.example.com");
-        REQUIRE(results1.size() == 1);
-        
-        auto stats1 = server().getStats();
-        auto udpQueries1 = stats1.udpQueries;
-        
-        // Second query - should be cache hit (no network query)
-        auto results2 = client().resolveA("cached.example.com");
-        REQUIRE(results2.size() == 1);
-        CHECK(results1[0] == results2[0]);
-        
-        auto stats2 = server().getStats();
-        CHECK(stats2.udpQueries == udpQueries1); // No additional network queries
-    }
-    
-    SECTION("Negative caching with SOA minimum (RFC 2308)")
+  startServer();
+
+  SECTION("Positive cache hit")
+  {
+    server().addRecord({"cached.example.com", "A", "192.168.1.50", 300}); // 5 min TTL
+
+    // First query - cache miss
+    auto results1 = client().resolveA("cached.example.com");
+    REQUIRE(results1.size() == 1);
+
+    auto stats1 = server().getStats();
+    auto udpQueries1 = stats1.udpQueries;
+
+    // Second query - should be cache hit (no network query)
+    auto results2 = client().resolveA("cached.example.com");
+    REQUIRE(results2.size() == 1);
+    CHECK(results1[0] == results2[0]);
+
+    auto stats2 = server().getStats();
+    CHECK(stats2.udpQueries == udpQueries1); // No additional network queries
+  }
+
+  SECTION("Negative caching with SOA minimum (RFC 2308)")
+  {
+    // Setup SOA record for negative caching
+    // SOA format: MNAME RNAME SERIAL REFRESH RETRY EXPIRE MINIMUM
+    std::string soaData = "ns1.example.com. admin.example.com. 2023010101 3600 1800 604800 300";
+    server().addRecord({"example.com", "SOA", soaData, 3600});
+
+    // NOTE: This test requires MockDnsServer NXDOMAIN support
+    // MockDnsServer::QueryConfig nxConfig;
+    // nxConfig.shouldReturnNXDOMAIN = true;
+    // nxConfig.includeSOAInAuthority = true;
+    // server().configureQuery("nonexistent.example.com", nxConfig);
+
+    // First query - should get NXDOMAIN and cache the negative result
+    REQUIRE_THROWS_AS(client().resolveA("nonexistent.example.com"), DnsResolverException);
+
+    auto stats1 = server().getStats();
+    auto udpQueries1 = stats1.udpQueries;
+
+    // Second query - should hit negative cache (no network query)
+    REQUIRE_THROWS_AS(client().resolveA("nonexistent.example.com"), DnsResolverException);
+
+    auto stats2 = server().getStats();
+    CHECK(stats2.udpQueries == udpQueries1); // No additional queries due to negative cache
+
+    // Verify cache contains negative entry with SOA.minimum TTL
+    if (client().isCacheEnabled())
     {
-        // Setup SOA record for negative caching
-        // SOA format: MNAME RNAME SERIAL REFRESH RETRY EXPIRE MINIMUM
-        std::string soaData = "ns1.example.com. admin.example.com. 2023010101 3600 1800 604800 300";
-        server().addRecord({"example.com", "SOA", soaData, 3600});
-        
-        // NOTE: This test requires MockDnsServer NXDOMAIN support  
-        // MockDnsServer::QueryConfig nxConfig;
-        // nxConfig.shouldReturnNXDOMAIN = true;
-        // nxConfig.includeSOAInAuthority = true;
-        // server().configureQuery("nonexistent.example.com", nxConfig);
-        
-        // First query - should get NXDOMAIN and cache the negative result
-        REQUIRE_THROWS_AS(client().resolveA("nonexistent.example.com"), DnsResolverException);
-        
-        auto stats1 = server().getStats();
-        auto udpQueries1 = stats1.udpQueries;
-        
-        // Second query - should hit negative cache (no network query)
-        REQUIRE_THROWS_AS(client().resolveA("nonexistent.example.com"), DnsResolverException);
-        
-        auto stats2 = server().getStats();
-        CHECK(stats2.udpQueries == udpQueries1); // No additional queries due to negative cache
-        
-        // Verify cache contains negative entry with SOA.minimum TTL
-        if (client().isCacheEnabled()) {
-            auto cacheStats = client().getCacheStats();
-            CHECK(cacheStats.negative_hits == cacheStats.negative_hits); // Just check field exists
-        }
+      auto cacheStats = client().getCacheStats();
+      CHECK(cacheStats.negative_hits == cacheStats.negative_hits); // Just check field exists
     }
+  }
 }
 
 // =============================================================================
@@ -435,33 +441,83 @@ TEST_CASE_METHOD(DnsTestFixture, "DNS Caching and TTL Handling", "[dns][cache][t
 
 TEST_CASE_METHOD(DnsTestFixture, "DNS Error Handling", "[dns][error-handling]")
 {
-    startServer();
-    
-    SECTION("Timeout handling") 
+  startServer();
+
+  SECTION("Timeout handling")
+  {
+    MockDnsServer::QueryConfig timeoutConfig;
+    timeoutConfig.shouldTimeout = true;
+    timeoutConfig.delay = std::chrono::milliseconds(5000);
+    server().configureQuery("timeout.example.com", timeoutConfig);
+
+    REQUIRE_THROWS_AS(client().resolveA("timeout.example.com"), DnsTimeoutException);
+  }
+
+  SECTION("Very short timeout handling (50ms)")
+  {
+    // Create a client with very short timeout to test transport layer timeout precision
+    DnsConfig shortTimeoutConfig;
+    std::vector<std::string> shortTimeoutServers = {"127.0.0.1:" + std::to_string(TEST_UDP_PORT)};
+    shortTimeoutConfig.setServers(shortTimeoutServers);
+    shortTimeoutConfig.timeout = std::chrono::milliseconds(50); // Very short timeout
+    shortTimeoutConfig.retryCount = 0; // No retries to ensure we test raw timeout
+    shortTimeoutConfig.transportMode = DnsTransportMode::UDP;
+    shortTimeoutConfig.enableCache = false; // Disable cache to ensure network query
+
+    DnsClient shortTimeoutClient(shortTimeoutConfig);
+
+    // Configure mock server to delay response longer than timeout
+    MockDnsServer::QueryConfig delayConfig;
+    delayConfig.delay = std::chrono::milliseconds(200); // 200ms delay > 50ms timeout
+    server().configureQuery("shorttimeout.example.com", delayConfig);
+
+    // Measure actual timeout duration
+    auto startTime = std::chrono::steady_clock::now();
+
+    // Should timeout quickly (around 50ms, not wait for 200ms delay)
+    try
     {
-        MockDnsServer::QueryConfig timeoutConfig;
-        timeoutConfig.shouldTimeout = true;
-        timeoutConfig.delay = std::chrono::milliseconds(5000);
-        server().configureQuery("timeout.example.com", timeoutConfig);
-        
-        REQUIRE_THROWS_AS(client().resolveA("timeout.example.com"), DnsTimeoutException);
+      shortTimeoutClient.resolveA("shorttimeout.example.com");
+      FAIL("Expected DNS resolution to throw exception");
     }
-    
-    SECTION("NXDOMAIN handling") 
+    catch (const DnsTimeoutException &e)
     {
-        // Query for non-configured domain
-        REQUIRE_THROWS_AS(client().resolveA("nonexistent.example.com"), DnsResolverException);
+      INFO("Got expected DnsTimeoutException: " << e.what());
     }
-    
-    SECTION("Server failure simulation") 
+    catch (const std::exception &e)
     {
-        MockDnsServer::QueryConfig failConfig;
-        failConfig.shouldFail = true;
-        failConfig.errorMessage = "Server failure";
-        server().configureQuery("serverfail.example.com", failConfig);
-        
-        REQUIRE_THROWS_AS(client().resolveA("serverfail.example.com"), DnsResolverException);
+      INFO("Got unexpected exception type: " << e.what());
+      INFO("This indicates the DNS timeout is NOT working correctly!");
+      FAIL("Expected DnsTimeoutException but got different exception type");
     }
+
+    auto endTime = std::chrono::steady_clock::now();
+    auto actualDuration =
+      std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
+
+    // Verify timeout happened quickly (allow some tolerance for system scheduling)
+    CHECK(actualDuration.count() < 150); // Should be much less than 200ms server delay
+    CHECK(actualDuration.count() > 30);  // But at least close to 50ms timeout
+
+    INFO("Configured timeout: 50ms, Server delay: 200ms, Actual duration: "
+         << actualDuration.count() << "ms");
+  }
+
+  SECTION("NXDOMAIN handling")
+  {
+    // Query for non-configured domain
+    REQUIRE_THROWS_AS(client().resolveA("nonexistent.example.com"), DnsResolverException);
+  }
+
+  SECTION("Server failure simulation")
+  {
+    MockDnsServer::QueryConfig failConfig;
+    failConfig.shouldFail = true;
+    failConfig.errorMessage = "Server failure";
+    server().configureQuery("serverfail.example.com", failConfig);
+
+    REQUIRE_THROWS_AS(client().resolveA("serverfail.example.com"), DnsResolverException);
+  }
 }
 
 // =============================================================================
@@ -470,184 +526,199 @@ TEST_CASE_METHOD(DnsTestFixture, "DNS Error Handling", "[dns][error-handling]")
 
 TEST_CASE_METHOD(DnsTestFixture, "IPv6 Reverse DNS (ip6.arpa)", "[dns][ipv6][reverse]")
 {
-    startServer();
-    
-    SECTION("IPv6 address to reverse DNS format") 
-    {
-        // Test the IPv6 reverse DNS implementation
-        std::string ipv6 = "2001:db8::1";
-        std::string expected = "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa";
-        
-        // Create temporary DnsClient to access createReverseQuery
-        DnsClient tempClient;
-        // Note: createReverseQuery is private, so this would need to be made public or tested via PTR queries
-        
-        // For now, test via PTR query if implemented
-        server().addRecord({expected, "PTR", "test.example.com", 3600});
-        
-        // This would test the full reverse lookup chain
-        // auto result = client().resolvePTR(ipv6);
-        // CHECK(result == "test.example.com");
-    }
+  startServer();
+
+  SECTION("IPv6 address to reverse DNS format")
+  {
+    // Test the IPv6 reverse DNS implementation
+    std::string ipv6 = "2001:db8::1";
+    std::string expected =
+      "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa";
+
+    // Create temporary DnsClient to access createReverseQuery
+    DnsClient tempClient;
+    // Note: createReverseQuery is private, so this would need to be made public or tested via PTR
+    // queries
+
+    // For now, test via PTR query if implemented
+    server().addRecord({expected, "PTR", "test.example.com", 3600});
+
+    // This would test the full reverse lookup chain
+    // auto result = client().resolvePTR(ipv6);
+    // CHECK(result == "test.example.com");
+  }
 }
 
 // =============================================================================
-// ASYNC API AND CANCELLATION TESTS  
+// ASYNC API AND CANCELLATION TESTS
 // =============================================================================
 
 TEST_CASE_METHOD(DnsTestFixture, "DNS Future Cancellation Readiness", "[dns][async][cancellation]")
 {
-    startServer();
-    
-    SECTION("resolveAAsync cancellation prevents future hang") 
-    {
-        server().addRecord({"slow.example.com", "A", "192.168.1.100", 3600});
-        
-        // Configure server to delay response
-        MockDnsServer::QueryConfig slowConfig;
-        slowConfig.delay = std::chrono::milliseconds(5000); // 5 second delay
-        server().configureQuery("slow.example.com", slowConfig);
-        
-        // Start async resolution
-        auto cancellableFuture = client().resolveAAsync("slow.example.com");
-        
-        // Immediately cancel the request
-        bool cancelResult = cancellableFuture.cancel();
-        CHECK(cancelResult == true); // Should successfully cancel
-        
-        // Future must become ready with cancellation exception (no hang)
-        auto status = cancellableFuture.future.wait_for(std::chrono::milliseconds(1000));
-        REQUIRE(status == std::future_status::ready);
-        
-        // Future should contain cancellation exception
-        REQUIRE_THROWS_AS(cancellableFuture.future.get(), DnsResolverException);
-        
-        // Verify cancellation state
-        CHECK(cancellableFuture.isCancelled());
-        CHECK(cancellableFuture.isCompleted());
-    }
-    
-    SECTION("resolveServiceDomainFuture cancellation prevents hang") 
+  startServer();
+
+  SECTION("resolveAAsync cancellation prevents future hang")
+  {
+    server().addRecord({"slow.example.com", "A", "192.168.1.100", 3600});
+
+    // Configure server to delay response
+    MockDnsServer::QueryConfig slowConfig;
+    slowConfig.delay = std::chrono::milliseconds(5000); // 5 second delay
+    server().configureQuery("slow.example.com", slowConfig);
+
+    // Start async resolution
+    auto cancellableFuture = client().resolveAAsync("slow.example.com");
+
+    // Immediately cancel the request
+    bool cancelResult = cancellableFuture.cancel();
+    CHECK(cancelResult == true); // Should successfully cancel
+
+    // Future must become ready with cancellation exception (no hang)
+    auto status = cancellableFuture.future.wait_for(std::chrono::milliseconds(1000));
+    REQUIRE(status == std::future_status::ready);
+
+    // Future should contain cancellation exception
+    REQUIRE_THROWS_AS(cancellableFuture.future.get(), DnsResolverException);
+
+    // Verify cancellation state
+    CHECK(cancellableFuture.isCancelled());
+    CHECK(cancellableFuture.isCompleted());
+  }
+
+  SECTION("resolveServiceDomainFuture cancellation prevents hang")
+  {
+    server().addRecord(
+      {"slow-service.example.com", "SRV", "target.example.com", 3600, 10, 5, 5060});
+
+    // Configure delay for ALL possible service discovery queries to ensure cancellation wins
+    MockDnsServer::QueryConfig slowConfig;
+    slowConfig.delay =
+      std::chrono::milliseconds(5000); // Longer delay to ensure cancellation happens first
+
+    // Service discovery may query NAPTR, SRV, and potentially other records
+    server().configureQuery("slow-service.example.com", slowConfig);
+    server().configureQuery("_sip._tcp.slow-service.example.com", slowConfig);
+    server().configureQuery("_sips._tcp.slow-service.example.com", slowConfig);
+    server().configureQuery("_sip._udp.slow-service.example.com", slowConfig);
+    server().configureQuery("target.example.com", slowConfig);
+
+    // Start async service resolution
+    auto cancellableFuture = client().resolveServiceDomainFuture("slow-service.example.com");
+
+    // Cancel immediately
+    CHECK(cancellableFuture.cancel());
+
+    // Must not hang
+    auto status = cancellableFuture.future.wait_for(std::chrono::milliseconds(1000));
+    REQUIRE(status == std::future_status::ready);
+
+    // Should throw cancellation exception
+    REQUIRE_THROWS_AS(cancellableFuture.future.get(), DnsResolverException);
+  }
+
+  SECTION("Best-effort cancellation semantics")
+  {
+    server().addRecord({"race.example.com", "A", "192.168.1.200", 3600});
+
+    // Start resolution (might complete before cancel)
+    auto cancellableFuture = client().resolveAAsync("race.example.com");
+
+    // Try to cancel (may or may not succeed due to timing)
+    bool cancelled = cancellableFuture.cancel();
+
+    // Future must become ready regardless
+    auto status = cancellableFuture.future.wait_for(std::chrono::milliseconds(2000));
+    REQUIRE(status == std::future_status::ready);
+
+    if (cancelled)
     {
-        server().addRecord({"slow-service.example.com", "SRV", "target.example.com", 3600, 10, 5, 5060});
-        
-        // Configure delay for ALL possible service discovery queries to ensure cancellation wins
-        MockDnsServer::QueryConfig slowConfig;
-        slowConfig.delay = std::chrono::milliseconds(5000); // Longer delay to ensure cancellation happens first
-        
-        // Service discovery may query NAPTR, SRV, and potentially other records
-        server().configureQuery("slow-service.example.com", slowConfig);
-        server().configureQuery("_sip._tcp.slow-service.example.com", slowConfig);
-        server().configureQuery("_sips._tcp.slow-service.example.com", slowConfig);
-        server().configureQuery("_sip._udp.slow-service.example.com", slowConfig);
-        server().configureQuery("target.example.com", slowConfig);
-        
-        // Start async service resolution  
-        auto cancellableFuture = client().resolveServiceDomainFuture("slow-service.example.com");
-        
-        // Cancel immediately
-        CHECK(cancellableFuture.cancel());
-        
-        // Must not hang
-        auto status = cancellableFuture.future.wait_for(std::chrono::milliseconds(1000));
-        REQUIRE(status == std::future_status::ready);
-        
-        // Should throw cancellation exception
-        REQUIRE_THROWS_AS(cancellableFuture.future.get(), DnsResolverException);
+      // If successfully cancelled, should throw
+      REQUIRE_THROWS_AS(cancellableFuture.future.get(), DnsResolverException);
     }
-    
-    SECTION("Best-effort cancellation semantics") 
+    else
     {
-        server().addRecord({"race.example.com", "A", "192.168.1.200", 3600});
-        
-        // Start resolution (might complete before cancel)
-        auto cancellableFuture = client().resolveAAsync("race.example.com");
-        
-        // Try to cancel (may or may not succeed due to timing)
-        bool cancelled = cancellableFuture.cancel();
-        
-        // Future must become ready regardless
-        auto status = cancellableFuture.future.wait_for(std::chrono::milliseconds(2000));
-        REQUIRE(status == std::future_status::ready);
-        
-        if (cancelled) {
-            // If successfully cancelled, should throw
-            REQUIRE_THROWS_AS(cancellableFuture.future.get(), DnsResolverException);
-        } else {
-            // If not cancelled, should return result
-            auto result = cancellableFuture.future.get();
-            CHECK_FALSE(result.empty());
-        }
+      // If not cancelled, should return result
+      auto result = cancellableFuture.future.get();
+      CHECK_FALSE(result.empty());
     }
+  }
 }
 
 // =============================================================================
 // PERFORMANCE AND CONCURRENT ACCESS TESTS
 // =============================================================================
 
-TEST_CASE_METHOD(DnsTestFixture, "DNS Concurrent Query Performance", "[dns][performance][concurrency]")
+TEST_CASE_METHOD(DnsTestFixture, "DNS Concurrent Query Performance",
+                 "[dns][performance][concurrency]")
 {
-    startServer();
-    
-    server().setupCommonSipRecords();
-    
-    SECTION("Sequential queries performance") 
+  startServer();
+
+  server().setupCommonSipRecords();
+
+  SECTION("Sequential queries performance")
+  {
+    const int numQueries = 10; // Reduced for synchronous testing
+
+    auto startTime = std::chrono::steady_clock::now();
+
+    // Run sequential queries
+    int successCount = 0;
+    for (int i = 0; i < numQueries; ++i)
     {
-        const int numQueries = 10; // Reduced for synchronous testing
-        
-        auto startTime = std::chrono::steady_clock::now();
-        
-        // Run sequential queries
-        int successCount = 0;
-        for (int i = 0; i < numQueries; ++i) 
+      try
+      {
+        auto result = client().resolveA("example.com");
+        if (!result.empty())
         {
-            try {
-                auto result = client().resolveA("example.com");
-                if (!result.empty()) {
-                    successCount++;
-                }
-            } catch (const std::exception&) {
-                // Some queries might fail - that's ok for this test
-            }
+          successCount++;
         }
-        
-        auto endTime = std::chrono::steady_clock::now();
-        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
-        
-        // Should complete reasonably quickly with good success rate
-        CHECK(duration < std::chrono::milliseconds(10000)); // More time for sequential
-        CHECK(successCount > numQueries / 2); // At least 50% success rate
-        
-        INFO("Sequential queries: " << numQueries);
-        INFO("Successful: " << successCount);
-        INFO("Duration: " << duration.count() << "ms");
+      }
+      catch (const std::exception &)
+      {
+        // Some queries might fail - that's ok for this test
+      }
     }
+
+    auto endTime = std::chrono::steady_clock::now();
+    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
+
+    // Should complete reasonably quickly with good success rate
+    CHECK(duration < std::chrono::milliseconds(10000)); // More time for sequential
+    CHECK(successCount > numQueries / 2);               // At least 50% success rate
+
+    INFO("Sequential queries: " << numQueries);
+    INFO("Successful: " << successCount);
+    INFO("Duration: " << duration.count() << "ms");
+  }
 }
 
 // =============================================================================
 // INTEGRATION TESTS
 // =============================================================================
 
-TEST_CASE_METHOD(DnsTestFixture, "DNS Full Service Discovery Chain", "[dns][integration][service-discovery]")
+TEST_CASE_METHOD(DnsTestFixture, "DNS Full Service Discovery Chain",
+                 "[dns][integration][service-discovery]")
 {
-    startServer();
-    
-    SECTION("Complete NAPTR -> SRV -> A resolution chain") 
-    {
-        // Setup complete service discovery chain
-        server().addRecord({"service.example.com", "NAPTR", "100 10 \"s\" \"SIP+D2U\" \"\" _sip._udp.service.example.com", 3600});
-        server().addRecord({"_sip._udp.service.example.com", "SRV", "sip.service.example.com", 3600, 10, 5, 5060});
-        server().addRecord({"sip.service.example.com", "A", "192.168.1.100", 3600});
-        
-        auto result = client().resolveServiceDomain("service.example.com");
-        
-        REQUIRE_FALSE(result.targets.empty());
-        CHECK(result.targets[0].hostname == "sip.service.example.com");
-        CHECK(result.targets[0].port == 5060);
-        CHECK(result.targets[0].transport == ServiceType::SIP_UDP);
-        
-        // Test preferred target selection
-        auto preferred = result.getPreferredTarget();
-        CHECK(preferred.hostname == "sip.service.example.com");
-    }
+  startServer();
+
+  SECTION("Complete NAPTR -> SRV -> A resolution chain")
+  {
+    // Setup complete service discovery chain
+    server().addRecord({"service.example.com", "NAPTR",
+                        "100 10 \"s\" \"SIP+D2U\" \"\" _sip._udp.service.example.com", 3600});
+    server().addRecord(
+      {"_sip._udp.service.example.com", "SRV", "sip.service.example.com", 3600, 10, 5, 5060});
+    server().addRecord({"sip.service.example.com", "A", "192.168.1.100", 3600});
+
+    auto result = client().resolveServiceDomain("service.example.com");
+
+    REQUIRE_FALSE(result.targets.empty());
+    CHECK(result.targets[0].hostname == "sip.service.example.com");
+    CHECK(result.targets[0].port == 5060);
+    CHECK(result.targets[0].transport == ServiceType::SIP_UDP);
+
+    // Test preferred target selection
+    auto preferred = result.getPreferredTarget();
+    CHECK(preferred.hostname == "sip.service.example.com");
+  }
 }
\ No newline at end of file
diff --git a/tests/network/iora_test_dns_timer_cancellation.cpp b/tests/network/iora_test_dns_timer_cancellation.cpp
index 150a663..9f5e7c1 100644
--- a/tests/network/iora_test_dns_timer_cancellation.cpp
+++ b/tests/network/iora_test_dns_timer_cancellation.cpp
@@ -14,64 +14,62 @@
 #include <catch2/catch.hpp>
 
 #include "iora/core/timer.hpp"
+#include <atomic>
 #include <chrono>
 #include <thread>
-#include <atomic>
 
 using namespace iora::core;
 
 TEST_CASE("TimerService Cancellation Functionality", "[dns][timer][cancellation]")
 {
-    SECTION("Basic timer cancellation")
-    {
-        TimerService timerService; // Use default constructor
-        
-        std::atomic<bool> timerFired{false};
-        
-        // Schedule a timer for 1 second
-        auto timerId = timerService.scheduleAfter(std::chrono::milliseconds(1000), [&]() {
-            timerFired.store(true);
-        });
-        
-        // Cancel it immediately
-        bool cancelled = timerService.cancel(timerId);
-        
-        CHECK(cancelled == true);  // Should successfully cancel
-        
-        // Wait a bit to ensure timer doesn't fire
-        std::this_thread::sleep_for(std::chrono::milliseconds(50));
-        
-        CHECK(timerFired.load() == false);  // Timer should not have fired
-    }
-    
-    SECTION("Cancel non-existent timer")
-    {
-        TimerService timerService;
-        
-        // Try to cancel a non-existent timer
-        bool cancelled = timerService.cancel(99999);
-        
-        CHECK(cancelled == false);  // Should return false for non-existent timer
-    }
-    
-    SECTION("Timer fires if not cancelled")
-    {
-        TimerService timerService;
-        
-        std::atomic<bool> timerFired{false};
-        
-        // Schedule a very short timer
-        auto timerId = timerService.scheduleAfter(std::chrono::milliseconds(10), [&]() {
-            timerFired.store(true);
-        });
-        
-        // Don't cancel it, wait for it to fire
-        std::this_thread::sleep_for(std::chrono::milliseconds(50));
-        
-        CHECK(timerFired.load() == true);  // Timer should have fired
-        
-        // Now try to cancel the already-fired timer
-        bool cancelled = timerService.cancel(timerId);
-        CHECK(cancelled == false);  // Should return false for already-fired timer
-    }
+  SECTION("Basic timer cancellation")
+  {
+    TimerService timerService; // Use default constructor
+
+    std::atomic<bool> timerFired{false};
+
+    // Schedule a timer for 1 second
+    auto timerId = timerService.scheduleAfter(std::chrono::milliseconds(1000),
+                                              [&]() { timerFired.store(true); });
+
+    // Cancel it immediately
+    bool cancelled = timerService.cancel(timerId);
+
+    CHECK(cancelled == true); // Should successfully cancel
+
+    // Wait a bit to ensure timer doesn't fire
+    std::this_thread::sleep_for(std::chrono::milliseconds(50));
+
+    CHECK(timerFired.load() == false); // Timer should not have fired
+  }
+
+  SECTION("Cancel non-existent timer")
+  {
+    TimerService timerService;
+
+    // Try to cancel a non-existent timer
+    bool cancelled = timerService.cancel(99999);
+
+    CHECK(cancelled == false); // Should return false for non-existent timer
+  }
+
+  SECTION("Timer fires if not cancelled")
+  {
+    TimerService timerService;
+
+    std::atomic<bool> timerFired{false};
+
+    // Schedule a very short timer
+    auto timerId =
+      timerService.scheduleAfter(std::chrono::milliseconds(10), [&]() { timerFired.store(true); });
+
+    // Don't cancel it, wait for it to fire
+    std::this_thread::sleep_for(std::chrono::milliseconds(50));
+
+    CHECK(timerFired.load() == true); // Timer should have fired
+
+    // Now try to cancel the already-fired timer
+    bool cancelled = timerService.cancel(timerId);
+    CHECK(cancelled == false); // Should return false for already-fired timer
+  }
 }
\ No newline at end of file
diff --git a/tests/network/iora_test_http.cpp b/tests/network/iora_test_http.cpp
index c1a025c..6729f96 100644
--- a/tests/network/iora_test_http.cpp
+++ b/tests/network/iora_test_http.cpp
@@ -5,8 +5,8 @@
 // See the LICENSE file or <https://www.mozilla.org/MPL/2.0/> for details.
 
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 
 using namespace iora::test;
 
@@ -16,7 +16,7 @@ TEST_CASE("HttpClient and WebhookServer integration tests")
   server.setPort(8081);
 
   server.onJsonPost("/test-post-json",
-                    [](const iora::parsers::Json& input) -> iora::parsers::Json
+                    [](const iora::parsers::Json &input) -> iora::parsers::Json
                     {
                       auto obj = iora::parsers::Json::object();
                       obj["echo"] = input;
@@ -24,7 +24,7 @@ TEST_CASE("HttpClient and WebhookServer integration tests")
                     });
 
   server.onJsonPost("/test-async",
-                    [](const iora::parsers::Json& input) -> iora::parsers::Json
+                    [](const iora::parsers::Json &input) -> iora::parsers::Json
                     {
                       auto obj = iora::parsers::Json::object();
                       obj["async"] = true;
@@ -33,23 +33,23 @@ TEST_CASE("HttpClient and WebhookServer integration tests")
                     });
 
   server.onJsonGet("/test-get",
-                   [](const iora::parsers::Json&) -> iora::parsers::Json
+                   [](const iora::parsers::Json &) -> iora::parsers::Json
                    {
                      auto obj = iora::parsers::Json::object();
                      obj["status"] = "ok";
                      return obj;
                    });
 
-  server.onPost("/test-stream",
-                [](const iora::network::WebhookServer::Request&,
-                   iora::network::WebhookServer::Response& res)
-                {
-                  res.set_content("data: {\"text\":\"line1\"}\n"
-                                  "data: {\"text\":\"line2\"}\n"
-                                  "data: [DONE]\n",
-                                  "text/event-stream");
-                  res.status = 200;
-                });
+  server.onPost(
+    "/test-stream",
+    [](const iora::network::WebhookServer::Request &, iora::network::WebhookServer::Response &res)
+    {
+      res.set_content("data: {\"text\":\"line1\"}\n"
+                      "data: {\"text\":\"line2\"}\n"
+                      "data: [DONE]\n",
+                      "text/event-stream");
+      res.status = 200;
+    });
 
   server.start();
   std::this_thread::sleep_for(std::chrono::milliseconds(1000));
@@ -65,7 +65,7 @@ TEST_CASE("HttpClient and WebhookServer integration tests")
       auto json = iora::network::HttpClient::parseJsonOrThrow(res);
       REQUIRE(json["status"] == "ok");
     }
-    catch (const std::exception& ex)
+    catch (const std::exception &ex)
     {
       FAIL(std::string("Exception: ") + ex.what());
     }
@@ -86,7 +86,7 @@ TEST_CASE("HttpClient and WebhookServer integration tests")
     auto payload = iora::parsers::Json::object();
     payload["async_test"] = 1;
     std::future<iora::network::HttpClient::Response> future =
-        client.postJsonAsync("http://localhost:8081/test-async", payload);
+      client.postJsonAsync("http://localhost:8081/test-async", payload);
     auto res = future.get();
     REQUIRE(res.success());
     auto json = iora::network::HttpClient::parseJsonOrThrow(res);
@@ -99,7 +99,7 @@ TEST_CASE("HttpClient and WebhookServer integration tests")
     auto payload = iora::parsers::Json::object();
     std::vector<std::string> chunks;
     client.postStream("http://localhost:8081/test-stream", payload, {},
-                      [&](const std::string& line)
+                      [&](const std::string &line)
                       {
                         if (!line.empty())
                         {
@@ -117,13 +117,13 @@ TEST_CASE("HttpClient and WebhookServer integration tests")
 }
 
 // BSD socket tests for HTTP client timeout behavior
-#include <sys/socket.h>
-#include <netinet/in.h>
 #include <arpa/inet.h>
-#include <fcntl.h>
-#include <unistd.h>
 #include <atomic>
+#include <fcntl.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
 #include <thread>
+#include <unistd.h>
 
 TEST_CASE("HTTP Client BSD Socket Timeout Tests", "[http][timeout][bsd]")
 {
@@ -147,7 +147,7 @@ TEST_CASE("HTTP Client BSD Socket Timeout Tests", "[http][timeout][bsd]")
     addr.sin_addr.s_addr = INADDR_ANY;
     addr.sin_port = htons(port);
 
-    if (bind(sockfd, (struct sockaddr*) &addr, sizeof(addr)) < 0)
+    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
     {
       close(sockfd);
       throw std::runtime_error("Failed to bind socket");
@@ -173,24 +173,23 @@ TEST_CASE("HTTP Client BSD Socket Timeout Tests", "[http][timeout][bsd]")
 
     std::atomic<bool> shouldAccept{true};
     std::thread acceptThread(
-        [listenSock, &shouldAccept]()
+      [listenSock, &shouldAccept]()
+      {
+        while (shouldAccept)
         {
-          while (shouldAccept)
+          struct sockaddr_in clientAddr;
+          socklen_t clientLen = sizeof(clientAddr);
+          int clientSock = accept(listenSock, (struct sockaddr *)&clientAddr, &clientLen);
+          if (clientSock >= 0)
           {
-            struct sockaddr_in clientAddr;
-            socklen_t clientLen = sizeof(clientAddr);
-            int clientSock =
-                accept(listenSock, (struct sockaddr*) &clientAddr, &clientLen);
-            if (clientSock >= 0)
-            {
-              // Accept connection but don't send any response
-              // Just hold the connection open
-              std::this_thread::sleep_for(std::chrono::seconds(10));
-              close(clientSock);
-            }
-            std::this_thread::sleep_for(std::chrono::milliseconds(10));
+            // Accept connection but don't send any response
+            // Just hold the connection open
+            std::this_thread::sleep_for(std::chrono::seconds(10));
+            close(clientSock);
           }
-        });
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      });
 
     // Give the accept thread time to start
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
@@ -204,19 +203,17 @@ TEST_CASE("HTTP Client BSD Socket Timeout Tests", "[http][timeout][bsd]")
 
     try
     {
-      auto response = clientWithTimeout.get(
-          "http://127.0.0.1:" + std::to_string(port) + "/test");
+      auto response = clientWithTimeout.get("http://127.0.0.1:" + std::to_string(port) + "/test");
       FAIL("Should have timed out");
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
-          std::chrono::steady_clock::now() - startTime);
+        std::chrono::steady_clock::now() - startTime);
 
       // Should timeout within 2-3 seconds (allowing some overhead)
       REQUIRE(elapsed.count() < 3000);
-      REQUIRE(elapsed.count() >=
-              1900); // Should wait at least most of the timeout
+      REQUIRE(elapsed.count() >= 1900); // Should wait at least most of the timeout
 
       std::string error = e.what();
       // Check that it's a timeout error
@@ -240,22 +237,21 @@ TEST_CASE("HTTP Client BSD Socket Timeout Tests", "[http][timeout][bsd]")
 
     std::atomic<bool> shouldAccept{true};
     std::thread acceptThread(
-        [listenSock, &shouldAccept]()
+      [listenSock, &shouldAccept]()
+      {
+        while (shouldAccept)
         {
-          while (shouldAccept)
+          struct sockaddr_in clientAddr;
+          socklen_t clientLen = sizeof(clientAddr);
+          int clientSock = accept(listenSock, (struct sockaddr *)&clientAddr, &clientLen);
+          if (clientSock >= 0)
           {
-            struct sockaddr_in clientAddr;
-            socklen_t clientLen = sizeof(clientAddr);
-            int clientSock =
-                accept(listenSock, (struct sockaddr*) &clientAddr, &clientLen);
-            if (clientSock >= 0)
-            {
-              // Immediately close the connection
-              close(clientSock);
-            }
-            std::this_thread::sleep_for(std::chrono::milliseconds(10));
+            // Immediately close the connection
+            close(clientSock);
           }
-        });
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      });
 
     // Give the accept thread time to start
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
@@ -267,14 +263,13 @@ TEST_CASE("HTTP Client BSD Socket Timeout Tests", "[http][timeout][bsd]")
 
     try
     {
-      auto response =
-          client.get("http://127.0.0.1:" + std::to_string(port) + "/test");
+      auto response = client.get("http://127.0.0.1:" + std::to_string(port) + "/test");
       FAIL("Should have been disconnected");
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
-          std::chrono::steady_clock::now() - startTime);
+        std::chrono::steady_clock::now() - startTime);
 
       // Should fail almost immediately (within 1 second)
       REQUIRE(elapsed.count() < 1000);
@@ -305,14 +300,13 @@ TEST_CASE("HTTP Client BSD Socket Timeout Tests", "[http][timeout][bsd]")
 
     try
     {
-      auto response =
-          client.get("http://127.0.0.1:" + std::to_string(bogusPort) + "/test");
+      auto response = client.get("http://127.0.0.1:" + std::to_string(bogusPort) + "/test");
       FAIL("Should have been refused");
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
-          std::chrono::steady_clock::now() - startTime);
+        std::chrono::steady_clock::now() - startTime);
 
       // Should fail immediately (within 500ms for local connection)
       REQUIRE(elapsed.count() < 500);
@@ -333,15 +327,12 @@ TEST_CASE("HTTP Client BSD Socket Timeout Tests", "[http][timeout][bsd]")
 }
 
 // TLS BSD socket tests for HTTP client timeout behavior
-TEST_CASE("HTTPS Client BSD Socket Timeout Tests with TLS",
-          "[https][timeout][bsd][tls]")
+TEST_CASE("HTTPS Client BSD Socket Timeout Tests with TLS", "[https][timeout][bsd][tls]")
 {
   using namespace iora::network;
 
-  const std::string certFile =
-      std::string(IORA_TEST_RESOURCE_DIR) + "/tls-certs/test_tls_cert.pem";
-  const std::string keyFile =
-      std::string(IORA_TEST_RESOURCE_DIR) + "/tls-certs/test_tls_key.pem";
+  const std::string certFile = std::string(IORA_TEST_RESOURCE_DIR) + "/tls-certs/test_tls_cert.pem";
+  const std::string keyFile = std::string(IORA_TEST_RESOURCE_DIR) + "/tls-certs/test_tls_key.pem";
 
   if (!std::filesystem::exists(certFile) || !std::filesystem::exists(keyFile))
   {
@@ -350,27 +341,25 @@ TEST_CASE("HTTPS Client BSD Socket Timeout Tests with TLS",
   }
 
   // Helper to create TLS listening socket using OpenSSL
-  auto createTlsListeningSocket = [&](uint16_t port) -> std::pair<int, SSL_CTX*>
+  auto createTlsListeningSocket = [&](uint16_t port) -> std::pair<int, SSL_CTX *>
   {
     SSL_library_init();
     SSL_load_error_strings();
     OpenSSL_add_all_algorithms();
 
-    SSL_CTX* ctx = SSL_CTX_new(TLS_server_method());
+    SSL_CTX *ctx = SSL_CTX_new(TLS_server_method());
     if (!ctx)
     {
       throw std::runtime_error("Failed to create SSL context");
     }
 
-    if (SSL_CTX_use_certificate_file(ctx, certFile.c_str(), SSL_FILETYPE_PEM) <=
-        0)
+    if (SSL_CTX_use_certificate_file(ctx, certFile.c_str(), SSL_FILETYPE_PEM) <= 0)
     {
       SSL_CTX_free(ctx);
       throw std::runtime_error("Failed to load certificate");
     }
 
-    if (SSL_CTX_use_PrivateKey_file(ctx, keyFile.c_str(), SSL_FILETYPE_PEM) <=
-        0)
+    if (SSL_CTX_use_PrivateKey_file(ctx, keyFile.c_str(), SSL_FILETYPE_PEM) <= 0)
     {
       SSL_CTX_free(ctx);
       throw std::runtime_error("Failed to load private key");
@@ -392,7 +381,7 @@ TEST_CASE("HTTPS Client BSD Socket Timeout Tests with TLS",
     addr.sin_addr.s_addr = INADDR_ANY;
     addr.sin_port = htons(port);
 
-    if (bind(sockfd, (struct sockaddr*) &addr, sizeof(addr)) < 0)
+    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
     {
       close(sockfd);
       SSL_CTX_free(ctx);
@@ -420,34 +409,33 @@ TEST_CASE("HTTPS Client BSD Socket Timeout Tests with TLS",
 
     std::atomic<bool> shouldAccept{true};
     std::thread acceptThread(
-        [listenSock, sslCtx, &shouldAccept]()
+      [listenSock, sslCtx, &shouldAccept]()
+      {
+        while (shouldAccept)
         {
-          while (shouldAccept)
+          struct sockaddr_in clientAddr;
+          socklen_t clientLen = sizeof(clientAddr);
+          int clientSock = accept(listenSock, (struct sockaddr *)&clientAddr, &clientLen);
+          if (clientSock >= 0)
           {
-            struct sockaddr_in clientAddr;
-            socklen_t clientLen = sizeof(clientAddr);
-            int clientSock =
-                accept(listenSock, (struct sockaddr*) &clientAddr, &clientLen);
-            if (clientSock >= 0)
-            {
-              SSL* ssl = SSL_new(sslCtx);
-              SSL_set_fd(ssl, clientSock);
+            SSL *ssl = SSL_new(sslCtx);
+            SSL_set_fd(ssl, clientSock);
 
-              // Perform TLS handshake
-              if (SSL_accept(ssl) > 0)
-              {
-                // Handshake successful, but don't send any HTTP response
-                // Just hold the connection open
-                std::this_thread::sleep_for(std::chrono::seconds(10));
-              }
-
-              SSL_shutdown(ssl);
-              SSL_free(ssl);
-              close(clientSock);
+            // Perform TLS handshake
+            if (SSL_accept(ssl) > 0)
+            {
+              // Handshake successful, but don't send any HTTP response
+              // Just hold the connection open
+              std::this_thread::sleep_for(std::chrono::seconds(10));
             }
-            std::this_thread::sleep_for(std::chrono::milliseconds(10));
+
+            SSL_shutdown(ssl);
+            SSL_free(ssl);
+            close(clientSock);
           }
-        });
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      });
 
     // Give the accept thread time to start
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
@@ -466,19 +454,17 @@ TEST_CASE("HTTPS Client BSD Socket Timeout Tests with TLS",
 
     try
     {
-      auto response =
-          client.get("https://127.0.0.1:" + std::to_string(port) + "/test");
+      auto response = client.get("https://127.0.0.1:" + std::to_string(port) + "/test");
       FAIL("Should have timed out");
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
-          std::chrono::steady_clock::now() - startTime);
+        std::chrono::steady_clock::now() - startTime);
 
       // Should timeout within 2-3 seconds (allowing some overhead)
       REQUIRE(elapsed.count() < 3000);
-      REQUIRE(elapsed.count() >=
-              1900); // Should wait at least most of the timeout
+      REQUIRE(elapsed.count() >= 1900); // Should wait at least most of the timeout
 
       std::string error = e.what();
       bool isTimeout = (error.find("timeout") != std::string::npos) ||
@@ -502,32 +488,31 @@ TEST_CASE("HTTPS Client BSD Socket Timeout Tests with TLS",
 
     std::atomic<bool> shouldAccept{true};
     std::thread acceptThread(
-        [listenSock, sslCtx, &shouldAccept]()
+      [listenSock, sslCtx, &shouldAccept]()
+      {
+        while (shouldAccept)
         {
-          while (shouldAccept)
+          struct sockaddr_in clientAddr;
+          socklen_t clientLen = sizeof(clientAddr);
+          int clientSock = accept(listenSock, (struct sockaddr *)&clientAddr, &clientLen);
+          if (clientSock >= 0)
           {
-            struct sockaddr_in clientAddr;
-            socklen_t clientLen = sizeof(clientAddr);
-            int clientSock =
-                accept(listenSock, (struct sockaddr*) &clientAddr, &clientLen);
-            if (clientSock >= 0)
+            SSL *ssl = SSL_new(sslCtx);
+            SSL_set_fd(ssl, clientSock);
+
+            // Perform TLS handshake then immediately close
+            if (SSL_accept(ssl) > 0)
             {
-              SSL* ssl = SSL_new(sslCtx);
-              SSL_set_fd(ssl, clientSock);
-
-              // Perform TLS handshake then immediately close
-              if (SSL_accept(ssl) > 0)
-              {
-                // Immediately close after handshake
-                SSL_shutdown(ssl);
-              }
-
-              SSL_free(ssl);
-              close(clientSock);
+              // Immediately close after handshake
+              SSL_shutdown(ssl);
             }
-            std::this_thread::sleep_for(std::chrono::milliseconds(10));
+
+            SSL_free(ssl);
+            close(clientSock);
           }
-        });
+          std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+      });
 
     // Give the accept thread time to start
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
@@ -544,14 +529,13 @@ TEST_CASE("HTTPS Client BSD Socket Timeout Tests with TLS",
 
     try
     {
-      auto response =
-          client.get("https://127.0.0.1:" + std::to_string(port) + "/test");
+      auto response = client.get("https://127.0.0.1:" + std::to_string(port) + "/test");
       FAIL("Should have been disconnected");
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
-          std::chrono::steady_clock::now() - startTime);
+        std::chrono::steady_clock::now() - startTime);
 
       // Should fail within 2 seconds (TLS handshake + disconnect)
       REQUIRE(elapsed.count() < 2000);
@@ -588,14 +572,13 @@ TEST_CASE("HTTPS Client BSD Socket Timeout Tests with TLS",
 
     try
     {
-      auto response = client.get(
-          "https://127.0.0.1:" + std::to_string(bogusPort) + "/test");
+      auto response = client.get("https://127.0.0.1:" + std::to_string(bogusPort) + "/test");
       FAIL("Should have been refused");
     }
-    catch (const std::exception& e)
+    catch (const std::exception &e)
     {
       auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
-          std::chrono::steady_clock::now() - startTime);
+        std::chrono::steady_clock::now() - startTime);
 
       // Should fail immediately (within 500ms for local connection)
       REQUIRE(elapsed.count() < 500);
@@ -613,17 +596,13 @@ TEST_CASE("HTTPS Client BSD Socket Timeout Tests with TLS",
   }
 }
 
-constexpr const char* TEST_CERT_PATH =
-    "/workspace/iora/tests/tls-certs/test_tls_cert.pem";
-constexpr const char* TEST_KEY_PATH =
-    "/workspace/iora/tests/tls-certs/test_tls_key.pem";
+constexpr const char *TEST_CERT_PATH = "/workspace/iora/tests/tls-certs/test_tls_cert.pem";
+constexpr const char *TEST_KEY_PATH = "/workspace/iora/tests/tls-certs/test_tls_key.pem";
 
 TEST_CASE("WebhookServer TLS (SSL) basic functionality", "[webhookserver][tls]")
 {
-  const std::string certFile =
-      std::string(IORA_TEST_RESOURCE_DIR) + "/tls-certs/test_tls_cert.pem";
-  const std::string keyFile =
-      std::string(IORA_TEST_RESOURCE_DIR) + "/tls-certs/test_tls_key.pem";
+  const std::string certFile = std::string(IORA_TEST_RESOURCE_DIR) + "/tls-certs/test_tls_cert.pem";
+  const std::string keyFile = std::string(IORA_TEST_RESOURCE_DIR) + "/tls-certs/test_tls_key.pem";
 
   if (!std::filesystem::exists(certFile) || !std::filesystem::exists(keyFile))
   {
@@ -642,7 +621,7 @@ TEST_CASE("WebhookServer TLS (SSL) basic functionality", "[webhookserver][tls]")
   REQUIRE_NOTHROW(server.enableTls(tlsCfg));
 
   server.onJsonGet("/tls-test",
-                   [](const iora::parsers::Json&) -> iora::parsers::Json
+                   [](const iora::parsers::Json &) -> iora::parsers::Json
                    {
                      auto obj = iora::parsers::Json::object();
                      obj["tls"] = true;
@@ -666,7 +645,7 @@ TEST_CASE("WebhookServer TLS (SSL) basic functionality", "[webhookserver][tls]")
       auto json = iora::network::HttpClient::parseJsonOrThrow(res);
       REQUIRE(json["tls"] == true);
     }
-    catch (const std::exception& ex)
+    catch (const std::exception &ex)
     {
       FAIL(std::string("Exception: ") + ex.what());
     }
diff --git a/tests/network/iora_test_shared_tcp.cpp b/tests/network/iora_test_shared_tcp.cpp
index 0b2c410..67ea8e0 100644
--- a/tests/network/iora_test_shared_tcp.cpp
+++ b/tests/network/iora_test_shared_tcp.cpp
@@ -1,12 +1,12 @@
 #define CATCH_CONFIG_MAIN
 #include <catch2/catch.hpp>
-#include "test_helpers.hpp"
 #include "iora/network/shared_transport.hpp"
 #include "iora_test_net_utils.hpp"
-#include <vector>
-#include <map>
+#include "test_helpers.hpp"
 #include <algorithm>
+#include <map>
 #include <numeric>
+#include <vector>
 
 using namespace std::chrono_literals;
 using SharedTransport = iora::network::SharedTransport;
@@ -40,7 +40,7 @@ struct TcpFixture
   std::vector<std::string> errorMessages;
 
   std::mutex callbackMutex;
-  
+
   SessionId serverSid{0};
   SessionId clientSid{0};
   std::string lastErrMsg;
@@ -48,33 +48,40 @@ struct TcpFixture
   TcpFixture()
   {
     SharedTransport::Callbacks cbs{};
-    cbs.onAccept = [&](SessionId sid, const std::string& addr, const IoResult& res)
+    cbs.onAccept = [&](SessionId sid, const std::string &addr, const IoResult &res)
     {
       std::lock_guard<std::mutex> lock(callbackMutex);
-      if (res.ok) {
+      if (res.ok)
+      {
         acceptedSessions.push_back(sid);
-        if (serverSid == 0) serverSid = sid;
+        if (serverSid == 0)
+          serverSid = sid;
       }
       acceptCount++;
     };
-    cbs.onConnect = [&](SessionId sid, const IoResult& res)
+    cbs.onConnect = [&](SessionId sid, const IoResult &res)
     {
       std::lock_guard<std::mutex> lock(callbackMutex);
-      if (res.ok) {
+      if (res.ok)
+      {
         connectedSessions.push_back(sid);
-        if (clientSid == 0) clientSid = sid;
+        if (clientSid == 0)
+          clientSid = sid;
         connectCount++;
-      } else {
+      }
+      else
+      {
         connectFailCount++;
       }
     };
-    cbs.onData = [&](SessionId sid, const std::uint8_t* data, std::size_t n, const IoResult& res)
+    cbs.onData = [&](SessionId sid, const std::uint8_t *data, std::size_t n, const IoResult &res)
     {
       std::lock_guard<std::mutex> lock(callbackMutex);
-      if (res.ok) {
+      if (res.ok)
+      {
         totalBytesReceived += n;
-        sessionData[sid].append(reinterpret_cast<const char*>(data), n);
-        
+        sessionData[sid].append(reinterpret_cast<const char *>(data), n);
+
         // Echo back from server; detect echo on client
         if (sid == serverSid)
         {
@@ -83,26 +90,27 @@ struct TcpFixture
       }
       dataCount++;
     };
-    cbs.onClosed = [&](SessionId sid, const IoResult& res) 
-    { 
+    cbs.onClosed = [&](SessionId sid, const IoResult &res)
+    {
       std::lock_guard<std::mutex> lock(callbackMutex);
       closedSessions.push_back(sid);
       closeCount++;
     };
-    cbs.onError = [&](TransportError err, const std::string& msg) 
-    { 
+    cbs.onError = [&](TransportError err, const std::string &msg)
+    {
       std::lock_guard<std::mutex> lock(callbackMutex);
-      lastErrMsg = msg; 
+      lastErrMsg = msg;
       errorMessages.push_back(msg);
       errorCount++;
     };
     tx.setCallbacks(cbs);
   }
-  
+
   void reset()
   {
     std::lock_guard<std::mutex> lock(callbackMutex);
-    acceptCount = connectCount = connectFailCount = dataCount = closeCount = errorCount = totalBytesReceived = 0;
+    acceptCount = connectCount = connectFailCount = dataCount = closeCount = errorCount =
+      totalBytesReceived = 0;
     serverSid = clientSid = 0;
     acceptedSessions.clear();
     connectedSessions.clear();
@@ -111,11 +119,12 @@ struct TcpFixture
     errorMessages.clear();
     lastErrMsg.clear();
   }
-  
+
   bool waitForCondition(std::function<bool()> condition, std::chrono::milliseconds timeout = 1000ms)
   {
     auto start = std::chrono::steady_clock::now();
-    while (!condition() && (std::chrono::steady_clock::now() - start) < timeout) {
+    while (!condition() && (std::chrono::steady_clock::now() - start) < timeout)
+    {
       std::this_thread::sleep_for(5ms);
     }
     return condition();
@@ -149,7 +158,7 @@ TEST_CASE("TCP loopback echo", "[tcp][echo]")
   REQUIRE(f.acceptedSessions.size() == 1);
   REQUIRE(f.connectedSessions.size() == 1);
 
-  const char* msg = "hello tcp";
+  const char *msg = "hello tcp";
   REQUIRE(f.tx.send(cs, msg, std::strlen(msg)));
 
   // Wait for echo data to come back
@@ -187,7 +196,7 @@ TEST_CASE("TCP stats verification", "[tcp][stats]")
   REQUIRE(stats2.sessionsCurrent == 2); // client + server session
   REQUIRE(stats2.sessionsPeak >= 2);
 
-  const char* msg = "test stats";
+  const char *msg = "test stats";
   size_t msgLen = std::strlen(msg);
   REQUIRE(f.tx.send(cs, msg, msgLen));
 
@@ -220,47 +229,57 @@ TEST_CASE("TCP multiple clients to single server", "[tcp][multiconnect]")
   std::vector<SessionId> clients;
 
   // Connect multiple clients
-  for (size_t i = 0; i < numClients; ++i) {
+  for (size_t i = 0; i < numClients; ++i)
+  {
     SessionId cs = f.tx.connect("127.0.0.1", port, TlsMode::None);
     REQUIRE(cs != 0);
     clients.push_back(cs);
   }
 
-  REQUIRE(f.waitForCondition([&]() { 
-    return f.acceptCount >= numClients && f.connectCount >= numClients; 
-  }));
+  REQUIRE(f.waitForCondition(
+    [&]() { return f.acceptCount >= numClients && f.connectCount >= numClients; }));
 
   REQUIRE(f.acceptedSessions.size() == numClients);
   REQUIRE(f.connectedSessions.size() == numClients);
 
   // Send data from each client
-  for (size_t i = 0; i < numClients; ++i) {
+  for (size_t i = 0; i < numClients; ++i)
+  {
     std::string msg = "client " + std::to_string(i);
     REQUIRE(f.tx.send(clients[i], msg.c_str(), msg.size()));
   }
 
   // Wait for all echoes with extended timeout for multiple connections
-  bool allEchoed = f.waitForCondition([&]() {
-    size_t clientsWithData = 0;
-    for (auto client : clients) {
-      if (f.sessionData[client].size() > 0) clientsWithData++;
-    }
-    return clientsWithData == numClients;
-  });
-  
+  bool allEchoed = f.waitForCondition(
+    [&]()
+    {
+      size_t clientsWithData = 0;
+      for (auto client : clients)
+      {
+        if (f.sessionData[client].size() > 0)
+          clientsWithData++;
+      }
+      return clientsWithData == numClients;
+    });
+
   // If not all echoes received immediately, allow more time for concurrent operations
-  if (!allEchoed) {
+  if (!allEchoed)
+  {
     std::this_thread::sleep_for(300ms);
     size_t clientsWithData = 0;
-    for (auto client : clients) {
-      if (f.sessionData[client].size() > 0) clientsWithData++;
+    for (auto client : clients)
+    {
+      if (f.sessionData[client].size() > 0)
+        clientsWithData++;
     }
     REQUIRE(clientsWithData >= 1); // At least one client should succeed in concurrent scenario
   }
 
   // Verify clients that received data got the correct echo
-  for (size_t i = 0; i < numClients; ++i) {
-    if (f.sessionData[clients[i]].size() > 0) {
+  for (size_t i = 0; i < numClients; ++i)
+  {
+    if (f.sessionData[clients[i]].size() > 0)
+    {
       std::string expected = "client " + std::to_string(i);
       REQUIRE(f.sessionData[clients[i]] == expected);
     }
@@ -306,13 +325,12 @@ TEST_CASE("TCP large data transfer", "[tcp][largedata]")
 
   REQUIRE(f.tx.send(cs, largeData.data(), largeData.size()));
 
-  REQUIRE(f.waitForCondition([&]() { 
-    return f.sessionData[cs].size() == dataSize; 
-  }, 5000ms));
+  REQUIRE(f.waitForCondition([&]() { return f.sessionData[cs].size() == dataSize; }, 5000ms));
 
   // Verify data integrity
   REQUIRE(f.sessionData[cs].size() == dataSize);
-  for (size_t i = 0; i < dataSize; ++i) {
+  for (size_t i = 0; i < dataSize; ++i)
+  {
     REQUIRE(static_cast<uint8_t>(f.sessionData[cs][i]) == static_cast<uint8_t>(i));
   }
 
@@ -337,12 +355,11 @@ TEST_CASE("TCP binary data handling", "[tcp][binary]")
   std::vector<uint8_t> binaryData = {0x00, 0x01, 0xFF, 0x7F, 0x80, 0xAB, 0xCD, 0xEF};
   REQUIRE(f.tx.send(cs, binaryData.data(), binaryData.size()));
 
-  REQUIRE(f.waitForCondition([&]() { 
-    return f.sessionData[cs].size() == binaryData.size(); 
-  }));
+  REQUIRE(f.waitForCondition([&]() { return f.sessionData[cs].size() == binaryData.size(); }));
 
   // Verify binary data integrity
-  for (size_t i = 0; i < binaryData.size(); ++i) {
+  for (size_t i = 0; i < binaryData.size(); ++i)
+  {
     REQUIRE(static_cast<uint8_t>(f.sessionData[cs][i]) == binaryData[i]);
   }
 
@@ -416,17 +433,17 @@ TEST_CASE("TCP listener management", "[tcp][listeners]")
 {
   TcpFixture f;
   REQUIRE(f.tx.start());
-  
+
   auto port1 = testnet::getFreePortTCP();
   auto port2 = testnet::getFreePortTCP();
 
   // Add multiple listeners
   ListenerId lid1 = f.tx.addListener("127.0.0.1", port1, TlsMode::None);
   REQUIRE(lid1 != 0);
-  
+
   ListenerId lid2 = f.tx.addListener("127.0.0.1", port2, TlsMode::None);
   REQUIRE(lid2 != 0);
-  
+
   REQUIRE(lid1 != lid2);
 
   // Connect to both listeners
@@ -439,18 +456,18 @@ TEST_CASE("TCP listener management", "[tcp][listeners]")
 
   // Note: removeListener API not available, skip this test part
   // REQUIRE(f.tx.removeListener(lid1));
-  
+
   // Existing connections should still work
   REQUIRE(f.tx.send(cs1, "test1", 5));
   REQUIRE(f.tx.send(cs2, "test2", 5));
 
   // Wait for data with some tolerance for connection timing
-  bool dataReceived = f.waitForCondition([&]() {
-    return f.sessionData[cs1].size() > 0 && f.sessionData[cs2].size() > 0;
-  });
-  
+  bool dataReceived = f.waitForCondition(
+    [&]() { return f.sessionData[cs1].size() > 0 && f.sessionData[cs2].size() > 0; });
+
   // If immediate data transfer fails, allow for connection setup timing
-  if (!dataReceived) {
+  if (!dataReceived)
+  {
     std::this_thread::sleep_for(200ms);
     dataReceived = f.sessionData[cs1].size() > 0 && f.sessionData[cs2].size() > 0;
   }
@@ -474,7 +491,7 @@ TEST_CASE("TCP empty data send", "[tcp][emptydata]")
 
   // Send empty data
   REQUIRE(f.tx.send(cs, nullptr, 0));
-  
+
   std::this_thread::sleep_for(100ms); // Give it time to process
 
   f.tx.stop();
@@ -494,15 +511,14 @@ TEST_CASE("TCP session ID uniqueness", "[tcp][sessionids]")
   std::vector<SessionId> serverIds;
 
   // Create multiple connections
-  for (size_t i = 0; i < numConnections; ++i) {
+  for (size_t i = 0; i < numConnections; ++i)
+  {
     SessionId cs = f.tx.connect("127.0.0.1", port, TlsMode::None);
     REQUIRE(cs != 0);
     clientIds.push_back(cs);
   }
 
-  REQUIRE(f.waitForCondition([&]() { 
-    return f.acceptedSessions.size() >= numConnections; 
-  }));
+  REQUIRE(f.waitForCondition([&]() { return f.acceptedSessions.size() >= numConnections; }));
 
   serverIds = f.acceptedSessions;
 
@@ -532,16 +548,16 @@ TEST_CASE("TCP high frequency small messages", "[tcp][highfreq]")
   size_t totalExpectedBytes = 0;
 
   // Send many small messages rapidly
-  for (size_t i = 0; i < numMessages; ++i) {
+  for (size_t i = 0; i < numMessages; ++i)
+  {
     std::string msg = "msg" + std::to_string(i);
     totalExpectedBytes += msg.size();
     REQUIRE(f.tx.send(cs, msg.c_str(), msg.size()));
   }
 
   // Wait for all data to be echoed back
-  REQUIRE(f.waitForCondition([&]() { 
-    return f.sessionData[cs].size() == totalExpectedBytes; 
-  }, 3000ms));
+  REQUIRE(
+    f.waitForCondition([&]() { return f.sessionData[cs].size() == totalExpectedBytes; }, 3000ms));
 
   // Verify we received all the data
   REQUIRE(f.sessionData[cs].size() == totalExpectedBytes);
@@ -559,7 +575,7 @@ TEST_CASE("TCP duplicate listener error handling", "[tcp][duplicatelistener]")
   REQUIRE(lid1 != 0);
 
   ListenerId lid2 = f.tx.addListener("127.0.0.1", port, TlsMode::None);
-  REQUIRE(lid2 != 0);  // API might return valid ID, but binding should fail
+  REQUIRE(lid2 != 0); // API might return valid ID, but binding should fail
 
   // Give time for async bind failures to surface
   std::this_thread::sleep_for(100ms);
diff --git a/tests/network/iora_test_shared_transport_timers.cpp b/tests/network/iora_test_shared_transport_timers.cpp
index b3bd11b..3cf3ba8 100644
--- a/tests/network/iora_test_shared_transport_timers.cpp
+++ b/tests/network/iora_test_shared_transport_timers.cpp
@@ -1,8 +1,8 @@
 #define CATCH_CONFIG_MAIN
 #include <catch2/catch.hpp>
-#include "test_helpers.hpp"
 #include "iora/network/shared_transport.hpp"
 #include "iora_test_net_utils.hpp"
+#include "test_helpers.hpp"
 
 using namespace std::chrono_literals;
 using SharedTransport = iora::network::SharedTransport;
@@ -18,19 +18,19 @@ TEST_CASE("High-resolution timer configuration", "[shared_transport][timers]")
   cfg.connectTimeout = 500ms;
   cfg.handshakeTimeout = 1000ms;
   cfg.writeStallTimeout = 750ms;
-  
+
   SharedTransport::TlsConfig srvTls{};
   SharedTransport::TlsConfig cliTls{};
-  
+
   SharedTransport transport(cfg, srvTls, cliTls);
   REQUIRE(transport.start());
-  
+
   // Verify the configuration is set correctly
   REQUIRE(cfg.enableHighResolutionTimers == true);
   REQUIRE(cfg.connectTimeout == 500ms);
   REQUIRE(cfg.handshakeTimeout == 1000ms);
   REQUIRE(cfg.writeStallTimeout == 750ms);
-  
+
   transport.stop();
 }
 
@@ -41,17 +41,17 @@ TEST_CASE("Legacy timer fallback when high-resolution disabled", "[shared_transp
   cfg.connectTimeout = 1000ms;
   cfg.handshakeTimeout = 2000ms;
   cfg.gcInterval = 1s;
-  
+
   SharedTransport::TlsConfig srvTls{};
   SharedTransport::TlsConfig cliTls{};
-  
+
   SharedTransport transport(cfg, srvTls, cliTls);
   REQUIRE(transport.start());
-  
+
   // Verify legacy configuration
   REQUIRE(cfg.enableHighResolutionTimers == false);
   REQUIRE(cfg.gcInterval == 1s);
-  
+
   transport.stop();
 }
 
@@ -60,25 +60,25 @@ TEST_CASE("SIP-optimized timeout configuration", "[shared_transport][timers][sip
   // Test SIP-specific timeout configurations for DNS/SRV failover
   SharedTransport::Config sipCfg{};
   sipCfg.enableHighResolutionTimers = true;
-  sipCfg.connectTimeout = 2000ms;      // 2s per SRV record
-  sipCfg.handshakeTimeout = 3000ms;    // 3s for TLS handshake  
-  sipCfg.writeStallTimeout = 1000ms;   // 1s write timeout
-  
+  sipCfg.connectTimeout = 2000ms;    // 2s per SRV record
+  sipCfg.handshakeTimeout = 3000ms;  // 3s for TLS handshake
+  sipCfg.writeStallTimeout = 1000ms; // 1s write timeout
+
   // Verify SIP-optimized timeouts are suitable for DNS/SRV failover
   REQUIRE(sipCfg.connectTimeout == 2000ms);
   REQUIRE(sipCfg.handshakeTimeout == 3000ms);
   REQUIRE(sipCfg.writeStallTimeout == 1000ms);
-  
+
   // These timeouts are suitable for SIP DNS/SRV failover scenarios
   // where we need fast failover through multiple records
   REQUIRE(sipCfg.connectTimeout <= 5000ms);    // Fast enough for SRV failover
   REQUIRE(sipCfg.handshakeTimeout <= 5000ms);  // Fast TLS establishment
   REQUIRE(sipCfg.writeStallTimeout <= 2000ms); // Quick write failure detection
-  
+
   SharedTransport::TlsConfig srvTls{};
   SharedTransport::TlsConfig cliTls{};
   SharedTransport sipTransport(sipCfg, srvTls, cliTls);
-  
+
   REQUIRE(sipTransport.start());
   sipTransport.stop();
 }
@@ -87,19 +87,19 @@ TEST_CASE("Connect timeout with high-resolution timer", "[shared_transport][time
 {
   SharedTransport::Config cfg{};
   cfg.enableHighResolutionTimers = true;
-  cfg.connectTimeout = 100ms;      // Very short timeout for testing
-  
+  cfg.connectTimeout = 100ms; // Very short timeout for testing
+
   SharedTransport::TlsConfig srvTls{};
   SharedTransport::TlsConfig cliTls{};
   SharedTransport transport(cfg, srvTls, cliTls);
-  
+
   std::atomic<bool> connectionFailed{false};
   std::atomic<bool> connected{false};
   std::string lastErrorMessage;
   TransportError lastErrorCode{TransportError::None};
-  
+
   SharedTransport::Callbacks cbs{};
-  cbs.onConnect = [&](SessionId sid, const IoResult& res)
+  cbs.onConnect = [&](SessionId sid, const IoResult &res)
   {
     if (res.ok)
     {
@@ -110,40 +110,42 @@ TEST_CASE("Connect timeout with high-resolution timer", "[shared_transport][time
       connectionFailed = true;
       lastErrorMessage = res.message;
       lastErrorCode = res.code;
-      std::cout << "Connection failed: " << res.message << " (code " << static_cast<int>(res.code) << ")\n";
+      std::cout << "Connection failed: " << res.message << " (code " << static_cast<int>(res.code)
+                << ")\n";
     }
   };
-  
-  cbs.onClosed = [&](SessionId sid, const IoResult& res)
+
+  cbs.onClosed = [&](SessionId sid, const IoResult &res)
   {
     connectionFailed = true;
     lastErrorMessage = res.message;
     lastErrorCode = res.code;
-    std::cout << "Connection closed: " << res.message << " (code " << static_cast<int>(res.code) << ")\n";
+    std::cout << "Connection closed: " << res.message << " (code " << static_cast<int>(res.code)
+              << ")\n";
   };
-  
+
   transport.setCallbacks(cbs);
   REQUIRE(transport.start());
-  
+
   // Try to connect to a non-routable address that should timeout quickly
   // Using 10.254.254.254 which should be non-routable
   SessionId sid = transport.connect("10.254.254.254", 9999, TlsMode::None);
   REQUIRE(sid != 0);
-  
+
   // Wait for timeout to occur (should be around 100ms)
   auto start = std::chrono::steady_clock::now();
-  
+
   for (int i = 0; i < 50 && !connectionFailed && !connected; ++i)
   {
     std::this_thread::sleep_for(10ms);
   }
-  
+
   auto elapsed = std::chrono::steady_clock::now() - start;
-  
+
   // Should timeout much faster than the old default of 30 seconds
   REQUIRE((connectionFailed || connected));
   REQUIRE(elapsed < 500ms); // Should be much faster than 5 seconds
   REQUIRE(lastErrorCode == TransportError::Timeout);
-  
+
   transport.stop();
 }
\ No newline at end of file
diff --git a/tests/network/iora_test_shared_udp.cpp b/tests/network/iora_test_shared_udp.cpp
index b83fe0e..3b52c55 100644
--- a/tests/network/iora_test_shared_udp.cpp
+++ b/tests/network/iora_test_shared_udp.cpp
@@ -1,9 +1,8 @@
 #define CATCH_CONFIG_MAIN
 #include <catch2/catch.hpp>
-#include "test_helpers.hpp"
 #include "iora/network/shared_transport_udp.hpp"
 #include "iora_test_net_utils.hpp"
-
+#include "test_helpers.hpp"
 
 using namespace std::chrono_literals;
 using SharedUdpTransport = iora::network::SharedUdpTransport;
@@ -43,7 +42,7 @@ struct UdpFixture
   UdpFixture()
   {
     SharedUdpTransport::Callbacks cbs{};
-    cbs.onAccept = [&](SessionId sid, const std::string&, const IoResult& res)
+    cbs.onAccept = [&](SessionId sid, const std::string &, const IoResult &res)
     {
       REQUIRE(res.ok);
       serverSid = sid;
@@ -51,7 +50,7 @@ struct UdpFixture
       acceptCount++;
       acceptedSessions.push_back(sid);
     };
-    cbs.onConnect = [&](SessionId sid, const IoResult& res)
+    cbs.onConnect = [&](SessionId sid, const IoResult &res)
     {
       if (res.ok)
       {
@@ -61,46 +60,49 @@ struct UdpFixture
         connectedSessions.push_back(sid);
       }
     };
-    cbs.onData = [&](SessionId sid, const std::uint8_t* data, std::size_t n, const IoResult& res)
+    cbs.onData = [&](SessionId sid, const std::uint8_t *data, std::size_t n, const IoResult &res)
     {
       REQUIRE(res.ok);
       dataCount++;
       // Echo on server; detect on client
-      if (std::find(acceptedSessions.begin(), acceptedSessions.end(), sid) != acceptedSessions.end())
+      if (std::find(acceptedSessions.begin(), acceptedSessions.end(), sid) !=
+          acceptedSessions.end())
       {
         REQUIRE(tx.send(sid, data, n));
       }
       if (sid == clientSid)
       {
         clientGotEcho = true;
-        lastData = std::string(reinterpret_cast<const char*>(data), n);
+        lastData = std::string(reinterpret_cast<const char *>(data), n);
       }
       {
         std::lock_guard<std::mutex> lock(dataMutex);
-        receivedData.push_back(std::string(reinterpret_cast<const char*>(data), n));
+        receivedData.push_back(std::string(reinterpret_cast<const char *>(data), n));
       }
     };
-    cbs.onClosed = [&](SessionId, const IoResult&) { 
-      anyClosed = true; 
+    cbs.onClosed = [&](SessionId, const IoResult &)
+    {
+      anyClosed = true;
       closeCount++;
     };
-    cbs.onError = [&](TransportError, const std::string& msg) { 
-      lastErrMsg = msg; 
-      errored = true; 
+    cbs.onError = [&](TransportError, const std::string &msg)
+    {
+      lastErrMsg = msg;
+      errored = true;
     };
     tx.setCallbacks(cbs);
   }
 
-  bool waitFor(const std::atomic<bool>& flag, int ms = 1000)
+  bool waitFor(const std::atomic<bool> &flag, int ms = 1000)
   {
-    for (int i = 0; i < ms/5 && !flag.load(); ++i) 
+    for (int i = 0; i < ms / 5 && !flag.load(); ++i)
       std::this_thread::sleep_for(5ms);
     return flag.load();
   }
 
-  bool waitForCount(const std::atomic<int>& counter, int expected, int ms = 1000)
+  bool waitForCount(const std::atomic<int> &counter, int expected, int ms = 1000)
   {
-    for (int i = 0; i < ms/5 && counter.load() < expected; ++i) 
+    for (int i = 0; i < ms / 5 && counter.load() < expected; ++i)
       std::this_thread::sleep_for(5ms);
     return counter.load() >= expected;
   }
@@ -131,7 +133,7 @@ TEST_CASE("UDP loopback echo", "[udp][echo]")
   // In UDP, connected should be immediate, but accepted only happens after first data
   REQUIRE(f.waitFor(f.connected));
 
-  const char* msg = "hello udp";
+  const char *msg = "hello udp";
   REQUIRE(f.tx.send(cs, msg, std::strlen(msg)));
 
   // Now wait for both acceptance (from first data) and echo response
@@ -155,7 +157,7 @@ TEST_CASE("UDP rejects TLS mode", "[udp][config]")
   // Should return 0 and error-callback for TLS attempt
   ListenerId lid = f.tx.addListener("127.0.0.1", port, TlsMode::Server);
   REQUIRE(lid == 0);
-  
+
   f.tx.stop();
 }
 
@@ -169,7 +171,7 @@ TEST_CASE("UDP duplicate listener error", "[udp][error]")
   REQUIRE(a != 0);
 
   ListenerId b = f.tx.addListener("127.0.0.1", port, TlsMode::None);
-  REQUIRE(b != 0);  // Returns a valid ID, but bind will fail async
+  REQUIRE(b != 0); // Returns a valid ID, but bind will fail async
 
   // Give time for async bind error
   std::this_thread::sleep_for(100ms);
@@ -192,21 +194,21 @@ TEST_CASE("UDP stats verification", "[udp][stats]")
 
   (void)f.tx.addListener("127.0.0.1", port, TlsMode::None);
   SessionId cs = f.tx.connect("127.0.0.1", port, TlsMode::None);
-  
+
   REQUIRE(f.waitFor(f.connected));
-  
-  const char* msg = "test message";
+
+  const char *msg = "test message";
   size_t msgLen = std::strlen(msg);
   REQUIRE(f.tx.send(cs, msg, msgLen));
-  
+
   REQUIRE(f.waitFor(f.accepted));
   REQUIRE(f.waitFor(f.clientGotEcho));
 
   auto stats2 = f.tx.stats();
   REQUIRE(stats2.connected == 1);
   REQUIRE(stats2.accepted == 1);
-  REQUIRE(stats2.bytesIn >= msgLen);  // At least the original message
-  REQUIRE(stats2.bytesOut >= msgLen); // At least the echo
+  REQUIRE(stats2.bytesIn >= msgLen);    // At least the original message
+  REQUIRE(stats2.bytesOut >= msgLen);   // At least the echo
   REQUIRE(stats2.sessionsCurrent == 2); // Client and server peer
   REQUIRE(stats2.sessionsPeak >= 2);
 
@@ -232,7 +234,7 @@ TEST_CASE("UDP multiple simultaneous connections", "[udp][multi]")
   // Create multiple clients
   const int numClients = 5;
   std::vector<SessionId> clients;
-  
+
   for (int i = 0; i < numClients; ++i)
   {
     SessionId cs = f.tx.connect("127.0.0.1", port, TlsMode::None);
@@ -276,17 +278,17 @@ TEST_CASE("UDP connectViaListener", "[udp][via]")
   SharedUdpTransport::Config cfg2{};
   SharedUdpTransport::TlsConfig tlsCfg2{};
   SharedUdpTransport tx2{cfg2, tlsCfg2, tlsCfg2};
-  
+
   std::atomic<bool> server2Received{false};
   SharedUdpTransport::Callbacks cbs2{};
-  cbs2.onData = [&](SessionId, const std::uint8_t* data, std::size_t n, const IoResult&)
+  cbs2.onData = [&](SessionId, const std::uint8_t *data, std::size_t n, const IoResult &)
   {
-    std::string msg(reinterpret_cast<const char*>(data), n);
+    std::string msg(reinterpret_cast<const char *>(data), n);
     if (msg == "via_test")
       server2Received = true;
   };
   tx2.setCallbacks(cbs2);
-  
+
   REQUIRE(tx2.start());
   ListenerId lid2 = tx2.addListener("127.0.0.1", port2, TlsMode::None);
   REQUIRE(lid2 != 0);
@@ -297,11 +299,11 @@ TEST_CASE("UDP connectViaListener", "[udp][via]")
 
   REQUIRE(f.waitFor(f.connected));
 
-  const char* msg = "via_test";
+  const char *msg = "via_test";
   REQUIRE(f.tx.send(cs, msg, std::strlen(msg)));
 
   // Wait for server2 to receive
-  for (int i = 0; i < 200 && !server2Received.load(); ++i) 
+  for (int i = 0; i < 200 && !server2Received.load(); ++i)
     std::this_thread::sleep_for(5ms);
   REQUIRE(server2Received.load());
 
@@ -319,7 +321,7 @@ TEST_CASE("UDP configuration changes", "[udp][config]")
   auto port = testnet::getFreePortUDP();
   (void)f.tx.addListener("127.0.0.1", port, TlsMode::None);
   SessionId cs = f.tx.connect("127.0.0.1", port, TlsMode::None);
-  
+
   REQUIRE(f.waitFor(f.connected));
 
   // Change configuration
@@ -327,13 +329,13 @@ TEST_CASE("UDP configuration changes", "[udp][config]")
   newCfg.gcInterval = std::chrono::seconds(2);
   newCfg.maxWriteQueue = 20;
   newCfg.ioReadChunk = 128 * 1024;
-  
+
   f.tx.reconfigure(newCfg);
 
   // Verify connection still works after reconfigure
-  const char* msg = "after_reconfig";
+  const char *msg = "after_reconfig";
   REQUIRE(f.tx.send(cs, msg, std::strlen(msg)));
-  
+
   REQUIRE(f.waitFor(f.accepted));
   REQUIRE(f.waitFor(f.clientGotEcho));
   REQUIRE(f.lastData == msg);
@@ -349,7 +351,7 @@ TEST_CASE("UDP error conditions", "[udp][error]")
   SECTION("send to non-existent session")
   {
     SessionId fakeSid = 9999;
-    const char* msg = "test";
+    const char *msg = "test";
     REQUIRE(f.tx.send(fakeSid, msg, std::strlen(msg))); // Returns true but does nothing
   }
 
@@ -363,10 +365,10 @@ TEST_CASE("UDP error conditions", "[udp][error]")
   {
     SessionId cs = f.tx.connect("not.an.ip.address", 1234, TlsMode::None);
     REQUIRE(cs != 0); // ID allocated
-    
+
     // Wait for connect error callback
     std::this_thread::sleep_for(100ms);
-    
+
     // Connection should have failed
     REQUIRE_FALSE(f.connected.load());
   }
@@ -376,10 +378,10 @@ TEST_CASE("UDP error conditions", "[udp][error]")
     ListenerId fakeLid = 9999;
     SessionId cs = f.tx.connectViaListener(fakeLid, "127.0.0.1", 1234);
     REQUIRE(cs != 0); // ID allocated
-    
+
     // Wait a bit
     std::this_thread::sleep_for(100ms);
-    
+
     // Connection should have failed
     REQUIRE_FALSE(f.connected.load());
   }
@@ -393,16 +395,16 @@ TEST_CASE("UDP garbage collection", "[udp][gc]")
   f.cfg.idleTimeout = std::chrono::seconds(1);
   f.cfg.gcInterval = std::chrono::seconds(1);
   f.cfg.maxConnAge = std::chrono::seconds(0); // Disabled
-  
+
   REQUIRE(f.tx.start());
   auto port = testnet::getFreePortUDP();
 
   (void)f.tx.addListener("127.0.0.1", port, TlsMode::None);
   SessionId cs = f.tx.connect("127.0.0.1", port, TlsMode::None);
-  
+
   REQUIRE(f.waitFor(f.connected));
 
-  const char* msg = "test";
+  const char *msg = "test";
   REQUIRE(f.tx.send(cs, msg, std::strlen(msg)));
   REQUIRE(f.waitFor(f.accepted));
 
@@ -417,8 +419,8 @@ TEST_CASE("UDP garbage collection", "[udp][gc]")
   // Note: GC timer implementation might not be working in tests
   // Just verify basic functionality
   // sessionsCurrent is unsigned, so >= 0 check is always true
-  REQUIRE(true);  // Sessions might be cleaned up
-  
+  REQUIRE(true); // Sessions might be cleaned up
+
   f.tx.stop();
 }
 
@@ -428,16 +430,16 @@ TEST_CASE("UDP max connection age", "[udp][gc][age]")
   f.cfg.idleTimeout = std::chrono::seconds(0); // Disabled
   f.cfg.maxConnAge = std::chrono::seconds(1);
   f.cfg.gcInterval = std::chrono::seconds(1);
-  
+
   REQUIRE(f.tx.start());
   auto port = testnet::getFreePortUDP();
 
   (void)f.tx.addListener("127.0.0.1", port, TlsMode::None);
   SessionId cs = f.tx.connect("127.0.0.1", port, TlsMode::None);
-  
+
   REQUIRE(f.waitFor(f.connected));
 
-  const char* msg = "test";
+  const char *msg = "test";
   REQUIRE(f.tx.send(cs, msg, std::strlen(msg)));
   REQUIRE(f.waitFor(f.accepted));
 
@@ -458,8 +460,8 @@ TEST_CASE("UDP max connection age", "[udp][gc][age]")
   // Note: GC timer implementation might not be working in tests
   // Just verify basic functionality
   // sessionsCurrent is unsigned, so >= 0 check is always true
-  REQUIRE(true);  // Sessions might be cleaned up
-  
+  REQUIRE(true); // Sessions might be cleaned up
+
   f.tx.stop();
 }
 
@@ -468,24 +470,24 @@ TEST_CASE("UDP backpressure handling", "[udp][backpressure]")
   UdpFixture f;
   f.cfg.maxWriteQueue = 5;
   f.cfg.closeOnBackpressure = true;
-  
+
   REQUIRE(f.tx.start());
   auto port = testnet::getFreePortUDP();
 
   (void)f.tx.addListener("127.0.0.1", port, TlsMode::None);
-  
+
   // Create a server that doesn't echo (to cause backpressure)
   SharedUdpTransport::Config cfg2{};
   SharedUdpTransport::TlsConfig tlsCfg2{};
   SharedUdpTransport tx2{cfg2, tlsCfg2, tlsCfg2};
-  
+
   SharedUdpTransport::Callbacks cbs2{};
-  cbs2.onData = [&](SessionId, const std::uint8_t*, std::size_t, const IoResult&)
+  cbs2.onData = [&](SessionId, const std::uint8_t *, std::size_t, const IoResult &)
   {
     // Don't echo - just receive
   };
   tx2.setCallbacks(cbs2);
-  
+
   REQUIRE(tx2.start());
   auto port2 = testnet::getFreePortUDP();
   (void)tx2.addListener("127.0.0.1", port2, TlsMode::None);
@@ -505,7 +507,7 @@ TEST_CASE("UDP backpressure handling", "[udp][backpressure]")
   (void)f.tx.stats();
   // Should have some backpressure events if queue filled
   // Note: UDP might not actually trigger backpressure easily
-  
+
   f.tx.stop();
   tx2.stop();
 }
@@ -514,12 +516,12 @@ TEST_CASE("UDP IPv6 support", "[udp][ipv6]")
 {
   UdpFixture f;
   REQUIRE(f.tx.start());
-  
+
   auto port = testnet::getFreePortUDP();
 
   // Try IPv6 loopback
   ListenerId lid = f.tx.addListener("::1", port, TlsMode::None);
-  
+
   if (lid != 0) // Only if IPv6 is available
   {
     SessionId cs = f.tx.connect("::1", port, TlsMode::None);
@@ -527,14 +529,14 @@ TEST_CASE("UDP IPv6 support", "[udp][ipv6]")
 
     REQUIRE(f.waitFor(f.connected));
 
-    const char* msg = "ipv6_test";
+    const char *msg = "ipv6_test";
     REQUIRE(f.tx.send(cs, msg, std::strlen(msg)));
 
     REQUIRE(f.waitFor(f.accepted));
     REQUIRE(f.waitFor(f.clientGotEcho));
     REQUIRE(f.lastData == msg);
   }
-  
+
   f.tx.stop();
 }
 
@@ -546,16 +548,16 @@ TEST_CASE("UDP large data transfer", "[udp][large]")
 
   (void)f.tx.addListener("127.0.0.1", port, TlsMode::None);
   SessionId cs = f.tx.connect("127.0.0.1", port, TlsMode::None);
-  
+
   REQUIRE(f.waitFor(f.connected));
 
   // Send a message near UDP MTU limit (typically ~1500 bytes for Ethernet)
   std::string largeMsg(1400, 'A');
   largeMsg[0] = 'S';
-  largeMsg[largeMsg.size()-1] = 'E';
-  
+  largeMsg[largeMsg.size() - 1] = 'E';
+
   REQUIRE(f.tx.send(cs, largeMsg.data(), largeMsg.size()));
-  
+
   REQUIRE(f.waitFor(f.accepted));
   REQUIRE(f.waitFor(f.clientGotEcho));
   REQUIRE(f.lastData == largeMsg);
@@ -563,7 +565,7 @@ TEST_CASE("UDP large data transfer", "[udp][large]")
   // Verify integrity
   REQUIRE(f.lastData.size() == largeMsg.size());
   REQUIRE(f.lastData[0] == 'S');
-  REQUIRE(f.lastData[f.lastData.size()-1] == 'E');
+  REQUIRE(f.lastData[f.lastData.size() - 1] == 'E');
 
   f.tx.stop();
 }
@@ -572,7 +574,7 @@ TEST_CASE("UDP multiple listeners", "[udp][multi-listener]")
 {
   UdpFixture f;
   REQUIRE(f.tx.start());
-  
+
   auto port1 = testnet::getFreePortUDP();
   auto port2 = testnet::getFreePortUDP();
   auto port3 = testnet::getFreePortUDP();
@@ -580,7 +582,7 @@ TEST_CASE("UDP multiple listeners", "[udp][multi-listener]")
   ListenerId lid1 = f.tx.addListener("127.0.0.1", port1, TlsMode::None);
   ListenerId lid2 = f.tx.addListener("127.0.0.1", port2, TlsMode::None);
   ListenerId lid3 = f.tx.addListener("127.0.0.1", port3, TlsMode::None);
-  
+
   REQUIRE(lid1 != 0);
   REQUIRE(lid2 != 0);
   REQUIRE(lid3 != 0);
@@ -619,18 +621,18 @@ TEST_CASE("UDP edge vs level triggered", "[udp][epoll]")
     UdpFixture f;
     f.cfg.useEdgeTriggered = true;
     REQUIRE(f.tx.start());
-    
+
     auto port = testnet::getFreePortUDP();
     (void)f.tx.addListener("127.0.0.1", port, TlsMode::None);
     SessionId cs = f.tx.connect("127.0.0.1", port, TlsMode::None);
-    
+
     REQUIRE(f.waitFor(f.connected));
-    
-    const char* msg = "edge_test";
+
+    const char *msg = "edge_test";
     REQUIRE(f.tx.send(cs, msg, std::strlen(msg)));
     REQUIRE(f.waitFor(f.clientGotEcho));
     REQUIRE(f.lastData == msg);
-    
+
     f.tx.stop();
   }
 
@@ -639,18 +641,18 @@ TEST_CASE("UDP edge vs level triggered", "[udp][epoll]")
     UdpFixture f;
     f.cfg.useEdgeTriggered = false;
     REQUIRE(f.tx.start());
-    
+
     auto port = testnet::getFreePortUDP();
     (void)f.tx.addListener("127.0.0.1", port, TlsMode::None);
     SessionId cs = f.tx.connect("127.0.0.1", port, TlsMode::None);
-    
+
     REQUIRE(f.waitFor(f.connected));
-    
-    const char* msg = "level_test";
+
+    const char *msg = "level_test";
     REQUIRE(f.tx.send(cs, msg, std::strlen(msg)));
     REQUIRE(f.waitFor(f.clientGotEcho));
     REQUIRE(f.lastData == msg);
-    
+
     f.tx.stop();
   }
 }
@@ -664,7 +666,7 @@ TEST_CASE("UDP synchronous listener API", "[udp][sync]")
   {
     auto port = testnet::getFreePortUDP();
     auto result = f.tx.addListenerSync("127.0.0.1", port, TlsMode::None);
-    
+
     REQUIRE(result.result.ok);
     REQUIRE(result.id != 0);
     REQUIRE(result.bindAddress == "127.0.0.1:" + std::to_string(port));
@@ -673,14 +675,14 @@ TEST_CASE("UDP synchronous listener API", "[udp][sync]")
   SECTION("duplicate bind fails immediately")
   {
     auto port = testnet::getFreePortUDP();
-    
+
     // First bind should succeed
     auto result1 = f.tx.addListenerSync("127.0.0.1", port, TlsMode::None);
     REQUIRE(result1.result.ok);
-    
+
     // Give time for the first listener to be actually bound
     std::this_thread::sleep_for(50ms);
-    
+
     // Second bind should fail immediately
     auto result2 = f.tx.addListenerSync("127.0.0.1", port, TlsMode::None);
     REQUIRE_FALSE(result2.result.ok);
@@ -692,7 +694,7 @@ TEST_CASE("UDP synchronous listener API", "[udp][sync]")
   {
     auto port = testnet::getFreePortUDP();
     auto result = f.tx.addListenerSync("127.0.0.1", port, TlsMode::Server);
-    
+
     REQUIRE_FALSE(result.result.ok);
     REQUIRE(result.result.code == TransportError::Config);
     REQUIRE(result.id == 0);
@@ -706,10 +708,10 @@ TEST_CASE("UDP session limits", "[udp][limits]")
   UdpFixture f;
   f.cfg.maxSessions = 4; // Set limit to 4 (2 clients + 2 server peers)
   REQUIRE(f.tx.start());
-  
+
   auto port = testnet::getFreePortUDP();
   (void)f.tx.addListener("127.0.0.1", port, TlsMode::None);
-  
+
   // Create 2 connections
   std::vector<SessionId> clients;
   for (int i = 0; i < 2; ++i)
@@ -718,31 +720,31 @@ TEST_CASE("UDP session limits", "[udp][limits]")
     REQUIRE(cs != 0);
     clients.push_back(cs);
   }
-  
+
   REQUIRE(f.waitForCount(f.connectCount, 2));
-  
+
   // Send from both clients to create server peers (should create 2+2=4 sessions total)
   REQUIRE(f.tx.send(clients[0], "test1", 5));
   REQUIRE(f.tx.send(clients[1], "test2", 5));
-  
+
   std::this_thread::sleep_for(100ms);
-  
+
   auto stats = f.tx.stats();
   REQUIRE(stats.sessionsCurrent <= f.cfg.maxSessions);
-  
+
   // Now try to create another client - should still work
   SessionId cs3 = f.tx.connect("127.0.0.1", port, TlsMode::None);
   REQUIRE(cs3 != 0);
-  
+
   // But sending from it should not create a new server peer (would exceed limit)
   REQUIRE(f.tx.send(cs3, "test3", 5));
   std::this_thread::sleep_for(100ms);
-  
+
   auto stats2 = f.tx.stats();
   // Session count should be reasonable (3 clients + up to 2 server peers)
   // The limit applies to preventing new server peer creation
   REQUIRE(stats2.sessionsCurrent <= 6); // Maximum possible: 3 clients + 3 peers
-  
+
   f.tx.stop();
 }
 
@@ -752,18 +754,18 @@ TEST_CASE("UDP socket buffer configuration", "[udp][socket]")
   f.cfg.soRcvBuf = 256 * 1024;
   f.cfg.soSndBuf = 256 * 1024;
   REQUIRE(f.tx.start());
-  
+
   auto port = testnet::getFreePortUDP();
   (void)f.tx.addListener("127.0.0.1", port, TlsMode::None);
   SessionId cs = f.tx.connect("127.0.0.1", port, TlsMode::None);
-  
+
   REQUIRE(f.waitFor(f.connected));
-  
+
   // Verify it works with configured buffers
-  const char* msg = "buffer_test";
+  const char *msg = "buffer_test";
   REQUIRE(f.tx.send(cs, msg, std::strlen(msg)));
   REQUIRE(f.waitFor(f.clientGotEcho));
   REQUIRE(f.lastData == msg);
-  
+
   f.tx.stop();
 }
\ No newline at end of file
diff --git a/tests/network/iora_test_transport_improvements.cpp b/tests/network/iora_test_transport_improvements.cpp
index 632a12c..bdae208 100644
--- a/tests/network/iora_test_transport_improvements.cpp
+++ b/tests/network/iora_test_transport_improvements.cpp
@@ -1,14 +1,14 @@
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
-#include "test_helpers.hpp"
-#include "iora/network/object_pool.hpp"
-#include "iora/network/connection_health.hpp"
 #include "iora/network/circuit_breaker.hpp"
+#include "iora/network/connection_health.hpp"
+#include "iora/network/object_pool.hpp"
 #include "iora/network/transport_types.hpp"
-#include <thread>
+#include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 #include <chrono>
-#include <vector>
 #include <random>
+#include <thread>
+#include <vector>
 
 using namespace std::chrono_literals;
 using namespace iora::network;
@@ -19,7 +19,7 @@ struct TestSession
   int id{0};
   std::string data;
   bool active{false};
-  
+
   void reset()
   {
     id = 0;
@@ -31,62 +31,62 @@ struct TestSession
 TEST_CASE("ObjectPool basic functionality", "[pool][basic]")
 {
   auto factory = []() { return std::make_unique<TestSession>(); };
-  auto resetter = [](TestSession* s) { s->reset(); };
-  
+  auto resetter = [](TestSession *s) { s->reset(); };
+
   ObjectPool<TestSession> pool(factory, resetter, 2);
-  
+
   SECTION("Pool starts with initial objects")
   {
     auto stats = pool.getStats();
     REQUIRE(stats.available == 2);
     REQUIRE(stats.totalCreated == 2);
   }
-  
+
   SECTION("Acquire and release works correctly")
   {
     auto obj1 = pool.acquire();
     REQUIRE(obj1 != nullptr);
-    
+
     auto stats = pool.getStats();
     REQUIRE(stats.available == 1);
     REQUIRE(stats.totalAcquired == 1);
-    
+
     obj1->id = 42;
     obj1->data = "test";
     pool.release(std::move(obj1));
-    
+
     // Object should be reset and back in pool
     auto obj2 = pool.acquire();
     REQUIRE(obj2 != nullptr);
     REQUIRE(obj2->id == 0);
     REQUIRE(obj2->data.empty());
   }
-  
+
   SECTION("Pool creates new objects when empty")
   {
     // Acquire all initial objects
     auto obj1 = pool.acquire();
     auto obj2 = pool.acquire();
-    
+
     // Should create new object
     auto obj3 = pool.acquire();
     REQUIRE(obj3 != nullptr);
-    
+
     auto stats = pool.getStats();
     REQUIRE(stats.totalCreated == 3);
   }
-  
+
   SECTION("Pool limits maximum size")
   {
     pool.setMaxPoolSize(1);
-    
+
     auto obj1 = pool.acquire();
     auto obj2 = pool.acquire();
-    
+
     // Release both - only one should be kept in pool, one destroyed due to size limit
     pool.release(std::move(obj1));
     pool.release(std::move(obj2));
-    
+
     auto stats = pool.getStats();
     REQUIRE(stats.available == 1);
     // Expect 2 destroyed: 1 from setMaxPoolSize trimming + 1 from release overflow
@@ -98,7 +98,7 @@ TEST_CASE("PooledObject RAII wrapper", "[pool][raii]")
 {
   auto factory = []() { return std::make_unique<TestSession>(); };
   ObjectPool<TestSession> pool(factory);
-  
+
   SECTION("Automatic return to pool on destruction")
   {
     {
@@ -106,17 +106,17 @@ TEST_CASE("PooledObject RAII wrapper", "[pool][raii]")
       pooled->id = 100;
       REQUIRE(pooled.get() != nullptr);
     } // pooled goes out of scope
-    
+
     // Object should be back in pool
     auto obj = pool.acquire();
     REQUIRE(obj->id == 100); // No resetter, so value preserved
   }
-  
+
   SECTION("Move semantics work correctly")
   {
     auto pooled1 = makePooled(pool);
     pooled1->id = 200;
-    
+
     auto pooled2 = std::move(pooled1);
     REQUIRE(pooled2->id == 200);
     REQUIRE(!pooled1); // moved-from object is empty
@@ -129,68 +129,68 @@ TEST_CASE("ConnectionHealth basic functionality", "[health][basic]")
   config.heartbeatInterval = 1s;
   config.timeoutThreshold = 2s;
   config.maxConsecutiveFailures = 3;
-  
+
   ConnectionHealth health(config);
-  
+
   SECTION("Starts in healthy state")
   {
     REQUIRE(health.isHealthy());
     REQUIRE(health.getState() == ConnectionState::Healthy);
   }
-  
+
   SECTION("Records activity correctly")
   {
     health.recordActivity();
     REQUIRE(health.isHealthy());
-    
+
     // Should not need heartbeat immediately after activity
     REQUIRE_FALSE(health.needsHeartbeat());
   }
-  
+
   SECTION("Handles failures correctly")
   {
     health.recordFailure();
     REQUIRE(health.getState() == ConnectionState::Warning);
-    
+
     health.recordFailure();
     REQUIRE(health.getState() == ConnectionState::Degraded);
-    
+
     health.recordFailure();
     REQUIRE(health.getState() == ConnectionState::Critical);
-    
+
     health.recordFailure();
     REQUIRE(health.getState() == ConnectionState::Unhealthy);
     REQUIRE_FALSE(health.isHealthy());
   }
-  
+
   SECTION("Recovers from failures with successes")
   {
     // Build up failures
     health.recordFailure();
     health.recordFailure();
     REQUIRE(health.getState() == ConnectionState::Degraded);
-    
+
     // Record success - should improve state
     health.recordSuccess();
     REQUIRE(health.getState() == ConnectionState::Warning);
-    
+
     health.recordSuccess();
     REQUIRE(health.getState() == ConnectionState::Healthy);
   }
-  
+
   SECTION("Detects timeout correctly")
   {
     // Fast forward time by sleeping beyond timeout threshold
     std::this_thread::sleep_for(3s);
     REQUIRE(health.isTimedOut());
   }
-  
+
   SECTION("Calculates statistics correctly")
   {
     health.recordSuccess();
     health.recordSuccess();
     health.recordFailure();
-    
+
     auto stats = health.getStats();
     REQUIRE(stats.totalSuccesses == 2);
     REQUIRE(stats.totalFailures == 1);
@@ -201,39 +201,39 @@ TEST_CASE("HealthMonitor manages multiple connections", "[health][monitor]")
 {
   HealthConfig config{};
   config.maxConsecutiveFailures = 2;
-  
+
   HealthMonitor monitor(config);
-  
+
   SECTION("Manages connection lifecycle")
   {
     monitor.addConnection(1);
     monitor.addConnection(2);
-    
+
     monitor.recordActivity(1);
     monitor.recordFailure(2);
     monitor.recordFailure(2);
     monitor.recordFailure(2); // Should become unhealthy
-    
+
     auto unhealthy = monitor.getUnhealthyConnections();
     REQUIRE(unhealthy.size() == 1);
     REQUIRE(unhealthy[0] == 2);
-    
+
     monitor.removeConnection(2);
     unhealthy = monitor.getUnhealthyConnections();
     REQUIRE(unhealthy.empty());
   }
-  
+
   SECTION("Provides overall statistics")
   {
     monitor.addConnection(1);
     monitor.addConnection(2);
     monitor.addConnection(3);
-    
+
     monitor.recordFailure(1);
     monitor.recordFailure(2);
     monitor.recordFailure(2);
     monitor.recordFailure(2);
-    
+
     auto stats = monitor.getOverallStats();
     REQUIRE(stats.totalConnections == 3);
     REQUIRE(stats.healthyConnections == 1);
@@ -248,33 +248,33 @@ TEST_CASE("CircuitBreaker basic functionality", "[circuit][basic]")
   config.failureThreshold = 3;
   config.timeout = 1s;
   config.successThreshold = 2;
-  
+
   CircuitBreaker breaker(config);
-  
+
   SECTION("Starts in closed state")
   {
     REQUIRE(breaker.getState() == CircuitBreakerState::Closed);
     REQUIRE(breaker.allowRequest());
   }
-  
+
   SECTION("Opens after failure threshold")
   {
     REQUIRE(breaker.allowRequest());
-    
+
     // Record failures
     breaker.recordFailure();
     REQUIRE(breaker.getState() == CircuitBreakerState::Closed);
     REQUIRE(breaker.allowRequest());
-    
+
     breaker.recordFailure();
     REQUIRE(breaker.getState() == CircuitBreakerState::Closed);
     REQUIRE(breaker.allowRequest());
-    
+
     breaker.recordFailure();
     REQUIRE(breaker.getState() == CircuitBreakerState::Open);
     REQUIRE_FALSE(breaker.allowRequest());
   }
-  
+
   SECTION("Transitions to half-open after timeout")
   {
     // Force open state
@@ -282,14 +282,14 @@ TEST_CASE("CircuitBreaker basic functionality", "[circuit][basic]")
     breaker.recordFailure();
     breaker.recordFailure();
     REQUIRE(breaker.getState() == CircuitBreakerState::Open);
-    
+
     // Wait for timeout
     std::this_thread::sleep_for(2s);
-    
+
     // Should allow request and transition to half-open
     REQUIRE(breaker.allowRequest());
   }
-  
+
   SECTION("Closes after successful recovery")
   {
     // Force to half-open state
@@ -298,14 +298,14 @@ TEST_CASE("CircuitBreaker basic functionality", "[circuit][basic]")
     breaker.recordFailure();
     std::this_thread::sleep_for(2s);
     breaker.allowRequest(); // Triggers half-open
-    
+
     // Record enough successes to close
     breaker.recordSuccess();
     breaker.recordSuccess();
-    
+
     REQUIRE(breaker.getState() == CircuitBreakerState::Closed);
   }
-  
+
   SECTION("Returns to open on failure during half-open")
   {
     // Force to half-open
@@ -314,18 +314,18 @@ TEST_CASE("CircuitBreaker basic functionality", "[circuit][basic]")
     breaker.recordFailure();
     std::this_thread::sleep_for(2s);
     breaker.allowRequest();
-    
+
     // Fail during half-open
     breaker.recordFailure();
     REQUIRE(breaker.getState() == CircuitBreakerState::Open);
   }
-  
+
   SECTION("Provides accurate statistics")
   {
     breaker.recordSuccess();
     breaker.recordFailure();
     breaker.recordFailure();
-    
+
     auto stats = breaker.getStats();
     REQUIRE(stats.totalRequests == 3);
     REQUIRE(stats.failureCount == 2);
@@ -335,16 +335,16 @@ TEST_CASE("CircuitBreaker basic functionality", "[circuit][basic]")
 TEST_CASE("CircuitBreakerManager handles multiple breakers", "[circuit][manager]")
 {
   CircuitBreakerManager manager;
-  
+
   SECTION("Creates breakers on demand")
   {
     REQUIRE(manager.allowRequest("service1"));
     REQUIRE(manager.allowRequest("service2"));
-    
+
     auto names = manager.getBreakerNames();
     REQUIRE(names.size() == 2);
   }
-  
+
   SECTION("Manages independent breaker states")
   {
     // Break one service (need 5 failures for default threshold)
@@ -353,28 +353,28 @@ TEST_CASE("CircuitBreakerManager handles multiple breakers", "[circuit][manager]
     manager.recordFailure("service1");
     manager.recordFailure("service1");
     manager.recordFailure("service1");
-    
+
     REQUIRE(manager.getState("service1") == CircuitBreakerState::Open);
     REQUIRE(manager.getState("service2") == CircuitBreakerState::Closed);
-    
+
     REQUIRE_FALSE(manager.allowRequest("service1"));
     REQUIRE(manager.allowRequest("service2"));
   }
-  
+
   SECTION("Updates all configurations")
   {
     manager.allowRequest("service1");
     manager.allowRequest("service2");
-    
+
     CircuitBreakerConfig newConfig{};
     newConfig.failureThreshold = 1;
-    
+
     manager.updateAllConfigs(newConfig);
-    
+
     // Both should open after single failure with threshold=1
     manager.recordFailure("service1");
     manager.recordFailure("service2");
-    
+
     REQUIRE(manager.getState("service1") == CircuitBreakerState::Open);
     REQUIRE(manager.getState("service2") == CircuitBreakerState::Open);
   }
@@ -388,19 +388,20 @@ TEST_CASE("Enhanced error structures", "[error][enhanced]")
     REQUIRE(warning.severity == ErrorSeverity::Warning);
     REQUIRE(warning.context == "test context");
     REQUIRE(warning.details == "test details");
-    
-    auto error = TransportEvent::error(TransportError::Bind, "bind failed", "port in use", EADDRINUSE);
+
+    auto error =
+      TransportEvent::error(TransportError::Bind, "bind failed", "port in use", EADDRINUSE);
     REQUIRE(error.severity == ErrorSeverity::Recoverable);
     REQUIRE(error.sysErrno == EADDRINUSE);
   }
-  
+
   SECTION("ListenerResult usage")
   {
     auto success = ListenerResult::success(42, "127.0.0.1:8080");
     REQUIRE(success.id == 42);
     REQUIRE(success.result.ok);
     REQUIRE(success.bindAddress == "127.0.0.1:8080");
-    
+
     auto failure = ListenerResult::failure(TransportError::Bind, "bind failed", EADDRINUSE);
     REQUIRE(failure.id == 0);
     REQUIRE_FALSE(failure.result.ok);
@@ -415,92 +416,94 @@ TEST_CASE("Concurrency stress tests", "[stress][concurrent]")
   {
     auto factory = []() { return std::make_unique<TestSession>(); };
     ObjectPool<TestSession> pool(factory, nullptr, 10);
-    
+
     constexpr int numThreads = 8;
     constexpr int operationsPerThread = 1000;
-    
+
     std::vector<std::thread> threads;
     std::atomic<int> totalAcquired{0};
-    
+
     for (int i = 0; i < numThreads; ++i)
     {
-      threads.emplace_back([&pool, &totalAcquired, operationsPerThread]()
-      {
-        for (int j = 0; j < operationsPerThread; ++j)
+      threads.emplace_back(
+        [&pool, &totalAcquired, operationsPerThread]()
         {
-          auto obj = pool.acquire();
-          totalAcquired.fetch_add(1, std::memory_order_relaxed);
-          
-          // Simulate some work
-          obj->id = j;
-          std::this_thread::sleep_for(std::chrono::microseconds(1));
-          
-          pool.release(std::move(obj));
-        }
-      });
+          for (int j = 0; j < operationsPerThread; ++j)
+          {
+            auto obj = pool.acquire();
+            totalAcquired.fetch_add(1, std::memory_order_relaxed);
+
+            // Simulate some work
+            obj->id = j;
+            std::this_thread::sleep_for(std::chrono::microseconds(1));
+
+            pool.release(std::move(obj));
+          }
+        });
     }
-    
-    for (auto& t : threads)
+
+    for (auto &t : threads)
     {
       t.join();
     }
-    
+
     REQUIRE(totalAcquired.load() == numThreads * operationsPerThread);
   }
-  
+
   SECTION("CircuitBreaker thread safety")
   {
     CircuitBreaker breaker;
-    
+
     constexpr int numThreads = 4;
     constexpr int operationsPerThread = 1000;
-    
+
     std::vector<std::thread> threads;
     std::atomic<int> allowedRequests{0};
     std::atomic<int> deniedRequests{0};
-    
+
     for (int i = 0; i < numThreads; ++i)
     {
-      threads.emplace_back([&, i]()
-      {
-        std::random_device rd;
-        std::mt19937 gen(rd());
-        std::uniform_real_distribution<> dis(0.0, 1.0);
-        
-        for (int j = 0; j < operationsPerThread; ++j)
+      threads.emplace_back(
+        [&, i]()
         {
-          if (breaker.allowRequest())
+          std::random_device rd;
+          std::mt19937 gen(rd());
+          std::uniform_real_distribution<> dis(0.0, 1.0);
+
+          for (int j = 0; j < operationsPerThread; ++j)
           {
-            allowedRequests.fetch_add(1, std::memory_order_relaxed);
-            
-            // Simulate 30% failure rate
-            if (dis(gen) < 0.3)
+            if (breaker.allowRequest())
             {
-              breaker.recordFailure();
+              allowedRequests.fetch_add(1, std::memory_order_relaxed);
+
+              // Simulate 30% failure rate
+              if (dis(gen) < 0.3)
+              {
+                breaker.recordFailure();
+              }
+              else
+              {
+                breaker.recordSuccess();
+              }
             }
             else
             {
-              breaker.recordSuccess();
+              deniedRequests.fetch_add(1, std::memory_order_relaxed);
             }
+
+            std::this_thread::sleep_for(std::chrono::microseconds(10));
           }
-          else
-          {
-            deniedRequests.fetch_add(1, std::memory_order_relaxed);
-          }
-          
-          std::this_thread::sleep_for(std::chrono::microseconds(10));
-        }
-      });
+        });
     }
-    
-    for (auto& t : threads)
+
+    for (auto &t : threads)
     {
       t.join();
     }
-    
+
     int totalRequests = allowedRequests.load() + deniedRequests.load();
     REQUIRE(totalRequests == numThreads * operationsPerThread);
-    
+
     // Circuit should have opened at some point due to failures
     REQUIRE(deniedRequests.load() > 0);
   }
@@ -512,15 +515,15 @@ TEST_CASE("Performance benchmarks", "[benchmark][performance]")
   {
     auto factory = []() { return std::make_unique<TestSession>(); };
     ObjectPool<TestSession> pool(factory, nullptr, 100);
-    
+
     constexpr int iterations = 10000;
-    
+
     // Warm up pool
     for (int i = 0; i < 100; ++i)
     {
       pool.release(pool.acquire());
     }
-    
+
     // Benchmark pool
     auto start = std::chrono::high_resolution_clock::now();
     for (int i = 0; i < iterations; ++i)
@@ -530,7 +533,7 @@ TEST_CASE("Performance benchmarks", "[benchmark][performance]")
       pool.release(std::move(obj));
     }
     auto poolTime = std::chrono::high_resolution_clock::now() - start;
-    
+
     // Benchmark raw allocation
     start = std::chrono::high_resolution_clock::now();
     for (int i = 0; i < iterations; ++i)
@@ -540,24 +543,24 @@ TEST_CASE("Performance benchmarks", "[benchmark][performance]")
       // obj automatically destroyed
     }
     auto rawTime = std::chrono::high_resolution_clock::now() - start;
-    
+
     // Pool should be faster (or at least not significantly slower)
     auto poolMs = std::chrono::duration_cast<std::chrono::microseconds>(poolTime).count();
     auto rawMs = std::chrono::duration_cast<std::chrono::microseconds>(rawTime).count();
-    
+
     // Pool may be slower than raw allocation due to synchronization overhead
     // The main benefit is reduced allocator contention in multi-threaded scenarios
     INFO("Pool time: " << poolMs << "s, Raw time: " << rawMs << "s");
-    
+
     // Instead of asserting performance, just verify the pool works correctly
     // Performance benefits are more visible under concurrent access
     REQUIRE(poolMs > 0); // Pool completed successfully
-    REQUIRE(rawMs > 0);   // Raw allocation completed successfully
-    
+    REQUIRE(rawMs > 0);  // Raw allocation completed successfully
+
     // Log the ratio for information
     double ratio = static_cast<double>(poolMs) / static_cast<double>(rawMs);
     INFO("Pool/Raw ratio: " << ratio << "x");
-    
+
     // The test passes as long as both approaches work
     SUCCEED("Pool performance test completed successfully");
   }
@@ -569,38 +572,38 @@ TEST_CASE("Edge cases and error conditions", "[edge][error]")
   {
     auto factory = []() -> std::unique_ptr<TestSession> { return nullptr; };
     ObjectPool<TestSession> pool(factory);
-    
+
     auto obj = pool.acquire();
     REQUIRE(obj == nullptr);
   }
-  
+
   SECTION("ConnectionHealth handles rapid state changes")
   {
     HealthConfig config{};
     config.maxConsecutiveFailures = 1;
-    
+
     ConnectionHealth health(config);
-    
+
     // Rapid failure/success cycles
     for (int i = 0; i < 100; ++i)
     {
       health.recordFailure();
       health.recordSuccess();
     }
-    
+
     // Should be in healthy or warning state
     auto state = health.getState();
     REQUIRE((state == ConnectionState::Healthy || state == ConnectionState::Warning));
   }
-  
+
   SECTION("CircuitBreaker handles configuration edge cases")
   {
     CircuitBreakerConfig config{};
     config.failureThreshold = 0; // Edge case
     config.successThreshold = 0; // Edge case
-    
+
     CircuitBreaker breaker(config);
-    
+
     // Should still function reasonably
     REQUIRE(breaker.allowRequest());
     breaker.recordFailure();
diff --git a/tests/network/iora_test_unified_tcp_udp.cpp b/tests/network/iora_test_unified_tcp_udp.cpp
index 4ec9d8d..be9cc42 100644
--- a/tests/network/iora_test_unified_tcp_udp.cpp
+++ b/tests/network/iora_test_unified_tcp_udp.cpp
@@ -1,26 +1,27 @@
 #define CATCH_CONFIG_MAIN
 #include <catch2/catch.hpp>
-#include "test_helpers.hpp"
-#include "iora/network/transport_types.hpp"
 #include "iora/network/shared_transport.hpp"
 #include "iora/network/shared_transport_udp.hpp"
+#include "iora/network/transport_types.hpp"
 #include "iora/network/unified_shared_transport.hpp"
 #include "iora_test_net_utils.hpp"
-#include <cstring>
-#include <chrono>
-#include <thread>
+#include "test_helpers.hpp"
+#include <algorithm>
 #include <atomic>
-#include <vector>
+#include <chrono>
+#include <cstring>
 #include <map>
 #include <memory>
-#include <set>
-#include <algorithm>
 #include <numeric>
+#include <set>
+#include <thread>
+#include <vector>
 
 using namespace std::chrono_literals;
 using namespace iora::network;
 
-namespace {
+namespace
+{
 struct UnifiedTestHarness
 {
   std::atomic<size_t> acceptCount{0};
@@ -36,69 +37,78 @@ struct UnifiedTestHarness
   std::vector<SessionId> closedSessions;
   std::map<SessionId, std::string> sessionData;
   std::vector<std::string> errorMessages;
-  
+
   std::mutex callbackMutex;
   SessionId serverSid{0};
   SessionId clientSid{0};
   std::string lastErr;
 
-  UnifiedCallbacks make(ITransport& tx)
+  UnifiedCallbacks make(ITransport &tx)
   {
     UnifiedCallbacks cbs{};
-    cbs.onAccept = [&](SessionId sid, const std::string& addr, const IoResult& res)
+    cbs.onAccept = [&](SessionId sid, const std::string &addr, const IoResult &res)
     {
       std::lock_guard<std::mutex> lock(callbackMutex);
-      if (res.ok) {
+      if (res.ok)
+      {
         acceptedSessions.push_back(sid);
-        if (serverSid == 0) serverSid = sid;
+        if (serverSid == 0)
+          serverSid = sid;
       }
       acceptCount++;
     };
-    cbs.onConnect = [&](SessionId sid, const IoResult& res)
+    cbs.onConnect = [&](SessionId sid, const IoResult &res)
     {
       std::lock_guard<std::mutex> lock(callbackMutex);
-      if (res.ok) {
+      if (res.ok)
+      {
         connectedSessions.push_back(sid);
-        if (clientSid == 0) clientSid = sid;
+        if (clientSid == 0)
+          clientSid = sid;
         connectCount++;
-      } else {
+      }
+      else
+      {
         connectFailCount++;
       }
     };
-    cbs.onData = [&](SessionId sid, const std::uint8_t* data, std::size_t n, const IoResult& res)
+    cbs.onData = [&](SessionId sid, const std::uint8_t *data, std::size_t n, const IoResult &res)
     {
       std::lock_guard<std::mutex> lock(callbackMutex);
-      if (res.ok) {
+      if (res.ok)
+      {
         totalBytesReceived += n;
-        sessionData[sid].append(reinterpret_cast<const char*>(data), n);
-        
+        sessionData[sid].append(reinterpret_cast<const char *>(data), n);
+
         // Echo back from server
-        if (sid == serverSid) {
+        if (sid == serverSid)
+        {
           tx.send(sid, data, n);
         }
       }
       dataCount++;
     };
-    cbs.onClosed = [&](SessionId sid, const IoResult& res) 
-    { 
+    cbs.onClosed = [&](SessionId sid, const IoResult &res)
+    {
       std::lock_guard<std::mutex> lock(callbackMutex);
       closedSessions.push_back(sid);
       closeCount++;
     };
-    cbs.onError = [&](TransportError err, const std::string& m) 
-    { 
+    cbs.onError = [&](TransportError err, const std::string &m)
+    {
       std::lock_guard<std::mutex> lock(callbackMutex);
-      lastErr = m; 
+      lastErr = m;
       errorMessages.push_back(m);
       errorCount++;
     };
     return cbs;
   }
-  
+
   void reset()
   {
     std::lock_guard<std::mutex> lock(callbackMutex);
-    acceptCount = connectCount = connectFailCount = dataCount = closeCount = errorCount = totalBytesReceived = 0;
+    acceptCount = connectCount = connectFailCount = dataCount = closeCount = errorCount =
+      totalBytesReceived = 0;
     serverSid = clientSid = 0;
     acceptedSessions.clear();
     connectedSessions.clear();
@@ -107,11 +117,12 @@ struct UnifiedTestHarness
     errorMessages.clear();
     lastErr.clear();
   }
-  
+
   bool waitForCondition(std::function<bool()> condition, std::chrono::milliseconds timeout = 1000ms)
   {
     auto start = std::chrono::steady_clock::now();
-    while (!condition() && (std::chrono::steady_clock::now() - start) < timeout) {
+    while (!condition() && (std::chrono::steady_clock::now() - start) < timeout)
+    {
       std::this_thread::sleep_for(5ms);
     }
     return condition();
@@ -130,29 +141,39 @@ struct EchoHarness
   SessionId clientSid{0};
   std::string lastErr;
 
-  UnifiedCallbacks make(ITransport& tx)
+  UnifiedCallbacks make(ITransport &tx)
   {
     UnifiedCallbacks cbs{};
-    cbs.onAccept = [&](SessionId sid, const std::string&, const IoResult& res)
+    cbs.onAccept = [&](SessionId sid, const std::string &, const IoResult &res)
     {
       REQUIRE(res.ok);
       serverSid = sid;
       accepted = true;
     };
-    cbs.onConnect = [&](SessionId sid, const IoResult& res)
+    cbs.onConnect = [&](SessionId sid, const IoResult &res)
     {
       REQUIRE(res.ok);
       clientSid = sid;
       connected = true;
     };
-    cbs.onData = [&](SessionId sid, const std::uint8_t* data, std::size_t n, const IoResult& res)
+    cbs.onData = [&](SessionId sid, const std::uint8_t *data, std::size_t n, const IoResult &res)
     {
       REQUIRE(res.ok);
-      if (sid == serverSid) { REQUIRE(tx.send(sid, data, n)); }
-      if (sid == clientSid) { clientGotEcho = true; }
+      if (sid == serverSid)
+      {
+        REQUIRE(tx.send(sid, data, n));
+      }
+      if (sid == clientSid)
+      {
+        clientGotEcho = true;
+      }
+    };
+    cbs.onClosed = [&](SessionId, const IoResult &) { anyClosed = true; };
+    cbs.onError = [&](TransportError err, const std::string &m)
+    {
+      lastErr = m;
+      errored = true;
     };
-    cbs.onClosed = [&](SessionId, const IoResult&) { anyClosed = true; };
-    cbs.onError = [&](TransportError err, const std::string& m) { lastErr = m; errored = true; };
     return cbs;
   }
 };
@@ -176,18 +197,21 @@ TEST_CASE("Unified TCP adapter echo", "[unified][tcp]")
   SessionId cs = ut.connect("127.0.0.1", port, TlsMode::None);
   REQUIRE(cs != 0);
 
-  for (int i = 0; i < 200 && (!h.accepted || !h.connected); ++i) std::this_thread::sleep_for(5ms);
+  for (int i = 0; i < 200 && (!h.accepted || !h.connected); ++i)
+    std::this_thread::sleep_for(5ms);
   REQUIRE(h.accepted.load());
   REQUIRE(h.connected.load());
 
-  const char* msg = "unified tcp hello";
+  const char *msg = "unified tcp hello";
   REQUIRE(ut.send(cs, msg, std::strlen(msg)));
 
-  for (int i = 0; i < 200 && !h.clientGotEcho; ++i) std::this_thread::sleep_for(5ms);
+  for (int i = 0; i < 200 && !h.clientGotEcho; ++i)
+    std::this_thread::sleep_for(5ms);
   REQUIRE(h.clientGotEcho.load());
 
   REQUIRE(ut.close(cs));
-  for (int i = 0; i < 200 && !h.anyClosed; ++i) std::this_thread::sleep_for(5ms);
+  for (int i = 0; i < 200 && !h.anyClosed; ++i)
+    std::this_thread::sleep_for(5ms);
 
   ut.stop();
 }
@@ -210,19 +234,22 @@ TEST_CASE("Unified UDP adapter echo", "[unified][udp]")
   REQUIRE(cs != 0);
 
   // In UDP, connected should be immediate, but accepted only happens after first data
-  for (int i = 0; i < 200 && !h.connected; ++i) std::this_thread::sleep_for(5ms);
+  for (int i = 0; i < 200 && !h.connected; ++i)
+    std::this_thread::sleep_for(5ms);
   REQUIRE(h.connected.load());
 
-  const char* msg = "unified udp hello";
+  const char *msg = "unified udp hello";
   REQUIRE(ut.send(cs, msg, std::strlen(msg)));
 
   // Now wait for both acceptance (from first data) and echo response
-  for (int i = 0; i < 200 && (!h.accepted || !h.clientGotEcho); ++i) std::this_thread::sleep_for(5ms);
+  for (int i = 0; i < 200 && (!h.accepted || !h.clientGotEcho); ++i)
+    std::this_thread::sleep_for(5ms);
   REQUIRE(h.accepted.load());
   REQUIRE(h.clientGotEcho.load());
 
   REQUIRE(ut.close(cs));
-  for (int i = 0; i < 200 && !h.anyClosed; ++i) std::this_thread::sleep_for(5ms);
+  for (int i = 0; i < 200 && !h.anyClosed; ++i)
+    std::this_thread::sleep_for(5ms);
 
   ut.stop();
 }
@@ -241,7 +268,8 @@ TEST_CASE("Unified transport stats snapshot", "[unified][stats]")
   REQUIRE(tlid != 0);
   SessionId tcs = tcp.connect("127.0.0.1", tport, TlsMode::None);
   REQUIRE(tcs != 0);
-  for (int i = 0; i < 200 && (!h1.accepted || !h1.connected); ++i) std::this_thread::sleep_for(5ms);
+  for (int i = 0; i < 200 && (!h1.accepted || !h1.connected); ++i)
+    std::this_thread::sleep_for(5ms);
   REQUIRE(h1.accepted.load());
   REQUIRE(h1.connected.load());
   UnifiedStats tcpStats = tcp.stats();
@@ -260,15 +288,17 @@ TEST_CASE("Unified transport stats snapshot", "[unified][stats]")
   SessionId ucs = udp.connect("127.0.0.1", uport, TlsMode::None);
   REQUIRE(ucs != 0);
   // In UDP, connected should be immediate, but accepted only happens after first data
-  for (int i = 0; i < 200 && !h2.connected; ++i) std::this_thread::sleep_for(5ms);
+  for (int i = 0; i < 200 && !h2.connected; ++i)
+    std::this_thread::sleep_for(5ms);
   REQUIRE(h2.connected.load());
-  
+
   // Send data to trigger server-side acceptance
-  const char* testMsg = "stats test udp";
+  const char *testMsg = "stats test udp";
   REQUIRE(udp.send(ucs, testMsg, std::strlen(testMsg)));
-  
+
   // Now wait for acceptance (from first data)
-  for (int i = 0; i < 200 && !h2.accepted; ++i) std::this_thread::sleep_for(5ms);
+  for (int i = 0; i < 200 && !h2.accepted; ++i)
+    std::this_thread::sleep_for(5ms);
   REQUIRE(h2.accepted.load());
   UnifiedStats udpStats = udp.stats();
   REQUIRE(udpStats.accepted >= 1);
@@ -291,9 +321,10 @@ TEST_CASE("Unified duplicate listener errors", "[unified][error]")
     ListenerId a = ut.addListener("127.0.0.1", port, TlsMode::None);
     REQUIRE(a != 0);
     ListenerId b = ut.addListener("127.0.0.1", port, TlsMode::None);
-    REQUIRE(b != 0);  // Currently returns a valid ID, but bind will fail async
+    REQUIRE(b != 0); // Currently returns a valid ID, but bind will fail async
 
-    for (int i = 0; i < 100 && !h.errored; ++i) std::this_thread::sleep_for(5ms);
+    for (int i = 0; i < 100 && !h.errored; ++i)
+      std::this_thread::sleep_for(5ms);
     // Note: Currently async bind failures don't reliably trigger error callbacks in time
     // REQUIRE(h.errored.load());  // TODO: Fix async error callback timing
     ut.stop();
@@ -311,9 +342,10 @@ TEST_CASE("Unified duplicate listener errors", "[unified][error]")
     ListenerId a = ut.addListener("127.0.0.1", port, TlsMode::None);
     REQUIRE(a != 0);
     ListenerId b = ut.addListener("127.0.0.1", port, TlsMode::None);
-    REQUIRE(b != 0);  // Currently returns a valid ID, but bind will fail async
+    REQUIRE(b != 0); // Currently returns a valid ID, but bind will fail async
 
-    for (int i = 0; i < 100 && !h.errored; ++i) std::this_thread::sleep_for(5ms);
+    for (int i = 0; i < 100 && !h.errored; ++i)
+      std::this_thread::sleep_for(5ms);
     // Note: Currently async bind failures don't reliably trigger error callbacks in time
     // REQUIRE(h.errored.load());  // TODO: Fix async error callback timing
     ut.stop();
@@ -326,56 +358,56 @@ TEST_CASE("Unified interface consistency TCP vs UDP", "[unified][consistency]")
   SharedTransport::Config tcpCfg{};
   SharedTransport::TlsConfig tcpSrv{}, tcpCli{};
   TcpTlsTransportAdapter tcpAdapter{tcpCfg, tcpSrv, tcpCli};
-  
+
   SharedUdpTransport::Config udpCfg{};
   UdpTransportAdapter udpAdapter{udpCfg};
-  
+
   UnifiedTestHarness tcpHarness, udpHarness;
   tcpAdapter.setCallbacks(tcpHarness.make(tcpAdapter));
   udpAdapter.setCallbacks(udpHarness.make(udpAdapter));
-  
+
   // Both should start successfully
   REQUIRE(tcpAdapter.start());
   REQUIRE(udpAdapter.start());
-  
+
   auto tcpPort = testnet::getFreePortTCP();
   auto udpPort = testnet::getFreePortUDP();
-  
+
   // Both should add listeners successfully
   ListenerId tcpLid = tcpAdapter.addListener("127.0.0.1", tcpPort, TlsMode::None);
   ListenerId udpLid = udpAdapter.addListener("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpLid != 0);
   REQUIRE(udpLid != 0);
-  
+
   // Both should connect successfully
   SessionId tcpSid = tcpAdapter.connect("127.0.0.1", tcpPort, TlsMode::None);
   SessionId udpSid = udpAdapter.connect("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpSid != 0);
   REQUIRE(udpSid != 0);
-  
+
   // Wait for connections
   REQUIRE(tcpHarness.waitForCondition([&]() { return tcpHarness.connectCount > 0; }));
   REQUIRE(udpHarness.waitForCondition([&]() { return udpHarness.connectCount > 0; }));
-  
-  // Both should send data successfully  
-  const char* msg = "interface test";
+
+  // Both should send data successfully
+  const char *msg = "interface test";
   REQUIRE(tcpAdapter.send(tcpSid, msg, strlen(msg)));
   REQUIRE(udpAdapter.send(udpSid, msg, strlen(msg)));
-  
+
   // Wait for data (UDP needs first data to trigger accept)
   REQUIRE(tcpHarness.waitForCondition([&]() { return tcpHarness.acceptCount > 0; }));
   REQUIRE(udpHarness.waitForCondition([&]() { return udpHarness.acceptCount > 0; }));
-  
+
   // Both should return valid stats
   UnifiedStats tcpStats = tcpAdapter.stats();
   UnifiedStats udpStats = udpAdapter.stats();
   REQUIRE(tcpStats.accepted >= 1);
   REQUIRE(udpStats.accepted >= 1);
-  
+
   // Both should close sessions successfully
   REQUIRE(tcpAdapter.close(tcpSid));
   REQUIRE(udpAdapter.close(udpSid));
-  
+
   tcpAdapter.stop();
   udpAdapter.stop();
 }
@@ -385,31 +417,32 @@ TEST_CASE("Unified simultaneous TCP and UDP operations", "[unified][mixed]")
   SharedTransport::Config tcpCfg{};
   SharedTransport::TlsConfig tcpSrv{}, tcpCli{};
   TcpTlsTransportAdapter tcpAdapter{tcpCfg, tcpSrv, tcpCli};
-  
+
   SharedUdpTransport::Config udpCfg{};
   UdpTransportAdapter udpAdapter{udpCfg};
-  
+
   UnifiedTestHarness tcpHarness, udpHarness;
   tcpAdapter.setCallbacks(tcpHarness.make(tcpAdapter));
   udpAdapter.setCallbacks(udpHarness.make(udpAdapter));
-  
+
   REQUIRE(tcpAdapter.start());
   REQUIRE(udpAdapter.start());
-  
+
   auto tcpPort = testnet::getFreePortTCP();
   auto udpPort = testnet::getFreePortUDP();
-  
+
   // Set up listeners
   ListenerId tcpLid = tcpAdapter.addListener("127.0.0.1", tcpPort, TlsMode::None);
   ListenerId udpLid = udpAdapter.addListener("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpLid != 0);
   REQUIRE(udpLid != 0);
-  
+
   // Create multiple connections on both protocols
   const size_t numConnections = 3;
   std::vector<SessionId> tcpClients, udpClients;
-  
-  for (size_t i = 0; i < numConnections; ++i) {
+
+  for (size_t i = 0; i < numConnections; ++i)
+  {
     SessionId tcpSid = tcpAdapter.connect("127.0.0.1", tcpPort, TlsMode::None);
     SessionId udpSid = udpAdapter.connect("127.0.0.1", udpPort, TlsMode::None);
     REQUIRE(tcpSid != 0);
@@ -417,39 +450,44 @@ TEST_CASE("Unified simultaneous TCP and UDP operations", "[unified][mixed]")
     tcpClients.push_back(tcpSid);
     udpClients.push_back(udpSid);
   }
-  
+
   // Wait for connections
   REQUIRE(tcpHarness.waitForCondition([&]() { return tcpHarness.connectCount >= numConnections; }));
   REQUIRE(udpHarness.waitForCondition([&]() { return udpHarness.connectCount >= numConnections; }));
-  
+
   // Send data on all connections simultaneously
-  for (size_t i = 0; i < numConnections; ++i) {
+  for (size_t i = 0; i < numConnections; ++i)
+  {
     std::string tcpMsg = "tcp-" + std::to_string(i);
     std::string udpMsg = "udp-" + std::to_string(i);
     REQUIRE(tcpAdapter.send(tcpClients[i], tcpMsg.c_str(), tcpMsg.size()));
     REQUIRE(udpAdapter.send(udpClients[i], udpMsg.c_str(), udpMsg.size()));
   }
-  
+
   // Wait for all data to be echoed back
-  REQUIRE(tcpHarness.waitForCondition([&]() { 
-    return tcpHarness.acceptCount >= numConnections && 
-           tcpHarness.sessionData.size() >= numConnections; 
-  }));
-  REQUIRE(udpHarness.waitForCondition([&]() { 
-    return udpHarness.acceptCount >= numConnections &&
-           udpHarness.sessionData.size() >= numConnections; 
-  }));
-  
+  REQUIRE(tcpHarness.waitForCondition(
+    [&]()
+    {
+      return tcpHarness.acceptCount >= numConnections &&
+             tcpHarness.sessionData.size() >= numConnections;
+    }));
+  REQUIRE(udpHarness.waitForCondition(
+    [&]()
+    {
+      return udpHarness.acceptCount >= numConnections &&
+             udpHarness.sessionData.size() >= numConnections;
+    }));
+
   // Verify session ID uniqueness across protocols
   std::set<SessionId> allSessions(tcpClients.begin(), tcpClients.end());
   allSessions.insert(udpClients.begin(), udpClients.end());
   allSessions.insert(tcpHarness.acceptedSessions.begin(), tcpHarness.acceptedSessions.end());
   allSessions.insert(udpHarness.acceptedSessions.begin(), udpHarness.acceptedSessions.end());
-  
+
   size_t expectedSessions = 2 * numConnections * 2; // 2 protocols * connections * (client+server)
   // Cross-protocol session management may have timing differences
   REQUIRE(allSessions.size() >= expectedSessions / 2); // At least half the expected sessions
-  
+
   tcpAdapter.stop();
   udpAdapter.stop();
 }
@@ -459,57 +497,58 @@ TEST_CASE("Unified large data transfer comparison", "[unified][largedata]")
   SharedTransport::Config tcpCfg{};
   SharedTransport::TlsConfig tcpSrv{}, tcpCli{};
   TcpTlsTransportAdapter tcpAdapter{tcpCfg, tcpSrv, tcpCli};
-  
+
   SharedUdpTransport::Config udpCfg{};
   UdpTransportAdapter udpAdapter{udpCfg};
-  
+
   UnifiedTestHarness tcpHarness, udpHarness;
   tcpAdapter.setCallbacks(tcpHarness.make(tcpAdapter));
   udpAdapter.setCallbacks(udpHarness.make(udpAdapter));
-  
+
   REQUIRE(tcpAdapter.start());
   REQUIRE(udpAdapter.start());
-  
+
   auto tcpPort = testnet::getFreePortTCP();
   auto udpPort = testnet::getFreePortUDP();
-  
+
   ListenerId tcpLid = tcpAdapter.addListener("127.0.0.1", tcpPort, TlsMode::None);
   ListenerId udpLid = udpAdapter.addListener("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpLid != 0);
   REQUIRE(udpLid != 0);
-  
+
   SessionId tcpSid = tcpAdapter.connect("127.0.0.1", tcpPort, TlsMode::None);
   SessionId udpSid = udpAdapter.connect("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpSid != 0);
   REQUIRE(udpSid != 0);
-  
+
   REQUIRE(tcpHarness.waitForCondition([&]() { return tcpHarness.connectCount > 0; }));
   REQUIRE(udpHarness.waitForCondition([&]() { return udpHarness.connectCount > 0; }));
-  
+
   // Create large test data
   const size_t dataSize = 8192; // Large for UDP, small for TCP
   std::vector<uint8_t> testData(dataSize);
   std::iota(testData.begin(), testData.end(), 0);
-  
+
   // Send large data through both protocols
   REQUIRE(tcpAdapter.send(tcpSid, testData.data(), testData.size()));
   REQUIRE(udpAdapter.send(udpSid, testData.data(), testData.size()));
-  
+
   // TCP should handle large data reliably
-  REQUIRE(tcpHarness.waitForCondition([&]() { 
-    return tcpHarness.acceptCount > 0 && 
-           tcpHarness.sessionData[tcpSid].size() == dataSize; 
-  }, 3000ms));
-  
+  REQUIRE(tcpHarness.waitForCondition(
+    [&]()
+    { return tcpHarness.acceptCount > 0 && tcpHarness.sessionData[tcpSid].size() == dataSize; },
+    3000ms));
+
   // UDP may fragment or fail with large data - just check it tried
   REQUIRE(udpHarness.waitForCondition([&]() { return udpHarness.acceptCount > 0; }, 3000ms));
-  
+
   // Verify TCP data integrity
   REQUIRE(tcpHarness.sessionData[tcpSid].size() == dataSize);
-  for (size_t i = 0; i < dataSize; ++i) {
+  for (size_t i = 0; i < dataSize; ++i)
+  {
     REQUIRE(static_cast<uint8_t>(tcpHarness.sessionData[tcpSid][i]) == static_cast<uint8_t>(i));
   }
-  
+
   tcpAdapter.stop();
   udpAdapter.stop();
 }
@@ -519,39 +558,39 @@ TEST_CASE("Unified protocol-specific error handling", "[unified][protocolerrors]
   SharedTransport::Config tcpCfg{};
   SharedTransport::TlsConfig tcpSrv{}, tcpCli{};
   TcpTlsTransportAdapter tcpAdapter{tcpCfg, tcpSrv, tcpCli};
-  
+
   SharedUdpTransport::Config udpCfg{};
   UdpTransportAdapter udpAdapter{udpCfg};
-  
+
   UnifiedTestHarness tcpHarness, udpHarness;
   tcpAdapter.setCallbacks(tcpHarness.make(tcpAdapter));
   udpAdapter.setCallbacks(udpHarness.make(udpAdapter));
-  
+
   REQUIRE(tcpAdapter.start());
   REQUIRE(udpAdapter.start());
-  
+
   // Try to connect to non-existent servers
   SessionId tcpFailSid = tcpAdapter.connect("127.0.0.1", 12345, TlsMode::None);
   SessionId udpFailSid = udpAdapter.connect("127.0.0.1", 54321, TlsMode::None);
   REQUIRE(tcpFailSid != 0);
   REQUIRE(udpFailSid != 0);
-  
+
   // TCP should fail to connect
   REQUIRE(tcpHarness.waitForCondition([&]() { return tcpHarness.connectFailCount > 0; }));
-  
+
   // UDP connect is immediate (connectionless), but send might fail
   // UDP "connect" typically succeeds even with no server
   REQUIRE(udpHarness.waitForCondition([&]() { return udpHarness.connectCount > 0; }));
-  
+
   // Operations on invalid session IDs - behavior may vary by protocol implementation
   SessionId invalidSid = 99999;
   // TCP adapter may handle invalid session IDs differently than UDP
   (void)tcpAdapter.send(invalidSid, "test", 4);
-  (void)udpAdapter.send(invalidSid, "test", 4); 
+  (void)udpAdapter.send(invalidSid, "test", 4);
   (void)tcpAdapter.close(invalidSid);
   (void)udpAdapter.close(invalidSid);
   // Note: Implementations may queue operations and validate session IDs asynchronously
-  
+
   tcpAdapter.stop();
   udpAdapter.stop();
 }
@@ -562,22 +601,23 @@ TEST_CASE("Unified adapter lifecycle management", "[unified][lifecycle]")
   SharedTransport::Config tcpCfg{};
   SharedTransport::TlsConfig tcpSrv{}, tcpCli{};
   TcpTlsTransportAdapter tcpAdapter{tcpCfg, tcpSrv, tcpCli};
-  
+
   SharedUdpTransport::Config udpCfg{};
   UdpTransportAdapter udpAdapter{udpCfg};
-  
+
   // Multiple start/stop cycles should work
-  for (int cycle = 0; cycle < 3; ++cycle) {
+  for (int cycle = 0; cycle < 3; ++cycle)
+  {
     REQUIRE(tcpAdapter.start());
     REQUIRE(udpAdapter.start());
-    
+
     // Start when already started should return false
     REQUIRE_FALSE(tcpAdapter.start());
     REQUIRE_FALSE(udpAdapter.start());
-    
+
     tcpAdapter.stop();
     udpAdapter.stop();
-    
+
     // Multiple stops should be safe
     tcpAdapter.stop();
     udpAdapter.stop();
@@ -589,52 +629,59 @@ TEST_CASE("Unified binary data handling", "[unified][binary]")
   SharedTransport::Config tcpCfg{};
   SharedTransport::TlsConfig tcpSrv{}, tcpCli{};
   TcpTlsTransportAdapter tcpAdapter{tcpCfg, tcpSrv, tcpCli};
-  
+
   SharedUdpTransport::Config udpCfg{};
   UdpTransportAdapter udpAdapter{udpCfg};
-  
+
   UnifiedTestHarness tcpHarness, udpHarness;
   tcpAdapter.setCallbacks(tcpHarness.make(tcpAdapter));
   udpAdapter.setCallbacks(udpHarness.make(udpAdapter));
-  
+
   REQUIRE(tcpAdapter.start());
   REQUIRE(udpAdapter.start());
-  
+
   auto tcpPort = testnet::getFreePortTCP();
   auto udpPort = testnet::getFreePortUDP();
-  
+
   ListenerId tcpLid = tcpAdapter.addListener("127.0.0.1", tcpPort, TlsMode::None);
   ListenerId udpLid = udpAdapter.addListener("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpLid != 0);
   REQUIRE(udpLid != 0);
-  
+
   SessionId tcpSid = tcpAdapter.connect("127.0.0.1", tcpPort, TlsMode::None);
   SessionId udpSid = udpAdapter.connect("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpSid != 0);
   REQUIRE(udpSid != 0);
-  
+
   REQUIRE(tcpHarness.waitForCondition([&]() { return tcpHarness.connectCount > 0; }));
   REQUIRE(udpHarness.waitForCondition([&]() { return udpHarness.connectCount > 0; }));
-  
+
   // Binary data with null bytes and high values
   std::vector<uint8_t> binaryData = {0x00, 0x01, 0xFF, 0x7F, 0x80, 0xAB, 0xCD, 0xEF};
-  
+
   REQUIRE(tcpAdapter.send(tcpSid, binaryData.data(), binaryData.size()));
   REQUIRE(udpAdapter.send(udpSid, binaryData.data(), binaryData.size()));
-  
-  REQUIRE(tcpHarness.waitForCondition([&]() { 
-    return tcpHarness.acceptCount > 0 && tcpHarness.sessionData[tcpSid].size() == binaryData.size(); 
-  }));
-  REQUIRE(udpHarness.waitForCondition([&]() { 
-    return udpHarness.acceptCount > 0 && udpHarness.sessionData[udpSid].size() == binaryData.size(); 
-  }));
-  
+
+  REQUIRE(tcpHarness.waitForCondition(
+    [&]()
+    {
+      return tcpHarness.acceptCount > 0 &&
+             tcpHarness.sessionData[tcpSid].size() == binaryData.size();
+    }));
+  REQUIRE(udpHarness.waitForCondition(
+    [&]()
+    {
+      return udpHarness.acceptCount > 0 &&
+             udpHarness.sessionData[udpSid].size() == binaryData.size();
+    }));
+
   // Verify binary data integrity for both protocols
-  for (size_t i = 0; i < binaryData.size(); ++i) {
+  for (size_t i = 0; i < binaryData.size(); ++i)
+  {
     REQUIRE(static_cast<uint8_t>(tcpHarness.sessionData[tcpSid][i]) == binaryData[i]);
     REQUIRE(static_cast<uint8_t>(udpHarness.sessionData[udpSid][i]) == binaryData[i]);
   }
-  
+
   tcpAdapter.stop();
   udpAdapter.stop();
 }
@@ -644,38 +691,39 @@ TEST_CASE("Unified high-frequency operations", "[unified][highfreq]")
   SharedTransport::Config tcpCfg{};
   SharedTransport::TlsConfig tcpSrv{}, tcpCli{};
   TcpTlsTransportAdapter tcpAdapter{tcpCfg, tcpSrv, tcpCli};
-  
+
   SharedUdpTransport::Config udpCfg{};
   UdpTransportAdapter udpAdapter{udpCfg};
-  
+
   UnifiedTestHarness tcpHarness, udpHarness;
   tcpAdapter.setCallbacks(tcpHarness.make(tcpAdapter));
   udpAdapter.setCallbacks(udpHarness.make(udpAdapter));
-  
+
   REQUIRE(tcpAdapter.start());
   REQUIRE(udpAdapter.start());
-  
+
   auto tcpPort = testnet::getFreePortTCP();
   auto udpPort = testnet::getFreePortUDP();
-  
+
   ListenerId tcpLid = tcpAdapter.addListener("127.0.0.1", tcpPort, TlsMode::None);
   ListenerId udpLid = udpAdapter.addListener("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpLid != 0);
   REQUIRE(udpLid != 0);
-  
+
   SessionId tcpSid = tcpAdapter.connect("127.0.0.1", tcpPort, TlsMode::None);
   SessionId udpSid = udpAdapter.connect("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpSid != 0);
   REQUIRE(udpSid != 0);
-  
+
   REQUIRE(tcpHarness.waitForCondition([&]() { return tcpHarness.connectCount > 0; }));
   REQUIRE(udpHarness.waitForCondition([&]() { return udpHarness.connectCount > 0; }));
-  
+
   const size_t numMessages = 50;
   size_t tcpExpectedBytes = 0, udpExpectedBytes = 0;
-  
+
   // Send many small messages rapidly on both protocols
-  for (size_t i = 0; i < numMessages; ++i) {
+  for (size_t i = 0; i < numMessages; ++i)
+  {
     std::string tcpMsg = "tcp" + std::to_string(i);
     std::string udpMsg = "udp" + std::to_string(i);
     tcpExpectedBytes += tcpMsg.size();
@@ -683,15 +731,23 @@ TEST_CASE("Unified high-frequency operations", "[unified][highfreq]")
     REQUIRE(tcpAdapter.send(tcpSid, tcpMsg.c_str(), tcpMsg.size()));
     REQUIRE(udpAdapter.send(udpSid, udpMsg.c_str(), udpMsg.size()));
   }
-  
+
   // Wait for all data to be echoed back
-  REQUIRE(tcpHarness.waitForCondition([&]() { 
-    return tcpHarness.acceptCount > 0 && tcpHarness.sessionData[tcpSid].size() == tcpExpectedBytes; 
-  }, 3000ms));
-  REQUIRE(udpHarness.waitForCondition([&]() { 
-    return udpHarness.acceptCount > 0 && udpHarness.sessionData[udpSid].size() == udpExpectedBytes; 
-  }, 3000ms));
-  
+  REQUIRE(tcpHarness.waitForCondition(
+    [&]()
+    {
+      return tcpHarness.acceptCount > 0 &&
+             tcpHarness.sessionData[tcpSid].size() == tcpExpectedBytes;
+    },
+    3000ms));
+  REQUIRE(udpHarness.waitForCondition(
+    [&]()
+    {
+      return udpHarness.acceptCount > 0 &&
+             udpHarness.sessionData[udpSid].size() == udpExpectedBytes;
+    },
+    3000ms));
+
   tcpAdapter.stop();
   udpAdapter.stop();
 }
@@ -701,40 +757,40 @@ TEST_CASE("Unified empty data handling", "[unified][emptydata]")
   SharedTransport::Config tcpCfg{};
   SharedTransport::TlsConfig tcpSrv{}, tcpCli{};
   TcpTlsTransportAdapter tcpAdapter{tcpCfg, tcpSrv, tcpCli};
-  
+
   SharedUdpTransport::Config udpCfg{};
   UdpTransportAdapter udpAdapter{udpCfg};
-  
+
   UnifiedTestHarness tcpHarness, udpHarness;
   tcpAdapter.setCallbacks(tcpHarness.make(tcpAdapter));
   udpAdapter.setCallbacks(udpHarness.make(udpAdapter));
-  
+
   REQUIRE(tcpAdapter.start());
   REQUIRE(udpAdapter.start());
-  
+
   auto tcpPort = testnet::getFreePortTCP();
   auto udpPort = testnet::getFreePortUDP();
-  
+
   ListenerId tcpLid = tcpAdapter.addListener("127.0.0.1", tcpPort, TlsMode::None);
   ListenerId udpLid = udpAdapter.addListener("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpLid != 0);
   REQUIRE(udpLid != 0);
-  
+
   SessionId tcpSid = tcpAdapter.connect("127.0.0.1", tcpPort, TlsMode::None);
   SessionId udpSid = udpAdapter.connect("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpSid != 0);
   REQUIRE(udpSid != 0);
-  
+
   REQUIRE(tcpHarness.waitForCondition([&]() { return tcpHarness.connectCount > 0; }));
   REQUIRE(udpHarness.waitForCondition([&]() { return udpHarness.connectCount > 0; }));
-  
+
   // Send empty data - both protocols should handle gracefully
   REQUIRE(tcpAdapter.send(tcpSid, nullptr, 0));
   REQUIRE(udpAdapter.send(udpSid, nullptr, 0));
-  
+
   // Give some time for processing
   std::this_thread::sleep_for(100ms);
-  
+
   tcpAdapter.stop();
   udpAdapter.stop();
 }
@@ -744,17 +800,17 @@ TEST_CASE("Unified stats comparison", "[unified][statscompare]")
   SharedTransport::Config tcpCfg{};
   SharedTransport::TlsConfig tcpSrv{}, tcpCli{};
   TcpTlsTransportAdapter tcpAdapter{tcpCfg, tcpSrv, tcpCli};
-  
+
   SharedUdpTransport::Config udpCfg{};
   UdpTransportAdapter udpAdapter{udpCfg};
-  
+
   UnifiedTestHarness tcpHarness, udpHarness;
   tcpAdapter.setCallbacks(tcpHarness.make(tcpAdapter));
   udpAdapter.setCallbacks(udpHarness.make(udpAdapter));
-  
+
   REQUIRE(tcpAdapter.start());
   REQUIRE(udpAdapter.start());
-  
+
   // Get initial stats
   UnifiedStats tcpStats1 = tcpAdapter.stats();
   UnifiedStats udpStats1 = udpAdapter.stats();
@@ -762,47 +818,47 @@ TEST_CASE("Unified stats comparison", "[unified][statscompare]")
   REQUIRE(tcpStats1.connected == 0);
   REQUIRE(udpStats1.accepted == 0);
   REQUIRE(udpStats1.connected == 0);
-  
+
   auto tcpPort = testnet::getFreePortTCP();
   auto udpPort = testnet::getFreePortUDP();
-  
+
   ListenerId tcpLid = tcpAdapter.addListener("127.0.0.1", tcpPort, TlsMode::None);
   ListenerId udpLid = udpAdapter.addListener("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpLid != 0);
   REQUIRE(udpLid != 0);
-  
+
   SessionId tcpSid = tcpAdapter.connect("127.0.0.1", tcpPort, TlsMode::None);
   SessionId udpSid = udpAdapter.connect("127.0.0.1", udpPort, TlsMode::None);
   REQUIRE(tcpSid != 0);
   REQUIRE(udpSid != 0);
-  
+
   REQUIRE(tcpHarness.waitForCondition([&]() { return tcpHarness.connectCount > 0; }));
   REQUIRE(udpHarness.waitForCondition([&]() { return udpHarness.connectCount > 0; }));
-  
+
   // Send data to trigger accepts
-  const char* msg = "stats test";
+  const char *msg = "stats test";
   REQUIRE(tcpAdapter.send(tcpSid, msg, strlen(msg)));
   REQUIRE(udpAdapter.send(udpSid, msg, strlen(msg)));
-  
+
   REQUIRE(tcpHarness.waitForCondition([&]() { return tcpHarness.acceptCount > 0; }));
   REQUIRE(udpHarness.waitForCondition([&]() { return udpHarness.acceptCount > 0; }));
-  
+
   // Get final stats
   UnifiedStats tcpStats2 = tcpAdapter.stats();
   UnifiedStats udpStats2 = udpAdapter.stats();
-  
+
   // Both should show activity
   REQUIRE(tcpStats2.accepted >= 1);
   REQUIRE(tcpStats2.connected >= 1);
   REQUIRE(udpStats2.accepted >= 1);
   REQUIRE(udpStats2.connected >= 1);
-  
+
   // Stats should have increased
   REQUIRE(tcpStats2.accepted > tcpStats1.accepted);
   REQUIRE(tcpStats2.connected > tcpStats1.connected);
   REQUIRE(udpStats2.accepted > udpStats1.accepted);
   REQUIRE(udpStats2.connected > udpStats1.connected);
-  
+
   tcpAdapter.stop();
   udpAdapter.stop();
 }
\ No newline at end of file
diff --git a/tests/network/iora_test_webhook_transport.cpp b/tests/network/iora_test_webhook_transport.cpp
index 3b4fc62..2f6277d 100644
--- a/tests/network/iora_test_webhook_transport.cpp
+++ b/tests/network/iora_test_webhook_transport.cpp
@@ -1,8 +1,8 @@
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "test_helpers.hpp"
-#include <thread>
+#include <catch2/catch.hpp>
 #include <chrono>
+#include <thread>
 
 using namespace iora::test;
 
@@ -12,145 +12,145 @@ TEST_CASE("WebhookServer transport-specific tests")
   {
     iora::network::WebhookServer server;
     server.setPort(8082);
-    
+
     REQUIRE_NOTHROW(server.start());
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
     REQUIRE_NOTHROW(server.stop());
   }
-  
+
   SECTION("Server handles multiple simultaneous connections")
   {
     iora::network::WebhookServer server;
     server.setPort(8083);
-    
+
     std::atomic<int> requestCount{0};
-    server.onGet("/count", 
-      [&requestCount](const iora::network::WebhookServer::Request&, 
-                      iora::network::WebhookServer::Response& res)
-      {
-        int count = ++requestCount;
-        res.set_content(std::to_string(count), "text/plain");
-      });
-    
+    server.onGet("/count",
+                 [&requestCount](const iora::network::WebhookServer::Request &,
+                                 iora::network::WebhookServer::Response &res)
+                 {
+                   int count = ++requestCount;
+                   res.set_content(std::to_string(count), "text/plain");
+                 });
+
     server.start();
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
-    
+
     // Create multiple HTTP clients and make simultaneous requests
     std::vector<std::thread> threads;
     const int numThreads = 5;
-    
+
     for (int i = 0; i < numThreads; ++i)
     {
-      threads.emplace_back([i, numThreads]()
-      {
-        iora::network::HttpClient client;
-        auto res = client.get("http://localhost:8083/count");
-        REQUIRE(res.success());
-        // Each response should contain a different count
-        int responseCount = std::stoi(res.body);
-        REQUIRE(responseCount >= 1);
-        REQUIRE(responseCount <= numThreads);
-      });
+      threads.emplace_back(
+        [i, numThreads]()
+        {
+          iora::network::HttpClient client;
+          auto res = client.get("http://localhost:8083/count");
+          REQUIRE(res.success());
+          // Each response should contain a different count
+          int responseCount = std::stoi(res.body);
+          REQUIRE(responseCount >= 1);
+          REQUIRE(responseCount <= numThreads);
+        });
     }
-    
+
     // Wait for all threads to complete
-    for (auto& t : threads)
+    for (auto &t : threads)
     {
       t.join();
     }
-    
+
     REQUIRE(requestCount == numThreads);
     server.stop();
   }
-  
+
   SECTION("Server handles large request body")
   {
     iora::network::WebhookServer server;
     server.setPort(8084);
-    
-    server.onPost("/large", 
-      [](const iora::network::WebhookServer::Request& req, 
-         iora::network::WebhookServer::Response& res)
-      {
-        res.set_content("Received " + std::to_string(req.body.size()) + " bytes", "text/plain");
-      });
-    
+
+    server.onPost(
+      "/large", [](const iora::network::WebhookServer::Request &req,
+                   iora::network::WebhookServer::Response &res)
+      { res.set_content("Received " + std::to_string(req.body.size()) + " bytes", "text/plain"); });
+
     server.start();
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
-    
+
     // Create a large request body (64KB)
     std::string largeBody(64 * 1024, 'x');
-    
+
     iora::network::HttpClient client;
-    auto res = client.post("http://localhost:8084/large", largeBody, {{"Content-Type", "text/plain"}});
-    
+    auto res =
+      client.post("http://localhost:8084/large", largeBody, {{"Content-Type", "text/plain"}});
+
     REQUIRE(res.success());
     REQUIRE(res.body == "Received 65536 bytes");
-    
+
     server.stop();
   }
-  
+
   SECTION("Server properly parses query parameters")
   {
     iora::network::WebhookServer server;
     server.setPort(8085);
-    
-    server.onGet("/params", 
-      [](const iora::network::WebhookServer::Request& req, 
-         iora::network::WebhookServer::Response& res)
-      {
-        iora::parsers::Json response;
-        for (const auto& [key, value] : req.params)
-        {
-          response[key] = value;
-        }
-        res.set_content(response.dump(), "application/json");
-      });
-    
+
+    server.onGet("/params",
+                 [](const iora::network::WebhookServer::Request &req,
+                    iora::network::WebhookServer::Response &res)
+                 {
+                   iora::parsers::Json response;
+                   for (const auto &[key, value] : req.params)
+                   {
+                     response[key] = value;
+                   }
+                   res.set_content(response.dump(), "application/json");
+                 });
+
     server.start();
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
-    
+
     iora::network::HttpClient client;
     auto res = client.get("http://localhost:8085/params?foo=bar&test=123&empty=");
-    
+
     REQUIRE(res.success());
     auto json = iora::parsers::Json::parseString(res.body);
     REQUIRE(json["foo"] == "bar");
     REQUIRE(json["test"] == "123");
     REQUIRE(json["empty"] == "");
-    
+
     server.stop();
   }
-  
+
   SECTION("Server handles keep-alive connections")
   {
     iora::network::WebhookServer server;
     server.setPort(8086);
-    
+
     std::atomic<int> connectionCount{0};
-    server.onGet("/ping", 
-      [&connectionCount](const iora::network::WebhookServer::Request&, 
-                         iora::network::WebhookServer::Response& res)
-      {
-        connectionCount++;
-        res.set_content("pong", "text/plain");
-      });
-    
+    server.onGet("/ping",
+                 [&connectionCount](const iora::network::WebhookServer::Request &,
+                                    iora::network::WebhookServer::Response &res)
+                 {
+                   connectionCount++;
+                   res.set_content("pong", "text/plain");
+                 });
+
     server.start();
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
-    
+
     iora::network::HttpClient client;
-    
+
     // Make multiple requests - should reuse connection
     auto res1 = client.get("http://localhost:8086/ping");
     auto res2 = client.get("http://localhost:8086/ping");
     auto res3 = client.get("http://localhost:8086/ping");
-    
+
     REQUIRE(res1.success());
     REQUIRE(res2.success());
     REQUIRE(res3.success());
     REQUIRE(connectionCount == 3);
-    
+
     server.stop();
   }
 
@@ -158,29 +158,29 @@ TEST_CASE("WebhookServer transport-specific tests")
   {
     iora::network::WebhookServer server;
     server.setPort(8087);
-    
-    server.onGet("/headers", 
-      [](const iora::network::WebhookServer::Request&, 
-         iora::network::WebhookServer::Response& res)
+
+    server.onGet(
+      "/headers",
+      [](const iora::network::WebhookServer::Request &, iora::network::WebhookServer::Response &res)
       {
         res.set_header("Custom-Header", "test-value");
         res.set_content("OK", "text/plain");
       });
-    
+
     server.start();
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
-    
+
     iora::network::HttpClient client;
     auto res = client.get("http://localhost:8087/headers");
-    
+
     REQUIRE(res.success());
-    
+
     // Check standard headers are present
     bool hasServer = false;
     bool hasConnection = false;
     bool hasCustom = false;
-    
-    for (const auto& [key, value] : res.headers)
+
+    for (const auto &[key, value] : res.headers)
     {
       if (key == "Server" && value.find("Iora/1.0") != std::string::npos)
         hasServer = true;
@@ -189,89 +189,91 @@ TEST_CASE("WebhookServer transport-specific tests")
       if (key == "Custom-Header" && value == "test-value")
         hasCustom = true;
     }
-    
+
     REQUIRE(hasServer);
     REQUIRE(hasConnection);
     REQUIRE(hasCustom);
-    
+
     server.stop();
   }
-  
 
   SECTION("Server handles backpressure with 503 Service Unavailable")
   {
     // Create a WebhookServer with very small thread pool for testing backpressure
     iora::network::WebhookServer server;
     server.setPort(8088);
-    
+
     std::atomic<int> requestsProcessed{0};
     std::atomic<bool> allowProcessing{false};
-    
+
     // Set up a slow endpoint to fill the thread pool
-    server.onPost("/slow", 
-      [&requestsProcessed, &allowProcessing](const iora::network::WebhookServer::Request&, 
-                                           iora::network::WebhookServer::Response& res)
+    server.onPost(
+      "/slow",
+      [&requestsProcessed, &allowProcessing](const iora::network::WebhookServer::Request &,
+                                             iora::network::WebhookServer::Response &res)
       {
         // Wait until allowed to proceed
         while (!allowProcessing)
         {
           std::this_thread::sleep_for(std::chrono::milliseconds(10));
         }
-        
+
         requestsProcessed++;
         res.set_content("processed", "text/plain");
       });
-    
+
     server.start();
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
-    
+
     // Send enough requests to overwhelm the thread pool
     // The WebhookServer uses default ThreadPool which has maxQueueSize of 1024
     // but we'll send just a few concurrent requests to block the pool
     std::vector<std::thread> requestThreads;
     std::vector<std::unique_ptr<std::atomic<int>>> responseStatuses;
-    
+
     const int numRequests = 10; // More than default thread pool initial size
-    
+
     for (int i = 0; i < numRequests; ++i)
     {
       responseStatuses.push_back(std::make_unique<std::atomic<int>>(0));
-      requestThreads.emplace_back([i, &responseStatuses]()
-      {
-        try
-        {
-          iora::network::HttpClient client;
-          auto res = client.post("http://localhost:8088/slow", "test data", {{"Content-Type", "text/plain"}});
-          responseStatuses[i]->store(res.statusCode);
-        }
-        catch (...)
+      requestThreads.emplace_back(
+        [i, &responseStatuses]()
         {
-          responseStatuses[i]->store(-1); // Error indicator
-        }
-      });
+          try
+          {
+            iora::network::HttpClient client;
+            auto res = client.post("http://localhost:8088/slow", "test data",
+                                   {{"Content-Type", "text/plain"}});
+            responseStatuses[i]->store(res.statusCode);
+          }
+          catch (...)
+          {
+            responseStatuses[i]->store(-1); // Error indicator
+          }
+        });
     }
-    
+
     // Give some time for requests to hit the server and potentially fill the thread pool
     std::this_thread::sleep_for(std::chrono::milliseconds(100));
-    
+
     // Now allow processing to continue so some requests can complete successfully
     allowProcessing = true;
-    
+
     // Give enough time for requests to complete successfully
     std::this_thread::sleep_for(std::chrono::milliseconds(500));
-    
+
     // Wait for all requests to complete
-    for (auto& t : requestThreads)
+    for (auto &t : requestThreads)
     {
       t.join();
     }
-    
+
     // Check results
     int successCount = 0;
     int serviceUnavailableCount = 0;
     int errorCount = 0;
-    
-    for (const auto& status : responseStatuses)
+
+    for (const auto &status : responseStatuses)
     {
       int code = status->load();
       if (code == 200)
@@ -287,19 +289,18 @@ TEST_CASE("WebhookServer transport-specific tests")
         errorCount++;
       }
     }
-    
+
     // We should have processed some requests successfully
     REQUIRE(successCount > 0);
-    
+
     // Under normal load, all requests should succeed, but this test verifies
     // that the backpressure mechanism is in place and can reject requests
     // when the thread pool is overwhelmed
     REQUIRE(requestsProcessed == successCount);
-    
+
     // Verify total requests equals success + rejections + errors
     REQUIRE(successCount + serviceUnavailableCount + errorCount == numRequests);
-    
+
     server.stop();
   }
-
 }
diff --git a/tests/parsers/iora_test_json_parser.cpp b/tests/parsers/iora_test_json_parser.cpp
index d25d2b4..d11bf95 100644
--- a/tests/parsers/iora_test_json_parser.cpp
+++ b/tests/parsers/iora_test_json_parser.cpp
@@ -5,17 +5,17 @@
 // See the LICENSE file or <https://www.mozilla.org/MPL/2.0/> for details.
 
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "iora/parsers/json.hpp"
+#include <atomic>
+#include <catch2/catch.hpp>
+#include <chrono>
+#include <cmath>
+#include <limits>
+#include <mutex>
 #include <random>
 #include <string>
-#include <vector>
-#include <limits>
-#include <cmath>
-#include <chrono>
 #include <thread>
-#include <atomic>
-#include <mutex>
+#include <vector>
 
 using namespace iora::parsers;
 
@@ -23,7 +23,7 @@ namespace
 {
 
 /// \brief Generate random strings for fuzzing
-std::string generateRandomString(std::mt19937& rng, size_t maxLength = 100)
+std::string generateRandomString(std::mt19937 &rng, size_t maxLength = 100)
 {
   std::uniform_int_distribution<size_t> lengthDist(0, maxLength);
   std::uniform_int_distribution<char> charDist(32, 126); // Printable ASCII
@@ -40,25 +40,25 @@ std::string generateRandomString(std::mt19937& rng, size_t maxLength = 100)
 }
 
 /// \brief Generate random JSON-like strings with varying validity
-std::string generateRandomJsonLike(std::mt19937& rng)
+std::string generateRandomJsonLike(std::mt19937 &rng)
 {
   std::vector<std::string> templates = {
-      R"({"key": "value"})",
-      R"([1, 2, 3])",
-      R"({"nested": {"key": [1, 2, 3]}})",
-      R"(null)",
-      R"(true)",
-      R"(false)",
-      R"(123)",
-      R"(-456.789)",
-      R"("string")",
-      R"({"malformed": })",   // Invalid
-      R"([1, 2, 3,])",        // Invalid trailing comma
-      R"({"key": value})",    // Unquoted value
-      R"({key: "value"})",    // Unquoted key
-      R"({"key": "value")",   // Missing closing brace
-      R"({"key": "value"}})", // Extra closing brace
-      ""                      // Empty string
+    R"({"key": "value"})",
+    R"([1, 2, 3])",
+    R"({"nested": {"key": [1, 2, 3]}})",
+    R"(null)",
+    R"(true)",
+    R"(false)",
+    R"(123)",
+    R"(-456.789)",
+    R"("string")",
+    R"({"malformed": })",   // Invalid
+    R"([1, 2, 3,])",        // Invalid trailing comma
+    R"({"key": value})",    // Unquoted value
+    R"({key: "value"})",    // Unquoted key
+    R"({"key": "value")",   // Missing closing brace
+    R"({"key": "value"}})", // Extra closing brace
+    ""                      // Empty string
   };
 
   std::uniform_int_distribution<size_t> dist(0, templates.size() - 1);
@@ -216,7 +216,7 @@ TEST_CASE("JSON Parser - Object Operations", "[json][objects]")
     obj["c"] = 3;
 
     size_t count = 0;
-    for (const auto& [key, value] : obj.items())
+    for (const auto &[key, value] : obj.items())
     {
       REQUIRE(obj.contains(key));
       count++;
@@ -274,7 +274,7 @@ TEST_CASE("JSON Parser - Array Operations", "[json][arrays]")
     }
 
     size_t index = 0;
-    for (const auto& item : arr)
+    for (const auto &item : arr)
     {
       REQUIRE(item.get<int>() == static_cast<int>(index));
       index++;
@@ -343,30 +343,29 @@ TEST_CASE("JSON Parser - String Parsing", "[json][parsing]")
       REQUIRE(nested["array"].is_array());
       REQUIRE(nested["array"].size() == 3);
       REQUIRE(nested["object"]["nested"].get<bool>() == true);
-      REQUIRE(nested["mixed"][static_cast<std::size_t>(0)]["a"].get<int>() ==
-              1);
+      REQUIRE(nested["mixed"][static_cast<std::size_t>(0)]["a"].get<int>() == 1);
     }
   }
 
   SECTION("Invalid JSON parsing")
   {
     std::vector<std::string> invalidJson = {
-        "",                    // Empty
-        "{",                   // Incomplete object
-        "}",                   // Unexpected closing
-        "[1, 2, 3,]",          // Trailing comma
-        R"({"key": })",        // Missing value
-        R"({key: "value"})",   // Unquoted key
-        R"({"key": value})",   // Unquoted value
-        "undefined",           // Invalid literal
-        "NaN",                 // Invalid number
-        "Infinity",            // Invalid number
-        R"("unclosed string)", // Unclosed string
-        "[1, 2, 3}",           // Mismatched brackets
-        "{1, 2, 3]"            // Mismatched brackets
+      "",                    // Empty
+      "{",                   // Incomplete object
+      "}",                   // Unexpected closing
+      "[1, 2, 3,]",          // Trailing comma
+      R"({"key": })",        // Missing value
+      R"({key: "value"})",   // Unquoted key
+      R"({"key": value})",   // Unquoted value
+      "undefined",           // Invalid literal
+      "NaN",                 // Invalid number
+      "Infinity",            // Invalid number
+      R"("unclosed string)", // Unclosed string
+      "[1, 2, 3}",           // Mismatched brackets
+      "{1, 2, 3]"            // Mismatched brackets
     };
 
-    for (const auto& invalid : invalidJson)
+    for (const auto &invalid : invalidJson)
     {
       REQUIRE_THROWS_AS(Json::parseString(invalid), std::exception);
     }
@@ -417,20 +416,19 @@ TEST_CASE("JSON Parser - Serialization", "[json][serialization]")
 
   SECTION("Round-trip consistency")
   {
-    std::vector<std::string> testCases = {
-        R"(null)",
-        R"(true)",
-        R"(false)",
-        R"(42)",
-        R"(-123.456)",
-        R"("string with spaces")",
-        R"([])",
-        R"({})",
-        R"([1, 2, 3])",
-        R"({"a": 1, "b": 2})",
-        R"({"nested": {"array": [1, 2, {"deep": true}]}})"};
-
-    for (const auto& testCase : testCases)
+    std::vector<std::string> testCases = {R"(null)",
+                                          R"(true)",
+                                          R"(false)",
+                                          R"(42)",
+                                          R"(-123.456)",
+                                          R"("string with spaces")",
+                                          R"([])",
+                                          R"({})",
+                                          R"([1, 2, 3])",
+                                          R"({"a": 1, "b": 2})",
+                                          R"({"nested": {"array": [1, 2, {"deep": true}]}})"};
+
+    for (const auto &testCase : testCases)
     {
       auto parsed = Json::parseString(testCase);
       auto serialized = parsed.dump();
@@ -441,7 +439,7 @@ TEST_CASE("JSON Parser - Serialization", "[json][serialization]")
       if (parsed.is_object() && reparsed.is_object())
       {
         REQUIRE(parsed.size() == reparsed.size());
-        for (const auto& [key, value] : parsed.items())
+        for (const auto &[key, value] : parsed.items())
         {
           REQUIRE(reparsed.contains(key));
           REQUIRE(reparsed[key].dump() == value.dump());
@@ -456,8 +454,7 @@ TEST_CASE("JSON Parser - Serialization", "[json][serialization]")
   }
 }
 
-TEST_CASE("JSON Parser - Type Conversions and Edge Cases",
-          "[json][conversions]")
+TEST_CASE("JSON Parser - Type Conversions and Edge Cases", "[json][conversions]")
 {
   SECTION("Number precision")
   {
@@ -478,8 +475,7 @@ TEST_CASE("JSON Parser - Type Conversions and Edge Cases",
     std::string serialized = escaped.dump();
     auto parsed = Json::parseString(serialized);
 
-    REQUIRE(parsed.get<std::string>() ==
-            "Line 1\nLine 2\tTab\r\nQuote: \"Hello\"");
+    REQUIRE(parsed.get<std::string>() == "Line 1\nLine 2\tTab\r\nQuote: \"Hello\"");
   }
 
   SECTION("Unicode handling")
@@ -524,8 +520,7 @@ TEST_CASE("JSON Parser - Performance and Memory", "[json][performance]")
     }
 
     auto end = std::chrono::high_resolution_clock::now();
-    auto duration =
-        std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
+    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
 
     REQUIRE(largeObj.size() == 10000);
     REQUIRE(duration.count() < 1000); // Should complete in less than 1 second
@@ -544,8 +539,7 @@ TEST_CASE("JSON Parser - Performance and Memory", "[json][performance]")
     }
 
     auto end = std::chrono::high_resolution_clock::now();
-    auto duration =
-        std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
+    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
 
     REQUIRE(largeArr.size() == 100000);
     REQUIRE(duration.count() < 1000); // Should complete in less than 1 second
@@ -554,7 +548,7 @@ TEST_CASE("JSON Parser - Performance and Memory", "[json][performance]")
   SECTION("Deep nesting")
   {
     Json root = Json::object();
-    Json* current = &root;
+    Json *current = &root;
 
     // Create nested structure 100 levels deep
     for (int i = 0; i < 100; ++i)
@@ -587,7 +581,7 @@ TEST_CASE("JSON Parser - Fuzzing Tests", "[json][fuzzing]")
       {
         Json::parseString(randomStr);
       }
-      catch (const std::exception&)
+      catch (const std::exception &)
       {
         // Expected for invalid JSON
       }
@@ -607,7 +601,7 @@ TEST_CASE("JSON Parser - Fuzzing Tests", "[json][fuzzing]")
         // If parsing succeeded, serialization should work
         REQUIRE_NOTHROW(parsed.dump());
       }
-      catch (const std::exception&)
+      catch (const std::exception &)
       {
         // Expected for invalid JSON
       }
@@ -617,22 +611,22 @@ TEST_CASE("JSON Parser - Fuzzing Tests", "[json][fuzzing]")
   SECTION("Boundary value fuzzing")
   {
     std::vector<std::string> boundaryTests = {
-        std::string(1000000, 'a'),                       // Very long string
-        "\"" + std::string(100000, 'x') + "\"",          // Long JSON string
-        "[" + std::string(10000, '1') + "]",             // Malformed long array
-        "{" + std::string(10000, ' ') + "}",             // Whitespace object
-        std::string(1000, '[') + std::string(1000, ']'), // Deep nesting
-        "null" + std::string(100000, ' '),               // Trailing whitespace
-        std::string(100000, ' ') + "null"                // Leading whitespace
+      std::string(1000000, 'a'),                       // Very long string
+      "\"" + std::string(100000, 'x') + "\"",          // Long JSON string
+      "[" + std::string(10000, '1') + "]",             // Malformed long array
+      "{" + std::string(10000, ' ') + "}",             // Whitespace object
+      std::string(1000, '[') + std::string(1000, ']'), // Deep nesting
+      "null" + std::string(100000, ' '),               // Trailing whitespace
+      std::string(100000, ' ') + "null"                // Leading whitespace
     };
 
-    for (const auto& test : boundaryTests)
+    for (const auto &test : boundaryTests)
     {
       try
       {
         Json::parseString(test);
       }
-      catch (const std::exception&)
+      catch (const std::exception &)
       {
         // Expected for malformed JSON
       }
@@ -653,27 +647,27 @@ TEST_CASE("JSON Parser - Thread Safety", "[json][threading]")
     for (int i = 0; i < 10; ++i)
     {
       threads.emplace_back(
-          [&, i]()
+        [&, i]()
+        {
+          try
           {
-            try
+            for (int j = 0; j < 100; ++j)
             {
-              for (int j = 0; j < 100; ++j)
+              auto parsed = Json::parseString(validJson);
+              if (parsed["thread"].get<std::string>() == "test")
               {
-                auto parsed = Json::parseString(validJson);
-                if (parsed["thread"].get<std::string>() == "test")
-                {
-                  successCount++;
-                }
+                successCount++;
               }
             }
-            catch (...)
-            {
-              failureCount++;
-            }
-          });
+          }
+          catch (...)
+          {
+            failureCount++;
+          }
+        });
     }
 
-    for (auto& thread : threads)
+    for (auto &thread : threads)
     {
       thread.join();
     }
@@ -691,18 +685,17 @@ TEST_CASE("JSON Parser - Thread Safety", "[json][threading]")
     for (int i = 0; i < 5; ++i)
     {
       threads.emplace_back(
-          [&, i]()
+        [&, i]()
+        {
+          for (int j = 0; j < 100; ++j)
           {
-            for (int j = 0; j < 100; ++j)
-            {
-              std::lock_guard<std::mutex> lock(objMutex);
-              sharedObj["thread_" + std::to_string(i) + "_" +
-                        std::to_string(j)] = i * 100 + j;
-            }
-          });
+            std::lock_guard<std::mutex> lock(objMutex);
+            sharedObj["thread_" + std::to_string(i) + "_" + std::to_string(j)] = i * 100 + j;
+          }
+        });
     }
 
-    for (auto& thread : threads)
+    for (auto &thread : threads)
     {
       thread.join();
     }
@@ -716,21 +709,21 @@ TEST_CASE("JSON Parser - Error Recovery", "[json][errors]")
   SECTION("Graceful error handling")
   {
     std::vector<std::pair<std::string, std::string>> errorCases = {
-        {"", "Empty JSON"},
-        {"{", "Incomplete object"},
-        {"[1,2,", "Incomplete array"},
-        {R"({"key": undefined})", "Invalid value"},
-        {"1.2.3", "Invalid number"},
-        {R"("unclosed)", "Unclosed string"}};
-
-    for (const auto& [input, description] : errorCases)
+      {"", "Empty JSON"},
+      {"{", "Incomplete object"},
+      {"[1,2,", "Incomplete array"},
+      {R"({"key": undefined})", "Invalid value"},
+      {"1.2.3", "Invalid number"},
+      {R"("unclosed)", "Unclosed string"}};
+
+    for (const auto &[input, description] : errorCases)
     {
       bool threwException = false;
       try
       {
         Json::parseString(input);
       }
-      catch (const std::exception& e)
+      catch (const std::exception &e)
       {
         threwException = true;
         // Error message should be meaningful
diff --git a/tests/parsers/iora_test_xml_parser.cpp b/tests/parsers/iora_test_xml_parser.cpp
index 7bbab6c..8c42ab1 100644
--- a/tests/parsers/iora_test_xml_parser.cpp
+++ b/tests/parsers/iora_test_xml_parser.cpp
@@ -1,8 +1,8 @@
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "iora/parsers/xml.hpp"
-#include <string>
+#include <catch2/catch.hpp>
 #include <sstream>
+#include <string>
 
 using namespace iora::parsers::xml;
 
@@ -12,50 +12,50 @@ TEST_CASE("XML Parser - Basic Parsing", "[xml][parser][basic]")
   {
     std::string xml = "<root>hello</root>";
     Parser parser(xml);
-    
+
     REQUIRE(parser.next());
     const auto &tok1 = parser.current();
     REQUIRE(tok1.kind == TokenKind::StartElement);
     REQUIRE(tok1.name == "root");
     REQUIRE(tok1.depth == 1);
-    
+
     REQUIRE(parser.next());
     const auto &tok2 = parser.current();
     REQUIRE(tok2.kind == TokenKind::Text);
     REQUIRE(tok2.text == "hello");
     REQUIRE(tok2.depth == 1);
-    
+
     REQUIRE(parser.next());
     const auto &tok3 = parser.current();
     REQUIRE(tok3.kind == TokenKind::EndElement);
     REQUIRE(tok3.name == "root");
     REQUIRE(tok3.depth == 1);
-    
+
     REQUIRE_FALSE(parser.next());
     REQUIRE(parser.error() == nullptr);
   }
-  
+
   SECTION("Empty element parsing")
   {
     std::string xml = "<empty/>";
     Parser parser(xml);
-    
+
     REQUIRE(parser.next());
     const auto &tok = parser.current();
     REQUIRE(tok.kind == TokenKind::EmptyElement);
     REQUIRE(tok.name == "empty");
     REQUIRE(tok.selfClosing == true);
     REQUIRE(tok.depth == 1);
-    
+
     REQUIRE_FALSE(parser.next());
     REQUIRE(parser.error() == nullptr);
   }
-  
+
   SECTION("Element with attributes")
   {
     std::string xml = "<elem attr1=\"value1\" attr2='value2'>content</elem>";
     Parser parser(xml);
-    
+
     REQUIRE(parser.next());
     const auto &tok = parser.current();
     REQUIRE(tok.kind == TokenKind::StartElement);
@@ -65,17 +65,17 @@ TEST_CASE("XML Parser - Basic Parsing", "[xml][parser][basic]")
     REQUIRE(tok.attributes[0].value == "value1");
     REQUIRE(tok.attributes[1].name == "attr2");
     REQUIRE(tok.attributes[1].value == "value2");
-    
+
     REQUIRE(parser.next());
     const auto &textTok = parser.current();
     REQUIRE(textTok.kind == TokenKind::Text);
     REQUIRE(textTok.text == "content");
-    
+
     REQUIRE(parser.next());
     const auto &endTok = parser.current();
     REQUIRE(endTok.kind == TokenKind::EndElement);
     REQUIRE(endTok.name == "elem");
-    
+
     REQUIRE_FALSE(parser.next());
     REQUIRE(parser.error() == nullptr);
   }
@@ -87,65 +87,65 @@ TEST_CASE("XML Parser - Nested Elements", "[xml][parser][nested]")
   {
     std::string xml = "<root><child1>text1</child1><child2>text2</child2></root>";
     Parser parser(xml);
-    
+
     // Root start
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::StartElement);
     REQUIRE(parser.current().name == "root");
     REQUIRE(parser.current().depth == 1);
-    
+
     // Child1 start
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::StartElement);
     REQUIRE(parser.current().name == "child1");
     REQUIRE(parser.current().depth == 2);
-    
+
     // Child1 text
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::Text);
     REQUIRE(parser.current().text == "text1");
     REQUIRE(parser.current().depth == 2);
-    
+
     // Child1 end
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::EndElement);
     REQUIRE(parser.current().name == "child1");
     REQUIRE(parser.current().depth == 2);
-    
+
     // Child2 start
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::StartElement);
     REQUIRE(parser.current().name == "child2");
     REQUIRE(parser.current().depth == 2);
-    
+
     // Child2 text
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::Text);
     REQUIRE(parser.current().text == "text2");
-    
+
     // Child2 end
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::EndElement);
     REQUIRE(parser.current().name == "child2");
-    
+
     // Root end
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::EndElement);
     REQUIRE(parser.current().name == "root");
     REQUIRE(parser.current().depth == 1);
-    
+
     REQUIRE_FALSE(parser.next());
     REQUIRE(parser.error() == nullptr);
   }
-  
+
   SECTION("Deep nesting")
   {
     std::string xml = "<a><b><c><d>deep</d></c></b></a>";
     Parser parser(xml);
-    
+
     std::vector<std::string> expectedNames = {"a", "b", "c", "d"};
     std::vector<std::size_t> expectedDepths = {1, 2, 3, 4};
-    
+
     for (std::size_t i = 0; i < expectedNames.size(); ++i)
     {
       REQUIRE(parser.next());
@@ -153,13 +153,13 @@ TEST_CASE("XML Parser - Nested Elements", "[xml][parser][nested]")
       REQUIRE(parser.current().name == expectedNames[i]);
       REQUIRE(parser.current().depth == expectedDepths[i]);
     }
-    
+
     // Text content
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::Text);
     REQUIRE(parser.current().text == "deep");
     REQUIRE(parser.current().depth == 4);
-    
+
     // End elements in reverse order
     for (int i = static_cast<int>(expectedNames.size()) - 1; i >= 0; --i)
     {
@@ -168,7 +168,7 @@ TEST_CASE("XML Parser - Nested Elements", "[xml][parser][nested]")
       REQUIRE(parser.current().name == expectedNames[static_cast<std::size_t>(i)]);
       REQUIRE(parser.current().depth == expectedDepths[static_cast<std::size_t>(i)]);
     }
-    
+
     REQUIRE_FALSE(parser.next());
     REQUIRE(parser.error() == nullptr);
   }
@@ -180,72 +180,72 @@ TEST_CASE("XML Parser - Special Content", "[xml][parser][special]")
   {
     std::string xml = "<root><![CDATA[This is <raw> content & stuff]]></root>";
     Parser parser(xml);
-    
+
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::StartElement);
     REQUIRE(parser.current().name == "root");
-    
+
     REQUIRE(parser.next());
     const auto &cdataTok = parser.current();
     REQUIRE(cdataTok.kind == TokenKind::CData);
     REQUIRE(cdataTok.text == "This is <raw> content & stuff");
-    
+
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::EndElement);
-    
+
     REQUIRE_FALSE(parser.next());
     REQUIRE(parser.error() == nullptr);
   }
-  
+
   SECTION("Comments")
   {
     std::string xml = "<root><!-- This is a comment --><child/></root>";
     Parser parser(xml);
-    
+
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::StartElement);
     REQUIRE(parser.current().name == "root");
-    
+
     REQUIRE(parser.next());
     const auto &commentTok = parser.current();
     REQUIRE(commentTok.kind == TokenKind::Comment);
     REQUIRE(commentTok.text == " This is a comment ");
-    
+
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::EmptyElement);
     REQUIRE(parser.current().name == "child");
-    
+
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::EndElement);
-    
+
     REQUIRE_FALSE(parser.next());
     REQUIRE(parser.error() == nullptr);
   }
-  
+
   SECTION("Processing instruction")
   {
     std::string xml = "<?xml version=\"1.0\"?><root><?target data?></root>";
     Parser parser(xml);
-    
+
     REQUIRE(parser.next());
     const auto &piTok = parser.current();
     REQUIRE(piTok.kind == TokenKind::ProcessingInstruction);
     REQUIRE(piTok.name == "xml");
     REQUIRE(piTok.text == " version=\"1.0\"");
-    
+
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::StartElement);
     REQUIRE(parser.current().name == "root");
-    
+
     REQUIRE(parser.next());
     const auto &piTok2 = parser.current();
     REQUIRE(piTok2.kind == TokenKind::ProcessingInstruction);
     REQUIRE(piTok2.name == "target");
     REQUIRE(piTok2.text == " data");
-    
+
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::EndElement);
-    
+
     REQUIRE_FALSE(parser.next());
     REQUIRE(parser.error() == nullptr);
   }
@@ -258,47 +258,47 @@ TEST_CASE("XML Parser - Entity Decoding", "[xml][parser][entities]")
     std::string input = "&lt;&gt;&amp;&apos;&quot;";
     std::string output;
     Error err;
-    
+
     REQUIRE(Parser::decodeEntities(input, output, &err));
     REQUIRE(output == "<>&'\"");
   }
-  
+
   SECTION("Numeric character references")
   {
     std::string input = "&#65;&#x42;&#67;"; // A B C
     std::string output;
     Error err;
-    
+
     REQUIRE(Parser::decodeEntities(input, output, &err));
     REQUIRE(output == "ABC");
   }
-  
+
   SECTION("Mixed content with entities")
   {
     std::string input = "Hello &amp; goodbye &lt;world&gt;";
     std::string output;
     Error err;
-    
+
     REQUIRE(Parser::decodeEntities(input, output, &err));
     REQUIRE(output == "Hello & goodbye <world>");
   }
-  
+
   SECTION("Invalid entity")
   {
     std::string input = "&unknown;";
     std::string output;
     Error err;
-    
+
     REQUIRE_FALSE(Parser::decodeEntities(input, output, &err));
     REQUIRE(err.message == "unknown entity");
   }
-  
+
   SECTION("Unterminated entity")
   {
     std::string input = "&amp";
     std::string output;
     Error err;
-    
+
     REQUIRE_FALSE(Parser::decodeEntities(input, output, &err));
     REQUIRE(err.message == "unterminated entity");
   }
@@ -310,27 +310,27 @@ TEST_CASE("XML Parser - QName Splitting", "[xml][parser][qname]")
   {
     Token token;
     token.name = "element";
-    
+
     auto [prefix, localName] = token.splitQName();
     REQUIRE(prefix.empty());
     REQUIRE(localName == "element");
   }
-  
+
   SECTION("Namespaced name")
   {
     Token token;
     token.name = "ns:element";
-    
+
     auto [prefix, localName] = token.splitQName();
     REQUIRE(prefix == "ns");
     REQUIRE(localName == "element");
   }
-  
+
   SECTION("Multiple colons")
   {
     Token token;
     token.name = "ns:sub:element";
-    
+
     auto [prefix, localName] = token.splitQName();
     REQUIRE(prefix == "ns");
     REQUIRE(localName == "sub:element");
@@ -343,66 +343,66 @@ TEST_CASE("XML Parser - Error Handling", "[xml][parser][errors]")
   {
     std::string xml = "<root><child>text";
     Parser parser(xml);
-    
-    REQUIRE(parser.next()); // root start
-    REQUIRE(parser.next()); // child start
-    REQUIRE(parser.next()); // text
+
+    REQUIRE(parser.next());       // root start
+    REQUIRE(parser.next());       // child start
+    REQUIRE(parser.next());       // text
     REQUIRE_FALSE(parser.next()); // should fail at EOF
-    
+
     // Parser now correctly reports unclosed tags at EOF
     const Error *err = parser.error();
     REQUIRE(err != nullptr);
     REQUIRE(std::string(err->message).find("unclosed elements") != std::string::npos);
   }
-  
+
   SECTION("Malformed XML - unbalanced tags")
   {
     std::string xml = "<root><child></root>";
     Parser parser(xml);
-    
-    REQUIRE(parser.next()); // root start
-    REQUIRE(parser.next()); // child start  
+
+    REQUIRE(parser.next());       // root start
+    REQUIRE(parser.next());       // child start
     REQUIRE_FALSE(parser.next()); // Should fail on mismatched end tag
-    
+
     // Parser now correctly reports unbalanced tag errors
     const Error *err = parser.error();
     REQUIRE(err != nullptr);
     REQUIRE(std::string(err->message).find("mismatched end tag") != std::string::npos);
   }
-  
+
   SECTION("Invalid tag name")
   {
     std::string xml = "<123invalid>";
     Parser parser(xml);
-    
+
     REQUIRE_FALSE(parser.next());
     const Error *err = parser.error();
     REQUIRE(err != nullptr);
   }
-  
+
   SECTION("Invalid attribute syntax")
   {
     std::string xml = "<elem attr=value>";
     Parser parser(xml);
-    
+
     REQUIRE_FALSE(parser.next());
     const Error *err = parser.error();
     REQUIRE(err != nullptr);
   }
-  
+
   SECTION("Depth limit exceeded")
   {
     Options opts;
     opts.maxDepth = 3;
-    
+
     std::string xml = "<a><b><c><d>too deep</d></c></b></a>";
     Parser parser(xml, opts);
-    
-    REQUIRE(parser.next()); // a
-    REQUIRE(parser.next()); // b  
-    REQUIRE(parser.next()); // c
+
+    REQUIRE(parser.next());       // a
+    REQUIRE(parser.next());       // b
+    REQUIRE(parser.next());       // c
     REQUIRE_FALSE(parser.next()); // d should fail depth limit
-    
+
     const Error *err = parser.error();
     REQUIRE(err != nullptr);
     REQUIRE(err->message == "maximum element depth exceeded");
@@ -415,42 +415,42 @@ TEST_CASE("XML Parser - Configuration Options", "[xml][parser][options]")
   {
     Options opts;
     opts.maxTotalTokens = 3;
-    
+
     std::string xml = "<root><child>text</child></root>";
     Parser parser(xml, opts);
-    
-    REQUIRE(parser.next()); // 1: root start
-    REQUIRE(parser.next()); // 2: child start  
-    REQUIRE(parser.next()); // 3: text
+
+    REQUIRE(parser.next());       // 1: root start
+    REQUIRE(parser.next());       // 2: child start
+    REQUIRE(parser.next());       // 3: text
     REQUIRE_FALSE(parser.next()); // 4: should fail
-    
+
     const Error *err = parser.error();
     REQUIRE(err != nullptr);
     REQUIRE(err->message == "token limit exceeded");
   }
-  
+
   SECTION("Attribute limit")
   {
     Options opts;
     opts.maxAttrsPerElement = 2;
-    
+
     std::string xml = "<elem a=\"1\" b=\"2\" c=\"3\"/>";
     Parser parser(xml, opts);
-    
+
     REQUIRE_FALSE(parser.next());
     const Error *err = parser.error();
     REQUIRE(err != nullptr);
     REQUIRE(err->message == "too many attributes");
   }
-  
+
   SECTION("Name length limit")
   {
     Options opts;
     opts.maxNameLength = 5;
-    
+
     std::string xml = "<verylongname>";
     Parser parser(xml, opts);
-    
+
     REQUIRE_FALSE(parser.next());
     const Error *err = parser.error();
     REQUIRE(err != nullptr);
@@ -465,37 +465,26 @@ TEST_CASE("XML Parser - SAX Interface", "[xml][parser][sax]")
   {
     std::string xml = "<root attr=\"val\"><!-- comment --><child>text</child></root>";
     Parser parser(xml);
-    
+
     std::vector<std::string> events;
     SaxCallbacks callbacks;
-    
-    callbacks.onStartElement = [&](const Token &t) {
-      events.push_back("start:" + std::string(t.name));
-    };
-    
-    callbacks.onEndElement = [&](const Token &t) {
-      events.push_back("end:" + std::string(t.name));
-    };
-    
-    callbacks.onText = [&](const Token &t) {
-      events.push_back("text:" + std::string(t.text));
-    };
-    
-    callbacks.onComment = [&](const Token &t) {
-      events.push_back("comment:" + std::string(t.text));
-    };
-    
+
+    callbacks.onStartElement = [&](const Token &t)
+    { events.push_back("start:" + std::string(t.name)); };
+
+    callbacks.onEndElement = [&](const Token &t)
+    { events.push_back("end:" + std::string(t.name)); };
+
+    callbacks.onText = [&](const Token &t) { events.push_back("text:" + std::string(t.text)); };
+
+    callbacks.onComment = [&](const Token &t)
+    { events.push_back("comment:" + std::string(t.text)); };
+
     REQUIRE(runSax(parser, callbacks));
-    
-    std::vector<std::string> expected = {
-      "start:root",
-      "comment: comment ",
-      "start:child", 
-      "text:text",
-      "end:child",
-      "end:root"
-    };
-    
+
+    std::vector<std::string> expected = {"start:root", "comment: comment ", "start:child",
+                                         "text:text",  "end:child",         "end:root"};
+
     REQUIRE(events == expected);
   }
 }
@@ -508,83 +497,83 @@ TEST_CASE("XML Parser - DOM Interface", "[xml][parser][dom]")
   {
     std::string xml = "<root attr=\"value\"><child>text content</child><empty/></root>";
     Parser parser(xml);
-    
+
     Error err;
     auto doc = DomBuilder::build(parser, &err);
-    
+
     REQUIRE(doc != nullptr);
     REQUIRE(doc->type == NodeType::Document);
     REQUIRE(doc->children.size() == 1);
-    
+
     const Node *root = doc->children[0].get();
     REQUIRE(root->type == NodeType::Element);
     REQUIRE(root->name == "root");
     REQUIRE(root->attributes.size() == 1);
     REQUIRE(root->attributes[0].name == "attr");
     REQUIRE(root->attributes[0].value == "value");
-    
+
     REQUIRE(root->children.size() == 2);
-    
+
     const Node *child = root->children[0].get();
     REQUIRE(child->type == NodeType::Element);
     REQUIRE(child->name == "child");
     REQUIRE(child->children.size() == 1);
     REQUIRE(child->children[0]->type == NodeType::Text);
     REQUIRE(child->children[0]->value == "text content");
-    
+
     const Node *empty = root->children[1].get();
     REQUIRE(empty->type == NodeType::Element);
     REQUIRE(empty->name == "empty");
     REQUIRE(empty->children.empty());
   }
-  
+
   SECTION("DOM helper methods")
   {
     std::string xml = "<root><person name=\"Alice\"><age>30</age></person></root>";
     Parser parser(xml);
-    
+
     auto doc = DomBuilder::build(parser);
     REQUIRE(doc != nullptr);
-    
+
     const Node *root = doc->children[0].get();
     const Node *person = root->childByName("person");
     REQUIRE(person != nullptr);
     REQUIRE(person->getAttribute("name") == "Alice");
-    
+
     const Node *age = person->childByName("age");
     REQUIRE(age != nullptr);
     REQUIRE(age->getTextContent() == "30");
-    
+
     // Test non-existent child
     const Node *missing = root->childByName("missing");
     REQUIRE(missing == nullptr);
-    
+
     // Test non-existent attribute
     auto missingAttr = person->getAttribute("missing");
     REQUIRE(missingAttr.empty());
   }
-  
+
   SECTION("DOM with entities")
   {
     std::string xml = "<root attr=\"&lt;value&gt;\">Text with &amp; entities</root>";
     Parser parser(xml);
-    
+
     auto doc = DomBuilder::build(parser);
     REQUIRE(doc != nullptr);
-    
+
     const Node *root = doc->children[0].get();
     REQUIRE(root->getAttribute("attr") == "<value>");
     REQUIRE(root->getTextContent() == "Text with & entities");
   }
-  
+
   SECTION("DOM error handling")
   {
     std::string xml = "<root><unclosed>";
     Parser parser(xml);
-    
+
     Error err;
     auto doc = DomBuilder::build(parser, &err);
-    
+
     REQUIRE(doc == nullptr);
     REQUIRE(err.message.find("unclosed elements at end of document") != std::string::npos);
   }
@@ -606,9 +595,9 @@ TEST_CASE("XML Parser - Real-world Examples", "[xml][parser][realworld]")
         </channel>
       </rss>
     )";
-    
+
     Parser parser(xml);
-    
+
     // Skip whitespace and parse structure
     REQUIRE(parser.next());
     REQUIRE(parser.current().kind == TokenKind::StartElement);
@@ -616,12 +605,14 @@ TEST_CASE("XML Parser - Real-world Examples", "[xml][parser][realworld]")
     REQUIRE(parser.current().attributes.size() == 1);
     REQUIRE(parser.current().attributes[0].name == "version");
     REQUIRE(parser.current().attributes[0].value == "2.0");
-    
+
     // Should parse without errors
-    while (parser.next()) { /* consume all tokens */ }
+    while (parser.next())
+    { /* consume all tokens */
+    }
     REQUIRE(parser.error() == nullptr);
   }
-  
+
   SECTION("SOAP-like envelope")
   {
     std::string xml = R"(
@@ -633,24 +624,26 @@ TEST_CASE("XML Parser - Real-world Examples", "[xml][parser][realworld]")
         </soap:Body>
       </soap:Envelope>
     )";
-    
+
     Parser parser(xml);
-    
+
     // Test namespace parsing
     REQUIRE(parser.next());
     const auto &envelope = parser.current();
     REQUIRE(envelope.kind == TokenKind::StartElement);
     REQUIRE(envelope.name == "soap:Envelope");
-    
+
     auto [prefix, localName] = envelope.splitQName();
     REQUIRE(prefix == "soap");
     REQUIRE(localName == "Envelope");
-    
+
     // Should parse without errors
-    while (parser.next()) { /* consume all tokens */ }
+    while (parser.next())
+    { /* consume all tokens */
+    }
     REQUIRE(parser.error() == nullptr);
   }
-  
+
   SECTION("Configuration file")
   {
     std::string xml = R"(
@@ -666,26 +659,26 @@ TEST_CASE("XML Parser - Real-world Examples", "[xml][parser][realworld]")
         <logging level="debug" file="/var/log/app.log"/>
       </config>
     )";
-    
+
     Parser parser(xml);
     auto doc = DomBuilder::build(parser);
-    
+
     REQUIRE(doc != nullptr);
     const Node *config = doc->children[0].get();
     const Node *database = config->childByName("database");
     REQUIRE(database != nullptr);
-    
+
     const Node *host = database->childByName("host");
     REQUIRE(host != nullptr);
     REQUIRE(host->getTextContent() == "localhost");
-    
+
     const Node *settings = database->childByName("settings");
     REQUIRE(settings != nullptr);
-    
+
     const Node *timeout = settings->childByName("timeout");
     REQUIRE(timeout != nullptr);
     REQUIRE(timeout->getTextContent() == "30");
-    
+
     const Node *logging = config->childByName("logging");
     REQUIRE(logging != nullptr);
     REQUIRE(logging->getAttribute("level") == "debug");
@@ -699,24 +692,24 @@ TEST_CASE("XML Parser - Performance and Limits", "[xml][parser][performance]")
   {
     std::string largeText(10000, 'x');
     std::string xml = "<root>" + largeText + "</root>";
-    
+
     Parser parser(xml);
-    
+
     REQUIRE(parser.next()); // start element
     REQUIRE(parser.next()); // text
     REQUIRE(parser.current().kind == TokenKind::Text);
     REQUIRE(parser.current().text.size() == 10000);
-    REQUIRE(parser.next()); // end element
+    REQUIRE(parser.next());       // end element
     REQUIRE_FALSE(parser.next()); // EOF
     REQUIRE(parser.error() == nullptr);
   }
-  
+
   SECTION("Many attributes")
   {
     // Test with minimal attributes due to parser limitations with many attributes
     std::string xml = "<elem attr1=\"val1\" attr2=\"val2\"/>";
     Parser parser(xml);
-    
+
     REQUIRE(parser.next());
     const auto &tok = parser.current();
     REQUIRE(tok.kind == TokenKind::EmptyElement);
@@ -725,7 +718,7 @@ TEST_CASE("XML Parser - Performance and Limits", "[xml][parser][performance]")
     REQUIRE(tok.attributes[0].value == "val1");
     REQUIRE(tok.attributes[1].name == "attr2");
     REQUIRE(tok.attributes[1].value == "val2");
-    
+
     REQUIRE_FALSE(parser.next());
     REQUIRE(parser.error() == nullptr);
   }
diff --git a/tests/plugins/BasePlugin.cpp b/tests/plugins/BasePlugin.cpp
index 2f1a918..9f7ac20 100644
--- a/tests/plugins/BasePlugin.cpp
+++ b/tests/plugins/BasePlugin.cpp
@@ -5,48 +5,21 @@
 class BasePlugin : public iora::IoraService::Plugin
 {
 public:
-  explicit BasePlugin(iora::IoraService* svc)
-    : Plugin(svc), _counter(0)
-  {
-  }
+  explicit BasePlugin(iora::IoraService *svc) : Plugin(svc), _counter(0) {}
 
-  void onLoad(iora::IoraService* svc) override
+  void onLoad(iora::IoraService *svc) override
   {
     // Export basic APIs that other plugins can use
     svc->exportApi(*this, "baseplugin.getVersion",
-      [this]() -> std::string
-      { 
-        return "BasePlugin v1.0"; 
-      }
-    );
-
-    svc->exportApi(*this, "baseplugin.increment",
-      [this]() -> int
-      { 
-        return ++_counter; 
-      }
-    );
-
-    svc->exportApi(*this, "baseplugin.getCounter",
-      [this]() -> int
-      { 
-        return _counter; 
-      }
-    );
-
-    svc->exportApi(*this, "baseplugin.setCounter",
-      [this](int value) -> void
-      { 
-        _counter = value; 
-      }
-    );
-
-    svc->exportApi(*this, "baseplugin.reset",
-      [this]() -> void
-      { 
-        _counter = 0; 
-      }
-    );
+                   [this]() -> std::string { return "BasePlugin v1.0"; });
+
+    svc->exportApi(*this, "baseplugin.increment", [this]() -> int { return ++_counter; });
+
+    svc->exportApi(*this, "baseplugin.getCounter", [this]() -> int { return _counter; });
+
+    svc->exportApi(*this, "baseplugin.setCounter", [this](int value) -> void { _counter = value; });
+
+    svc->exportApi(*this, "baseplugin.reset", [this]() -> void { _counter = 0; });
   }
 
   void onUnload() override
diff --git a/tests/plugins/ChainedPlugin.cpp b/tests/plugins/ChainedPlugin.cpp
index db83b52..04cb795 100644
--- a/tests/plugins/ChainedPlugin.cpp
+++ b/tests/plugins/ChainedPlugin.cpp
@@ -5,12 +5,12 @@
 class ChainedPlugin : public iora::IoraService::Plugin
 {
 public:
-  explicit ChainedPlugin(iora::IoraService* svc)
-    : Plugin(svc), _service(svc), _baseDependencyCount(0), _dependentDependencyCount(0)
+  explicit ChainedPlugin(iora::IoraService *svc)
+      : Plugin(svc), _service(svc), _baseDependencyCount(0), _dependentDependencyCount(0)
   {
   }
 
-  void onLoad(iora::IoraService* svc) override
+  void onLoad(iora::IoraService *svc) override
   {
     // Require both dependencies
     require("baseplugin.so");
@@ -18,48 +18,56 @@ public:
 
     // Export API that uses both dependencies
     svc->exportApi(*this, "chainedplugin.useChain",
-      [this]() -> std::string
-      { 
-        try {
-          auto baseVersion = _service->callExportedApi<std::string>("baseplugin.getVersion");
-          auto dependentStatus = _service->callExportedApi<std::string>("dependentplugin.getStatus");
-          auto baseCounter = _service->callExportedApi<int>("baseplugin.getCounter");
-          
-          return "ChainedPlugin using " + baseVersion + ", " + dependentStatus + ", counter: " + std::to_string(baseCounter);
-        } catch (const std::exception& e) {
-          return "Error in chain: " + std::string(e.what());
-        }
-      }
-    );
+                   [this]() -> std::string
+                   {
+                     try
+                     {
+                       auto baseVersion =
+                         _service->callExportedApi<std::string>("baseplugin.getVersion");
+                       auto dependentStatus =
+                         _service->callExportedApi<std::string>("dependentplugin.getStatus");
+                       auto baseCounter = _service->callExportedApi<int>("baseplugin.getCounter");
+
+                       return "ChainedPlugin using " + baseVersion + ", " + dependentStatus +
+                              ", counter: " + std::to_string(baseCounter);
+                     }
+                     catch (const std::exception &e)
+                     {
+                       return "Error in chain: " + std::string(e.what());
+                     }
+                   });
 
     svc->exportApi(*this, "chainedplugin.getDependencyStatus",
-      [this]() -> std::string
-      { 
-        return "BaseDep: " + std::to_string(_baseDependencyCount) + 
-               ", DependentDep: " + std::to_string(_dependentDependencyCount);
-      }
-    );
+                   [this]() -> std::string
+                   {
+                     return "BaseDep: " + std::to_string(_baseDependencyCount) +
+                            ", DependentDep: " + std::to_string(_dependentDependencyCount);
+                   });
 
     svc->exportApi(*this, "chainedplugin.complexOperation",
-      [this]() -> std::string
-      { 
-        try {
-          // Use BasePlugin to increment counter
-          _service->callExportedApi<int>("baseplugin.increment");
-          _service->callExportedApi<int>("baseplugin.increment");
-          
-          // Use DependentPlugin to get status
-          auto dependentResult = _service->callExportedApi<std::string>("dependentplugin.useBase");
-          
-          // Get final counter value
-          auto finalCounter = _service->callExportedApi<int>("baseplugin.getCounter");
-          
-          return "Complex operation result: " + dependentResult + ", final counter: " + std::to_string(finalCounter);
-        } catch (const std::exception& e) {
-          return "Complex operation failed: " + std::string(e.what());
-        }
-      }
-    );
+                   [this]() -> std::string
+                   {
+                     try
+                     {
+                       // Use BasePlugin to increment counter
+                       _service->callExportedApi<int>("baseplugin.increment");
+                       _service->callExportedApi<int>("baseplugin.increment");
+
+                       // Use DependentPlugin to get status
+                       auto dependentResult =
+                         _service->callExportedApi<std::string>("dependentplugin.useBase");
+
+                       // Get final counter value
+                       auto finalCounter = _service->callExportedApi<int>("baseplugin.getCounter");
+
+                       return "Complex operation result: " + dependentResult +
+                              ", final counter: " + std::to_string(finalCounter);
+                     }
+                     catch (const std::exception &e)
+                     {
+                       return "Complex operation failed: " + std::string(e.what());
+                     }
+                   });
   }
 
   void onUnload() override
@@ -69,26 +77,32 @@ public:
     _dependentDependencyCount = 0;
   }
 
-  void onDependencyLoaded(const std::string& moduleName) override
+  void onDependencyLoaded(const std::string &moduleName) override
   {
-    if (moduleName == "baseplugin.so") {
+    if (moduleName == "baseplugin.so")
+    {
       _baseDependencyCount++;
-    } else if (moduleName == "dependentplugin.so") {
+    }
+    else if (moduleName == "dependentplugin.so")
+    {
       _dependentDependencyCount++;
     }
   }
 
-  void onDependencyUnloaded(const std::string& moduleName) override
+  void onDependencyUnloaded(const std::string &moduleName) override
   {
-    if (moduleName == "baseplugin.so") {
+    if (moduleName == "baseplugin.so")
+    {
       _baseDependencyCount--;
-    } else if (moduleName == "dependentplugin.so") {
+    }
+    else if (moduleName == "dependentplugin.so")
+    {
       _dependentDependencyCount--;
     }
   }
 
 private:
-  iora::IoraService* _service;
+  iora::IoraService *_service;
   int _baseDependencyCount;
   int _dependentDependencyCount;
 };
diff --git a/tests/plugins/CyclePluginA.cpp b/tests/plugins/CyclePluginA.cpp
index c30278a..7628dc3 100644
--- a/tests/plugins/CyclePluginA.cpp
+++ b/tests/plugins/CyclePluginA.cpp
@@ -5,22 +5,15 @@
 class CyclePluginA : public iora::IoraService::Plugin
 {
 public:
-  explicit CyclePluginA(iora::IoraService* svc)
-    : Plugin(svc)
-  {
-  }
+  explicit CyclePluginA(iora::IoraService *svc) : Plugin(svc) {}
 
-  void onLoad(iora::IoraService* svc) override
+  void onLoad(iora::IoraService *svc) override
   {
     // This should cause a cyclical dependency error if CyclePluginB also requires this plugin
-    require("cyclepluginb.so");  // A depends on B
+    require("cyclepluginb.so"); // A depends on B
 
     svc->exportApi(*this, "cycleplugina.getValue",
-      [this]() -> std::string
-      { 
-        return "CyclePluginA loaded";
-      }
-    );
+                   [this]() -> std::string { return "CyclePluginA loaded"; });
   }
 
   void onUnload() override
@@ -28,14 +21,14 @@ public:
     // Nothing special to do
   }
 
-  void onDependencyLoaded(const std::string& moduleName) override
+  void onDependencyLoaded(const std::string &moduleName) override
   {
     // Handle dependency load
   }
 
-  void onDependencyUnloaded(const std::string& moduleName) override
+  void onDependencyUnloaded(const std::string &moduleName) override
   {
-    // Handle dependency unload  
+    // Handle dependency unload
   }
 };
 
diff --git a/tests/plugins/CyclePluginB.cpp b/tests/plugins/CyclePluginB.cpp
index 260ae07..9a565f0 100644
--- a/tests/plugins/CyclePluginB.cpp
+++ b/tests/plugins/CyclePluginB.cpp
@@ -5,22 +5,15 @@
 class CyclePluginB : public iora::IoraService::Plugin
 {
 public:
-  explicit CyclePluginB(iora::IoraService* svc)
-    : Plugin(svc)
-  {
-  }
+  explicit CyclePluginB(iora::IoraService *svc) : Plugin(svc) {}
 
-  void onLoad(iora::IoraService* svc) override
+  void onLoad(iora::IoraService *svc) override
   {
     // This creates the direct cyclical dependency: B depends on A, A already depends on B
-    require("cycleplugina.so");  // B depends on A
+    require("cycleplugina.so"); // B depends on A
 
     svc->exportApi(*this, "cyclepluginb.getValue",
-      [this]() -> std::string
-      { 
-        return "CyclePluginB loaded";
-      }
-    );
+                   [this]() -> std::string { return "CyclePluginB loaded"; });
   }
 
   void onUnload() override
@@ -28,14 +21,14 @@ public:
     // Nothing special to do
   }
 
-  void onDependencyLoaded(const std::string& moduleName) override
+  void onDependencyLoaded(const std::string &moduleName) override
   {
     // Handle dependency load
   }
 
-  void onDependencyUnloaded(const std::string& moduleName) override
+  void onDependencyUnloaded(const std::string &moduleName) override
   {
-    // Handle dependency unload  
+    // Handle dependency unload
   }
 };
 
diff --git a/tests/plugins/CyclePluginC.cpp b/tests/plugins/CyclePluginC.cpp
index 43bb8b1..ee90fe4 100644
--- a/tests/plugins/CyclePluginC.cpp
+++ b/tests/plugins/CyclePluginC.cpp
@@ -1,26 +1,19 @@
-// File: iora/tests/plugins/CyclePluginC.cpp  
+// File: iora/tests/plugins/CyclePluginC.cpp
 // Plugin C that creates an indirect cycle: ABCA
 #include "iora/iora.hpp"
 
 class CyclePluginC : public iora::IoraService::Plugin
 {
 public:
-  explicit CyclePluginC(iora::IoraService* svc)
-    : Plugin(svc)
-  {
-  }
+  explicit CyclePluginC(iora::IoraService *svc) : Plugin(svc) {}
 
-  void onLoad(iora::IoraService* svc) override
+  void onLoad(iora::IoraService *svc) override
   {
     // This completes the indirect cycle: ABCA
-    require("cycleplugina.so");  // C depends on A (completing the cycle)
+    require("cycleplugina.so"); // C depends on A (completing the cycle)
 
     svc->exportApi(*this, "cyclepluginc.getValue",
-      [this]() -> std::string
-      { 
-        return "CyclePluginC loaded";
-      }
-    );
+                   [this]() -> std::string { return "CyclePluginC loaded"; });
   }
 
   void onUnload() override
@@ -28,14 +21,14 @@ public:
     // Nothing special to do
   }
 
-  void onDependencyLoaded(const std::string& moduleName) override
+  void onDependencyLoaded(const std::string &moduleName) override
   {
     // Handle dependency load
   }
 
-  void onDependencyUnloaded(const std::string& moduleName) override
+  void onDependencyUnloaded(const std::string &moduleName) override
   {
-    // Handle dependency unload  
+    // Handle dependency unload
   }
 };
 
diff --git a/tests/plugins/DependentPlugin.cpp b/tests/plugins/DependentPlugin.cpp
index c25857b..663df91 100644
--- a/tests/plugins/DependentPlugin.cpp
+++ b/tests/plugins/DependentPlugin.cpp
@@ -1,76 +1,77 @@
-// File: iora/tests/plugins/DependentPlugin.cpp  
+// File: iora/tests/plugins/DependentPlugin.cpp
 // A plugin that depends on BasePlugin and demonstrates dependency handling
 #include "iora/iora.hpp"
 
 class DependentPlugin : public iora::IoraService::Plugin
 {
 public:
-  explicit DependentPlugin(iora::IoraService* svc)
-    : Plugin(svc), _service(svc), _basePluginAvailable(false), _loadNotifications(0), _unloadNotifications(0)
+  explicit DependentPlugin(iora::IoraService *svc)
+      : Plugin(svc), _service(svc), _basePluginAvailable(false), _loadNotifications(0),
+        _unloadNotifications(0)
   {
   }
 
-  void onLoad(iora::IoraService* svc) override
+  void onLoad(iora::IoraService *svc) override
   {
-    // Require BasePlugin as a dependency  
+    // Require BasePlugin as a dependency
     require("baseplugin.so");
 
-    // Export APIs that use BasePlugin functionality  
+    // Export APIs that use BasePlugin functionality
     svc->exportApi(*this, "dependentplugin.useBase",
-      [this]() -> std::string
-      { 
-        if (!_basePluginAvailable) {
-          return "BasePlugin not available";
-        }
-        
-        try {
-          auto baseVersion = _service->callExportedApi<std::string>("baseplugin.getVersion");
-          auto counter = _service->callExportedApi<int>("baseplugin.increment");
-          return "Using " + baseVersion + ", counter: " + std::to_string(counter);
-        } catch (const std::exception& e) {
-          return "Error using BasePlugin: " + std::string(e.what());
-        }
-      }
-    );
+                   [this]() -> std::string
+                   {
+                     if (!_basePluginAvailable)
+                     {
+                       return "BasePlugin not available";
+                     }
 
-    svc->exportApi(*this, "dependentplugin.getStatus",
-      [this]() -> std::string
-      { 
-        return _basePluginAvailable ? "BasePlugin available" : "BasePlugin not available";
-      }
-    );
+                     try
+                     {
+                       auto baseVersion =
+                         _service->callExportedApi<std::string>("baseplugin.getVersion");
+                       auto counter = _service->callExportedApi<int>("baseplugin.increment");
+                       return "Using " + baseVersion + ", counter: " + std::to_string(counter);
+                     }
+                     catch (const std::exception &e)
+                     {
+                       return "Error using BasePlugin: " + std::string(e.what());
+                     }
+                   });
+
+    svc->exportApi(
+      *this, "dependentplugin.getStatus", [this]() -> std::string
+      { return _basePluginAvailable ? "BasePlugin available" : "BasePlugin not available"; });
 
     svc->exportApi(*this, "dependentplugin.getNotificationCounts",
-      [this]() -> std::string
-      { 
-        return "Load: " + std::to_string(_loadNotifications) + ", Unload: " + std::to_string(_unloadNotifications);
-      }
-    );
+                   [this]() -> std::string
+                   {
+                     return "Load: " + std::to_string(_loadNotifications) +
+                            ", Unload: " + std::to_string(_unloadNotifications);
+                   });
   }
 
-  void onUnload() override
-  {
-    _basePluginAvailable = false;
-  }
+  void onUnload() override { _basePluginAvailable = false; }
 
-  void onDependencyLoaded(const std::string& moduleName) override
+  void onDependencyLoaded(const std::string &moduleName) override
   {
-    if (moduleName == "baseplugin.so") {
+    if (moduleName == "baseplugin.so")
+    {
       _basePluginAvailable = true;
       _loadNotifications++;
     }
   }
 
-  void onDependencyUnloaded(const std::string& moduleName) override  
+  void onDependencyUnloaded(const std::string &moduleName) override
   {
-    if (moduleName == "baseplugin.so") {
+    if (moduleName == "baseplugin.so")
+    {
       _basePluginAvailable = false;
       _unloadNotifications++;
     }
   }
 
 private:
-  iora::IoraService* _service;
+  iora::IoraService *_service;
   bool _basePluginAvailable;
   int _loadNotifications;
   int _unloadNotifications;
diff --git a/tests/plugins/IndirectCycleA.cpp b/tests/plugins/IndirectCycleA.cpp
index b7a1c0c..6429c46 100644
--- a/tests/plugins/IndirectCycleA.cpp
+++ b/tests/plugins/IndirectCycleA.cpp
@@ -5,27 +5,20 @@
 class IndirectCycleA : public iora::IoraService::Plugin
 {
 public:
-  explicit IndirectCycleA(iora::IoraService* svc)
-    : Plugin(svc)
-  {
-  }
+  explicit IndirectCycleA(iora::IoraService *svc) : Plugin(svc) {}
 
-  void onLoad(iora::IoraService* svc) override
+  void onLoad(iora::IoraService *svc) override
   {
     // A depends on B (start of ABCA chain)
-    require("indirectcycleb.so");  
+    require("indirectcycleb.so");
 
     svc->exportApi(*this, "indirectcyclea.getValue",
-      [this]() -> std::string
-      { 
-        return "IndirectCycleA loaded";
-      }
-    );
+                   [this]() -> std::string { return "IndirectCycleA loaded"; });
   }
 
   void onUnload() override {}
-  void onDependencyLoaded(const std::string& moduleName) override {}
-  void onDependencyUnloaded(const std::string& moduleName) override {}
+  void onDependencyLoaded(const std::string &moduleName) override {}
+  void onDependencyUnloaded(const std::string &moduleName) override {}
 };
 
 IORA_DECLARE_PLUGIN(IndirectCycleA)
\ No newline at end of file
diff --git a/tests/plugins/IndirectCycleB.cpp b/tests/plugins/IndirectCycleB.cpp
index 1c84f5e..23c75ce 100644
--- a/tests/plugins/IndirectCycleB.cpp
+++ b/tests/plugins/IndirectCycleB.cpp
@@ -5,27 +5,20 @@
 class IndirectCycleB : public iora::IoraService::Plugin
 {
 public:
-  explicit IndirectCycleB(iora::IoraService* svc)
-    : Plugin(svc)
-  {
-  }
+  explicit IndirectCycleB(iora::IoraService *svc) : Plugin(svc) {}
 
-  void onLoad(iora::IoraService* svc) override
+  void onLoad(iora::IoraService *svc) override
   {
     // B depends on C (middle of ABCA chain)
-    require("indirectcyclec.so");  
+    require("indirectcyclec.so");
 
     svc->exportApi(*this, "indirectcycleb.getValue",
-      [this]() -> std::string
-      { 
-        return "IndirectCycleB loaded";
-      }
-    );
+                   [this]() -> std::string { return "IndirectCycleB loaded"; });
   }
 
   void onUnload() override {}
-  void onDependencyLoaded(const std::string& moduleName) override {}
-  void onDependencyUnloaded(const std::string& moduleName) override {}
+  void onDependencyLoaded(const std::string &moduleName) override {}
+  void onDependencyUnloaded(const std::string &moduleName) override {}
 };
 
 IORA_DECLARE_PLUGIN(IndirectCycleB)
\ No newline at end of file
diff --git a/tests/plugins/IndirectCycleC.cpp b/tests/plugins/IndirectCycleC.cpp
index 6f3ef3a..52193e9 100644
--- a/tests/plugins/IndirectCycleC.cpp
+++ b/tests/plugins/IndirectCycleC.cpp
@@ -1,31 +1,24 @@
-// File: iora/tests/plugins/IndirectCycleC.cpp  
+// File: iora/tests/plugins/IndirectCycleC.cpp
 // Plugin C for indirect cycle: ABCA
 #include "iora/iora.hpp"
 
 class IndirectCycleC : public iora::IoraService::Plugin
 {
 public:
-  explicit IndirectCycleC(iora::IoraService* svc)
-    : Plugin(svc)
-  {
-  }
+  explicit IndirectCycleC(iora::IoraService *svc) : Plugin(svc) {}
 
-  void onLoad(iora::IoraService* svc) override
+  void onLoad(iora::IoraService *svc) override
   {
     // C depends on A (completes the ABCA cycle)
-    require("indirectcyclea.so");  
+    require("indirectcyclea.so");
 
     svc->exportApi(*this, "indirectcyclec.getValue",
-      [this]() -> std::string
-      { 
-        return "IndirectCycleC loaded";
-      }
-    );
+                   [this]() -> std::string { return "IndirectCycleC loaded"; });
   }
 
   void onUnload() override {}
-  void onDependencyLoaded(const std::string& moduleName) override {}
-  void onDependencyUnloaded(const std::string& moduleName) override {}
+  void onDependencyLoaded(const std::string &moduleName) override {}
+  void onDependencyUnloaded(const std::string &moduleName) override {}
 };
 
 IORA_DECLARE_PLUGIN(IndirectCycleC)
\ No newline at end of file
diff --git a/tests/plugins/TestPlugin.cpp b/tests/plugins/TestPlugin.cpp
index 6149f74..83d5e61 100644
--- a/tests/plugins/TestPlugin.cpp
+++ b/tests/plugins/TestPlugin.cpp
@@ -4,56 +4,34 @@
 class TestPlugin : public iora::IoraService::Plugin
 {
 public:
-  explicit TestPlugin(iora::IoraService* svc)
-    : Plugin(svc), loaded(false)
-  {
-  }
+  explicit TestPlugin(iora::IoraService *svc) : Plugin(svc), loaded(false) {}
 
-  void onLoad(iora::IoraService* svc) override
+  void onLoad(iora::IoraService *svc) override
   {
     loaded = true;
 
     // Register a simple API: returns the sum of two integers
-    svc->exportApi(*this, "testplugin.add",
-      [this](int a, int b) 
-      { 
-        return a + b; 
-      }
-    );
+    svc->exportApi(*this, "testplugin.add", [this](int a, int b) { return a + b; });
 
     // Register an API: returns a greeting string
-    svc->exportApi(*this,"testplugin.greet",
-      [this](const std::string& name) 
-      { 
-        return std::string("Hello, ") + name + "!"; 
-      }
-    );
+    svc->exportApi(*this, "testplugin.greet",
+                   [this](const std::string &name) { return std::string("Hello, ") + name + "!"; });
 
     // Register an API: toggles and returns the loaded state
     svc->exportApi(*this, "testplugin.toggleLoaded",
-      [this]() 
-      { 
-        loaded = !loaded; 
-        return loaded; 
-      }
-    );
+                   [this]()
+                   {
+                     loaded = !loaded;
+                     return loaded;
+                   });
 
     // Register an API: returns the loaded state
-    svc->exportApi(*this, "testplugin.isLoaded",
-      [this]() 
-      { 
-        return loaded; 
-      }
-    );
+    svc->exportApi(*this, "testplugin.isLoaded", [this]() { return loaded; });
   }
 
-  void onUnload() override
-  {
-    loaded = false;
-  }
+  void onUnload() override { loaded = false; }
 
   bool loaded;
 };
 
 IORA_DECLARE_PLUGIN(TestPlugin)
-
diff --git a/tests/service/iora_test_iora_service.cpp b/tests/service/iora_test_iora_service.cpp
index d93249a..01eeea9 100644
--- a/tests/service/iora_test_iora_service.cpp
+++ b/tests/service/iora_test_iora_service.cpp
@@ -5,8 +5,8 @@
 // See the LICENSE file or <https://www.mozilla.org/MPL/2.0/> for details.
 
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 
 using namespace iora::test;
 
@@ -21,14 +21,13 @@ TEST_CASE("IoraService basic operations", "[iora][IoraService]")
 
   // Initialize service with config
   iora::IoraService::init(config);
-  iora::IoraService& svc = iora::IoraService::instanceRef();
+  iora::IoraService &svc = iora::IoraService::instanceRef();
   AutoServiceShutdown autoShutdown(svc);
 
   svc.stateStore()->set("foo", "bar");
   REQUIRE(svc.stateStore()->get("foo").value() == "bar");
 
-  svc.cache()->set("cacheKey", std::string("cacheValue"),
-                   std::chrono::seconds(1));
+  svc.cache()->set("cacheKey", std::string("cacheValue"), std::chrono::seconds(1));
   REQUIRE(svc.cache()->get("cacheKey").value() == "cacheValue");
   std::this_thread::sleep_for(std::chrono::seconds(2));
   REQUIRE_FALSE(svc.cache()->get("cacheKey").has_value());
@@ -46,7 +45,7 @@ TEST_CASE("IoraService basic operations", "[iora][IoraService]")
 
   {
     std::unique_ptr<iora::storage::JsonFileStore> tmp =
-        svc.makeJsonFileStore("ioraservice_factory_state.json");
+      svc.makeJsonFileStore("ioraservice_factory_state.json");
     tmp->set("altKey", "altValue");
     REQUIRE(tmp->get("altKey").value() == "altValue");
     REQUIRE_FALSE(svc.jsonFileStore()->get("altKey").has_value());
@@ -59,14 +58,13 @@ TEST_CASE("IoraService basic operations", "[iora][IoraService]")
     REQUIRE(&c1 != &c2);
   }
 
-  svc.webhookServer()->onJsonGet(
-      "/basic",
-      [](const iora::parsers::Json&) -> iora::parsers::Json
-      {
-        auto obj = iora::parsers::Json::object();
-        obj["ok"] = true;
-        return obj;
-      });
+  svc.webhookServer()->onJsonGet("/basic",
+                                 [](const iora::parsers::Json &) -> iora::parsers::Json
+                                 {
+                                   auto obj = iora::parsers::Json::object();
+                                   obj["ok"] = true;
+                                   return obj;
+                                 });
   std::this_thread::sleep_for(std::chrono::milliseconds(200));
   {
     auto client = svc.makeHttpClient();
@@ -76,12 +74,10 @@ TEST_CASE("IoraService basic operations", "[iora][IoraService]")
     REQUIRE(json["ok"] == true);
   }
 
-  iora::util::removeFilesContainingAny(
-      {"ioraservice_basic_log", "ioraservice_basic_state.json"});
+  iora::util::removeFilesContainingAny({"ioraservice_basic_log", "ioraservice_basic_state.json"});
 }
 
-TEST_CASE("IoraService configuration file override",
-          "[iora][IoraService][config]")
+TEST_CASE("IoraService configuration file override", "[iora][IoraService][config]")
 {
   const std::string cfg = "ioraservice_cfg_override.toml";
   {
@@ -96,7 +92,7 @@ TEST_CASE("IoraService configuration file override",
   iora::IoraService::Config config;
   auto configLoader = std::make_unique<iora::core::ConfigLoader>(cfg);
   configLoader->reload();
-  
+
   // Parse TOML values into config
   if (auto portOpt = configLoader->getInt("iora.server.port"))
   {
@@ -118,18 +114,17 @@ TEST_CASE("IoraService configuration file override",
   // Initialize service with config
   iora::IoraService::init(config);
   iora::IoraService::instanceRef().setConfigLoader(std::move(configLoader));
-  iora::IoraService& svc = iora::IoraService::instanceRef();
+  iora::IoraService &svc = iora::IoraService::instanceRef();
   AutoServiceShutdown autoShutdown(svc);
 
   std::this_thread::sleep_for(std::chrono::milliseconds(500));
-  svc.webhookServer()->onJsonGet(
-      "/cfg",
-      [](const iora::parsers::Json&) -> iora::parsers::Json
-      {
-        auto obj = iora::parsers::Json::object();
-        obj["cfg"] = true;
-        return obj;
-      });
+  svc.webhookServer()->onJsonGet("/cfg",
+                                 [](const iora::parsers::Json &) -> iora::parsers::Json
+                                 {
+                                   auto obj = iora::parsers::Json::object();
+                                   obj["cfg"] = true;
+                                   return obj;
+                                 });
   std::this_thread::sleep_for(std::chrono::milliseconds(100));
   {
     auto client = svc.makeHttpClient();
@@ -145,12 +140,10 @@ TEST_CASE("IoraService configuration file override",
 
   IORA_LOG_DEBUG("Configuration override test message");
   iora::core::Logger::shutdown();
-  std::string logFile =
-      "ioraservice_cfg_log." + iora::core::Logger::currentDate() + ".log";
+  std::string logFile = "ioraservice_cfg_log." + iora::core::Logger::currentDate() + ".log";
   REQUIRE(std::filesystem::exists(logFile));
 
-  iora::util::removeFilesContainingAny(
-      {"ioraservice_cfg_log", "ioraservice_cfg_state.json", cfg});
+  iora::util::removeFilesContainingAny({"ioraservice_cfg_log", "ioraservice_cfg_state.json", cfg});
 }
 
 TEST_CASE("IoraService CLI overrides precedence", "[iora][IoraService][cli]")
@@ -169,11 +162,11 @@ TEST_CASE("IoraService CLI overrides precedence", "[iora][IoraService][cli]")
   config.state.file = "ioraservice_cli_override_state.json";
   config.log.file = "ioraservice_cli_override_log";
   config.log.level = "error";
-  
+
   // Parse TOML file (but CLI values should override)
   auto configLoader = std::make_unique<iora::core::ConfigLoader>(cfg);
   configLoader->reload();
-  
+
   // Only parse TOML values that aren't already set by CLI
   if (!config.server.port.has_value())
   {
@@ -187,18 +180,17 @@ TEST_CASE("IoraService CLI overrides precedence", "[iora][IoraService][cli]")
   // Initialize service with config
   iora::IoraService::init(config);
   iora::IoraService::instanceRef().setConfigLoader(std::move(configLoader));
-  iora::IoraService& svc = iora::IoraService::instanceRef();
+  iora::IoraService &svc = iora::IoraService::instanceRef();
   AutoServiceShutdown autoShutdown(svc);
 
   std::this_thread::sleep_for(std::chrono::milliseconds(500));
-  svc.webhookServer()->onJsonGet(
-      "/cli",
-      [](const iora::parsers::Json&) -> iora::parsers::Json
-      {
-        auto obj = iora::parsers::Json::object();
-        obj["cli"] = true;
-        return obj;
-      });
+  svc.webhookServer()->onJsonGet("/cli",
+                                 [](const iora::parsers::Json &) -> iora::parsers::Json
+                                 {
+                                   auto obj = iora::parsers::Json::object();
+                                   obj["cli"] = true;
+                                   return obj;
+                                 });
   std::this_thread::sleep_for(std::chrono::milliseconds(100));
   {
     auto client = svc.makeHttpClient();
@@ -211,24 +203,23 @@ TEST_CASE("IoraService CLI overrides precedence", "[iora][IoraService][cli]")
   svc.jsonFileStore()->set("cliKey", "cliValue");
   std::this_thread::sleep_for(svc.jsonFileStore()->flushInterval() +
                               std::chrono::milliseconds(100));
-  REQUIRE(std::filesystem::exists(
-      "ioraservice_cli_override_state.json")); // Not guaranteed since flushing
-                                               // the store is done using a
-                                               // background thread
+  REQUIRE(
+    std::filesystem::exists("ioraservice_cli_override_state.json")); // Not guaranteed since
+                                                                     // flushing the store is done
+                                                                     // using a background thread
 
   IORA_LOG_ERROR("CLI override log test");
   iora::core::Logger::shutdown();
-  std::string logFile = "ioraservice_cli_override_log." +
-                        iora::core::Logger::currentDate() + ".log";
+  std::string logFile =
+    "ioraservice_cli_override_log." + iora::core::Logger::currentDate() + ".log";
   REQUIRE(std::filesystem::exists(logFile));
 
-  iora::util::removeFilesContainingAny(
-      {"ioraservice_cli_override_log", "ioraservice_cli_state.json",
-       "ioraservice_cli_override_state.json", cfg});
+  iora::util::removeFilesContainingAny({"ioraservice_cli_override_log",
+                                        "ioraservice_cli_state.json",
+                                        "ioraservice_cli_override_state.json", cfg});
 }
 
-TEST_CASE("IoraService concurrent HTTP clients",
-          "[iora][IoraService][concurrency]")
+TEST_CASE("IoraService concurrent HTTP clients", "[iora][IoraService][concurrency]")
 {
   // Setup IoraService config
   iora::IoraService::Config config;
@@ -239,18 +230,17 @@ TEST_CASE("IoraService concurrent HTTP clients",
 
   // Initialize service with config
   iora::IoraService::init(config);
-  iora::IoraService& svc = iora::IoraService::instanceRef();
+  iora::IoraService &svc = iora::IoraService::instanceRef();
   AutoServiceShutdown autoShutdown(svc);
 
   std::this_thread::sleep_for(std::chrono::milliseconds(500));
-  svc.webhookServer()->onJsonGet(
-      "/ping",
-      [](const iora::parsers::Json&) -> iora::parsers::Json
-      {
-        auto obj = iora::parsers::Json::object();
-        obj["pong"] = true;
-        return obj;
-      });
+  svc.webhookServer()->onJsonGet("/ping",
+                                 [](const iora::parsers::Json &) -> iora::parsers::Json
+                                 {
+                                   auto obj = iora::parsers::Json::object();
+                                   obj["pong"] = true;
+                                   return obj;
+                                 });
   std::this_thread::sleep_for(std::chrono::milliseconds(100));
 
   const int threadCount = 5;
@@ -259,34 +249,34 @@ TEST_CASE("IoraService concurrent HTTP clients",
   for (int i = 0; i < threadCount; ++i)
   {
     workers.emplace_back(
-        [&svc, &successCount]()
+      [&svc, &successCount]()
+      {
+        auto client = svc.makeHttpClient();
+        try
         {
-          auto client = svc.makeHttpClient();
-          try
+          auto res = client.get("http://localhost:8113/ping");
+          if (res.success())
           {
-            auto res = client.get("http://localhost:8113/ping");
-            if (res.success())
+            auto json = iora::network::HttpClient::parseJsonOrThrow(res);
+            if (json["pong"] == true)
             {
-              auto json = iora::network::HttpClient::parseJsonOrThrow(res);
-              if (json["pong"] == true)
-              {
-                successCount.fetch_add(1);
-              }
+              successCount.fetch_add(1);
             }
           }
-          catch (...)
-          {
-          }
-        });
+        }
+        catch (...)
+        {
+        }
+      });
   }
-  for (auto& t : workers)
+  for (auto &t : workers)
   {
     t.join();
   }
   REQUIRE(successCount.load() == threadCount);
 
   iora::util::removeFilesContainingAny(
-      {"ioraservice_concurrency_log", "ioraservice_concurrency_state.json"});
+    {"ioraservice_concurrency_log", "ioraservice_concurrency_state.json"});
 }
 
 TEST_CASE("IoraService fluent event handler registration by name and pattern",
@@ -301,26 +291,26 @@ TEST_CASE("IoraService fluent event handler registration by name and pattern",
 
   // Initialize service with config
   iora::IoraService::init(config);
-  iora::IoraService& svc = iora::IoraService::instanceRef();
+  iora::IoraService &svc = iora::IoraService::instanceRef();
   AutoServiceShutdown autoShutdown(svc);
 
   std::atomic<int> nameCounter{0};
   svc.onEventName("fluentEvent")
-      .handle(
-          [&](const iora::parsers::Json& event)
-          {
-            REQUIRE(event["eventName"] == "fluentEvent");
-            nameCounter++;
-          });
+    .handle(
+      [&](const iora::parsers::Json &event)
+      {
+        REQUIRE(event["eventName"] == "fluentEvent");
+        nameCounter++;
+      });
 
   std::atomic<int> patternCounter{0};
   svc.onEventNameMatches("^fluent.*")
-      .handle(
-          [&](const iora::parsers::Json& event)
-          {
-            REQUIRE(event["eventName"].get<std::string>().find("fluent") == 0);
-            patternCounter++;
-          });
+    .handle(
+      [&](const iora::parsers::Json &event)
+      {
+        REQUIRE(event["eventName"].get<std::string>().find("fluent") == 0);
+        patternCounter++;
+      });
 
   auto event1 = iora::parsers::Json::object();
   event1["eventId"] = "id1";
@@ -340,12 +330,10 @@ TEST_CASE("IoraService fluent event handler registration by name and pattern",
   REQUIRE(patternCounter == 2);
 
   iora::util::removeFilesContainingAny(
-      {"ioraservice_fluent_eventqueue_log",
-       "ioraservice_fluent_eventqueue_state.json"});
+    {"ioraservice_fluent_eventqueue_log", "ioraservice_fluent_eventqueue_state.json"});
 }
 
-TEST_CASE("IoraService integrates EventQueue",
-          "[iora][IoraService][EventQueue]")
+TEST_CASE("IoraService integrates EventQueue", "[iora][IoraService][EventQueue]")
 {
   // Setup IoraService config
   iora::IoraService::Config config;
@@ -355,17 +343,17 @@ TEST_CASE("IoraService integrates EventQueue",
 
   // Initialize service with config
   iora::IoraService::init(config);
-  iora::IoraService& svc = iora::IoraService::instanceRef();
+  iora::IoraService &svc = iora::IoraService::instanceRef();
   AutoServiceShutdown autoShutdown(svc);
 
   std::atomic<int> counter{0};
   svc.onEvent("testEventId")
-      .handle(
-          [&](const iora::parsers::Json& event)
-          {
-            REQUIRE(event["eventId"] == "testEventId");
-            counter++;
-          });
+    .handle(
+      [&](const iora::parsers::Json &event)
+      {
+        REQUIRE(event["eventId"] == "testEventId");
+        counter++;
+      });
 
   auto testEvent = iora::parsers::Json::object();
   testEvent["eventId"] = "testEventId";
@@ -375,5 +363,5 @@ TEST_CASE("IoraService integrates EventQueue",
   REQUIRE(counter == 1);
 
   iora::util::removeFilesContainingAny(
-      {"ioraservice_eventqueue_log", "ioraservice_eventqueue_state.json"});
+    {"ioraservice_eventqueue_log", "ioraservice_eventqueue_state.json"});
 }
diff --git a/tests/service/iora_test_plugin.cpp b/tests/service/iora_test_plugin.cpp
index 1792282..07ace6e 100644
--- a/tests/service/iora_test_plugin.cpp
+++ b/tests/service/iora_test_plugin.cpp
@@ -1,17 +1,19 @@
 #define CATCH_CONFIG_RUNNER
+#include "test_helpers.hpp"
 #include <catch2/catch.hpp>
 #include <chrono>
 #include <iomanip>
-#include "test_helpers.hpp"
 
 using namespace iora::test;
 
 // Global service instance for all tests
-static iora::IoraService* globalSvc = nullptr;
+static iora::IoraService *globalSvc = nullptr;
 
 // Helper function to get service instance
-iora::IoraService& getTestService() {
-  if (!globalSvc) {
+iora::IoraService &getTestService()
+{
+  if (!globalSvc)
+  {
     throw std::runtime_error("Test service not initialized");
   }
   return *globalSvc;
@@ -19,7 +21,7 @@ iora::IoraService& getTestService() {
 
 TEST_CASE("Dynamic loading of testplugin shared library")
 {
-  iora::IoraService& svc = getTestService();
+  iora::IoraService &svc = getTestService();
 
   auto pluginPathOpt = iora::util::getExecutableDir() + "/plugins/testplugin.so";
   std::cout << "Plugin path: " << pluginPathOpt << std::endl;
@@ -34,7 +36,8 @@ TEST_CASE("Dynamic loading of testplugin shared library")
 
   SECTION("callExportedApi: greet")
   {
-    std::string greet = svc.callExportedApi<std::string, const std::string&>("testplugin.greet", "World");
+    std::string greet =
+      svc.callExportedApi<std::string, const std::string &>("testplugin.greet", "World");
     REQUIRE(greet == "Hello, World!");
   }
 
@@ -56,7 +59,7 @@ TEST_CASE("Dynamic loading of testplugin shared library")
 
   SECTION("getExportedApi: greet")
   {
-    auto greetApi = svc.getExportedApi<std::string(const std::string&)>("testplugin.greet");
+    auto greetApi = svc.getExportedApi<std::string(const std::string &)>("testplugin.greet");
     REQUIRE(greetApi("Iora") == "Hello, Iora!");
   }
 
@@ -65,10 +68,11 @@ TEST_CASE("Dynamic loading of testplugin shared library")
     auto safeAddApi = svc.getExportedApiSafe<int(int, int)>("testplugin.add");
     REQUIRE((*safeAddApi)(5, 7) == 12);
     REQUIRE(safeAddApi->isAvailable() == true);
-    REQUIRE(safeAddApi->getModuleName() == "testplugin.so");  // Should be full filename
+    REQUIRE(safeAddApi->getModuleName() == "testplugin.so"); // Should be full filename
     REQUIRE(safeAddApi->getApiName() == "testplugin.add");
 
-    auto safeGreetApi = svc.getExportedApiSafe<std::string(const std::string&)>("testplugin.greet");
+    auto safeGreetApi =
+      svc.getExportedApiSafe<std::string(const std::string &)>("testplugin.greet");
     REQUIRE((*safeGreetApi)("SafeAPI") == "Hello, SafeAPI!");
     REQUIRE(safeGreetApi->isAvailable() == true);
   }
@@ -77,7 +81,8 @@ TEST_CASE("Dynamic loading of testplugin shared library")
   {
     // Create safe API wrappers before unloading
     auto safeAddApi = svc.getExportedApiSafe<int(int, int)>("testplugin.add");
-    auto safeGreetApi = svc.getExportedApiSafe<std::string(const std::string&)>("testplugin.greet");
+    auto safeGreetApi =
+      svc.getExportedApiSafe<std::string(const std::string &)>("testplugin.greet");
 
     // Test that they work initially
     REQUIRE((*safeAddApi)(3, 4) == 7);
@@ -103,7 +108,7 @@ TEST_CASE("Dynamic loading of testplugin shared library")
     {
       (*safeAddApi)(1, 1);
     }
-    catch (const std::runtime_error& e)
+    catch (const std::runtime_error &e)
     {
       addThrew = true;
       addError = e.what();
@@ -113,7 +118,7 @@ TEST_CASE("Dynamic loading of testplugin shared library")
     {
       (*safeGreetApi)("Test");
     }
-    catch (const std::runtime_error& e)
+    catch (const std::runtime_error &e)
     {
       greetThrew = true;
       greetError = e.what();
@@ -153,7 +158,8 @@ TEST_CASE("Dynamic loading of testplugin shared library")
 
     REQUIRE(svc.loadSingleModule(pluginPathOpt));
     REQUIRE(svc.callExportedApi<int, int, int>("testplugin.add", 7, 8) == 15);
-    REQUIRE(svc.callExportedApi<std::string, const std::string&>("testplugin.greet", "Reloaded") == "Hello, Reloaded!");
+    REQUIRE(svc.callExportedApi<std::string, const std::string &>("testplugin.greet", "Reloaded") ==
+            "Hello, Reloaded!");
   }
 
   SECTION("Comparison: unsafe vs safe API behavior on module unload")
@@ -176,7 +182,7 @@ TEST_CASE("Dynamic loading of testplugin shared library")
     {
       (*safeAdd)(1, 2);
     }
-    catch (const std::runtime_error& e)
+    catch (const std::runtime_error &e)
     {
       safeThrew = true;
       std::string error = e.what();
@@ -214,32 +220,32 @@ TEST_CASE("Dynamic loading of testplugin shared library")
     for (int i = 0; i < numThreads; ++i)
     {
       threads.emplace_back(
-          [&, i]()
+        [&, i]()
+        {
+          for (int j = 0; j < callsPerThread && !stopTest.load(); ++j)
           {
-            for (int j = 0; j < callsPerThread && !stopTest.load(); ++j)
+            try
             {
-              try
-              {
-                int result = (*safeAddApi)(i, j);
-                if (result == i + j)
-                {
-                  successCount.fetch_add(1);
-                }
-                std::this_thread::sleep_for(std::chrono::microseconds(10));
-              }
-              catch (const std::runtime_error& e)
-              {
-                exceptionCount.fetch_add(1);
-                // Expected when module is unloaded
-              }
-              catch (...)
+              int result = (*safeAddApi)(i, j);
+              if (result == i + j)
               {
-                // Unexpected exception - this would indicate a race condition
-                std::cout << "UNEXPECTED EXCEPTION in thread " << i << std::endl;
-                stopTest.store(true);
+                successCount.fetch_add(1);
               }
+              std::this_thread::sleep_for(std::chrono::microseconds(10));
             }
-          });
+            catch (const std::runtime_error &e)
+            {
+              exceptionCount.fetch_add(1);
+              // Expected when module is unloaded
+            }
+            catch (...)
+            {
+              // Unexpected exception - this would indicate a race condition
+              std::cout << "UNEXPECTED EXCEPTION in thread " << i << std::endl;
+              stopTest.store(true);
+            }
+          }
+        });
     }
 
     // Let threads run for a bit
@@ -261,7 +267,7 @@ TEST_CASE("Dynamic loading of testplugin shared library")
     stopTest.store(true);
 
     // Wait for all threads to finish
-    for (auto& t : threads)
+    for (auto &t : threads)
     {
       t.join();
     }
@@ -277,7 +283,7 @@ TEST_CASE("Dynamic loading of testplugin shared library")
     // Verify thread safety: total calls should equal expected maximum
     int expectedMaxCalls = numThreads * callsPerThread;
     int actualCalls = successCount.load() + exceptionCount.load();
-    REQUIRE(actualCalls <= expectedMaxCalls);  // Some threads may exit early due to stopTest
+    REQUIRE(actualCalls <= expectedMaxCalls); // Some threads may exit early due to stopTest
   }
 
   SECTION("Performance benchmark: Safe vs Unsafe vs CallExportedApi")
@@ -285,7 +291,7 @@ TEST_CASE("Dynamic loading of testplugin shared library")
     auto unsafeAddApi = svc.getExportedApi<int(int, int)>("testplugin.add");
     auto safeAddApi = svc.getExportedApiSafe<int(int, int)>("testplugin.add");
 
-    const int numCalls = 100000;  // 100k calls for statistically significant results
+    const int numCalls = 100000; // 100k calls for statistically significant results
 
     // Warm up all APIs to ensure caches are populated
     unsafeAddApi(1, 1);
@@ -297,17 +303,18 @@ TEST_CASE("Dynamic loading of testplugin shared library")
     for (int i = 0; i < numCalls; ++i)
     {
       volatile int result = unsafeAddApi(i % 100, (i + 1) % 100);
-      (void)result;  // Prevent optimization
+      (void)result; // Prevent optimization
     }
     auto unsafeEnd = std::chrono::high_resolution_clock::now();
-    auto unsafeDuration = std::chrono::duration_cast<std::chrono::nanoseconds>(unsafeEnd - unsafeStart);
+    auto unsafeDuration =
+      std::chrono::duration_cast<std::chrono::nanoseconds>(unsafeEnd - unsafeStart);
 
     // Benchmark 2: Safe API (cached path - module stays loaded)
     auto safeStart = std::chrono::high_resolution_clock::now();
     for (int i = 0; i < numCalls; ++i)
     {
       volatile int result = (*safeAddApi)(i % 100, (i + 1) % 100);
-      (void)result;  // Prevent optimization
+      (void)result; // Prevent optimization
     }
     auto safeEnd = std::chrono::high_resolution_clock::now();
     auto safeDuration = std::chrono::duration_cast<std::chrono::nanoseconds>(safeEnd - safeStart);
@@ -316,8 +323,9 @@ TEST_CASE("Dynamic loading of testplugin shared library")
     auto callStart = std::chrono::high_resolution_clock::now();
     for (int i = 0; i < numCalls; ++i)
     {
-      volatile int result = svc.callExportedApi<int, int, int>("testplugin.add", i % 100, (i + 1) % 100);
-      (void)result;  // Prevent optimization
+      volatile int result =
+        svc.callExportedApi<int, int, int>("testplugin.add", i % 100, (i + 1) % 100);
+      (void)result; // Prevent optimization
     }
     auto callEnd = std::chrono::high_resolution_clock::now();
     auto callDuration = std::chrono::duration_cast<std::chrono::nanoseconds>(callEnd - callStart);
@@ -332,21 +340,22 @@ TEST_CASE("Dynamic loading of testplugin shared library")
 
     std::cout << "\n=== Performance Benchmark Results ===" << std::endl;
     std::cout << "Test: " << numCalls << " API calls each" << std::endl;
-    std::cout << "1. Unsafe API (getExportedApi):     " << std::fixed << std::setprecision(2) << unsafeNsPerCall
-              << " ns/call" << std::endl;
-    std::cout << "2. Safe API (getExportedApiSafe):   " << std::fixed << std::setprecision(2) << safeNsPerCall
-              << " ns/call" << std::endl;
-    std::cout << "3. CallExportedApi (lookup each):   " << std::fixed << std::setprecision(2) << callNsPerCall
-              << " ns/call" << std::endl;
-    std::cout << "\nSafe API overhead: " << std::fixed << std::setprecision(2) << safeOverheadNs << " ns/call ("
-              << std::fixed << std::setprecision(1) << safeOverheadPercent << "%)" << std::endl;
+    std::cout << "1. Unsafe API (getExportedApi):     " << std::fixed << std::setprecision(2)
+              << unsafeNsPerCall << " ns/call" << std::endl;
+    std::cout << "2. Safe API (getExportedApiSafe):   " << std::fixed << std::setprecision(2)
+              << safeNsPerCall << " ns/call" << std::endl;
+    std::cout << "3. CallExportedApi (lookup each):   " << std::fixed << std::setprecision(2)
+              << callNsPerCall << " ns/call" << std::endl;
+    std::cout << "\nSafe API overhead: " << std::fixed << std::setprecision(2) << safeOverheadNs
+              << " ns/call (" << std::fixed << std::setprecision(1) << safeOverheadPercent << "%)"
+              << std::endl;
 
     // Safe API should be faster than callExportedApi (which does lookup each time)
     REQUIRE(safeNsPerCall < callNsPerCall);
 
     // Performance should be reasonable - safe API overhead should be under 50ns per call
     // The percentage can be high if the base unsafe call is very fast (few nanoseconds)
-    REQUIRE(safeOverheadNs < 50.0);  // Less than 50ns absolute overhead per call
+    REQUIRE(safeOverheadNs < 50.0); // Less than 50ns absolute overhead per call
   }
 
   SECTION("Performance: Safe API cache invalidation cost")
@@ -364,7 +373,7 @@ TEST_CASE("Dynamic loading of testplugin shared library")
       // Force cache invalidation by simulating module reload
       svc.unloadSingleModule("testplugin.so");
       svc.loadSingleModule(pluginPathOpt);
-      std::this_thread::sleep_for(std::chrono::milliseconds(1));  // Let events process
+      std::this_thread::sleep_for(std::chrono::milliseconds(1)); // Let events process
 
       // Measure first call after reload (cache miss)
       auto start = std::chrono::high_resolution_clock::now();
@@ -385,22 +394,22 @@ TEST_CASE("Dynamic loading of testplugin shared library")
     avgRefreshNs /= refreshTimes.size();
 
     std::cout << "\n=== Cache Refresh Performance ===" << std::endl;
-    std::cout << "Average cache refresh time: " << std::fixed << std::setprecision(0) << avgRefreshNs << " ns"
-              << std::endl;
+    std::cout << "Average cache refresh time: " << std::fixed << std::setprecision(0)
+              << avgRefreshNs << " ns" << std::endl;
     std::cout << "This cost is only paid on first call after module reload" << std::endl;
 
     // Cache refresh should complete within reasonable time (typically < 10s)
-    REQUIRE(avgRefreshNs < 50000.0);  // Less than 50s for cache refresh
+    REQUIRE(avgRefreshNs < 50000.0); // Less than 50s for cache refresh
   }
 
   // Clean up between sections by unloading modules instead of shutting down service
   svc.unloadAllModules();
 }
 
-int main(int argc, char* argv[])
+int main(int argc, char *argv[])
 {
   Catch::Session session;
-  
+
   // Initialize test logging
   initializeTestLogging();
 
diff --git a/tests/simple_chained_test.cpp b/tests/simple_chained_test.cpp
index 09e77c3..d37e647 100644
--- a/tests/simple_chained_test.cpp
+++ b/tests/simple_chained_test.cpp
@@ -1,7 +1,7 @@
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
-#include "test_helpers.hpp"
 #include "iora/iora.hpp"
+#include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 
 using AutoServiceShutdown = iora::IoraService::AutoServiceShutdown;
 
@@ -12,7 +12,7 @@ TEST_CASE("Simple chained dependencies test", "[simple]")
   auto dependentPluginPath = iora::util::getExecutableDir() + "/plugins/dependentplugin.so";
   auto chainedPluginPath = iora::util::getExecutableDir() + "/plugins/chainedplugin.so";
 
-  // Setup IoraService config 
+  // Setup IoraService config
   iora::IoraService::Config config;
   config.server.port = 8144;
   config.state.file = "simple_test_state.json";
@@ -21,27 +21,27 @@ TEST_CASE("Simple chained dependencies test", "[simple]")
 
   // Initialize service with config
   iora::IoraService::init(config);
-  iora::IoraService& svc = iora::IoraService::instanceRef();
-  
+  iora::IoraService &svc = iora::IoraService::instanceRef();
+
   // Load all three plugins in correct order
   REQUIRE(svc.loadSingleModule(basePluginPath));
   REQUIRE(svc.loadSingleModule(dependentPluginPath));
   REQUIRE(svc.loadSingleModule(chainedPluginPath));
-  
+
   // Verify chained plugin can access all dependencies
   std::string chainResult = svc.callExportedApi<std::string>("chainedplugin.useChain");
   REQUIRE(chainResult.find("BasePlugin v1.0") != std::string::npos);
   REQUIRE(chainResult.find("BasePlugin available") != std::string::npos);
-  
+
   // Verify dependency status tracking
   std::string depStatus = svc.callExportedApi<std::string>("chainedplugin.getDependencyStatus");
   REQUIRE(depStatus == "BaseDep: 1, DependentDep: 1");
-  
+
   // Test complex operation using multiple dependencies
   std::string complexResult = svc.callExportedApi<std::string>("chainedplugin.complexOperation");
   REQUIRE(complexResult.find("Complex operation result") != std::string::npos);
   REQUIRE(complexResult.find("counter: 3") != std::string::npos); // Should be 3 after 2 increments
-  
+
   // Explicitly shutdown before section ends
   iora::IoraService::shutdown();
 }
\ No newline at end of file
diff --git a/tests/storage/iora_test_state.cpp b/tests/storage/iora_test_state.cpp
index cdf2192..c5ad315 100644
--- a/tests/storage/iora_test_state.cpp
+++ b/tests/storage/iora_test_state.cpp
@@ -1,6 +1,6 @@
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 
 TEST_CASE("JsonFileStore basic operations", "[state][JsonFileStore]")
 {
@@ -84,7 +84,7 @@ TEST_CASE("ConcreteStateStore basic operations", "[state][ConcreteStateStore]")
     store.set("apple", "fruit");
     store.set("banana", "fruit");
     store.set("carrot", "vegetable");
-    auto matcher = [](const std::string& k) { return k.find('a') != std::string::npos; };
+    auto matcher = [](const std::string &k) { return k.find('a') != std::string::npos; };
     auto matched = store.findKeysMatching(matcher);
     REQUIRE(matched.size() >= 2);
     REQUIRE(std::find(matched.begin(), matched.end(), "banana") != matched.end());
diff --git a/tests/test_helpers.hpp b/tests/test_helpers.hpp
index b93c8e7..546da53 100644
--- a/tests/test_helpers.hpp
+++ b/tests/test_helpers.hpp
@@ -8,30 +8,28 @@
 
 // Include the full iora header for now - tests need full access
 #include "iora/iora.hpp"
-#include <fstream>
+#include <chrono>
+#include <ctime>
 #include <dlfcn.h>
 #include <filesystem>
-#include <chrono>
-#include <thread>
+#include <fstream>
+#include <netinet/in.h>
 #include <random>
-#include <ctime>
 #include <sys/socket.h>
-#include <netinet/in.h>
+#include <thread>
 #include <unistd.h>
 
-namespace iora::test {
+namespace iora::test
+{
 
 /// \brief Automatic logger initialization for tests
-struct LoggerInit 
+struct LoggerInit
 {
-  LoggerInit() 
-  {
-    iora::core::Logger::setLevel(iora::core::Logger::Level::Debug);
-  }
+  LoggerInit() { iora::core::Logger::setLevel(iora::core::Logger::Level::Debug); }
 };
 
 /// \brief Static logger initializer - call once per test executable
-inline void initializeTestLogging() 
+inline void initializeTestLogging()
 {
   static LoggerInit init;
   (void)init; // Suppress unused variable warning
@@ -42,66 +40,75 @@ using AutoServiceShutdown = iora::IoraService::AutoServiceShutdown;
 
 /// \brief Helper function to create IoraService from CLI-style arguments (DEPRECATED)
 /// Use initServiceFromConfig() with Config objects instead
-inline iora::IoraService& initServiceFromArgs(int argc, const char* args[])
+inline iora::IoraService &initServiceFromArgs(int argc, const char *args[])
 {
   // Convert argc/argv to Config object
   iora::IoraService::Config config;
-  
-  for (int i = 1; i < argc; i++) {
+
+  for (int i = 1; i < argc; i++)
+  {
     std::string arg = args[i];
-    
-    if (arg == "--port" && i + 1 < argc) {
+
+    if (arg == "--port" && i + 1 < argc)
+    {
       config.server.port = std::stoi(args[i + 1]);
       i++; // Skip the value
     }
-    else if (arg == "--state-file" && i + 1 < argc) {
+    else if (arg == "--state-file" && i + 1 < argc)
+    {
       config.state.file = args[i + 1];
       i++; // Skip the value
     }
-    else if (arg == "--log-file" && i + 1 < argc) {
+    else if (arg == "--log-file" && i + 1 < argc)
+    {
       config.log.file = args[i + 1];
       i++; // Skip the value
     }
-    else if (arg == "--log-level" && i + 1 < argc) {
+    else if (arg == "--log-level" && i + 1 < argc)
+    {
       config.log.level = args[i + 1];
       i++; // Skip the value
     }
-    else if (arg == "--config" && i + 1 < argc) {
+    else if (arg == "--config" && i + 1 < argc)
+    {
       config.configFile = args[i + 1];
       i++; // Skip the value
     }
   }
-  
+
   iora::IoraService::init(config);
   return iora::IoraService::instanceRef();
 }
 
 /// \brief Helper function to create IoraService from Config object
-inline void initServiceFromConfig(const iora::IoraService::Config& config)
+inline void initServiceFromConfig(const iora::IoraService::Config &config)
 {
   iora::IoraService::init(config);
 }
 
 /// \brief Helper to create a basic test IoraService configuration
-inline iora::IoraService::Config createTestConfig(int port = 8080, 
-                                                   const std::string& logFile = "", 
-                                                   const std::string& stateFile = "",
-                                                   const std::string& logLevel = "debug")
+inline iora::IoraService::Config createTestConfig(int port = 8080, const std::string &logFile = "",
+                                                  const std::string &stateFile = "",
+                                                  const std::string &logLevel = "debug")
 {
   iora::IoraService::Config config;
   config.server.port = port;
   config.log.level = logLevel;
-  
-  if (!logFile.empty()) {
+
+  if (!logFile.empty())
+  {
     config.log.file = logFile;
-  } else {
+  }
+  else
+  {
     config.log.file = "test_" + std::to_string(port);
   }
-  
-  if (!stateFile.empty()) {
+
+  if (!stateFile.empty())
+  {
     config.state.file = stateFile;
   }
-  
+
   return config;
 }
 
@@ -110,19 +117,13 @@ class TempFileManager
 {
 public:
   TempFileManager() = default;
-  ~TempFileManager()
-  {
-    cleanup();
-  }
+  ~TempFileManager() { cleanup(); }
 
-  void addFile(const std::string& filename)
-  {
-    _files.push_back(filename);
-  }
+  void addFile(const std::string &filename) { _files.push_back(filename); }
 
   void cleanup()
   {
-    for (const auto& file : _files)
+    for (const auto &file : _files)
     {
       std::remove(file.c_str());
     }
@@ -137,8 +138,8 @@ private:
 class TempDirManager
 {
 public:
-  TempDirManager(const std::string& prefix = "iora_test_")
-    : _dir("/tmp/" + prefix + std::to_string(std::time(nullptr)))
+  TempDirManager(const std::string &prefix = "iora_test_")
+      : _dir("/tmp/" + prefix + std::to_string(std::time(nullptr)))
   {
     std::filesystem::create_directories(_dir);
   }
@@ -151,18 +152,15 @@ public:
     }
   }
 
-  const std::string& path() const { return _dir; }
-  std::string filePath(const std::string& filename) const
-  {
-    return _dir + "/" + filename;
-  }
+  const std::string &path() const { return _dir; }
+  std::string filePath(const std::string &filename) const { return _dir + "/" + filename; }
 
 private:
   std::string _dir;
 };
 
 /// \brief Helper to wait for a condition with timeout
-template<typename Predicate>
+template <typename Predicate>
 bool waitFor(Predicate pred, std::chrono::milliseconds timeout = std::chrono::milliseconds(5000))
 {
   auto start = std::chrono::steady_clock::now();
@@ -184,7 +182,7 @@ inline std::string generateRandomString(size_t length = 10)
   std::random_device rd;
   std::mt19937 gen(rd());
   std::uniform_int_distribution<> dis(0, sizeof(charset) - 2);
-  
+
   std::string result;
   result.reserve(length);
   for (size_t i = 0; i < length; ++i)
@@ -198,14 +196,15 @@ inline std::string generateRandomString(size_t length = 10)
 inline bool isPortAvailable(int port)
 {
   int sock = socket(AF_INET, SOCK_STREAM, 0);
-  if (sock < 0) return false;
-  
+  if (sock < 0)
+    return false;
+
   struct sockaddr_in addr{};
   addr.sin_family = AF_INET;
   addr.sin_addr.s_addr = INADDR_ANY;
   addr.sin_port = htons(port);
-  
-  int result = bind(sock, (struct sockaddr*)&addr, sizeof(addr));
+
+  int result = bind(sock, (struct sockaddr *)&addr, sizeof(addr));
   close(sock);
   return result == 0;
 }
diff --git a/tests/util/iora_test_expiring_cache.cpp b/tests/util/iora_test_expiring_cache.cpp
index 6c0aa7c..958fd35 100644
--- a/tests/util/iora_test_expiring_cache.cpp
+++ b/tests/util/iora_test_expiring_cache.cpp
@@ -6,8 +6,8 @@
 // See the LICENSE file or <https://www.mozilla.org/MPL/2.0/> for details.
 
 #define CATCH_CONFIG_MAIN
-#include <catch2/catch.hpp>
 #include "test_helpers.hpp"
+#include <catch2/catch.hpp>
 
 TEST_CASE("ExpiringCache basic operations")
 {
@@ -35,10 +35,9 @@ TEST_CASE("ExpiringCache concurrency")
   std::vector<std::thread> threads;
   for (int i = 0; i < 10; ++i)
   {
-    threads.emplace_back([&cache, i]()
-                         { cache.set(i, i * 10, std::chrono::seconds(1)); });
+    threads.emplace_back([&cache, i]() { cache.set(i, i * 10, std::chrono::seconds(1)); });
   }
-  for (auto& t : threads)
+  for (auto &t : threads)
   {
     t.join();
   }
